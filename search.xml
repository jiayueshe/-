<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c# 高级编程(10th)第三章 对象和类型</title>
      <link href="2021/02/17/c/c-10th-03/"/>
      <url>2021/02/17/c/c-10th-03/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第三章-对象和类型"><a href="#c-语言-第三章-对象和类型" class="headerlink" title="c#语言 第三章 对象和类型"></a>c#语言 第三章 对象和类型</h1><h2 id="3-2-类和结构的区别"><a href="#3-2-类和结构的区别" class="headerlink" title="3.2 类和结构的区别"></a>3.2 类和结构的区别</h2><p>​    类和结构实际上都是常见对象的模板</p><p>​    类是引用类型</p><p>​    结构是值类型</p><p>​    较小的数据类型使用结构可以提高性能</p><p>​    类和结构都用new来声明实例</p><h2 id="3-3-类"><a href="#3-3-类" class="headerlink" title="3.3 类"></a>3.3 类</h2><p>类包含成员。成员可以是静态成员或实例成员，static静态成员属于类；实例成员属于对象</p><p>成员：字段、常量、方法、属性、构造函数、索引器、运算符、事件、析构函数、类型</p><h3 id="3-3-1字段"><a href="#3-3-1字段" class="headerlink" title="3.3.1字段"></a>3.3.1字段</h3><p>​       const 常量 公开 public</p><p>​      最好把字段声明为private</p><h3 id="2-3-2属性"><a href="#2-3-2属性" class="headerlink" title="2.3.2属性"></a>2.3.2属性</h3><p> 一个方法或一对方法，看起来是一个字段</p><h4 id="自动实现的属性："><a href="#自动实现的属性：" class="headerlink" title="自动实现的属性："></a>自动实现的属性：</h4><p>​    set；get；访问器没有任何逻辑，属性会自动实现后备成员变量</p><p>​    属性初始化器来初始化 public int Age {get;set;}=42;</p><h4 id="属性的访问修饰符"><a href="#属性的访问修饰符" class="headerlink" title="属性的访问修饰符"></a>属性的访问修饰符</h4><p>​    public get private set</p><h3 id="3-3-3方法"><a href="#3-3-3方法" class="headerlink" title="3.3.3方法"></a>3.3.3方法</h3><p>非数据成员</p><p>​      正式的c#术语区分函数和方法，在c#术语中，函数成员不仅包含方法，也包含类或结构的一些非数据成员，如索引器、运算符、构造函数、析构函数等，还有属性，这些事非数据成员</p><p>数据成员</p><p>​    字段、常量、事件才是数据成员</p><h4 id="方法的声明"><a href="#方法的声明" class="headerlink" title="方法的声明"></a>方法的声明</h4><p>​    表达式体方法：  =&gt; 区分操作符左边的声明和右边的实现代码</p><p>​    调用方法</p><h4 id="方法的重载："><a href="#方法的重载：" class="headerlink" title="方法的重载："></a>方法的重载：</h4><p>​    方法名相同，但是参数的数量和/或数据类型不同</p><h4 id="命名的参数："><a href="#命名的参数：" class="headerlink" title="命名的参数："></a>命名的参数：</h4><p>​    任何方法都可以使用命名的参数调用，编译器会去掉变量名</p><p>这种方式更改变量的顺序，编译器会重新安排，获得正确的顺序</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>​    一个或多个，可选参数置后</p><h4 id="个数可变的参数-params关键字"><a href="#个数可变的参数-params关键字" class="headerlink" title="个数可变的参数 params关键字"></a>个数可变的参数 params关键字</h4><p>​    如果params关键字与方法签名定义的多个参数一起使用，params只能使用一次，且必须是最后一个参数</p><h3 id="3-3-4构造函数"><a href="#3-3-4构造函数" class="headerlink" title="3.3.4构造函数"></a>3.3.4构造函数</h3><p>​    如果没有构造函数，编译器会默认生成一个默认的构造函数（引用类型为空引用，数值类型为0，bool为false）</p><p>构造函数的重载遵循与其他方法相同的规则 ；</p><p>​    构造函数的重载遵循与其他方法相同的</p><p>​    如果提供了带参数的构造函数，编译器就不会自动提供默认的构造函数</p><p>​    可以把构造函数定义为private或者protected，这样不相关的类就不能访问他们</p><p><strong>没有公有或受保护的构造函数的用法</strong></p><p>​    类仅仅是静态成员或属性的容器，永远不会实例化，static修饰类，只能包含静态成员，不能实例化</p><p>​    希望仅通过条用个某个静态成员函数来实例化（对象实例化的类工厂方法）（单例模式的实现）</p><h4 id="从构造函数中调用其他构造函数"><a href="#从构造函数中调用其他构造函数" class="headerlink" title="从构造函数中调用其他构造函数"></a>从构造函数中调用其他构造函数</h4><p>​    this关键字仅条用参数最匹配的那个构造函数</p><p>​    c#构造函数初始化器可以包含对同一个类的另一个构造函数的调用，也可以对直接基类的构造函数的调用应使用base代替this关键字，初始化器不能有多个调用</p><h4 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h4><p>​    无参数的静态构造函数</p><p>​        不能带任何参数，一个类只有一个静态构造函数</p><h4 id="只读成员-readonly"><a href="#只读成员-readonly" class="headerlink" title="只读成员 readonly"></a>只读成员 readonly</h4><h4 id="只读字段-readonly"><a href="#只读字段-readonly" class="headerlink" title="只读字段 readonly"></a>只读字段 readonly</h4><h4 id="只读readonly与const的区别"><a href="#只读readonly与const的区别" class="headerlink" title="只读readonly与const的区别"></a>只读readonly与const的区别</h4><p>​        const 编译器通过值取代了使用它的变量，编译器知道它的值</p><p>​        readonly在运行期间通过构造函数制定，与常量字段相反，只读字段可以是实例成员，使用只读字段作为类成员时，需要把static修饰符分配给该字段</p><p>只读字段，不能在构造函数外部赋值</p><p>只读属性{get}</p><p>​    自动实现的只读属性</p><p>​    只读属性也可以在构造函数中初始化</p><p>表达式体属性</p><blockquote><p>public string FullName =&gt; $”{FirstName} {LastName}”;</p></blockquote><p>不可变的类型</p><p>​        例如String，，任何改变总会返回一个新的字符串</p><h2 id="3-4匿名类型"><a href="#3-4匿名类型" class="headerlink" title="3.4匿名类型"></a>3.4匿名类型</h2><h2 id="3-5结构-struct"><a href="#3-5结构-struct" class="headerlink" title="3.5结构 struct"></a>3.5结构 struct</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>​    数据小 提升性能</p><p>​    值类型</p><p>​    不支持继承</p><p>​    分配内存非常快，销毁也快</p><p>​    互相赋予时，会复制一份，有性能损失</p><p>​    当把结构作为参数传递时，应把它作为ref参数传递---避免性能损失，只传递地址；被调用的方法可以改变结构的值</p><h3 id="结构和继承"><a href="#结构和继承" class="headerlink" title="结构和继承"></a>结构和继承</h3><p>​    不能从一个结构中继承</p><p>​    例外： 结构最终派生于类System.Object ,因此可以访问System.Object 的方法</p><p>​    结构 &lt;= System.ValueType&lt;= System.Object</p><h3 id="结构的构造函数"><a href="#结构的构造函数" class="headerlink" title="结构的构造函数"></a>结构的构造函数</h3><h2 id="3-6按值和按引用传递参数"><a href="#3-6按值和按引用传递参数" class="headerlink" title="3.6按值和按引用传递参数"></a>3.6按值和按引用传递参数</h2><h3 id="ref参数-gt-可以通过引用传递结构"><a href="#ref参数-gt-可以通过引用传递结构" class="headerlink" title="ref参数 -&gt;可以通过引用传递结构"></a>ref参数 -&gt;可以通过引用传递结构</h3><p>out参数 -&gt;</p><p>​    如果一个方法返回多个值，可能类型还不同</p><h2 id="3-7可空类型-int-x2-null"><a href="#3-7可空类型-int-x2-null" class="headerlink" title="3.7可空类型  int? x2=null;"></a>3.7可空类型  int? x2=null;</h2><h2 id="3-8枚举-enum"><a href="#3-8枚举-enum" class="headerlink" title="3.8枚举 enum"></a>3.8枚举 enum</h2><p>​    默认enum的类型是int</p><p>​    使用强制类型转换可以把数字改为枚举值，把枚举改为数字</p><p>​    Flags</p><h2 id="3-9-部分类-partial"><a href="#3-9-部分类-partial" class="headerlink" title="3.9 部分类 partial"></a>3.9 部分类 partial</h2><p>​    可以把类分开放在两个文件中</p><p>声明类和结构，返回信息都是类成员</p><p>元组类型</p><h2 id="3-10-扩展方法"><a href="#3-10-扩展方法" class="headerlink" title="3.10 扩展方法"></a>3.10 扩展方法</h2><p>扩展</p><p>​    继承给对象添加功能的好方法</p><p>​    扩展方法是给对象添加功能的另一个选项，在不能使用继承时，可以使用这个选项（例如类是密封的）</p><p>扩展方法是静态方法，是类的一部分，但实际上没有放在类的源代码中</p><p>使用this关键字和第一个参数来扩展字符串，这个关键字定义了要扩展的类型</p><blockquote><p>public static class StringExtension{ public static int<br>GetWordCount(this string s)=&gt; s.Split().Length; ​} ​</p></blockquote><p>好处：</p><p>​    可以使用实例方法的语法，而不是从代码中直接调用静态方法</p><p>​    该方法的实现可以用另一个类取代，而不需要更改代码</p><p>编译器如何找到某个类型的扩展方法？</p><p>​    this关键字必须匹配类型的扩展方法</p><p>​    而且需要打开定义扩展方法的静态类所在名称空间</p><p>​    如果类型还定义了同名的实例方法，扩展方法就永远不会使用</p><p>​    类中已有的实例方法都优先</p><p>Object类，其他类型都从该类派生而来</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第二章 核心C#</title>
      <link href="2021/02/17/c/c-10th-02/"/>
      <url>2021/02/17/c/c-10th-02/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-2-核心c"><a href="#c-语言-2-核心c" class="headerlink" title="c#语言 2 核心c#"></a>c#语言 2 核心c#</h1><h2 id="2-3变量"><a href="#2-3变量" class="headerlink" title="2.3变量"></a>2.3变量</h2><p>c# 区分大小写</p><h3 id="2-3-1初始化变量"><a href="#2-3-1初始化变量" class="headerlink" title="2.3.1初始化变量"></a>2.3.1初始化变量</h3><p>​    c#编译器需要用某个初始值对变量进行初始化，之后才能在操作中引用变量；c#中有两个方法可确保变量使用前进行了初始化</p><p>​        变量是类或结构中的字段，如果没有显示初始化，则创建这些变量时，其默认值就是0</p><p>​        方法的局部变量必须在代码中显示初始化，变量初始化之前就使用了其值，编译器就会标记错误</p><h3 id="2-3-2类型推断"><a href="#2-3-2类型推断" class="headerlink" title="2.3.2类型推断"></a>2.3.2类型推断</h3><p>​    变量必须初始化，编译器推断类型的依据</p><p>​    初始化器不能为空</p><p>​    初始化器必须放在表达式中</p><p>​    不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象</p><h3 id="2-3-3变量的作用域"><a href="#2-3-3变量的作用域" class="headerlink" title="2.3.3变量的作用域"></a>2.3.3变量的作用域</h3><p>定义或规则</p><p>​    只要类在某个作用域内，其字段也在该作用域内</p><p>​    局部变量存在于表示声明该变量的块语句或方法结束的右花括号之前的作用域内</p><p>​    在 for whild 或类似语句中声明的局部变量存在于该循环体内</p><h4 id="局部变量的作用域冲突"><a href="#局部变量的作用域冲突" class="headerlink" title="局部变量的作用域冲突"></a>局部变量的作用域冲突</h4><h4 id="字段和局部变量的作用域冲突"><a href="#字段和局部变量的作用域冲突" class="headerlink" title="字段和局部变量的作用域冲突"></a>字段和局部变量的作用域冲突</h4><blockquote><p>class program{ static int j=20; static void Main(){ int<br>j=30;WriteLine(j); WriteLine(program.j) } ​}</p></blockquote><h3 id="2-3-4常量"><a href="#2-3-4常量" class="headerlink" title="2.3.4常量"></a>2.3.4常量</h3><p>特点</p><p>​    常量声明时必须初始化，指定其值后，就不能再改写了、</p><p>​    常量的值必须在编译时用于计算，因此不能用从变量中提取的值来初始化常亮</p><p>​    常量总是隐式静态的</p><p>好处</p><p>​    易于读取的名称</p><p>​    是程序更易于修改</p><p>​    更容易避免程序出现错误</p><h2 id="2-4预定义数据类型"><a href="#2-4预定义数据类型" class="headerlink" title="2.4预定义数据类型"></a>2.4预定义数据类型</h2><h3 id="2-4-1-值类型和引用类型"><a href="#2-4-1-值类型和引用类型" class="headerlink" title="2.4.1 值类型和引用类型"></a>2.4.1 值类型和引用类型</h3><p>堆栈</p><p>​    值类型存储在堆栈中stack</p><p>​    引用各类型存储在托管堆中 managed heap</p><p>bool 和long等都是值类型，值类型的赋予是通过值复制的</p><p>大多数更复杂的c#数据类型，包括自己声明的类，都是引用类型</p><p>​    CLR实现一种精细的算法，来跟踪哪些引用变量是可以访问的，哪些不能访问，CLR会定期删除不能访问的对象，把占用的内存返回给操作系统，垃圾回收器</p><p>​    如果要把自己的类型定义为值类型，就应把它声明为一个结构</p><h3 id="2-4-2-net-类型"><a href="#2-4-2-net-类型" class="headerlink" title="2.4.2 .net 类型"></a>2.4.2 .net 类型</h3><p>​    15个预定义类型，13个值类型，两个引用类型string 和 object</p><h3 id="2-4-3预定义的值类型"><a href="#2-4-3预定义的值类型" class="headerlink" title="2.4.3预定义的值类型"></a>2.4.3预定义的值类型</h3><p>整型 sbyte 8 short 16 int32 long64</p><p>浮点类型 float32位单精度浮点，double 64位双精度浮点 15/16</p><p>decimal类型 128位高精度十进制数表示法<br>（decimal类型不是基本类型，计算时有性能损失）(高精度计算)</p><blockquote><p>decimal d =12.30M;</p></blockquote><p>bool类型</p><p>字符类型 char 表示一个16位的Unicode字符</p><p>​    转义字符\</p><h3 id="2-4-4预定义的引用类型"><a href="#2-4-4预定义的引用类型" class="headerlink" title="2.4.4预定义的引用类型"></a>2.4.4预定义的引用类型</h3><h4 id="object-类型"><a href="#object-类型" class="headerlink" title="object 类型"></a>object 类型</h4><p>​     可以使用object引用来绑定任何特定子类型的对象;如值类型装箱，再移动到堆中，object引用也可以用于反射，此时必须有代码来处理类型未知的对象</p><p>​    object类型实现了许多一般用途的基本方法，包括Equals(),GetHashCode(),GetType()和ToString()用户定义的类型需要使用一种面向对象技术---重写</p><h4 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h4><p>​    字符串不可修改，修改会产生新的string对象</p><p>​    @的使用，看做所有字符保持原来的含义</p><p>​    字符串插值功能 $</p><h2 id="2-5程序流控制"><a href="#2-5程序流控制" class="headerlink" title="2.5程序流控制"></a>2.5程序流控制</h2><p>if</p><p>for</p><p>while</p><p>do while</p><p>foreach 不能改变集合中各项的值</p><p>跳转语句</p><p>goto语句<br>不能跳转像for循环这样的代码块中，也不能跳出类的范围，不能退出try<br>catch后面的finally</p><p>break语句</p><p>switch 中退出某个语句</p><p>也可用于for foreach whild do...while</p><p>continue语句 只能退出循环的当前迭代</p><p>return 语句 退出类的方法</p><h2 id="2-6-枚举"><a href="#2-6-枚举" class="headerlink" title="2.6 枚举"></a>2.6 枚举</h2><h3 id="枚举是用户定义的整数类型"><a href="#枚举是用户定义的整数类型" class="headerlink" title="枚举是用户定义的整数类型"></a>枚举是用户定义的整数类型</h3><p>优势</p><p>​    代码易于维护，有助于确保给变量制定合法的期望的值</p><p>​    枚举使代码更清晰，允许描述性的蒙城表示整数值，而不是含义模糊的数</p><p>​    更易于输入</p><p>​    枚举真正强大之处，在于实例化为派生自积累system.enum的结构，不会造成性能损失</p><h2 id="2-7名称空间"><a href="#2-7名称空间" class="headerlink" title="2.7名称空间"></a>2.7名称空间</h2><p>using语句</p><h3 id="2-7-2名称空间的别名"><a href="#2-7-2名称空间的别名" class="headerlink" title="2.7.2名称空间的别名"></a>2.7.2名称空间的别名</h3><h2 id="2-8main方法"><a href="#2-8main方法" class="headerlink" title="2.8main方法"></a>2.8main方法</h2><h2 id="2-9使用注释"><a href="#2-9使用注释" class="headerlink" title="2.9使用注释"></a>2.9使用注释</h2><h2 id="2-10-c-预处理指令"><a href="#2-10-c-预处理指令" class="headerlink" title="2.10 c#预处理指令"></a>2.10 c#预处理指令</h2><p>#define 和#undef</p><p>#if #elif #else #endif</p><p>#warning 和#ERROR</p><p>#region 和 #endregion</p><p>#LINE</p><p>#pragma</p><h2 id="2-11c-编程准则"><a href="#2-11c-编程准则" class="headerlink" title="2.11c#编程准则"></a>2.11c#编程准则</h2><h3 id="标识符的规则"><a href="#标识符的规则" class="headerlink" title="标识符的规则"></a>标识符的规则</h3><p>​    尽管可以包含数字字符，但他们必须以字母或下划线开头</p><p>​    不能把c#关键字用作标识符</p><p>用法约定</p><p>命名约定</p><p>​    名称的大小写 Pascal camel</p><p>​    名称的风格统一</p><p>​    名称和关键字</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客资源站收集</title>
      <link href="2021/02/17/good-blogs/"/>
      <url>2021/02/17/good-blogs/</url>
      
        <content type="html"><![CDATA[<h1 id="一个不错的博客-算法-leet-code"><a href="#一个不错的博客-算法-leet-code" class="headerlink" title="一个不错的博客  算法 leet code"></a>一个不错的博客  算法 leet code</h1><p><a href="https://www.cxyxiaowu.com/">https://www.cxyxiaowu.com/</a></p><h1 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h1><p><a href="http://www.ptbird.cn/list.html">http://www.ptbird.cn/list.html</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello MyBlog</title>
      <link href="2021/02/17/hello-myblog/"/>
      <url>2021/02/17/hello-myblog/</url>
      
        <content type="html"><![CDATA[<h2 id="使用github-page-和hexo搭建第一个网站"><a href="#使用github-page-和hexo搭建第一个网站" class="headerlink" title="使用github page 和hexo搭建第一个网站"></a>使用github page 和hexo搭建第一个网站</h2><p><a href="https://www.zhihu.com/question/22197688">https://www.zhihu.com/question/22197688</a></p><h2 id="博客美化-博客主题之hexo-theme-matery的介绍"><a href="#博客美化-博客主题之hexo-theme-matery的介绍" class="headerlink" title="博客美化 博客主题之hexo-theme-matery的介绍"></a>博客美化 博客主题之hexo-theme-matery的介绍</h2><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#alipay">https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#alipay</a></p><h3 id="hexo扩展学习"><a href="#hexo扩展学习" class="headerlink" title="hexo扩展学习"></a>hexo扩展学习</h3><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p><a href="https://hexo.io/themes/index.html">https://hexo.io/themes/index.html</a></p><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><h3 id="window下pandoc的如何使用-文档类型转换"><a href="#window下pandoc的如何使用-文档类型转换" class="headerlink" title="window下pandoc的如何使用 文档类型转换"></a>window下pandoc的如何使用 文档类型转换</h3><p><a href="https://www.jianshu.com/p/f4a9ceb68088">https://www.jianshu.com/p/f4a9ceb68088</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
            <tag> github gage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第一章 .net 应用程序体系结构</title>
      <link href="2021/02/17/c/c-10th-01/"/>
      <url>2021/02/17/c/c-10th-01/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第一章-net-应用程序体系结构"><a href="#c-语言-第一章-net-应用程序体系结构" class="headerlink" title="c#语言 第一章 .net 应用程序体系结构"></a>c#语言 第一章 .net 应用程序体系结构</h1><h2 id="1-2-回顾net-历史"><a href="#1-2-回顾net-历史" class="headerlink" title="1.2.回顾net 历史"></a>1.2.回顾net 历史</h2><h3 id="net-版本"><a href="#net-版本" class="headerlink" title=".net 版本"></a>.net 版本</h3><p>​    CLR(Common Language Runtime) 公共语言运行库</p><p>​    c#</p><p>​    Visual Studio</p><h3 id="1-2-1c-1-0-新语言"><a href="#1-2-1c-1-0-新语言" class="headerlink" title="1.2.1c#1.0 新语言"></a>1.2.1c#1.0 新语言</h3><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><p>​        面向对象编程语言，具备继承，封装和多态性等特性</p><p>​        也提供了基于组件的变成改造，如委托和事件</p><h4 id="CLR"><a href="#CLR" class="headerlink" title="CLR"></a>CLR</h4><p>​     .net 编程语言都使用的运行库，类似java虚拟机</p><p>​     中间语言Intermediate Language IL代码，编译器生成IL代码，当程序运行时，JIT编译器会从IL代码生成本地代码</p><p>​     GC垃圾回收</p><p>​     调试器扩展</p><p>​     线程实用工具</p><p>​    CLR还负责线程的处理，C#中创建托管的线程不一定来自底层操作系统，线程的虚拟化和管理有CLR负责</p><h3 id="1-2-2带有泛型的c-2-和-net-2"><a href="#1-2-2带有泛型的c-2-和-net-2" class="headerlink" title="1.2.2带有泛型的c#2 和.net 2"></a>1.2.2带有泛型的c#2 和.net 2</h3><h3 id="1-2-3-net-3-0-WPF"><a href="#1-2-3-net-3-0-WPF" class="headerlink" title="1.2.3 .net 3.0 WPF"></a>1.2.3 .net 3.0 WPF</h3><p>​    WPF 矢量图形控件</p><p>​     WCF 通用通信</p><h3 id="1-2-4-c-LINQ-EF"><a href="#1-2-4-c-LINQ-EF" class="headerlink" title="1.2.4 c##  LINQ   EF"></a>1.2.4 c##  LINQ   EF</h3><h3 id="1-2-5-c-4-dynamic-TPL-任务并行库"><a href="#1-2-5-c-4-dynamic-TPL-任务并行库" class="headerlink" title="1.2.5  c# 4 dynamic TPL(任务并行库)"></a>1.2.5  c# 4 dynamic TPL(任务并行库)</h3><p>​    使用Task 和 Parallel 类抽象出线程</p><h3 id="1-2-6c-5-异步编程-async-和await"><a href="#1-2-6c-5-异步编程-async-和await" class="headerlink" title="1.2.6c#5 异步编程  async 和await"></a>1.2.6c#5 异步编程  async 和await</h3><h3 id="1-2-7-c-6-新的编译器引擎-Roslyn"><a href="#1-2-7-c-6-新的编译器引擎-Roslyn" class="headerlink" title="1.2.7 c#6 新的编译器引擎 Roslyn"></a>1.2.7 c#6 新的编译器引擎 Roslyn</h3><h4 id="1-3-2-net-core-1-0-CORE-CLI"><a href="#1-3-2-net-core-1-0-CORE-CLI" class="headerlink" title="1.3.2 .net core 1.0   CORE CLI"></a>1.3.2 .net core 1.0   CORE CLI</h4><p>特性：</p><p>​    开源</p><p>​    模块化的方式设计</p><p>​    可以很快更新</p><p>程序集 assembly：编译好的，面向.net framework的代码逻辑单元</p><p>​        私有程序集</p><p>​        共享程序集（Global Assembly Cache）</p><h3 id="1-3-5-公共语言运行库"><a href="#1-3-5-公共语言运行库" class="headerlink" title="1.3.5 公共语言运行库"></a>1.3.5 公共语言运行库</h3><p>​       编译器将源代码编译为Microsoft中间语言(Intermediate Language, IL)生成IL代码，当程序运行时，JIT编译器会从IL代码生成本地代码</p><p>​       CLR还负责线程的处理，C#中创建托管的线程不一定来自底层操作系统，线程的虚拟化和管理有CLR负责</p><h3 id="1-3-7windows运行库-windows-runtime"><a href="#1-3-7windows运行库-windows-runtime" class="headerlink" title="1.3.7windows运行库 windows runtime"></a>1.3.7windows运行库 windows runtime</h3><h2 id="net-2015"><a href="#net-2015" class="headerlink" title=".net 2015"></a>.net 2015</h2><h3 id="1-5-net-4-6编译"><a href="#1-5-net-4-6编译" class="headerlink" title="1.5.net 4.6编译"></a>1.5.net 4.6编译</h3><p>​    c# 命令行编译器（csc.exe）: csc HelloWorld.cs -&gt; 中间语言代码</p><p>​    DASM中间语言反汇编程序 （ildasm.exe）</p><p>.net core cli编译</p><p>​    repl学习 ： dotnet repl</p><h2 id="1-7应用程序类型与技术"><a href="#1-7应用程序类型与技术" class="headerlink" title="1.7应用程序类型与技术"></a>1.7应用程序类型与技术</h2><h3 id="1-7-1数据访问"><a href="#1-7-1数据访问" class="headerlink" title="1.7.1数据访问"></a>1.7.1数据访问</h3><pre><code>Database FirstModel First</code></pre><p>CodeFirst:<br>   代码优先有一定意味着数据库不能事先存在；数据库可以动态创建，属性和流利的API可以以编程方式定义映射</p><h3 id="1-7-2桌面应用程序"><a href="#1-7-2桌面应用程序" class="headerlink" title="1.7.2桌面应用程序"></a>1.7.2桌面应用程序</h3><p>WF WPF</p><h3 id="1-7-3-UWP"><a href="#1-7-3-UWP" class="headerlink" title="1.7.3 UWP"></a>1.7.3 UWP</h3><h3 id="1-7-4soap服务和WCF"><a href="#1-7-4soap服务和WCF" class="headerlink" title="1.7.4soap服务和WCF"></a>1.7.4soap服务和WCF</h3><h3 id="1-7-5WEB服务-WEB-API-基于REST"><a href="#1-7-5WEB服务-WEB-API-基于REST" class="headerlink" title="1.7.5WEB服务 WEB API 基于REST"></a>1.7.5WEB服务 WEB API 基于REST</h3><h3 id="1-7-6WebHooks-和SignalR-基于-webSocket"><a href="#1-7-6WebHooks-和SignalR-基于-webSocket" class="headerlink" title="1.7.6WebHooks 和SignalR 基于 webSocket"></a>1.7.6WebHooks 和SignalR 基于 webSocket</h3><h3 id="1-7-7windows服务"><a href="#1-7-7windows服务" class="headerlink" title="1.7.7windows服务"></a>1.7.7windows服务</h3><pre><code>world wide web服务 可以监听客户端的web请求</code></pre><h3 id="Microsoft-Azure服务"><a href="#Microsoft-Azure服务" class="headerlink" title="Microsoft Azure服务"></a>Microsoft Azure服务</h3><p>​    SaaS IaaS PaaS</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 前言</title>
      <link href="2021/02/17/c/c-10th/"/>
      <url>2021/02/17/c/c-10th/</url>
      
        <content type="html"><![CDATA[<h1 id="c-是专门用于-net-的语言"><a href="#c-是专门用于-net-的语言" class="headerlink" title="c# 是专门用于 .net 的语言"></a>c# 是专门用于 .net 的语言</h1><p>web 页面<br>WPF<br>REST WEB服务<br>分布式应用程序的组件<br>数据库访问组件<br>桌面应用程序<br>UWP</p><h1 id="net-core-重要性"><a href="#net-core-重要性" class="headerlink" title=".net core 重要性"></a>.net core 重要性</h1><p>.net framework<br><a href="http://asp.net/">asp.net</a> web forms ？ MVC<br>WIN form /UWP<br>EF / LINQ</p><h1 id="NET-CORE"><a href="#NET-CORE" class="headerlink" title=".NET CORE"></a>.NET CORE</h1><p>开源<br>包较小，更快的创新<br>支持多个平台<br>可以编译为本地代码<br>Xamarin</p><h1 id="C-重要性"><a href="#C-重要性" class="headerlink" title="C# 重要性"></a>C# 重要性</h1><p>设计思想来源于C++ 、java、Pascal<br>面向对象的通用编程语言<br>给予组件的变成语言，支持属性、时间、特性和构建程序集<br>函数数编程理念<br>增加了泛型、语言集成查询linq、lambda表达式、动态特性、更简单的异步编程</p><h1 id="c-6-新特性"><a href="#c-6-新特性" class="headerlink" title="c#6 新特性"></a>c#6 新特性</h1><h2 id="静态using声明："><a href="#静态using声明：" class="headerlink" title="静态using声明："></a>静态using声明：</h2><p>静态的声明允许调用静态方式时不适用类名</p><blockquote><p>using static sysytem.console； Writeline(&quot;hello world&quot;) ​</p></blockquote><h2 id="表达式体方法"><a href="#表达式体方法" class="headerlink" title="表达式体方法:"></a>表达式体方法:</h2><p>表达式方法只包括一个可以用lambda语法编写的语句</p><blockquote><p>public bool isSquare（Rectangle rect）=&gt;rect.Height == rect.Width;</p></blockquote><h2 id="表达式体属性："><a href="#表达式体属性：" class="headerlink" title="表达式体属性："></a>表达式体属性：</h2><p>与表达式方法类似，只有get存取器的单行属性可以用lamabda语法编写</p><blockquote><p>public string FullName =&gt; FirstName +&quot;&quot;+ LastName;</p></blockquote><h2 id="自动实现的属性初始化器"><a href="#自动实现的属性初始化器" class="headerlink" title="自动实现的属性初始化器:"></a>自动实现的属性初始化器:</h2><p>自动实现的属性可以用属性初始化器来初始化</p><blockquote><p>public class Person{ public int Age{get;set;}=42; ​}</p></blockquote><h2 id="只读的自动属性"><a href="#只读的自动属性" class="headerlink" title="只读的自动属性"></a>只读的自动属性</h2><blockquote><p>public BookId {get;} </p></blockquote><h2 id="ameof-运算符："><a href="#ameof-运算符：" class="headerlink" title="ameof 运算符："></a>ameof 运算符：</h2><p>使用此运算符，可以访问字段名、属性名、方法名、类型名</p><h2 id="空值传播运算符"><a href="#空值传播运算符" class="headerlink" title="空值传播运算符"></a>空值传播运算符</h2><blockquote><p>int? age =p?.Age; handler?.Invoke(source,e)</p></blockquote><h2 id="字符串插值-占位符可以直接是表达式"><a href="#字符串插值-占位符可以直接是表达式" class="headerlink" title="字符串插值: 占位符可以直接是表达式"></a>字符串插值: 占位符可以直接是表达式</h2><blockquote><p>public override ToString() =&gt; $&quot;{Title} {Publisher}&quot;</p></blockquote><h2 id="字典初始化器"><a href="#字典初始化器" class="headerlink" title="字典初始化器"></a>字典初始化器</h2><blockquote><p>var dict = new Dictionary&lt;int,string&gt;(){<br>    2 =”three”,<br>  3=”seven”<br> ​}</p></blockquote><h2 id="异常过滤器"><a href="#异常过滤器" class="headerlink" title="异常过滤器"></a>异常过滤器</h2><h2 id="Catch-中的await"><a href="#Catch-中的await" class="headerlink" title="Catch 中的await"></a>Catch 中的await</h2><blockquote><p>try{ // }Catch(MyException ex){ await new<br>MessageDialog().showAsync(ex.Message); ​}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
