<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>centos安装使用教程</title>
      <link href="2021/03/27/linux/centos-an-zhuang-abp/"/>
      <url>2021/03/27/linux/centos-an-zhuang-abp/</url>
      
        <content type="html"><![CDATA[<h1 id="ABP框架-net-core3-1搭建的项目访问MySQL数据库"><a href="#ABP框架-net-core3-1搭建的项目访问MySQL数据库" class="headerlink" title="ABP框架+.net core3.1搭建的项目访问MySQL数据库"></a>ABP框架+.net core3.1搭建的项目访问MySQL数据库</h1><p><a href="https://www.jianshu.com/u/ef656625b423"><img src="https://upload.jianshu.io/users/upload_avatars/10254515/136575a0-060e-4fc5-96dc-a877877002bb.png?imageMogr2/auto-orient/strip%7CimageView2/1/w/96/h/96" alt="img"></a></p><p><a href="https://www.jianshu.com/u/ef656625b423">酷娃利息对比计算</a></p><p>2020.10.22 11:52:44字数 306阅读 199</p><p>1.Nuget卸载microsoft.entityframeworkcore.design</p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-6f323c6b0ee5faf0?imageMogr2/auto-orient/strip%7CimageView2/2/w/966" alt="img"></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9">2.Nuget卸载microsoft.entityframeworkcore.sqlserver</a></p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-3a93584bcea2b245?imageMogr2/auto-orient/strip%7CimageView2/2/w/939" alt="img"></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9">3.Nuget卸载microsoft.entityframeworkcore.sqlserver.design.</a></p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-8d0e74e2c0a7b4eb?imageMogr2/auto-orient/strip%7CimageView2/2/w/966" alt="img"></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9">4.Nuget安装pomelo.entityframeworkcore.mysql.design</a></p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-c1e594c1c91a6baf?imageMogr2/auto-orient/strip%7CimageView2/2/w/961" alt="img"></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9">5.Nuget安装pomelo.entityframeworkcore.mysql</a></p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-7f03c58323d81f2a?imageMogr2/auto-orient/strip%7CimageView2/2/w/968" alt="img"></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9">6.在解决方案的EntityFrameCore层找到DbContextOptionsConfigurer文件，并做如下修改：</a></p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-790f099a3be10b74?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="img"></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9">7.在xxx.xxx.Web层安装microsoft.entityframeworkcore.design.</a></p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-aa4c4e75b62f1742?imageMogr2/auto-orient/strip%7CimageView2/2/w/945" alt="img"></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9">8.更改数据库连接.</a></p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-f91242059c108b29?imageMogr2/auto-orient/strip%7CimageView2/2/w/872" alt="img"></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9">9.添加MySQL数据库中表对应的实体对象.</a></p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-9c38a43272477c7b?imageMogr2/auto-orient/strip%7CimageView2/2/w/707" alt="img"></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9">10.执行Migration:Add-Migration InitTable</a></p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-d1babe995d4560c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/676" alt="img"></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9">11.在执行Migration:update-database</a></p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-f7100e41ced2de03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/743" alt="img"></p><p>看到Done.就代表执行成功.</p><p>MySQL中查看,已经成功生成了表.</p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-f48ebb926970ca4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1047" alt="img"></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9">若过程中有如下报错情况:</a></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9">执行Migration报错：System.TypeLoadException</a></p><p>HResult=0x80131522</p><p>Message=Method ‘get_Info’ in type ‘MySql.Data.EntityFrameworkCore.Infraestructure.MySQLOptionsExtension’</p><p>Culture=neutral, PublicKeyToken=c5687fc88969c44d’ does not have an implementation.</p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-3efbe99890ffcb03?imageMogr2/auto-orient/strip%7CimageView2/2/w/1006" alt="img"></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9"><strong>解决办法:</strong></a></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9"><strong>Nuget更新:pomelo.entityframeworkcore.mysql 版本为3.0.0</strong></a></p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-2ad2005867281d3b?imageMogr2/auto-orient/strip%7CimageView2/2/w/975" alt="img"></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9">执行Migration报错:</a></p><p><img src alt="img"></p><p><a href="https://www.jianshu.com/p/152cbc4c60d9"><strong>解决办法:是因为MySQL的数据库链接配置错误.如截图所示:</strong></a></p><p><strong>要将Server 改为Data Source</strong></p><p>如截图所示:</p><p><img src="https://upload-images.jianshu.io/upload_images/10254515-0a362a8f65c8a753?imageMogr2/auto-orient/strip%7CimageView2/2/w/880" alt="img"></p><h1 id="mysql-新版本的连接方法"><a href="#mysql-新版本的连接方法" class="headerlink" title="mysql  新版本的连接方法"></a>mysql  新版本的连接方法</h1><pre><code>  public static class MaximGroupDbContextConfigurer    &#123;        public static void Configure(DbContextOptionsBuilder&lt;MaximGroupDbContext&gt; builder, string connectionString)        &#123;            builder.UseMySql(connectionString,                 new MySqlServerVersion(new System.Version(8, 0, 21)),                mySqlOptions =&gt; mySqlOptions                .CharSetBehavior(Pomelo.EntityFrameworkCore.MySql.Infrastructure.CharSetBehavior.NeverAppend)                ).EnableSensitiveDataLogging()                .EnableDetailedErrors();        &#125;        public static void Configure(DbContextOptionsBuilder&lt;MaximGroupDbContext&gt; builder, DbConnection connection)        &#123;            builder.UseMySql(connection, new MySqlServerVersion(new System.Version(8, 0, 21)),                mySqlOptions =&gt; mySqlOptions                .CharSetBehavior(Pomelo.EntityFrameworkCore.MySql.Infrastructure.CharSetBehavior.NeverAppend)                ).EnableSensitiveDataLogging()                .EnableDetailedErrors();        &#125;    &#125;</code></pre><h1 id="CentOS中zip压缩和unzip解压缩命令详解"><a href="#CentOS中zip压缩和unzip解压缩命令详解" class="headerlink" title="CentOS中zip压缩和unzip解压缩命令详解"></a>CentOS中zip压缩和unzip解压缩命令详解</h1><p>​                                                                                    </p><p>以下命令均在/home目录下操作</p><p>cd /home #进入/home目录</p><p>1、把/home目录下面的mydata目录压缩为mydata.zip</p><p>zip -r mydata.zip mydata #压缩mydata目录</p><p>2、把/home目录下面的mydata.zip解压到mydatabak目录里面</p><p>unzip mydata.zip -d mydatabak</p><p>3、把/home目录下面的abc文件夹和123.txt压缩成为abc123.zip</p><p>zip -r abc123.zip abc 123.txt</p><p>4、把/home目录下面的wwwroot.zip直接解压到/home目录里面</p><p>unzip wwwroot.zip</p><p>5、把/home目录下面的abc12.zip、abc23.zip、abc34.zip同时解压到/home目录里面 </p><p>unzip abc*.zip</p><p>6、查看把/home目录下面的wwwroot.zip里面的内容</p><p>unzip -v wwwroot.zip</p><p>7、验证/home目录下面的wwwroot.zip是否完整</p><p>unzip -t wwwroot.zip</p><p>8、把/home目录下面wwwroot.zip里面的所有文件解压到第一级目录</p><p>unzip -j wwwroot.zip</p><h1 id="CentOS7上部署-Net-Core项目"><a href="#CentOS7上部署-Net-Core项目" class="headerlink" title="CentOS7上部署.Net Core项目"></a>CentOS7上部署.Net Core项目</h1><h2 id="4-部署ASP-NET-Core-应用程序到CentOS服务器"><a href="#4-部署ASP-NET-Core-应用程序到CentOS服务器" class="headerlink" title="4.**部署ASP.NET Core 应用程序到CentOS服务器**"></a><strong>4.**</strong>部署ASP.NET Core 应用程序到CentOS服务器**</h2><p>将发布的文件夹传输到服务器，我这里用的是xftp(也可以用FileZilla等其他的ftp工具)</p><p><img src="https://img-blog.csdnimg.cn/20181102161749235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rhbmdtb3VfcmVu,size_16,color_FFFFFF,t_70" alt="img"></p><p>将发布的文件夹传输到服务器你想放的位置</p><h2 id="5-安装配置Nginx进行反向代理"><a href="#5-安装配置Nginx进行反向代理" class="headerlink" title="5. 安装配置Nginx进行反向代理"></a><strong>5.</strong> <strong>安装配置Nginx进行反向代理</strong></h2><h3 id="5-1-安装Nginx"><a href="#5-1-安装Nginx" class="headerlink" title="5.1**安装Nginx**"></a><strong>5.1**</strong>安装Nginx**</h3><p>①使用如下命令安装CentOS的 EPEL仓库：<strong>yum install epel-release</strong></p><p>②使用如下命令安装Nginx：<strong>yum install nginx</strong></p><p>③Nginx安装完成后, 系统并不会启动Nginx, 使用如下命令启动Nginx: <strong>systemctl start nginx</strong></p><p>④使用如下命令设置系统启动后, 默认启动Nginx: <strong>systemctl enable nginx</strong></p><p>⑤查看firewall 状态, 并启动防火墙：</p><p><strong>systemctl status firewalld</strong> //查看防火墙状态</p><p><strong>systemctl start firewalld</strong> //启动防火墙</p><p>⑥使用如下命令, 允许HTTP和HTTPS通过防火墙：</p><p><strong>firewall-cmd –permanent –zone=public –add-service=http</strong>   //允许HTTP</p><p><strong>firewall-cmd –permanent –zone=public –add-service=https</strong>  //允许HTTPS</p><p><strong>firewall-cmd –reload</strong> </p><p>⑦在浏览器地址栏输入你服务器的IP地址, 如果出现下图表示Nginx安装配置成功;</p><p><img src="https://img-blog.csdnimg.cn/20181102161749276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rhbmdtb3VfcmVu,size_16,color_FFFFFF,t_70" alt="img"></p><p>如果无法访问, 请查看firewall 是否开放80端口：</p><p><strong>firewall-cmd –zone= public –add-port= 3306 /tcp –permanent</strong>  //开放80端口</p><p><strong>systemctl restart firewalld.service</strong>               //重启防火墙</p><h3 id="5-2-修改Nginx的配置文件"><a href="#5-2-修改Nginx的配置文件" class="headerlink" title="5.2**修改Nginx的配置文件**"></a><strong>5.2**</strong>修改Nginx的配置文件**</h3><p>首先，把Nginx的默认配置文件 /etc/nginx/nginx.conf里 80 端口转发配置 server 节点用 # 符注释掉。使用命令vi 或将 nginx.conf 文件下载(使用xftp或其他ftp工具都行)到本地修改完成后在上传(建议);</p><p><strong>vi /etc/nginx/nginx.conf</strong>    //打开文件编辑模式, 输入i 进行编辑 完成后 按ESC键输入:wq 回车 退出编辑模式</p><p><img src="https://img-blog.csdnimg.cn/20181102161749249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rhbmdtb3VfcmVu,size_16,color_FFFFFF,t_70" alt="img"></p><p>然后我们重新创建一个自定义的Nginx配置文件用来代理Core 程序, 我创建名称为nginxforcore.conf(你可以自定义文件名);配置文件内容如下:</p><pre><code> </code></pre><ol><li><code>server &#123;</code></li><li><code>  listen 80;</code></li><li><code>  location / &#123;</code></li><li><code>    proxy_pass http://localhost:5000;</code></li><li><code>    proxy_http_version 1.1;</code></li><li><code>    proxy_set_header Upgrade $http_upgrade;</code></li><li><code>    proxy_set_header Connection keep-alive;</code></li><li><code>    proxy_set_header Host $host;</code></li><li><code>    proxy_cache_bypass $http_upgrade;</code></li><li><code>  &#125;</code></li><li><code>&#125;</code></li></ol><p>proxy_pass http: 后的url为你在core 启动项配置的路径(默认localhost:5000)</p><p>将创建好的自定义配置文件上传到 /etc/nginx/conf.d目录下 ，最后执行命令 重启Nginx: <strong>nginx –s reload</strong></p><h3 id="5-3-将Nginx添加到SELinux白名单"><a href="#5-3-将Nginx添加到SELinux白名单" class="headerlink" title="5.3**将Nginx添加到SELinux白名单**"></a><strong>5.3**</strong>将Nginx添加到SELinux白名单**</h3><p>①查看SELinux状态是否为Enforcing(SELinux默认状态为Disabled), 必须保证SELinux的状态为Enforcing否则添加白名单会失败;</p><p><a href="https://www.linuxidc.com/Linux/2016-11/137723.htm%EF%BC%88%E4%BF%AE%E6%94%B9SELinux%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%89">https://www.linuxidc.com/Linux/2016-11/137723.htm（修改SELinux的状态）</a></p><p>使用如下命令: <strong>getenforce</strong></p><p>如果查询出的值为Enforcing, 执行下一步操作：添加Nginx到SELinux白名单</p><p>②使用如下命令, 将Nginx添加至SELinux白名单，依次执行以下命令</p><pre><code> </code></pre><ol><li><code>yum install policycoreutils-python</code></li><li></li><li><code>cat /var/log/audit/audit.log | grep nginx | grep denied | audit2allow -M AddNginxToSELinux</code></li><li></li><li><code>semodule -i AddNginxToSELinux.pp</code></li></ol><p>(AddNginxToSELinux)该文件可以自己命名</p><p>测试是否修改成功：</p><p>①cd到发布目录（我的为publish文件夹）</p><p>②运行.Net Core程序：(dotnet AbpMPA.Web.Mvc.dll,后面的dll文件为你.Net Core程序的入库dll)</p><p>③在浏览器地址栏输入你服务器的IP地址, 如果出现你自己程序运行的界面，例如下图(这是我的程序的登陆界面)说明我们的ASP.NET Core MVC 已经发布成功了;</p><p><img src="https://img-blog.csdnimg.cn/20181102161749275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rhbmdtb3VfcmVu,size_16,color_FFFFFF,t_70" alt="img"></p><p>如果没有出现上图, 而是</p><p><img src="https://img-blog.csdnimg.cn/20181102161749283.png" alt="img"></p><p>请检查:</p><p>1-Nginx是否按上述步骤正确配置;</p><p>2-防火墙及阿里云安全组策略是否正确配置(主要指80端口);</p><p>3-.NET Core程序是否在CentOS下正常运行;</p><h2 id="6-配置守护进程Supervisor-让我们的程序能365天24小时不间断运行"><a href="#6-配置守护进程Supervisor-让我们的程序能365天24小时不间断运行" class="headerlink" title="6.**配置守护进程Supervisor, 让我们的程序能365天24小时不间断运行**"></a><strong>6.**</strong>配置守护进程Supervisor, 让我们的程序能365天24小时不间断运行**</h2><p>通过上面的操作, 我们已经能正常将.NET Core程序发布到CentOS下来, 但是发布过程中我们也发现了问题, 就是.NET Core不能自动的运行, 一旦我们的命令行工具关掉, 发布的程序就不能访问了;</p><p>是不是能安装一个类似于Windows Service一样的服务, 能实时监控程序状态，异常退出时能自动重启。经过各种百度我找到了Supervisor。</p><p>Supervisor 是用Python开发的Linux/Unix系统下的一个进程管理工具。它可以使进程(类似Windows Service)脱离终端，变为后台守护进程（daemon）。能实时监控进程状态，异常退出时能自动重启。详细文档请查看官网。</p><h3 id="6-1-安装Supervisor"><a href="#6-1-安装Supervisor" class="headerlink" title="6.1**安装Supervisor**"></a><strong>6.1**</strong>安装Supervisor**</h3><p><strong>yum install python-setuptools</strong></p><p><strong>easy_install supervisor</strong></p><h3 id="6-2-配置Supervisor"><a href="#6-2-配置Supervisor" class="headerlink" title="6.2**配置Supervisor**"></a><strong>6.2**</strong>配置Supervisor**</h3><p>①运行supervisord 服务的时候，需要指定 Supervisor 配置文件，所以，先通过如下命令创建目录，以便让 supervisor 成功加载默认配置：</p><p><strong>mkdir /etc/supervisor</strong></p><p>②目录创建成功后, 通过 echo_supervisord_conf 程序（用来生成初始配置文件,文件名可以自定义）来初始化一个配置文件：</p><p><strong>echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf</strong></p><p>③通过vim命令修改创建好的supervisord.conf配置信息：</p><p><strong>vi /etc/supervisor/supervisord.conf</strong></p><p>④最下边找到如下文本片段：</p><p><img src="https://img-blog.csdnimg.cn/20181102161749269.png" alt="img"></p><p>修改为：</p><p><img src="https://img-blog.csdnimg.cn/20181102161749332.png" alt="img"></p><p>该操作的目的是我们创建一个supervisor 进程配置文件加载目录。让supervisor自动加载该目录下 .ini 后缀的文件作为服务配置</p><h3 id="6-3-为我们部署的-NET-Core添加进程配置文件"><a href="#6-3-为我们部署的-NET-Core添加进程配置文件" class="headerlink" title="6.3**为我们部署的.NET Core添加进程配置文件**"></a><strong>6.3**</strong>为我们部署的.NET Core添加进程配置文件**</h3><p>①创建配置文件AbpMPACore.ini(文件名自定义)</p><pre><code> </code></pre><ol><li><code>[program:AbpMPACore]             ;自定义进程名称, 根据自己喜好命名</code></li><li><code>command=dotnet AbpMPA.Web.Mvc.dll       ;程序启动命令 使用dotnet 命令</code></li><li><code>directory=/publish              ;命令执行的目录 你.NET Core 程序存放目录</code></li><li><code>autostart=true                ;在Supervisord启动时，程序是否启动</code></li><li><code>autorestart=true               ;程序退出后自动重启</code></li><li><code>startretries=5                ;启动失败自动重试次数，默认是3</code></li><li><code>startsecs=1                  ;自动重启间隔</code></li><li><code>user=admin                  ;设置启动进程的用户，默认是root</code></li><li><code>priority=999                 ;进程启动优先级，默认999，值小的优先启动</code></li><li><code>stderr_logfile=/var/log/AbpMPA.err.log    ;标准错误日志 路径可以自定义</code></li><li><code>stdout_logfile=/var/log/AbpMPA.out.log    ;标准输出日志 路径可以自定义</code></li><li><code>environment=ASPNETCORE_ENVIRONMENT=Production ;进程环境变量</code></li><li><code>stopsignal=INT                ;请求停止时用来杀死程序的信号</code></li></ol><p><img src="https://img-blog.csdnimg.cn/20181102161749370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rhbmdtb3VfcmVu,size_16,color_FFFFFF,t_70" alt="img"></p><p>②在/etc/supervisor/目录下创建一个文件夹conf.d: <strong>mkdir /etc/supervisor/conf.d</strong></p><p>将刚创建的配置文件AbpMPACore.ini移到conf.d文件夹下</p><h3 id="6-4-启动-Supervisor-服务"><a href="#6-4-启动-Supervisor-服务" class="headerlink" title="6.4 启动 Supervisor 服务"></a><strong>6.4</strong> <strong>启动 Supervisor 服务</strong></h3><p><strong>supervisord -c /etc/supervisor/supervisord.conf</strong></p><p>这个时候, 我们已经不需要使用dotnet命令运行程序, 同样可以访问我们部署的.NET Core程序了</p><h3 id="6-5-配置Supervisor开机启动"><a href="#6-5-配置Supervisor开机启动" class="headerlink" title="6.5**配置Supervisor开机启动**"></a><strong>6.5**</strong>配置Supervisor开机启动**</h3><p>①进入/usr/lib/systemd/system/目录，并创建supervisord.service文件(或者在本地写好了再通过ftp工具传输到指定目录下)</p><p><strong>vi /usr/lib/systemd/system/supervisord.service</strong></p><pre><code> </code></pre><ol><li><code>[Unit]</code></li><li><code>Description=Supervisor daemon</code></li><li></li><li><code>[Service]</code></li><li><code>Type=forking</code></li><li><code>ExecStart=/usr/bin/supervisord -c /etc/ supervisor/supervisord.conf</code></li><li><code>ExecStop=/usr/bin/supervisorctl $OPTIONS shutdown</code></li><li><code>ExecReload=/usr/bin/supervisorctl $OPTIONS reload</code></li><li><code>KillMode=process</code></li><li><code>Restart=on-failure</code></li><li><code>RestartSec=42s</code></li><li></li><li><code>[Install]</code></li><li><code>WantedBy=multi-user.target</code></li></ol><p>②设置开机启动</p><p><strong>systemctl enable supervisord.service</strong></p><p><strong>systemctl daemon-reload</strong></p><p>③重启，测试是否可以开机自启</p><h1 id="yum-安装supervisor"><a href="#yum-安装supervisor" class="headerlink" title="yum 安装supervisor"></a>yum 安装<strong>supervisor</strong></h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>yum install epel-releaseyum install -y supervisor12</code></pre><p>默认配置文件：/etc/supervisord.conf<br> 进程管理配置文件放到：/etc/supervisord.d/目录下即可</p><p>进程配置文件如下实例：</p><pre><code>[program:test-server]process_name=%(program_name)scommand = /home/directory = /home/test-serverautostart = truestartsecs = 5autorestart = truestartretries = 3user = rootredirect_stderr = truestdout_logfile_maxbytes = 20MBstdout_logfile_backups = 10stdout_logfile = /var/log/test-server.log12345678910111213</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>supervisorctr restart start stop 等等</p><h1 id="Abp-aspnet-core项目部署到Centos7-2全流程攻略"><a href="#Abp-aspnet-core项目部署到Centos7-2全流程攻略" class="headerlink" title="Abp aspnet-core项目部署到Centos7.2全流程攻略"></a>Abp aspnet-core项目部署到Centos7.2全流程攻略</h1><h2 id><a href="#" class="headerlink" title></a></h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>鉴于跨平台趋势潮流，小试一把微软东家的跨平台体验。 期间坑多多，依次记录，与君共勉。</p><h3 id="流程简单记录"><a href="#流程简单记录" class="headerlink" title="流程简单记录"></a>流程简单记录</h3><ol><li>在官方<a href="https://aspnetboilerplate.com/Templates">aspnetboilerplate</a>生成项目架构</li><li>还原项目并修改配置添加数据库支持</li><li>本地生成并且打包成文件</li><li>linux系统选择的Centos7.2测试，其他版本请相应修改,环境以及服务的搭建</li><li>打包文件部署到服务器并部署调试</li><li>安装supervisor守护程序守护项目</li></ol><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1 前期准备"></a>1 前期准备</h3><h4 id="1-在官方下载项目模板"><a href="#1-在官方下载项目模板" class="headerlink" title="1. 在官方下载项目模板"></a>1. 在官方下载项目模板</h4><p><img src="https://user-gold-cdn.xitu.io/2018/1/5/160c522bb298d7ed?imageView2/0/w/1280/h/960/ignore-error/1" alt="模板下载"></p><p>版本选择ASPNET Core版本 至于前端展示取决于业务需求。反正我用的是前后端分离，所以这块是用不到的。</p><h4 id="2-下载的项目结构如图所示"><a href="#2-下载的项目结构如图所示" class="headerlink" title="2. 下载的项目结构如图所示"></a>2. 下载的项目结构如图所示</h4><p><img src="https://user-gold-cdn.xitu.io/2018/1/5/160c525398fbc45d?imageView2/0/w/1280/h/960/ignore-error/1" alt="img"></p><p>具体工程的功能请自寻解释在此不再展开。 修改XXX.Migrator 和XXX.Web.Host下appsetings.json的链接字符串,此处由于我用的是mysql数据库。关于如何修改配置 请参考<a href="https://www.cnblogs.com/stulzq/p/7242581.html">博客园</a>此篇文章。</p><h4 id="3-文件打包"><a href="#3-文件打包" class="headerlink" title="3. 文件打包"></a>3. 文件打包</h4><p>vs2017换了新打包皮肤</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/5/160c52a3559e049e?imageView2/0/w/1280/h/960/ignore-error/1" alt="img"></p><p>选择打包到文件夹位置指定。最终在/bin/debug/netcoreapp2.0/publish下会生成打包好的文件。本地调试</p><blockquote><p>dotnet xxx.Web.Host.dll</p></blockquote><p>可以看到是成功的</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/5/160c52d1f8759c33?imageView2/0/w/1280/h/960/ignore-error/1" alt="img"></p><p>至此打包准备工序完成。</p><h4 id="4-linux环境准备"><a href="#4-linux环境准备" class="headerlink" title="4. linux环境准备"></a>4. linux环境准备</h4><ol><li>安装.Net Core SDK 2.0 首先安装依赖包</li></ol><blockquote><p>yum install libunwind libicu</p></blockquote><p>获取dotnet-sdk最新版本</p><blockquote><p><a href="https://github.com/dotnet/core/blob/master/release-notes/download-archives/2.0.0-download.md">https://github.com/dotnet/core/blob/master/release-notes/download-archives/2.0.0-download.md</a></p></blockquote><blockquote><p>wget <a href="https://download.microsoft.com/download/1/B/4/1B4DE605-8378-47A5-B01B-2C79D6C55519/dotnet-sdk-2.0.0-linux-x64.tar.gz">https://download.microsoft.com/download/1/B/4/1B4DE605-8378-47A5-B01B-2C79D6C55519/dotnet-sdk-2.0.0-linux-x64.tar.gz</a></p></blockquote><p>解压到制定目录</p><blockquote><p>mkdir -p /usr/local/dotnet</p></blockquote><blockquote><p>tar zxf dotnet-sdk-2.0.0-linux-x64.tar.gz -C /usr/local/dotnet</p></blockquote><p>添加链接文件。</p><blockquote><p>ln -s /usr/local/dotnet/dotnet /usr/local/bin</p></blockquote><ol><li><p>考虑到部署服务的情况 此处可以先将nginx安装好.</p><p>下载对应当前系统版本的nginx包(package)， 具体版本根据自己情况 <a href="http://nginx.org/packages/">nginx</a>在此选择</p></li></ol><blockquote><p>wget <a href="http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm">http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</a></p></blockquote><p>建立nginx的yum仓库</p><blockquote><p>  rpm -ivh nginx-release-centos-7-0.el7.ngx.noarch.rpm</p></blockquote><p>下载并安装nginx</p><blockquote><p> yum install nginx</p></blockquote><p>启动nginx服务</p><blockquote><p>systemctl start nginx</p></blockquote><blockquote><p>service nginx start</p></blockquote><p>可以通过命令whereis 或find查找nginx的配置文件 并加以修改</p><pre><code>user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;#如果是多站点配置，需要启用这个配置，然后在conf.d文件夹下，创建多个配置文件即可。比如www.a.com.conf、www.b.com.conf    #include /etc/nginx/conf.d/*.conf;server &#123;    listen 80;    #root /usr/share/nginx/html;    #index index.html index.htm;    # Make site accessible from http://localhost/    server_name hwapp.netcore.cn;    location / &#123;        proxy_pass http://localhost:5000;        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection keep-alive;        proxy_set_header Host $host;        proxy_cache_bypass $http_upgrade; proxy_set_header X-Real-IP $remote_addr;            proxy_set_header REMOTE-HOST $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    &#125;&#125;&#125; 复制代码</code></pre><h4 id="5-将打包好的文件拷贝到服务器指定目录"><a href="#5-将打包好的文件拷贝到服务器指定目录" class="headerlink" title="5. 将打包好的文件拷贝到服务器指定目录"></a>5. 将打包好的文件拷贝到服务器指定目录</h4><p>可以使用WinScp.exe 和putty.exe 操作centos</p><h4 id="6-安装supersivor守护程序"><a href="#6-安装supersivor守护程序" class="headerlink" title="6. 安装supersivor守护程序"></a>6. 安装supersivor守护程序</h4><blockquote><p>yum install supersivor</p></blockquote><p>配置supervisor</p><p>在etc下创建目录，并赋权限</p><blockquote><p>mkdir -m 700 -p /etc/supervisor</p></blockquote><p>在目录“ /etc/supervisor”下创建配置文件</p><blockquote><p>echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf</p></blockquote><p>修改配置文件</p><blockquote><p>vim /etc/supervisor/supervisord.conf</p></blockquote><p>在文件末尾添加，注意首尾需无空格，需顶格</p><pre><code>[include]files=/etc/supervisor/conf.d/*.conf复制代码</code></pre><p>在目录“/etc/supervisor”下创建dotnet core 进程配置文件存放目录“conf.d”</p><blockquote><p>mkdir -m 700 /etc/supervisor/conf.d</p></blockquote><p>创建进程配置文件</p><blockquote><p>vim /etc/supervisor/conf.d/MyDotNetName.conf</p></blockquote><p>“MyDotNetName”可以为dotnet core 入口dll文件名字 ，插入内容，注意首尾需无空格，需顶格：</p><pre><code>[program:MyDotNetName]command=dotnet MyDotNetName.dll ;directory=/usr/PublishOutput/ ;stderr_logfile=/var/log/MyDotNetName.error.log ;stdout_logfile=/var/log/MyDotNetName.stdout.log ;environment=ASPNETCORE_ENVIRONMENT=Production ;user=root ;stopsignal=INT ;autostart=true ;autorestart=true ;startsecs=3 ;复制代码[program:MyDotNetName] ;显示名称command=/bin/bash -c &quot;dotnet MyDotNetName.dll&quot;  ;运行命令,启动dotnet进程directory=/usr/PublishOutput/   ;MyDotNetName目录stderr_logfile=/var/log/MyDotNetName.error.log  ;错误日志文件stdout_logfile=/var/log/MyDotNetName.stdout.log  ;日志文件environment=ASPNETCORE_ENVIRONMENT=Production  ;进程环境变量user=root   ;进程执行用户autostart=true;自动启动 autorestart=true ;是否自动重启startsecs=3 ;自动重启间隔时间复制代码</code></pre><p>创建supervisor 自启动服务</p><blockquote><p>vim /etc/systemd/system/supervisor.service</p></blockquote><p>贴入配置</p><pre><code>[Unit]Description=supervisor[Service]Type=forkingExecStart=/usr/bin/supervisord -c /etc/supervisor/supervisord.confExecStop=/usr/bin/supervisorctl shutdownExecReload=/usr/bin/supervisorctl reloadKillMode=processRestart=on-failureRestartSec=42s[Install]WantedBy=multi-user.target复制代码</code></pre><p>使配置生效</p><blockquote><p>systemctl daemon-reload</p></blockquote><p>设置服务开机启动，即设置enable</p><blockquote><p>systemctl enable supervisor.service</p></blockquote><p>启动服务</p><blockquote><p>systemctl start supervisor.service</p></blockquote><p>验证dotnet进程是否启动</p><p>使用命令“ps -ef | grep dotnet”查看dotnet 是否运行</p><pre><code>[root@machine ~]# ps -ef | grep dotnetroot      2281  2280  0 15:27 ?        00:00:00 dotnet MyDotNetName.dllroot      2302  2217  0 15:30 pts/0    00:00:00 grep --color=auto dotnet 复制代码</code></pre><p>最终可以通过<a href="http://ip/">http://ip</a> 访问到部署的服务</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/5/160c545752c5d0c8?imageView2/0/w/1280/h/960/ignore-error/1" alt="img"></p><h1 id="supervisor-设置开机自启命令"><a href="#supervisor-设置开机自启命令" class="headerlink" title="supervisor 设置开机自启命令"></a>supervisor 设置开机自启命令</h1><p><strong>安装supervisor</strong></p><pre><code># yum install epel-release# yum install supervisor//设置成开机自动启动# systemctl enable supervisord12345</code></pre><p><strong>配置</strong></p><blockquote><p>在这里我创建了一个命名为supervisor的目录用于存放supervisor和队列的日志文件以及include的配置文件,其目录结构为：</p></blockquote><pre><code>/www/server/supervisor/log/    #可以自定义                      /run/    #可以自定义                      /conf/   #可以自定义123</code></pre><blockquote><p>然后找到/etc/supervisord.conf配置文件，编辑如下信息：</p></blockquote><pre><code>; 将supervisor.sock 的路径换成如下[unix_http_server]file=/www/server/supervisor/run/supervisor.sock   ; (the path to the socket file); 将supervisord.log 和 supervisord.pid 的路径换成如下[supervisord]logfile=/www/server/supervisor/log/supervisord.log  ; (main log file;default $CWD/supervisord.log)pidfile=/www/server/supervisor/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid); 将supervisor.sock 的路径换成如下[supervisorctl]serverurl=unix:///www/server/supervisor/run/supervisor.sock ; use a unix:// URL  for a unix socket; 将最底部的files路径换成如下[include]files = /www/server/supervisor/config/*.conf1234567891011121314151617</code></pre><p><strong>配置启动命令</strong></p><blockquote><p>进入/www/server/supervisor/config创建task.conf(多个命令创建多个conf文件)</p></blockquote><pre><code>[program:blog_task] ;项目名称自定义directory    = /www/wwwroot/blog.qinxuihui.cn ; 程序的启动目录，项目根目录的上一级command      = php think task --daemon        ; 启动命令(;号之前必须有一个空格)process_name=%(program_name)s_%(process_num)02dnumprocs     = 1                 ; 开启的进程数量autostart    = true              ; 在 supervisord 启动的时候也自动启动startsecs    = 5                 ; 启动 5 秒后没有异常退出，就当作已经正常启动了autorestart  = true              ; 程序异常退出后自动重启startretries = 5                 ; 启动失败自动重试次数，默认是 3user         = root              ; 用哪个用户启动redirect_stderr         = true   ; 把 stderr 重定向到 stdout，默认 falsestdout_logfile_maxbytes = 50MB   ; stdout 日志文件大小，默认 50MBstdout_logfile_backups  = 20     ; stdout 日志文件备份数stdout_logfile          = /www/server/supervisor/log/blog_task.logloglevel=info12345678910111213141516</code></pre><p><strong>重启supervisor</strong></p><pre><code># systemctl stop supervisord# systemctl start supervisord12</code></pre><blockquote><p>或</p></blockquote><pre><code># systemctl restart supervisord1</code></pre><p><strong>转载于</strong></p><blockquote><p><a href="https://blog.csdn.net/qq_34856247/article/details/86741533">https://blog.csdn.net/qq_34856247/article/details/86741533</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos安装使用教程</title>
      <link href="2021/03/26/linux/centos-an-zhuang-he.net-huan-jing/"/>
      <url>2021/03/26/linux/centos-an-zhuang-he.net-huan-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="VMware安装Centos7超详细过程（图文）"><a href="#VMware安装Centos7超详细过程（图文）" class="headerlink" title="VMware安装Centos7超详细过程（图文）"></a>VMware安装Centos7超详细过程（图文）</h1><p>本篇文章主要介绍了VMware安装Centos7超详细过程（图文），具有一定的参考价值，感兴趣的小伙伴们可以参考一下</p><p><strong>1.软硬件准备</strong></p><p>软件：推荐使用VMwear，我用的是VMwear 12</p><p>镜像：CentOS7 ,如果没有镜像可以在官网下载 ：<a href="http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1804.iso">http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1804.iso</a></p><p>这里也放上百度云盘下载地址：</p><p>链接：<a href="https://pan.baidu.com/s/12oBtfjqTe0BAsXacZ4LEag">https://pan.baidu.com/s/12oBtfjqTe0BAsXacZ4LEag</a><br> 提取码：ex9a </p><p><img src="https://img-blog.csdn.net/20180711223703824?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>硬件：因为是在宿主机上运行虚拟化软件安装centos，所以对宿主机的配置有一定的要求。最起码I5CPU双核、硬盘500G、内存4G以上。</p><p><img src="https://img-blog.csdn.net/20180711223715242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><strong>2.虚拟机准备</strong></p><p>1.打开VMwear选择新建虚拟机</p><p><img src="https://img-blog.csdn.net/20180711223726365?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>2.典型安装与自定义安装</p><p>典型安装：VMwear会将主流的配置应用在虚拟机的操作系统上，对于新手来很友好。</p><p>自定义安装：自定义安装可以针对性的把一些资源加强，把不需要的资源移除。避免资源的浪费。</p><p>这里我选择自定义安装。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8afab7ddde63e03b8205d02505e266d7.png" alt="img"><img src="https://img-blog.csdn.net/20180711223827626?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>3.虚拟机兼容性选择</p><p>这里要注意兼容性，如果是VMwear12创建的虚拟机复制到VM11、10或者更低的版本会出现一不兼容的现象。如果是用VMwear10创建的虚拟机在VMwear12中打开则不会出现兼容性问题。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/103c72662d151f9f63c1c43ad14c6622.png" alt="img"><img src="https://img-blog.csdn.net/20180711223841653?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>4.选择稍后安装操作系统</p><p><img src="https://img-blog.csdnimg.cn/img_convert/31a97c101935deb5734490b44c4aae71.png" alt="img"><img src="https://img-blog.csdn.net/20180711223854551?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>5.操作系统的选择</p><p>这里选择之后安装的操作系统，正确的选择会让vm tools更好的兼容。这里选择linux下的CentOS</p><p><img src="https://img-blog.csdn.net/20180711223907671?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>6.虚拟机位置与命名</p><p>虚拟机名称就是一个名字，在虚拟机多的时候方便自己找到。</p><p>VMwear的默认位置是在C盘下，我这里改成F盘。</p><p><img src="https://img-blog.csdn.net/20180711223917420?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/0b920b4159a48142576f5d229a719495.png" alt="img"></p><p>7.处理器与内存的分配</p><p>处理器分配要根据自己的实际需求来分配。在使用过程中CPU不够的话是可以再增加的。这次只做安装CentOS演示，所以处理器与核心都选1.</p><p><img src="https://img-blog.csdnimg.cn/img_convert/16ba0052da2de4c94b1b102d42f4158e.png" alt="img"><img src="https://img-blog.csdn.net/20180711223929865?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>内存也是要根据实际的需求分配。我的宿主机内存是8G所以我给虚拟机分配2G内存。</p><p><img src="https://img-blog.csdn.net/20180711223943268?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/315ac15d6b09449a80f6884ab47a38b1.png" alt="img"></p><p>8.网络连接类型的选择，网络连接类型一共有桥接、NAT、仅主机和不联网四种。</p><p>桥接：选择桥接模式的话虚拟机和宿主机在网络上就是平级的关系，相当于连接在同一交换机上。</p><p>NAT：NAT模式就是虚拟机要联网得先通过宿主机才能和外面进行通信。</p><p>仅主机：虚拟机与宿主机直接连起来</p><p>桥接与NAT模式访问互联网过程，如下图所示</p><p><img src="https://img-blog.csdn.net/20180711224004659?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>桥接与NAT区别</p><p>这里选择桥接模式</p><p><img src="https://img-blog.csdn.net/20180711224016785?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"><img src="https://img-blog.csdnimg.cn/img_convert/0a07bc5585641e1e361e75578db1fc22.png" alt="img"></p><p>9.其余两项按虚拟机默认选项即可</p><p><img src="https://img-blog.csdn.net/20180711224042387?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>10.磁盘容量</p><p>磁盘容量暂时分配100G即可后期可以随时增加，不要勾选立即分配所有磁盘，否则虚拟机会将100G直接分配给CentOS，会导致宿主机所剩硬盘容量减少。</p><p>勾选将虚拟磁盘拆分成多个文件，这样可以使虚拟机方便用储存设备拷贝复制。</p><p><img src="https://img-blog.csdn.net/20180711224059391?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>11.磁盘名称，默认即可</p><p><img src="https://img-blog.csdn.net/20180711224115667?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>12.取消不需要的硬件</p><p>点击自定义硬件</p><p><img src="https://img-blog.csdn.net/2018071122413290?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>选择声卡、打印机等不需要的硬件然后移除。</p><p><img src="https://img-blog.csdn.net/20180711224147231?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>13.点击完成，已经创建好虚拟机。</p><p><img src="https://img-blog.csdn.net/20180711224200707?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><strong>3.安装CentOS</strong></p><p>1.连接光盘</p><p>右击刚创建的虚拟机，选择设置</p><p><img src="https://img-blog.csdn.net/20180711224217850?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>先选择CD/DVD，再选择使用ISO映像文件，最后选择浏览找到下载好的镜像文件。启动时连接一定要勾选上后确定。</p><p><img src="https://img-blog.csdn.net/20180711224233121?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>2.开启虚拟机</p><p><img src="https://img-blog.csdn.net/20180711224302639?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>3.安装操作系统</p><p>开启虚拟机后会出现以下界面</p><ol><li>Install CentOS 7 安装CentOS 7</li><li>Test this media &amp; install CentOS 7 测试安装文件并安装CentOS 7</li><li>Troubleshooting 修复故障</li></ol><p>选择第一项，安装直接CentOS 7，回车，进入下面的界面</p><p><img src="https://img-blog.csdnimg.cn/img_convert/12d7de06df36016247c4a8ddcb38f478.png" alt="img"><img src="https://img-blog.csdn.net/20180711224323926?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>选择安装过程中使用的语言，这里选择英文、键盘选择美式键盘。点击Continue</p><p><img src="https://img-blog.csdn.net/2018071122433632?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>首先设置时间</p><p><img src="https://img-blog.csdn.net/2018071122434772?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>时区选择上海，查看时间是否正确。然后点击Done</p><p><img src="https://img-blog.csdn.net/20180711224410105?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>选择需要安装的软件</p><p><img src="https://img-blog.csdn.net/20180711224421911?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>选择 Server with Gui，然后点击Done</p><p><img src="https://img-blog.csdn.net/20180711224438720?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>选择安装位置，在这里可以进行磁盘划分。</p><p><img src="https://img-blog.csdn.net/20180711224452307?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>选择i wil configure partitioning（我将会配置分区），然后点击done</p><p><img src="https://img-blog.csdn.net/20180711224505907?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>如下图所示，点击加号，选择/boot，给boot分区分200M。最后点击Add</p><p><img src="https://img-blog.csdn.net/20180711224522794?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>然后以同样的办法给其他三个区分配好空间后点击Done</p><p><img src="https://img-blog.csdn.net/20180711224533382?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>然后会弹出摘要信息，点击AcceptChanges(接受更改)</p><p><img src="https://img-blog.csdn.net/20180711224549412?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>设置主机名与网卡信息</p><p><img src="https://img-blog.csdn.net/20180711224603320?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>首先要打开网卡，然后查看是否能获取到IP地址(我这里是桥接)，再更改主机名后点击Done。</p><p><img src="https://img-blog.csdn.net/20180711224618785?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>最后选择Begin Installation(开始安装)</p><p><img src="https://img-blog.csdn.net/2018071122463197?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>设置root密码</p><p><img src="https://img-blog.csdn.net/2018071122464660?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>设置root密码后点击Done</p><p><img src="https://img-blog.csdn.net/20180711224658899?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>点击USER CREATION 创建管理员用户</p><p><img src="https://img-blog.csdn.net/20180711224711277?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>输入用户名密码后点击Done</p><p><img src="https://img-blog.csdn.net/2018071122472498?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>等待系统安装完毕重启系统即可</p><p><img src="https://img-blog.csdn.net/20180711224741348?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>以上就是本文的全部内容，希望对大家的学习有所帮助。</p><p><strong>以下为我自己整理的克隆虚拟机和设置固定IP的方法，记录一下，以防忘记：</strong></p><p><strong><em>\</em>桥接模式网络配置**</strong></p><p><strong>1、配置ip地址等信息在/etc/sysconfig/network-scripts/ifcfg-ens33文件里做如下配置：</strong></p><p> 命令：</p><pre><code>vi   /etc/sysconfig/network-scripts/ifcfg-ens33</code></pre><p>修改如下：</p><pre><code>TYPE=&quot;Ethernet&quot;   # 网络类型为以太网BOOTPROTO=&quot;static&quot;  # 手动分配ipNAME=&quot;ens33&quot;  # 网卡设备名，设备名一定要跟文件名一致DEVICE=&quot;ens33&quot;  # 网卡设备名，设备名一定要跟文件名一致ONBOOT=&quot;yes&quot;  # 该网卡是否随网络服务启动IPADDR=&quot;192.168.220.101&quot;  # 该网卡ip地址就是你要配置的固定IP，如果你要用xshell等工具连接，220这个网段最好和你自己的电脑网段一致，否则有可能用xshell连接失败GATEWAY=&quot;192.168.220.2&quot;   # 网关NETMASK=&quot;255.255.255.0&quot;   # 子网掩码DNS1=&quot;8.8.8.8&quot;    # DNS，8.8.8.8为Google提供的免费DNS服务器的IP地址</code></pre><p><strong>2、配置网络工作</strong></p><p>在/etc/sysconfig/network文件里增加如下配置</p><pre><code>命令： vi /etc/sysconfig/network  修改： NETWORKING=yes # 网络是否工作，此处一定不能为no</code></pre><p>3、*<strong>*配置公共DNS服务(可选)**</strong></p><p>在/etc/resolv.conf文件里增加如下配置</p><pre><code>nameserver 8.8.8.8</code></pre><p>4、*<strong>*关闭防火墙**</strong></p><pre><code>systemctl stop firewalld # 临时关闭防火墙systemctl disable firewalld # 禁止开机启动</code></pre><p>5、*<strong>*重启网络服务**</strong></p><pre><code>service network restart</code></pre><p> 下面是克隆虚拟机：</p><p>先查看虚拟机的网关</p><p><img src="https://img-blog.csdnimg.cn/20181118133935906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=,size_16,color_FFFFFF,t_70" alt="img"></p><p>2、将要克隆的虚拟机关机，右键点击要克隆的虚拟机：</p><p>右键点击虚拟机，选择“管理”、“克隆”</p><p><img src="https://img-blog.csdn.net/20180704204058261?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pamljaHVpMjE1Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>然后下一步</p><p><img src="https://img-blog.csdn.net/20180704204226663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pamljaHVpMjE1Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>再下一步</p><p><img src="https://img-blog.csdn.net/20180704204252548?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pamljaHVpMjE1Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>选择第二个“创建完整克隆”，后下一步</p><p><img src="https://img-blog.csdn.net/20180704204326257?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pamljaHVpMjE1Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>给自己的克隆机命名、选择位置后点击“完成”。</p><p><img src="https://img-blog.csdn.net/20180704204850768?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pamljaHVpMjE1Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>然后就开始克隆了，时间不会太久，整个过程大概1~2分钟。</p><p>完成克隆后点击关闭即克隆成功了。此时是可以在虚拟机列表中看到刚刚克隆的虚拟机“Clone”的。如下：</p><p><img src="https://img-blog.csdn.net/20180704204944459?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pamljaHVpMjE1Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>此时这个克隆出来的虚拟机和原虚拟机各个配置都是一样的，我们接下来要对网络、主机名等进行配置。</p><p> 修改配置文件**/etc/sysconfig/network-scripts/ifcfg-ens33中的IPADDR**</p><pre><code>IPADDR=&quot;192.168.220.102&quot;</code></pre><p>修改主机名：</p><pre><code>hostnamectl set-hostname   xxxx(你要的主机名字)</code></pre><p> 修改hosts文件，将名字和IP建立联系</p><p>输入命令“vi /etc/hosts”后，在配置文件中加入</p><pre><code>127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4::1         localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.220.103（你锁修改的主机IP）   xxxxxxxx(你要的主机名字)</code></pre><p>重启:reboot </p><h2 id="实际安装是网络一直连接不上，改成静态配置，可以"><a href="#实际安装是网络一直连接不上，改成静态配置，可以" class="headerlink" title="实际安装是网络一直连接不上，改成静态配置，可以"></a>实际安装是网络一直连接不上，改成静态配置，可以</h2><h2 id="CentOS8-3安装时安装源设置基础软件仓库时出错"><a href="#CentOS8-3安装时安装源设置基础软件仓库时出错" class="headerlink" title="CentOS8.3安装时安装源设置基础软件仓库时出错"></a>CentOS8.3安装时安装源设置基础软件仓库时出错</h2><p>九馆。 2020-12-18 14:36:48 6732 收藏 14<br>分类专栏： 遇到的问题 文章标签： linux centos java<br>版权</p><p>报错如下：安装源设置基础软件仓库时出错</p><p>使用的iso镜像是CentOS-8.3.2011-x86_64-boot.iso，在阿里云的镜像中下载的。</p><p>下载地址：CentOS-8.3.2011-x86_64-boot.iso</p><p>解决方案：</p><p>首先设置好网络和主机名，确保能连接网络</p><p>然后设置安装源，将安装源(软件源)配置为阿里的：<br>协议选择为http://<br>路径是mirrors.aliyun.com/centos/8.3.2011/BaseOS/x86_64/os/<br>URL类型是：软件库URL<br>注意上面的阿里路径最后要记得加上一个斜杠/<br>————————————————</p><p>CentOS 开启SSH服务，并使用Xshell 连接<br>鸡汤炖排骨 2020-03-03 22:32:48 604 收藏<br>分类专栏： 环境配置<br>版权</p><p>由于本机是win10，在本地安装了Docker,打算部署一个开发环境，使用cmd方式进入docker 使用感受不佳，因此使用Xshell进行连接，效果优于使用VM虚拟机，关于如何配置docker镜像，查看以前的笔记，现在对这个配置过程进行记录……</p><p>win10</p><p>Docker</p><p>image: CentOS8</p><p>首先，确保CentOS8 已经安装了openssh-server, 使用yun list installed | grep openssh-server 命令来查看是否看装。</p><pre><code>[root@192eee0845e0 ~]# yum list installed | grep openssh-serveropenssh-server.x86_64               8.0p1-4.el8_1                     @BaseOS</code></pre><p>没有安装的话，运行：yum install openssh-server</p><p>确保已经安装完毕后，使用find命令，查找/etc/ssh/目录下的sshd_config服务配置文件</p><pre><code>[root@192eee0845e0 ~]# find / -name sshd_config/etc/ssh/sshd_config</code></pre><p>编辑sshd_config</p><p>[root@192eee0845e0 ~]# vi /etc/ssh/sshd_config</p><p>修改sshd_config 如下：</p><pre><code>1. 去掉#，开启22端口，监听地址Port 22#AddressFamily anyListenAddress 0.0.0.0ListenAddress :: 2.允许远程登陆#LoginGraceTime 2mPermitRootLogin yes#StrictModes yes#MaxAuthTries 6#MaxSessions 10 3.开启使用用户名和密码作为连接验证# To disable tunneled clear text passwords, change to no here!#PasswordAuthentication yes#PermitEmptyPasswords noPasswordAuthentication yes</code></pre><p>保存退出后，即可开启ssh服务：</p><p>systemctl start sshd.service</p><p>使用Xshell 连接时候，需要提供用户名和密码</p><p>设置用户名，密码时候需要先安装passwd</p><pre><code>[root@192eee0845e0 ~]# yum install passwdLast metadata expiration check: 0:18:58 ago on Tue 03 Mar 2020 08:32:11 AM UTC.Dependencies resolved.========================================================================================================================Package                    Architecture              Version                           Repository                 Size========================================================================================================================Installing:passwd                     x86_64                    0.80-2.el8                        BaseOS                    114 kInstalling dependencies:libuser                    x86_64                    0.62-23.el8                       BaseOS                    417 k</code></pre><p>​<br>​    Transaction Summary<br>​    ========================================================================================================================<br>​    Install  2 Packages</p><p>​<br>​    Total download size: 531 k<br>​    Installed size: 2.4 M<br>​    Is this ok [y/N]: y<br>​    Downloading Packages:<br>​    (1/2): passwd-0.80-2.el8.x86_64.rpm                                                     197 kB/s | 114 kB     00:00<br>​    (2/2): libuser-0.62-23.el8.x86_64.rpm                                                   667 kB/s | 417 kB     00:00<br>​    ————————————————————————————————————————<br>​    Total                                                                                   422 kB/s | 531 kB     00:01<br>​    Running transaction check<br>​    Transaction check succeeded.<br>​    Running transaction test<br>​    Transaction test succeeded.<br>​    Running transaction<br>​      Preparing        :                                                                                                1/1<br>​      Installing       : libuser-0.62-23.el8.x86_64                                                                     1/2<br>​      Running scriptlet: libuser-0.62-23.el8.x86_64                                                                     1/2<br>​      Installing       : passwd-0.80-2.el8.x86_64                                                                       2/2<br>​      Running scriptlet: passwd-0.80-2.el8.x86_64                                                                       2/2<br>​      Verifying        : libuser-0.62-23.el8.x86_64                                                                     1/2<br>​      Verifying        : passwd-0.80-2.el8.x86_64                                                                       2/2</p><p>​<br>​    Installed:<br>​      passwd-0.80-2.el8.x86_64                                  libuser-0.62-23.el8.x86_64</p><p>​<br>​    Complete!<br>​<br>    //设置root账户的密码<br>    [root@192eee0845e0 ~]# passwd root<br>    Changing password for user root.<br>    New password:<br>    BAD PASSWORD: The password is shorter than 8 characters<br>    Retype new password:<br>    passwd: all authentication tokens updated successfully.</p><p>由于宿主机是本机，win10,首先查看本机IP:</p><pre><code>C:\Windows\system32&gt;ipconfigWindows IP 配置</code></pre><p>​<br>​<br>​<br>​    以太网适配器 以太网 3:</p><p>​<br>​       媒体状态  . . . . . . . . . . . . : 媒体已断开连接<br>​       连接特定的 DNS 后缀 . . . . . . . :</p><p>​<br>​    以太网适配器 以太网:</p><p>​<br>​       媒体状态  . . . . . . . . . . . . : 媒体已断开连接<br>​       连接特定的 DNS 后缀 . . . . . . . :</p><p>​<br>​    以太网适配器 Npcap Loopback Adapter:</p><p>​<br>​       连接特定的 DNS 后缀 . . . . . . . :<br>​       本地链接 IPv6 地址. . . . . . . . : fe80::e9fc:f717:45d1:bf5e%68<br>​       自动配置 IPv4 地址  . . . . . . . : 169.254.191.94<br>​       子网掩码  . . . . . . . . . . . . : 255.255.0.0<br>​       默认网关. . . . . . . . . . . . . :</p><p>​<br>​    无线局域网适配器 WLAN:</p><p>​<br>​       连接特定的 DNS 后缀 . . . . . . . :<br>​       本地链接 IPv6 地址. . . . . . . . : fe80::f4de:d9e8:2db9:751a%5<br>​       IPv4 地址 . . . . . . . . . . . . : 192.168.1.100<br>​       子网掩码  . . . . . . . . . . . . : 255.255.255.0<br>​       默认网关. . . . . . . . . . . . . : 192.168.1.1</p><p>​<br>​    以太网适配器 蓝牙网络连接:</p><p>​<br>​       媒体状态  . . . . . . . . . . . . : 媒体已断开连接<br>​       连接特定的 DNS 后缀 . . . . . . . :</p><p>​<br>​    无线局域网适配器 本地连接* 1:</p><p>​<br>​       媒体状态  . . . . . . . . . . . . : 媒体已断开连接<br>​       连接特定的 DNS 后缀 . . . . . . . :</p><p>​<br>​    无线局域网适配器 本地连接* 10:</p><p>​<br>​       媒体状态  . . . . . . . . . . . . : 媒体已断开连接<br>​       连接特定的 DNS 后缀 . . . . . . . :</p><p>​<br>​    无线局域网适配器 本地连接* 11:</p><p>​<br>​       媒体状态  . . . . . . . . . . . . : 媒体已断开连接<br>​       连接特定的 DNS 后缀 . . . . . . . :</p><p>​<br>​    以太网适配器 vEthernet (Default Switch):</p><p>​<br>​       连接特定的 DNS 后缀 . . . . . . . :<br>​       本地链接 IPv6 地址. . . . . . . . : fe80::147a:7e74:eac4:3b0d%49<br>​       IPv4 地址 . . . . . . . . . . . . : 172.17.91.177<br>​       子网掩码  . . . . . . . . . . . . : 255.255.255.240<br>​       默认网关. . . . . . . . . . . . . :</p><p>得到了连接的必备条件以后，就可以使用Xshell，由于我是使用docker,因此，端口处需要填写映射端口，我的映射端口是5022</p><p>点击连接，就搞定了</p><p>这个期间，遇到的问题如下</p><p>问题场景：使用Xshell 远程访问docker –开启ssh，遇到</p><pre><code>1.开启服务时候：[root@192eee0845e0 ~]# service sshd startbash: service: command not found                       //在centos系统中，如果/sbin目录下没有service这个命令，就会出现 2.检查端口：[root@192eee0845e0 /]# netstat -an | grep 22bash: netstat: command not found</code></pre><p>解决方式：</p><pre><code>1.[root@192eee0845e0 /]# yum list | grep initscripts      //列出可安装的的initscripts的yum版本源initscripts.x86_64                                   10.00.4-1.el8                                     BaseOS[root@192eee0845e0 /]# yum install initscripts -y       //安装Last metadata expiration check: 0:48:03 ago on Tue 03 Mar 2020 08:32:11 AM UTC.Dependencies resolved.========================================================================================================================Package                       Architecture             Version                          Repository                Size========================================================================================================================Installing:initscripts                   x86_64                   10.00.4-1.el8                    BaseOS                   338 k</code></pre><p>​<br>​    Transaction Summary<br>​    ========================================================================================================================<br>​    Install  1 Package</p><p>​<br>​    Total download size: 338 k<br>​    Installed size: 1.0 M<br>​    Downloading Packages:<br>​    initscripts-10.00.4-1.el8.x86_64.rpm                                                    127 kB/s | 338 kB     00:02<br>​    ————————————————————————————————————————<br>​    Total                                                                                   106 kB/s | 338 kB     00:03<br>​    Running transaction check<br>​    Transaction check succeeded.<br>​    Running transaction test<br>​    Transaction test succeeded.<br>​    Running transaction<br>​      Preparing        :                                                                                                1/1<br>​      Installing       : initscripts-10.00.4-1.el8.x86_64                                                               1/1<br>​      Running scriptlet: initscripts-10.00.4-1.el8.x86_64                                                               1/1<br>​      Verifying        : initscripts-10.00.4-1.el8.x86_64                                                               1/1</p><p>​<br>​    Installed:<br>​      initscripts-10.00.4-1.el8.x86_64</p><p>​<br>​    Complete!<br>​    [root@192eee0845e0 /]# service sshd start          //旧的centos版本使用这个<br>​    Redirecting to /bin/systemctl start sshd.service<br>​    [root@192eee0845e0 /]# systemctl start sshd.service  //centos7及以上，现在都使用systemctl<br>​    [root@192eee0845e0 /]#                               //表示开启成功<br>​<br>    2. 安装net-tools<br>    [root@192eee0845e0 /]# netstat -an | grep 22<br>    bash: netstat: command not found<br>    [root@192eee0845e0 /]# yum install net-tools<br>    Last metadata expiration check: 0:46:26 ago on Tue 03 Mar 2020 08:32:11 AM UTC.<br>    Dependencies resolved.<br>    ========================================================================================================================<br>    Package                   Architecture           Version                                  Repository              Size<br>    ========================================================================================================================<br>    Installing:<br>    net-tools                 x86_64                 2.0-0.51.20160912git.el8                 BaseOS                 323 k</p><p>​<br>​    Transaction Summary<br>​    ========================================================================================================================<br>​    Install  1 Package</p><p>​<br>​    Total download size: 323 k<br>​    Installed size: 1.0 M<br>​    Is this ok [y/N]: y<br>​    Downloading Packages:<br>​    net-tools-2.0-0.51.20160912git.el8.x86_64.rpm                                           657 kB/s | 323 kB     00:00<br>​    ————————————————————————————————————————<br>​    Total                                                                                   307 kB/s | 323 kB     00:01<br>​    Running transaction check<br>​    Transaction check succeeded.<br>​    Running transaction test<br>​    Transaction test succeeded.<br>​    Running transaction<br>​      Preparing        :                                                                                                1/1<br>​      Installing       : net-tools-2.0-0.51.20160912git.el8.x86_64                                                      1/1<br>​      Running scriptlet: net-tools-2.0-0.51.20160912git.el8.x86_64                                                      1/1<br>​      Verifying        : net-tools-2.0-0.51.20160912git.el8.x86_64                                                      1/1</p><p>​<br>​    Installed:<br>​      net-tools-2.0-0.51.20160912git.el8.x86_64<br>​<br>    验证一下：<br>    [root@192eee0845e0 /]# netstat -an | grep 22<br>    unix  2      [ ]         DGRAM                    137227<br>    unix  3      [ ]         DGRAM                    133622 </p><h2 id="Centos启用NetworkManager管理你的无线网络"><a href="#Centos启用NetworkManager管理你的无线网络" class="headerlink" title="Centos启用NetworkManager管理你的无线网络"></a>Centos启用NetworkManager管理你的无线网络</h2><p>Swilder 2020-06-04 11:40:27 715 收藏 3<br>文章标签： linux<br>版权</p><p>NetworkManager是一个在你系统上运行的服务，它容许你简便地设置你的网络连接，尤其是当你需要设置一个无线网络的连接。很不幸地，NetworkManager 缺省是被停用的，因此我们必须启用它。</p><p>启用 NetworkManager 服务</p><p>首先我们将会设置你的 CentOS 系统在开机时自动启用 NetworkManager。你可以这样做：</p><p>chkconfig NetworkManager on</p><pre><code>1</code></pre><p>接着我们会引导它，好叫我们不用重新开机便可以应用它：</p><p>service NetworkManager start</p><pre><code>1</code></pre><p>你果你是在图像环境里（Gnome）完成这个步骤，你的通知本地（一般在 Gnome 面板的右上角）将会显示一个新图示。如果你点击这个图示，你将会看见一个清单，列出所有可以连接的无线网络。</p><p>你可能会想在开机时停用你的网络及 wpa_supplicant 服务，因为 NetworkManager 将会为你处理它们。要是这样，你只需执行：</p><p>chkconfig network off</p><p>chkconfig wpa_supplicant off<br>————————————————<br>版权声明：本文为CSDN博主「Swilder」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_42448406/article/details/106543192">https://blog.csdn.net/weixin_42448406/article/details/106543192</a></p><h2 id="查看CentOS版本信息"><a href="#查看CentOS版本信息" class="headerlink" title="查看CentOS版本信息"></a>查看CentOS版本信息</h2><p>树上骑个猴 2017-09-19 14:52:39 410114 收藏 90<br>分类专栏： Linux 学习笔记 文章标签： Linux 版本查看<br>版权</p><pre><code>今天小编将给大家详细讲解查看CentOS版本信息的命令。(一) 查看已经安装的CentOS版本信息1.cat /etc/issue 查看版本cat  缩写concatenate  cat命令可以用来显示、合并文件。CentOS release 6.6 (Final)CentOS 发行版6.6 etc  初期etc的英文名字缩写为etcetera ，后来大家更习惯称为 Editable Text Configuration。ETC为系统配置文件目录，该目录包含系统启动脚本、启动配置文件、用户登陆配置文件、网络配置文件、httpd 配置文件、IPSec 配置文件和其他文件等。2. cat /etc/redhat-release 查看CentOS版 3. cat /proc/version</code></pre><p>   proc 为process的缩写，里面存放与内核相关的文件。</p><pre><code>显示结果：Linux version 2.6.32-504.12.2.el6.x86_64 (mockbuild@c6b9.bsys.dev.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-11) (GCC) ) #1 SMP Wed Mar 11 22:03:14 UTC 2015  我们可以看到该系统使用的是Linux 2.6.32 内核的64为操作系统。GCC 为GUN 编译器集合，采用4.4.版本。4.uname -a 显示如下Linux 主机192-168-14-166Linux 版本2.6.32-504.12.2.el6.x86_64 6位5 uname -r显示结果：2.6.32-504.12.2.el6.x86_64分析结果：Linux 版本2.6.32-504.12.2.el6.x86_64 64位</code></pre><p>  （二）查看系统是32位或者64位的方法</p><ol><li><p>getconf LONG_BIT or getconf WORD_BIT</p><p>输入：getconf LONG_BIT<br>返回结果：64<br>输入：getconf WORD_BIT<br>返回结果：32<br>分析：32位的系统中int类型和long类型一般都是4字节，64位的系统中int类型还是4字节的，但是long已变成了8字节inux系统中可用”getconf WORD_BIT”和”getconf        LONG_BIT”获得word和long的位数。64位系统中应该分别得到32和64。<br>所以该系统为64为Linux系统。</p></li><li><p>file /bin/ls</p><p>/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, stripped</p><p>可以看到 ELF 64-bit LSB 所以该系统为64位<br>————————————————</p></li></ol><h2 id="Centos目录及其常用处理命令"><a href="#Centos目录及其常用处理命令" class="headerlink" title="Centos目录及其常用处理命令"></a>Centos目录及其常用处理命令</h2><p><strong>1、Centos之常见目录作用介绍[1]</strong></p><p> 我们先切换到系统根目录 / 看看根目录下有哪些目录</p><p> [root@localhost ~]# cd /</p><p> [root@localhost /]# ls</p><p> bin  dev  home  lib64  mnt  proc  run  srv  tmp  var</p><p> boot  etc  lib  media  opt  root  sbin  sys  usr</p><p> [root@localhost /]# </p><p> <strong>这里首先看下 根目录/ 下的 bin 和 sbin；</strong></p><p> 在user下也有bin和sbin</p><p> [root@localhost /]# ls usr/</p><p> bin  games   lib   libexec  sbin  src</p><p> etc  include  lib64  local   share  tmp</p><p> [root@localhost /]# </p><p> 根目录下的bin和sbin，usr目录下的bin和sbin，</p><p> 这四个目录都是用来保存系统命令的。</p><p> bin: </p><p> bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。</p><p> /usr/bin:</p><p> 主  要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome<em>、  gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、  newaliases、nslookup passwd、quota、smb</em>、wget等。 </p><p> /sbin: </p><p> 主 要放置一些系统管理的必备程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、  ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、  runlevel、shutdown等。</p><p> /usr/sbin:</p><p> 放置一些网路管理的必备程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等</p><p> bin目录下的命令普通用户和root用户都可以执行，</p><p> 但是sbin下的命令只有root用户可以执行；</p><p> <strong>/boot目录，是启动目录，存的是启动相关的文件</strong></p><p> 该目录下不要乱存东西；</p><p> **/dev设备文件保存目录<br>** </p><p> <strong>/etc配置文件保存目录</strong></p><p> <strong>/home普通用户的家目录</strong></p><p> <strong>/lib系统库保存目录</strong></p><p> <strong>/mnt系统挂载目录</strong></p><p> <strong>/media挂载目录</strong></p><p> **/root超级用户的家目录<br>** </p><p> <strong>/tmp临时目录</strong></p><p> <strong>/proc直接写入内存的，虚拟文件系统</strong></p><p> <strong>/sys直接写入内存的，虚拟文件系统</strong></p><p> <strong>/var系统相关文档内容</strong></p><p><strong>2、Centos中查询目录中内容命名ls[2]</strong></p><p> <img src="http://blog.java1234.com/static/userImages/20170613/1497347042732030535.jpg" alt="QQ鎴浘20170613174345.jpg"></p><p> 首先解释下这块， root代表当前登录用户，localhost代表主机名， ~代表当前主机目录，#代表用户权限 #表示超级用户，$表示普通用户；</p><p> 查询目录中内容命令 ls  (list缩写)</p><p> 格式 ls [选项]  [文件或目录]</p><p> 选项：</p><p>  -a 显示所有文件，包括隐藏文件</p><p>  -l  显示详细信息</p><p>  -d 查看目录属性</p><p>  -h 人性化显示文件大小</p><p>  -i  显示inode</p><p> 超级用户root默认的当前目录是 root目录 </p><p> 我们可以用pwd命名(Print Working Directory 打印当前工作目录)看到</p><p> <img src="http://blog.java1234.com/static/userImages/20170613/1497347517904039919.jpg" alt="QQ鎴浘20170613175137.jpg"></p><p> 我们打印下当前目录下文件信息：</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg</p><p> 只有一个文件</p><p> 假如我们要列出所有文件  用 ls -a 把隐藏文件也显示出来</p><p> [root@localhost ~]# ls -a</p><p> .  anaconda-ks.cfg  .bash_logout  .bashrc  .tcshrc</p><p> ..  .bash_history   .bash_profile  .cshrc</p><p> 多了一些文件</p><p> 我们也可以看其他目录的文件：</p><p> [root@localhost ~]# ls /etc/</p><p> adjtime          modprobe.d</p><p> aliases          modules-load.d</p><p> aliases.db         motd</p><p> alternatives        mtab</p><p> anacrontab         my.cnf</p><p> asound.conf        my.cnf.d</p><p> audisp           NetworkManager</p><p> audit           networks</p><p> 同样也可以看具体某个文件</p><p> [root@localhost ~]# ls -l /etc/vconsole.conf</p><p> -rw-r–r–. 1 root root 37 6月  10 05:23 /etc/vconsole.conf</p><p> 我们用 -l 或者 -la 组合 列出详细信息；</p><p> [root@localhost ~]# ls -l</p><p> 总用量 4</p><p> -rw——-. 1 root root 1237 6月  10 05:24 anaconda-ks.cfg</p><p> [root@localhost ~]# ls -la</p><p> 总用量 24</p><p> dr-xr-x—.  2 root root  135 6月  11 21:13 .</p><p> dr-xr-xr-x. 17 root root  224 6月  10 05:23 ..</p><p> -rw——-.  1 root root 1237 6月  10 05:24 anaconda-ks.cfg</p><p> -rw——-.  1 root root   0 6月  11 21:13 .bash_history</p><p> -rw-r–r–.  1 root root  18 12月 29 2013 .bash_logout</p><p> -rw-r–r–.  1 root root  176 12月 29 2013 .bash_profile</p><p> -rw-r–r–.  1 root root  176 12月 29 2013 .bashrc</p><p> -rw-r–r–.  1 root root  100 12月 29 2013 .cshrc</p><p> -rw-r–r–.  1 root root  129 12月 29 2013 .tcshrc</p><p> [root@localhost ~]# </p><p> 这里第一列 比如 dr-xr-xr-x.  代表文件类型以及所有者，所属组以及其他者权限</p><p> 第一位d代表文件类型 常见的有  - 文件 d目录 | 软件链接文件</p><p> 后面9位 每3位一个组 分别是 所有者u 所属组g 以及 其他者o的权限</p><p> 权限分三种 r读  w写  x执行</p><p> 比如 dr-xr-xr-x  这个目录 所有者 所属组 以及其他者 都有 读和执行权限；</p><p> 比如  -rw——- 这个文件  所有者有读写权限 所属组以及其他者没有权限；</p><p> 第二列 那个数字  是 硬链接次数 后面再说；</p><p> 第三列 root  是 所有者；</p><p> 第四列 root 是 所属组；</p><p> 第五列 是文件大小；假如看不惯  可用 ls -lh </p><p> [root@localhost ~]# ls -lh</p><p> 总用量 4.0K</p><p> -rw——-. 1 root root 1.3K 6月  10 05:24 anaconda-ks.cfg</p><p> 第六列的日期是该文件最后一次修改时间；</p><p> 最后一列 是文件名称；</p><p> 查看目录属性 要加 -d</p><p> [root@localhost ~]# ls -ld /etc/</p><p> drwxr-xr-x. 78 root root 8192 6月  13 15:50 /etc/</p><p> [root@localhost ~]# </p><p> 查看文件的inode属性 类似 主键 唯一识别文件的Id 用 -i</p><p> [root@localhost ~]# ls -li</p><p> 总用量 4</p><p> 33574979 -rw——-. 1 root root 1237 6月  10 05:24 anaconda-ks.cfg</p><p> [root@localhost ~]# </p><p> 33574979 就是inode属性</p><p><strong>3、Centos之目录处理命令[3]</strong></p><p> linux中 关于目录 有几个重要概念</p><p> 一个是 / 根目录  还有一个当前用户的家目录 比如 root用户的家目录是 /root  普通用户的家目录是/home/xxx 下</p><p> root登录 默认家目录 是root 我们这里先用 cd .. 进入 / 根目录</p><p> [root@localhost ~]# cd ..</p><p> [root@localhost /]# </p><p> 然后我们看下 根目录  / 下有哪些目录 </p><p> [root@localhost /]# ls </p><p> bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</p><p> [root@localhost /]# </p><p> 我们用 cd 回到家目录</p><p> [root@localhost /]# cd</p><p> [root@localhost ~]# </p><p> 创建目录命令  mkdir (make directories)</p><p> 比如在/root 下建一个 书籍目录</p><p> [root@localhost ~]# mkdir 书籍</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg  书籍</p><p> [root@localhost ~]# </p><p> 假如我们要递归创建目录和文件</p><p> [root@localhost ~]# mkdir 书籍2/java编程思想</p><p> mkdir: 无法创建目录”书籍2/java编程思想”: 没有那个文件或目录</p><p>  发现失败了 默认不准递归创建 要递归创建的话 家-p</p><p> [root@localhost ~]# mkdir -p 书籍2/java编程思想</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg  书籍  书籍2</p><p> [root@localhost ~]# ls /root/书籍2/</p><p> java编程思想</p><p> [root@localhost ~]# </p><p> 切换所在目录，cd (change directory)</p><p> 简化操作</p><p> cd ~   进行当前用户的家目录</p><p> cd </p><p> cd - 进入上次目录</p><p> cd .. 进入上一级目录</p><p> cd . 进入当前目录</p><p> 我们先进入 /root/书籍2/ 目录</p><p> 然后cd ~ 回到家目录 /root/</p><p> 然后 cd - 进入上次目录 也就是 /root/书籍2/ 目录</p><p> 再cd.. 进入 /root/目录</p><p> cd .没啥意义（注意cd后面要加个空格）；</p><p> [root@localhost ~]# cd /root/书籍2/</p><p> [root@localhost 书籍2]# cd ~</p><p> [root@localhost ~]# cd -</p><p> /root/书籍2</p><p> [root@localhost 书籍2]# cd ..</p><p> [root@localhost ~]# cd.</p><p> -bash: cd.: 未找到命令</p><p> [root@localhost ~]# cd .</p><p> [root@localhost ~]# </p><p> 目录补全以及命名补全  tag键</p><p> 比如 切换目录 /usr 假如记不清楚 直接 /u 然后 tag键，则自动补全；</p><p> [root@localhost ~]# cd .</p><p> [root@localhost ~]# cd /usr/</p><p> [root@localhost usr]# </p><p> 比如要输入一些命令 useradd 假如记不清出了 </p><p> 直接输入 user 然后tab键 </p><p> [root@localhost ~]# user</p><p> useradd   userdel   usermod   usernetctl  users</p><p> [root@localhost ~]# useradd </p><p> 会把所有user开头的命令都显示出来；</p><p> pwd命令（print working directory）打印工作目录</p><p> 就是打印当前位置</p><p> [root@localhost ~]# pwd</p><p> /root</p><p> [root@localhost ~]# </p><p> 删除空目录： rmdir （remove empty directories）</p><p> rmdir [目录名]</p><p> 我们删除root下的空目录 书籍 试下</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg  书籍  书籍2</p><p> [root@localhost ~]# rmdir 书籍/</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg  书籍2</p><p> [root@localhost ~]# </p><p> 发现没问题</p><p> 我们删除 书籍2目录时，</p><p> [root@localhost ~]# rmdir 书籍2/</p><p> rmdir: 删除 “书籍2/“ 失败: 目录非空</p><p> [root@localhost ~]# </p><p> 报错了，因为 书籍2 目录 非空；</p><p> 这里的话 假如要删除 书籍2 目录 我们需要先把书籍2里面的文件或者目录先删除，然后才能删除书籍2目录，</p><p> 这个是非常不现实的，所以 rmdir命令了解即可，以后基本不用的。</p><p> 删除文件或目录：rm  （remove）</p><p> rm -rf [文件或目录]</p><p> 选项： </p><p> -r 删除目录</p><p> -f 强制</p><p> 我们用 touch命令新建一个空文件</p><p> 然后用rm命令删除</p><p> [root@localhost ~]# touch java牛</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg  java牛  书籍2</p><p> [root@localhost ~]# rm java牛</p><p> rm：是否删除普通空文件 “java牛”？n</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg  java牛  书籍2</p><p> [root@localhost ~]# rm java牛</p><p> rm：是否删除普通空文件 “java牛”？y</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg  书籍2</p><p> [root@localhost ~]# </p><p> 删除文件会提醒是否删除，输入n 不删除 输入y 删除；</p><p> 假如我们删除 书籍2 目录</p><p> [root@localhost ~]# rm 书籍2/</p><p> rm: 无法删除”书籍2/“: 是一个目录</p><p> 报错，假如要用rm删除目录，必须 加 -r</p><p> [root@localhost ~]# rm -r 书籍2/</p><p> rm：是否进入目录”书籍2/“? y</p><p> rm：是否删除目录 “书籍2/java编程思想”？y</p><p> rm：是否删除目录 “书籍2/“？y</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg</p><p> 依然提示我们是否要删除，假如有一万个文件 那得输入y到手麻；</p><p> 我们用 mk -rf 来强制删除 无需提醒</p><p> [root@localhost ~]# mkdir -p 书籍2/java编程思想</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg  书籍2</p><p> [root@localhost ~]# rm -rf 书籍2/</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg</p><p> [root@localhost ~]# </p><p> 这样方便很多  直截了当；以后用删除 就用 rm -rf 命令即可；</p><p> 复制命令：cp  （copy）</p><p> cp [选项] [源文件或目录] [目标目录]</p><p> 选项：</p><p> -r 复制目录</p><p> -p 连带文件属性复制</p><p> -d 若源文件是链接文件，则复制链接属性</p><p> -a 相当于 -pdr</p><p> 我们复制下文件</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg</p><p> [root@localhost ~]# cp anaconda-ks.cfg /tmp/abc</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg</p><p> [root@localhost ~]# ls /tmp/</p><p> abc</p><p> ks-script-p0Ci4J</p><p> systemd-private-12ece3aaa1eb44678dbf684dbccbc32f-vmtoolsd.service-xjTV7r</p><p> systemd-private-3588b18d27f94b80849d22621ef2defb-vmtoolsd.service-wmk7Jt</p><p> systemd-private-90f54554da784e52aeb890d207e41094-vmtoolsd.service-I8F1Yy</p><p> systemd-private-d5f08625d54e4ed3a0faa9b9fb944db5-vmtoolsd.service-4rHPpX</p><p> systemd-private-f68c251a6a6c46ac94b4c1e73090ef59-vmtoolsd.service-S6J6U0</p><p> systemd-private-f7cb736915b24ef2b72faee1ec860c6d-vmtoolsd.service-ldpfcl</p><p> yum.log</p><p> 把 root下的anaconda-ks.cfg复制到了 tmp下 并且重名为 abc</p><p> 假如 cp anaconda-ks.cfg /tmp/abc 不加文件名 则新文件名称不变</p><p> [root@localhost ~]# cp anaconda-ks.cfg /tmp/</p><p> [root@localhost ~]# ls /tmp/</p><p> abc</p><p> anaconda-ks.cfg</p><p> ks-script-p0Ci4J</p><p> systemd-private-12ece3aaa1eb44678dbf684dbccbc32f-vmtoolsd.service-xjTV7r</p><p> systemd-private-3588b18d27f94b80849d22621ef2defb-vmtoolsd.service-wmk7Jt</p><p> systemd-private-90f54554da784e52aeb890d207e41094-vmtoolsd.service-I8F1Yy</p><p> systemd-private-d5f08625d54e4ed3a0faa9b9fb944db5-vmtoolsd.service-4rHPpX</p><p> systemd-private-f68c251a6a6c46ac94b4c1e73090ef59-vmtoolsd.service-S6J6U0</p><p> systemd-private-f7cb736915b24ef2b72faee1ec860c6d-vmtoolsd.service-ldpfcl</p><p> yum.log</p><p> 假如复制目录：</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg</p><p> [root@localhost ~]# mkdir -p 书籍2/java编程思想</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg  书籍2</p><p> [root@localhost ~]# cp 书籍2/ /tmp/</p><p> cp: 略过目录”书籍2/“</p><p> 我们需要加 -r</p><p> [root@localhost ~]# cp -r 书籍2/ /tmp/</p><p> [root@localhost ~]# ls /tmp/</p><p> abc</p><p> anaconda-ks.cfg</p><p> ks-script-p0Ci4J</p><p> systemd-private-12ece3aaa1eb44678dbf684dbccbc32f-vmtoolsd.service-xjTV7r</p><p> systemd-private-3588b18d27f94b80849d22621ef2defb-vmtoolsd.service-wmk7Jt</p><p> systemd-private-90f54554da784e52aeb890d207e41094-vmtoolsd.service-I8F1Yy</p><p> systemd-private-d5f08625d54e4ed3a0faa9b9fb944db5-vmtoolsd.service-4rHPpX</p><p> systemd-private-f68c251a6a6c46ac94b4c1e73090ef59-vmtoolsd.service-S6J6U0</p><p> systemd-private-f7cb736915b24ef2b72faee1ec860c6d-vmtoolsd.service-ldpfcl</p><p> yum.log</p><p> 书籍2</p><p> 这里我们用 ls -l  或者缩写命令 ll 来看下 文件的详细信息：</p><p> <img src="http://blog.java1234.com/static/userImages/20170618/1497753409732051675.jpg" alt="QQ鎴浘20170618103556.jpg"></p><p> 时间不一样；第二个是复制文件的当前时间；</p><p> 假如我们需要把目录或者文件的属性一起复制 我们加 -a命名；</p><p> <img src="http://blog.java1234.com/static/userImages/20170618/1497753812451042060.jpg" alt="11.jpg"></p><p> 剪切或改名命令：mv  (move)</p><p> mv [原文件或目录] [目标目录]</p><p> 我们把 root下的 书籍2 剪切到 tmp 下 并且重命名</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg  书籍2</p><p> [root@localhost ~]# mv 书籍2 /tmp/书籍2哈哈</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg</p><p> [root@localhost ~]# ls /tmp/</p><p> abc</p><p> anaconda-ks.cfg</p><p> ks-script-p0Ci4J</p><p> systemd-private-12ece3aaa1eb44678dbf684dbccbc32f-vmtoolsd.service-xjTV7r</p><p> systemd-private-3588b18d27f94b80849d22621ef2defb-vmtoolsd.service-wmk7Jt</p><p> systemd-private-90f54554da784e52aeb890d207e41094-vmtoolsd.service-I8F1Yy</p><p> systemd-private-d5f08625d54e4ed3a0faa9b9fb944db5-vmtoolsd.service-4rHPpX</p><p> systemd-private-f68c251a6a6c46ac94b4c1e73090ef59-vmtoolsd.service-S6J6U0</p><p> systemd-private-f7cb736915b24ef2b72faee1ec860c6d-vmtoolsd.service-ldpfcl</p><p> yum.log</p><p> 书籍2</p><p> 书籍2哈哈</p><p> 假如在同一个目录 那就是重新命令操作了</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg</p><p> [root@localhost ~]# mkdir -p 书籍2/java.pdf</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg  书籍2</p><p> [root@localhost ~]# mv 书籍2/ 牛逼/</p><p> [root@localhost ~]# ls</p><p> anaconda-ks.cfg  牛逼</p><p> [root@localhost ~]# ls 牛逼/</p><p> java.pdf</p><p> [root@localhost ~]# </p><h2 id="vim-命令行下使用方法听语音"><a href="#vim-命令行下使用方法听语音" class="headerlink" title="vim 命令行下使用方法听语音"></a>vim 命令行下使用方法听语音</h2><ul><li><p>原创</p></li><li><p>|</p></li><li><p>浏览：11805</p></li><li><p>|</p></li><li><p>更新：2018-09-30 08:28</p></li><li><p><a href="http://jingyan.baidu.com/album/6b97984dfa464c1ca2b0bf97.html?picindex=1"><img src="https://exp-picture.cdn.bcebos.com/edafb3bcbe2f47700506856e6f3b3b86032179b6.jpg?x-bce-process=image/resize,m_fill,w_92,h_69,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></a>1</p></li><li><p><a href="http://jingyan.baidu.com/album/6b97984dfa464c1ca2b0bf97.html?picindex=2"><img src="https://exp-picture.cdn.bcebos.com/4e168d5653bbf82028e5ccbfba21056105a36eb6.jpg?x-bce-process=image/resize,m_fill,w_92,h_69,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></a>2</p></li><li><p><a href="http://jingyan.baidu.com/album/6b97984dfa464c1ca2b0bf97.html?picindex=3"><img src="https://exp-picture.cdn.bcebos.com/04201aa355e983aebbc9039e68efe078153169b6.jpg?x-bce-process=image/resize,m_fill,w_92,h_69,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></a>3</p></li><li><p><a href="http://jingyan.baidu.com/album/6b97984dfa464c1ca2b0bf97.html?picindex=4"><img src="https://exp-picture.cdn.bcebos.com/1570c1b6326c5766c2d158e7a4632385e13661b6.jpg?x-bce-process=image/resize,m_fill,w_92,h_69,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></a>4</p></li><li><p><a href="http://jingyan.baidu.com/album/6b97984dfa464c1ca2b0bf97.html?picindex=5"><img src="https://exp-picture.cdn.bcebos.com/031231632385e036828f1d5cb8e039723c035ab6.jpg?x-bce-process=image/resize,m_fill,w_92,h_69,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></a>5</p></li><li><p><a href="http://jingyan.baidu.com/album/6b97984dfa464c1ca2b0bf97.html?picindex=6"><img src="https://exp-picture.cdn.bcebos.com/e3d059e833e03972591de15eb5863048604356b6.jpg?x-bce-process=image/resize,m_fill,w_92,h_69,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></a>6</p></li><li><p><a href="http://jingyan.baidu.com/album/6b97984dfa464c1ca2b0bf97.html?picindex=7"><img src="https://exp-picture.cdn.bcebos.com/baab208630486143beca12858febf6a75e0f53b6.jpg?x-bce-process=image/resize,m_fill,w_92,h_69,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></a>7</p></li></ul><p><a href="http://jingyan.baidu.com/album/6b97984dfa464c1ca2b0bf97.html">分步阅读</a></p><p>Vim是从vi发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富。因此，学习vim的使用方法是很有必要的，本文将说明vim常用实用的使用方法，可以作为vim的基础入门！</p><h2 id="工具-原料"><a href="#工具-原料" class="headerlink" title="工具/原料"></a>工具/原料</h2><ul><li>vim</li></ul><h2 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法/步骤"></a>方法/步骤</h2><ol><li><p>1</p><p>首先通过vim创建文件，打开命令窗口，输入vim test.txt (假设要创建的文件名是test.txt)</p><p><img src="https://exp-picture.cdn.bcebos.com/edafb3bcbe2f47700506856e6f3b3b86032179b6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></p></li><li><p>输入完成上面的命令之后，出现如下的界面</p><p><img src="https://exp-picture.cdn.bcebos.com/4e168d5653bbf82028e5ccbfba21056105a36eb6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></p></li><li><p>然后按下英文字母i, 底部就会出现INSERT, 表示当前可以输入文本信息</p><p><img src="https://exp-picture.cdn.bcebos.com/04201aa355e983aebbc9039e68efe078153169b6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></p></li><li><p>输入信息之后，按下键盘上的esc, 接着输入英文形式的冒号：</p><p><img src="https://exp-picture.cdn.bcebos.com/1570c1b6326c5766c2d158e7a4632385e13661b6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></p></li><li><p>最后在冒号后面输入wq, 表示保存退出</p><p><img src="https://exp-picture.cdn.bcebos.com/031231632385e036828f1d5cb8e039723c035ab6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></p></li><li><p>当前目录查看，文件已经生成</p><p><img src="https://exp-picture.cdn.bcebos.com/e3d059e833e03972591de15eb5863048604356b6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></p></li><li><p>如果想要文件内容前面显示行号，那么打开文件之后，按下键盘上esc, 接着输入冒号，冒号后面输入set nu, 最后按下回车键，文件每一行前面就显示行号</p><p><img src="https://exp-picture.cdn.bcebos.com/baab208630486143beca12858febf6a75e0f53b6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></p></li><li><p>如果文件输入信息，但是不想要保存，那么按下键盘esc， 输入冒号，冒号后面输入q!, 表示退出不保存，最后按下回车键</p><p><img src="https://exp-picture.cdn.bcebos.com/cca2552c56ee7b7ffd1026c16ef4fcf5ef0d41b6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></p></li><li><p>如果想要复制某一行信息到其他地方，那么光标移到想要复制的所在行，执行yy, 表示复制该行，然后光标移到想要粘贴的地方，执行p，表示粘贴</p><p><img src="https://exp-picture.cdn.bcebos.com/e4b5e2f5ee0d3ace2bc928df87e265e7350fbbb6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></p></li><li><p>如果想要光标移到行尾，那么按下键盘上esc, 然后再按下¥（或者💲）</p><p><img src="https://exp-picture.cdn.bcebos.com/732a12e265e7340fe2664e9735b9763e20c2b4b6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></p></li><li><p>如果想要光标移到行首，那么按下键盘上esc, 然后按下数字0</p><p><img src="https://exp-picture.cdn.bcebos.com/1562a0b9763e21c230c8bb64e6e89a618725b1b6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="vim 命令行下使用方法"></p></li></ol><h1 id="虚拟机下CentOS7开启SSH连接"><a href="#虚拟机下CentOS7开启SSH连接" class="headerlink" title="虚拟机下CentOS7开启SSH连接"></a>虚拟机下CentOS7开启SSH连接</h1><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png" alt="img"></p><p>​                    <a href="https://blog.csdn.net/lishaojun0115">梦里断魂</a>                    2017-04-14 15:08:31                    <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes.png" alt="img">                    4483                                            <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect.png" alt="img">                                                收藏                                                    3                                                                </p><p>​                            分类专栏：                                <a href="https://blog.csdn.net/lishaojun0115/category_6279653.html">linux</a>                    </p><p>​                </p><p>在虚拟机（Vmware Workstation）下，安装了CentOS7，现在想通过SSH工具连接虚拟机中的CentOS7</p><p>1、 首先，要确保CentOS7安装了 openssh-server，在终端中输入 yum list installed | grep openssh-server<br> <img src="https://img-blog.csdn.net/20170414145229305?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 此处显示已经安装了 openssh-server，如果又没任何输出显示表示没有安装 openssh-server，通过输入 yum install openssh-server<br> <img src="https://img-blog.csdn.net/20170414145334291?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 来进行安装openssh-server</p><p>2、 找到了 /etc/ssh/ 目录下的sshd服务配置文件 sshd_config，用Vim编辑器打开</p><p>将文件中，关于监听端口、监听地址前的 # 号去除<br> <img src="https://img-blog.csdn.net/20170414145414728?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 然后开启允许远程登录<br> <img src="https://img-blog.csdn.net/20170414145452432?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 最后，开启使用用户名密码来作为连接验证<br> <img src="https://img-blog.csdn.net/20170414145534526?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 保存文件，退出</p><p>3、 开启 sshd 服务，输入 sudo service sshd start<br> <img src="https://img-blog.csdn.net/20170414145612257?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 检查 sshd 服务是否已经开启，输入ps -e | grep sshd<br> <img src="https://img-blog.csdn.net/20170414145646336?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 或者输入netstat -an | grep 22 检查 22 号端口是否开启监听<br> <img src="https://img-blog.csdn.net/20170414145719118?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>4、 在Vmware Workstation中，查看CentOS7的属性，发现网络连接方式是采用的 NAT 方式连接的<br> <img src="https://img-blog.csdn.net/20170414145755994?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>5、 在Vmware Workstation中，点击编辑=》虚拟网络编辑器，进入虚拟网络编辑器，查看发现 NAT 模式的连接采用的网络适配器名称为VMnet8<br> <img src="https://img-blog.csdn.net/20170414145915543?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 6、在 windows 主机中，在命令行中输入ipconfig 查看主机IP，找到 VMnet8 的连接信息，此处 ip 为192.168.30.1</p><p><img src="https://img-blog.csdn.net/20170414145956013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>7、在CentOS中，输入ifconfig查看网络连接地址，发现CentOS的网络地址为192.168.112.128<br> <img src="https://img-blog.csdn.net/20170414150027606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 8、在CentOS中，输入ping 192.168.30.1 测试是否能连通主机，发现可以连通<br> <img src="https://img-blog.csdn.net/20170414150105856?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 9、在主机中，输入 ping 192.168.112.128，测试主机是否能连通CentOS，发现连不通<br> <img src="https://img-blog.csdn.net/20170414150140466?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 如果可以连得通，可以直接跳至第12 步</p><p>10、在主机，打开网络配置，选择网络适配器 VMnet8 的 TCP/IPv4 的属性，进行一下网络配置<br> <img src="https://img-blog.csdn.net/20170414150302174?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>要求子网掩码、默认网关均和CentOS一致，并将IP地址修改为 192.168.112.1，即保证主机的 IP 和 CentOS 的 IP 在同一网络区段中</p><p>11、再在主机中，输入 ping 192.168.112.128，已经可以连接得通了<br> <img src="https://img-blog.csdn.net/20170414150338191?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 12、在SSH工具（此处使用的XShell）中，新建连接，输入 CentOS 的 IP 地址、用户名、密码即可连接成功</p><p><img src="https://img-blog.csdn.net/20170414150410545?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p><p><img src="https://img-blog.csdn.net/20170414150439030?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>连接成功</p><p><img src="https://img-blog.csdn.net/20170414150541577?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>13、为了免去每次开启 CentOS 时，都要手动开启 sshd 服务，可以将 sshd 服务添加至自启动列表中，输入systemctl enable sshd.service</p><p><img src="https://img-blog.csdn.net/20170414150619788?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>可以通过输入systemctl list-unit-files | grep sshd，查看是否开启了sshd 服务自启动<br> <img src="https://img-blog.csdn.net/20170414150654578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlzaGFvanVuMDExNQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>转载</p><h1 id="CentOS8-安装-MySQL8-0（yum）"><a href="#CentOS8-安装-MySQL8-0（yum）" class="headerlink" title="CentOS8 安装 MySQL8.0（yum）"></a>CentOS8 安装 MySQL8.0（yum）</h1><p><a href="https://author.baidu.com/home?from=bjh_article&app_id=1611486337963117"><img src="https://user-center-hb.cdn.bcebos.com/head/raw/uc.101.9e42f2a4.bJDtursR1101kdb8xt9_3Q?x-bce-process=image/resize,m_lfit,w_200,h_200&autime=9" alt="img"></a></p><p><a href="https://author.baidu.com/home?from=bjh_article&app_id=1611486337963117">张德Talk</a></p><p>发布时间: 20-01-2620:31</p><p>环境：Linux centos8 4.18.0-80.el8.x86_64、Mysql8.0.17</p><p>1、Mysql官网下载RPM包</p><p>wget <a href="https://dev.mysql.com/get/mysql80-community-release-el8-1.noarch.rpm2%E3%80%81%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AE%89%E8%A3%85%EF%BC%88%E5%BC%BA%E5%8A%9B%E5%8D%B8%E8%BD%BD%EF%BC%89">https://dev.mysql.com/get/mysql80-community-release-el8-1.noarch.rpm2、检查是否已安装（强力卸载）</a></p><p>for i in $(rpm -qa|grep mysql);do rpm -e $i –nodeps;donerm -rf /var/lib/mysql &amp;&amp; rm -rf /etc/my.cnf &amp;&amp; rm -rf /usr/share/mysql备注：可配合以下方式查找whereis mysqlfind /-name mysqlyum remove mysql mysql-server mysql-libs3、安装rpm包</p><p>yum localinstall rpm包</p><p><img src="https://pics3.baidu.com/feed/86d6277f9e2f0708a17ceb909779a59fa801f28d.jpeg?token=392f4cee75fe2e2054600cd16ca56acd&s=E9E233671FE083600CF1DC0F0000A0C1" alt="img"></p><p>4、yum安装</p><p>yum updateyum install mysql-server</p><p><img src="https://pics7.baidu.com/feed/bd3eb13533fa828b9ca173d583425c32960a5aed.jpeg?token=63e698125c99927bafa20de35ddbe957&s=E9E2336313F4B66D0E71DC030000E0C1" alt="img"></p><p><img src="https://pics6.baidu.com/feed/3812b31bb051f819f6ef34afa6e957eb2c73e7f4.jpeg?token=b169da4d9dd117272b58fb25b059ca0b&s=A8E2C303D1C4B9535CFC2D020100A0C1" alt="img"></p><p>5、查看mysql是否安装成功</p><p>ps -ef | grep mysqlmysqladmin –version</p><p><img src="https://pics0.baidu.com/feed/f9198618367adab4b237511af189ae1a8601e46c.jpeg?token=5eb4d52b6fbe5c6dbd3a598893c0b50c" alt="img"></p><p>6、启动mysql服务</p><p>systemctl start mysqldsystemctl enable mysqldsystemctl status mysqld</p><p><img src="https://pics0.baidu.com/feed/9c16fdfaaf51f3de0d76cd62eeb3ed193b297957.jpeg?token=6e099c6525b1225c965668a372ed7e36&s=A0F263238FE0B9601C5D940E0100E0C2" alt="img"></p><p>如何停止mysql的服务呢。方法也很简单，使用命令：service mysqld stop命令即可。</p><p>7、相关安装目录</p><p>/usr/bin //相关命令</p><p><img src="https://pics6.baidu.com/feed/a9d3fd1f4134970a7ed0e85ce897cccea6865d81.jpeg?token=be57481a213fe640da863e52f9dfca59&s=29E272233AB4B4DE0EF8D50F0000E0C1" alt="img"></p><p>/usr/share/mysql //配置文件目录</p><p><img src="https://pics2.baidu.com/feed/0bd162d9f2d3572c822e540cf04e7e2160d0c3f2.jpeg?token=8921c1cc8fa7f39321e7a1a2f652d9c6&s=69E23363FAA780CE4AD59D0A0100E0C1" alt="img"></p><p>/var/lib/mysql //数据库文件存放目录</p><p><img src="https://pics5.baidu.com/feed/6a600c338744ebf8ac92adc4a5a4ca2c6259a7ca.jpeg?token=e810878c5784fed75059285cf9b21720&s=29E27323E2A580EF0465C10A0100A0C1" alt="img"></p><p>/etc/my.cnf.d //mysql的启动配置文件* client.cnf //mysql客户端配置文件* mysql-server.cnf //mysql守护进程配置文件* mysql-default-authentication-plugin.cnf //默认权限授权配置文件备注：可复制一份到/etc下，修改成my.cnf</p><p><img src="https://pics0.baidu.com/feed/30adcbef76094b36bb25e73cdb9161df8c109d0b.jpeg?token=9aca0154c7971906a0041f61cbfc60f1&s=29E27323CF0C3D701E7DB00E0000E0C1" alt="img"></p><p>8、mysql登录（不用密码登录）</p><p>mysql -uroot</p><p><img src="https://pics3.baidu.com/feed/ac4bd11373f082023bfb537f31a6e6ebaa641bec.jpeg?token=238c6182a8fb786a3c1c3c3763928b49&s=69E2336353A48D4B4C50F8030000E0C1" alt="img"></p><p>9、重置root密码</p><p>use mysql;//选择数据库alter user ‘root’@’localhost’ identified by’root’;//修改密码flush privileges;//刷新权限表备注：mysql8.0修改用户密码命令（新的修改方式）</p><p><img src="https://pics0.baidu.com/feed/562c11dfa9ec8a13f7bf63a88f5e8c89a1ecc0b0.jpeg?token=10fe8561b6660600ad0179c1d2889209&s=24F2E32353A4934B4CDDF50F0000E0C1" alt="img"></p><p><img src="https://pics2.baidu.com/feed/83025aafa40f4bfbd465851a7b1265f6f63618ad.jpeg?token=c26b5dc74e7765d4693197bdcda0e458&s=A0F2E323919188630CC5290B010070C0" alt="img"></p><p>10、重新登录（使用新密码）</p><p>mysql -uroot -p</p><p><img src="https://pics1.baidu.com/feed/b7fd5266d016092401600a94ae5a28fce7cd345f.jpeg?token=da864bde94ac631775f05fb11ccd3ea0&s=29E27323D7E08D4B0CD9FD030000E0C1" alt="img"></p><pre><code>    # 创建用户并授权用户    create user &#39;username&#39;@&#39;localhost&#39; identified by &#39;your_password&#39;;    create database database_name default character set = &#39;utf8&#39; default collate = &#39;utf8_general_ci&#39;;    grant all privileges on database_name.* to &#39;username&#39;@&#39;localhost&#39;;    flush privileges;</code></pre><h1 id="linux下开启、关闭、重启mysql服务"><a href="#linux下开启、关闭、重启mysql服务" class="headerlink" title="linux下开启、关闭、重启mysql服务"></a>linux下开启、关闭、重启mysql服务</h1><h2 id="一、-启动"><a href="#一、-启动" class="headerlink" title="一、 启动"></a>一、 启动</h2><p>1、使用 service 启动：<strong>service mysql start</strong><br> 2、使用 mysqld 脚本启动：**/etc/inint.d/mysql start**<br> 3、使用 safe_mysqld 启动：<strong>safe_mysql&amp;</strong></p><h2 id="二、停止"><a href="#二、停止" class="headerlink" title="二、停止"></a>二、停止</h2><p>1、使用 service 启动：<strong>service mysql stop</strong><br> 2、使用 mysqld 脚本启动：**/etc/inint.d/mysql stop**<br> 3、<strong>mysqladmin shutdown</strong></p><h2 id="三、重启"><a href="#三、重启" class="headerlink" title="三、重启"></a>三、重启</h2><p>1、使用 service 启动：<strong>service mysql restart</strong><br> 2、使用 mysqld 脚本启动：**/etc/inint.d/mysql restart**</p><h2 id="四、查看mysql状态"><a href="#四、查看mysql状态" class="headerlink" title="四、查看mysql状态"></a>四、查看mysql状态</h2><pre><code>&gt;&gt;mysql1</code></pre><p><img src="https://img-blog.csdnimg.cn/20190530183259741." alt="在这里插入图片描述"><br> 表示服务关闭成功</p><h3 id="五-Unit-iptables-service-could-not-be-found-防火墙问题-。"><a href="#五-Unit-iptables-service-could-not-be-found-防火墙问题-。" class="headerlink" title="五.Unit iptables.service could not be found.(防火墙问题)。"></a>五.Unit <strong>iptables.service</strong> could not be found.(防火墙问题)。</h3><p>shuos_yan 2020-02-25 09:38:58 5175 收藏 6<br>分类专栏： Linux<br>版权</p><p>问题：查看防火墙状态出现：</p><p>Unit iptables.service could not be found.</p><pre><code>1</code></pre><p>解决方案：</p><pre><code>安装iptables-services</code></pre><p>yum install iptables-services</p><pre><code>1</code></pre><p>在这里插入图片描述<br>2. 启动iptables</p><p>systemctl enable iptables<br>systemctl start iptables</p><pre><code>12</code></pre><p>在这里插入图片描述<br>现在执行查看防火墙状态，停止，启动就行了</p><p>查看防火墙状态：</p><p>service iptables status</p><pre><code>1</code></pre><p>关闭防火墙:</p><p>service iptables stop</p><pre><code>1</code></pre><p>打开防火墙:</p><p>service iptables start </p><pre><code>1</code></pre><p>firewalld 方式<br>启动： systemctl start firewalld<br>查看状态： systemctl status firewalld<br>禁用，禁止开机启动： systemctl disable firewalld<br>停止运行： systemctl stop firewalld<br>重启：firewall-cmd –reload<br>————————————————<br>版权声明：本文为CSDN博主「shuos_yan」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/y368769/article/details/104490697/">https://blog.csdn.net/y368769/article/details/104490697/</a></p><h3 id="六-Linux中-MySQL-授权远程连接的方法步骤"><a href="#六-Linux中-MySQL-授权远程连接的方法步骤" class="headerlink" title="六.Linux中 MySQL 授权远程连接的方法步骤"></a>六.Linux中 MySQL 授权远程连接的方法步骤</h3><p><a href="https://blog.csdn.net/qq_34306360/article/details/80834255">https://blog.csdn.net/qq_34306360/article/details/80834255</a></p><p>  更新时间：2018年10月03日 10:49:28  作者：斯文败类i  </p><p>如果需要远程连接 Linux 系统上的 MySQL 时，必须为其 IP 和 具体用户 进行 授权，本篇文章主要介绍了Linux中 MySQL 授权远程连接的方法步骤，感兴趣的小伙伴们可以参考一下</p><p>说明：当别的机子（IP ）通过客户端的方式在没有授权的情况下是无法连接 MySQL 数据库的，如果需要远程连接 Linux 系统上的 MySQL 时，必须为其 IP 和 具体用户 进行 授权 。一般 root  用户不会提供给开发者。如：使用 Windows 上的 SQLyog 图形化管理工具连接 Linux 上的 MySQL  数据库，必须先对其进行授权。</p><p><img src="https://img.jbzj.com/file_images/article/201810/2018103104425739.png?20189310454" alt="img"></p><p>1、在虚拟机中使用 root 用户登录 mysql 数据库</p><pre><code>mysql -u root -p</code></pre><p>说明：root 用户密码一般设置为 root</p><p>2、使用 mysql 命令为 root 用户授权 mysql 远程连接服务</p><pre><code>mysql&gt; ``grant` `all` `privileges` `on` `*.* ``to` `&#39;root&#39;``@``&#39;%&#39;` `identified ``by` `&#39;root&#39;` `with` `grant` `option``;</code></pre><p>说明：此命令是为密码为 root 、IP（%）任意的 root 用户授权。（%：模糊查询，所有 IP 都可以,，可指定其他主机 IP；BY 后的 ‘root’ 为密码）</p><p>3、将配置写入 mysql 授权表中</p><pre><code>mysql&gt; flush ``privileges``;</code></pre><p>修改mysql库的user表，将host项，从localhost改为%。%这里表示的是允许任意host访问，如果只允许某一个ip访问，则可改为相应的ip，比如可以将localhost改为192.168.1.123，这表示只允许局域网的192.168.1.123这个ip远程访问mysql。</p><pre><code>mysql&gt;use mysql; ``mysql&gt;``update` `user` `set` `host = ``&#39;%&#39;` `where` `user` `=``&#39;root&#39;``;``mysql&gt;``select` `host,``user` `from` `user``;``mysql&gt; flush ``privileges``;</code></pre><p><strong>补充：防火墙开放3306端口</strong></p><p>1、打开防火墙配置文件</p><pre><code>vi` `/etc/sysconfig/iptables</code></pre><p>2、增加下面一行</p><pre><code>-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</code></pre><p>3、重启防火墙</p><pre><code>service iptables restart</code></pre><p>注意：增加的开放3306端口的语句一定要在icmp-host-prohibited之前</p><p>附：个人配置</p><pre><code># Firewall configuration written by system-config-firewall``# Manual customization of this file is not recommended.``*filter``:INPUT ACCEPT [0:0]``:FORWARD ACCEPT [0:0]``:OUTPUT ACCEPT [0:0]``-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT``-A INPUT -p icmp -j ACCEPT``-A INPUT -i lo -j ACCEPT``-A INPUT -i eth0 -j ACCEPT``-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT``-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT``-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT``-A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT``-A FORWARD -p icmp -j ACCEPT``-A FORWARD -i lo -j ACCEPT``-A FORWARD -i eth0 -j ACCEPT``-A INPUT -j REJECT --reject-with icmp-host-prohibited``-A FORWARD -j REJECT --reject-with icmp-host-prohibited``COMMIT</code></pre><p>以上就是这篇文章的全部内容了，希望本文的内容对大家的学习或者工作能带来一定的帮助，如果有疑问大家可以留言交流，谢谢大家对脚本之家的支持。</p><h1 id="Centos-安装-NET-CORE-3-1"><a href="#Centos-安装-NET-CORE-3-1" class="headerlink" title="Centos 安装.NET CORE 3.1"></a>Centos 安装.NET CORE 3.1</h1><p>2020.08.05 09:47:54字数 63阅读 400</p><ol><li><p>注册 Microsoft 密钥和源<br> sudo rpm -Uvh <a href="https://links.jianshu.com/go?to=https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm">https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm</a></p></li><li><p>安装 .NET Core SDK　<br> sudo yum install dotnet-sdk-3.1.0</p></li><li><p>安装 ASP.NET Core 运行时<br> sudo yum install aspnetcore-runtime-3.1.0</p></li><li><p>测试.NET SDK安装成功：<br> dotnet –version</p><p><img src="https://upload-images.jianshu.io/upload_images/24210891-0e844fc101c1d4ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p><p>image.png</p><p><img src="https://upload-images.jianshu.io/upload_images/24210891-593e5200a700d4da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/976" alt="img"></p></li></ol><h2 id="CentOS7上部署-Net-Core项目"><a href="#CentOS7上部署-Net-Core项目" class="headerlink" title="CentOS7上部署.Net Core项目"></a>CentOS7上部署.Net Core项目</h2><p>undefined^ 2018-11-02 16:59:59 13540 收藏 11<br>分类专栏： Asp.Net Core<br>版权</p><ol><li>安装CentOS</li></ol><p><a href="https://www.baidu.com/">https://www.baidu.com/</a>    百度解决<br>2. 安装.Net Core Sdk<br>2.1 添加.NET相关</p><p>为了安装.NET，需要注册微软签名密钥和添加微软相关的支持。这个操作每台机器只能做一次。</p><p>打开命令行，输出以下命令，注册Microsoft需要的依赖环境;：</p><pre><code>sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc</code></pre><p>​<br>​    sudo sh -c ‘echo -e “[packages-microsoft-com-prod]\nname=packages-microsoft-com-prod \nbaseurl=<a href="https://packages.microsoft.com/yumrepos/microsoft-rhel7.3-prod/nenabled=1/ngpgcheck=1/ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot;&gt;/etc/yum.repos.d/dotnetdev.repo&#39;">https://packages.microsoft.com/yumrepos/microsoft-rhel7.3-prod\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot;&gt;/etc/yum.repos.d/dotnetdev.repo&#39;</a></p><p>2.2 安装.NET SDK</p><p>①更新可用的安装包：sudo yum update</p><p>②安装.NET需要的组件，libunwind和libicu库：sudo yum install libunwind libicu</p><p>③安装.NET SDK(ps：我的开发环境是2.1.403，cmd：dotnet –version查看)：</p><p>sudo yum install dotnet-sdk-2.1.4</p><p>④安装完成之后，检测是否安装成功(ps:上面命令会默认安装2.1.4开头的最新版)：</p><p>dotnet –version</p><p>3.使用VS2017发布ASP.NET Core MVC程序<br>4.部署ASP.NET Core 应用程序到CentOS服务器</p><p>将发布的文件夹传输到服务器，我这里用的是xftp(也可以用FileZilla等其他的ftp工具)</p><p>将发布的文件夹传输到服务器你想放的位置<br>5. 安装配置Nginx进行反向代理<br>5.1安装Nginx</p><p>①使用如下命令安装CentOS的 EPEL仓库：yum install epel-release</p><p>②使用如下命令安装Nginx：yum install nginx</p><p>③Nginx安装完成后, 系统并不会启动Nginx, 使用如下命令启动Nginx: systemctl start nginx</p><p>④使用如下命令设置系统启动后, 默认启动Nginx: systemctl enable nginx</p><p>⑤查看firewall 状态, 并启动防火墙：</p><p>systemctl status firewalld  //查看防火墙状态</p><p>systemctl start firewalld  //启动防火墙</p><p>⑥使用如下命令, 允许HTTP和HTTPS通过防火墙：</p><p>firewall-cmd  –permanent –zone=public –add-service=http      //允许HTTP</p><p>firewall-cmd  –permanent –zone=public –add-service=https    //允许HTTPS</p><p>firewall-cmd  –reload </p><p>⑦在浏览器地址栏输入你服务器的IP地址, 如果出现下图表示Nginx安装配置成功;</p><p>如果无法访问, 请查看firewall 是否开放80端口：</p><p>firewall-cmd –permanent –zone=public –add-port=80/tcp   //开放80端口</p><p>firewall-cmd –reload                             //重启防火墙<br>5.2修改Nginx的配置文件</p><p>首先，把Nginx的默认配置文件 /etc/nginx/nginx.conf里 80 端口转发配置 server 节点用 # 符注释掉。使用命令vi 或将 nginx.conf 文件下载(使用xftp或其他ftp工具都行)到本地修改完成后在上传(建议);</p><p>vi /etc/nginx/nginx.conf       //打开文件编辑模式, 输入i 进行编辑 完成后 按ESC键输入:wq 回车 退出编辑模式</p><p>然后我们重新创建一个自定义的Nginx配置文件用来代理Core 程序, 我创建名称为nginxforcore.conf(你可以自定义文件名);配置文件内容如下:</p><pre><code>server &#123;    listen 80;    location / &#123;        proxy_pass http://localhost:5000;        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection keep-alive;        proxy_set_header Host $host;        proxy_cache_bypass $http_upgrade;    &#125;&#125;</code></pre><p>proxy_pass http: 后的url为你在core 启动项配置的路径(默认localhost:5000)</p><p>将创建好的自定义配置文件上传到 /etc/nginx/conf.d目录下 ，最后执行命令 重启Nginx: nginx –s reload<br>5.3将Nginx添加到SELinux白名单</p><p>①查看SELinux状态是否为Enforcing(SELinux默认状态为Disabled), 必须保证SELinux的状态为Enforcing否则添加白名单会失败;</p><p><a href="https://www.linuxidc.com/Linux/2016-11/137723.htm%EF%BC%88%E4%BF%AE%E6%94%B9SELinux%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%89">https://www.linuxidc.com/Linux/2016-11/137723.htm（修改SELinux的状态）</a></p><p>修改SELinux的状态：vim /etc/selinux/config</p><p>将SELINUX=disabled改为SELINUX=enforcing</p><p>使用如下命令: getenforce</p><p>如果查询出的值为Enforcing, 执行下一步操作：添加Nginx到SELinux白名单</p><p>②使用如下命令, 将Nginx添加至SELinux白名单，依次执行以下命令</p><pre><code>yum install policycoreutils-python cat /var/log/audit/audit.log | grep nginx | grep denied | audit2allow -M  AddNginxToSELinux semodule -i  AddNginxToSELinux.pp</code></pre><p>(AddNginxToSELinux)该文件可以自己命名</p><p>测试是否修改成功：</p><p>①cd到发布目录（我的为publish文件夹）</p><p>②运行.Net Core程序：(dotnet AbpMPA.Web.Mvc.dll,后面的dll文件为你.Net Core程序的入库dll)</p><p>③在浏览器地址栏输入你服务器的IP地址, 如果出现你自己程序运行的界面，例如下图(这是我的程序的登陆界面)说明我们的ASP.NET Core MVC 已经发布成功了;</p><p>如果没有出现上图, 而是</p><p>请检查:</p><p>1-Nginx是否按上述步骤正确配置;</p><p>2-防火墙及阿里云安全组策略是否正确配置(主要指80端口);</p><p>3-.NET Core程序是否在CentOS下正常运行;<br>6.配置守护进程Supervisor, 让我们的程序能365天24小时不间断运行</p><p>通过上面的操作, 我们已经能正常将.NET Core程序发布到CentOS下来, 但是发布过程中我们也发现了问题, 就是.NET Core不能自动的运行, 一旦我们的命令行工具关掉, 发布的程序就不能访问了;</p><p>是不是能安装一个类似于Windows Service一样的服务, 能实时监控程序状态，异常退出时能自动重启。经过各种百度我找到了Supervisor。</p><p>Supervisor 是用Python开发的Linux/Unix系统下的一个进程管理工具。它可以使进程(类似Windows Service)脱离终端，变为后台守护进程（daemon）。能实时监控进程状态，异常退出时能自动重启。详细文档请查看官网。<br>6.1安装Supervisor</p><p>yum install python-setuptools</p><p>easy_install supervisor<br>6.2配置Supervisor</p><p>①运行supervisord 服务的时候，需要指定 Supervisor 配置文件，所以，先通过如下命令创建目录，以便让 supervisor 成功加载默认配置：</p><p>mkdir /etc/supervisor</p><p>②目录创建成功后, 通过 echo_supervisord_conf 程序（用来生成初始配置文件,文件名可以自定义）来初始化一个配置文件：</p><p>echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf</p><p>③通过vim命令修改创建好的supervisord.conf配置信息：</p><p>vi /etc/supervisor/supervisord.conf</p><p>④最下边找到如下文本片段：</p><p>修改为：</p><p>该操作的目的是我们创建一个supervisor 进程配置文件加载目录。让supervisor自动加载该目录下 .ini 后缀的文件作为服务配置<br>6.3为我们部署的.NET Core添加进程配置文件</p><p>①创建配置文件AbpMPACore.ini(文件名自定义)</p><pre><code>[program:AbpMPACore]                          ;自定义进程名称, 根据自己喜好命名command=dotnet AbpMPA.Web.Mvc.dll             ;程序启动命令 使用dotnet 命令directory=/publish                            ;命令执行的目录 你.NET Core 程序存放目录autostart=true                                ;在Supervisord启动时，程序是否启动autorestart=true                              ;程序退出后自动重启startretries=5                                ;启动失败自动重试次数，默认是3startsecs=1                                   ;自动重启间隔user=admin                                    ;设置启动进程的用户，默认是rootpriority=999                                  ;进程启动优先级，默认999，值小的优先启动stderr_logfile=/var/log/AbpMPA.err.log        ;标准错误日志 路径可以自定义stdout_logfile=/var/log/AbpMPA.out.log        ;标准输出日志  路径可以自定义environment=ASPNETCORE_ENVIRONMENT=Production ;进程环境变量stopsignal=INT                                ;请求停止时用来杀死程序的信号</code></pre><p>②在/etc/supervisor/目录下创建一个文件夹conf.d: mkdir /etc/supervisor/conf.d</p><p>将刚创建的配置文件AbpMPACore.ini移到conf.d文件夹下<br>6.4 启动 Supervisor 服务</p><p>supervisord -c /etc/supervisor/supervisord.conf</p><p>这个时候, 我们已经不需要使用dotnet命令运行程序, 同样可以访问我们部署的.NET Core程序了<br>6.5配置Supervisor开机启动</p><p>①进入/usr/lib/systemd/system/目录，并创建supervisord.service文件(或者在本地写好了再通过ftp工具传输到指定目录下)</p><p>vi /usr/lib/systemd/system/supervisord.service</p><pre><code>[Unit]Description=Supervisor daemon [Service]Type=forkingExecStart=/usr/bin/supervisord -c /etc/supervisor/supervisord.confExecStop=/usr/bin/supervisorctl $OPTIONS shutdownExecReload=/usr/bin/supervisorctl $OPTIONS reloadKillMode=processRestart=on-failureRestartSec=42s [Install]WantedBy=multi-user.target</code></pre><p>②设置开机启动</p><p>systemctl enable supervisord.service</p><p>systemctl daemon-reload</p><p>③重启，测试是否可以开机自启</p><h1 id="net5正式版-在CentOS-8-x-下尝试安装-Net-5-的运行时"><a href="#net5正式版-在CentOS-8-x-下尝试安装-Net-5-的运行时" class="headerlink" title=".net5正式版_在CentOS 8.x 下尝试安装.Net 5 的运行时"></a>.net5正式版_在CentOS 8.x 下尝试安装.Net 5 的运行时</h1><h3 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a><strong>1、背景</strong></h3><p>看着不管是群里还是公众号里这几天最热闹就是.Net 5.0 正式版的发布、C#9。</p><p>当然要开发.net 5.0 的项目就需要把VisualStudio升级的v16.8.0版本了。升级后自带着安装了.Net 5.0 SDK 和它相应的运行时。</p><p><strong>有哪些改进</strong>：这并不是我们今天的重点，具体请查看官方文档：<a href="https://docs.microsoft.com/en-au/aspnet/core/release-notes/aspnetcore-5.0?view=aspnetcore-5.0">https://docs.microsoft.com/en-au/aspnet/core/release-notes/aspnetcore-5.0?view=aspnetcore-5.0</a></p><h3 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a><strong>2、安装</strong></h3><p>在CentOS 8.x 上 安装 .net 5 的运行时才是我们的重点，</p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/3a6ec76c85972671b59c2e14817dbcce.png" alt="3a6ec76c85972671b59c2e14817dbcce.png"> </p><p>为何这么说呢，本以为很简单的一件事，动手尝试后才发现有坑，那本文的重点就是记录踩过的坑。</p><h3 id="2-1、首次安装"><a href="#2-1、首次安装" class="headerlink" title="2.1、首次安装"></a><strong>2.1、首次安装</strong></h3><p>很规矩的去官网，看着官网(<a href="https://docs.microsoft.com/en-au/dotnet/core/install/linux-centos)%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E3%80%82">https://docs.microsoft.com/en-au/dotnet/core/install/linux-centos)一步一步进行安装。</a></p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/77df04c6f4b83ccb73fca03d9d55b15b.png" alt="77df04c6f4b83ccb73fca03d9d55b15b.png"> </p><p>实际操作：</p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/123fd06fc9b4e2cb618b6e0996a0d2b0.png" alt="123fd06fc9b4e2cb618b6e0996a0d2b0.png"> </p><p>我的天</p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/705d3a1f829706f93d6d227a9dd6044c.png" alt="705d3a1f829706f93d6d227a9dd6044c.png"> </p><p>，开玩笑吧(也许是对我的折磨)</p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/a0f861ef87be2c714befcb908bca423e.png" alt="a0f861ef87be2c714befcb908bca423e.png"> </p><p>，一顿折腾，最终也还是无济于事</p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/5ff5d6983a254b24d7174e4969e1d5a4.png" alt="5ff5d6983a254b24d7174e4969e1d5a4.png"> </p><p>。</p><h3 id="2-2、最终安装"><a href="#2-2、最终安装" class="headerlink" title="2.2、最终安装"></a><strong>2.2、最终安装</strong></h3><p>严重怀疑是不是我安装的就不是8.x版本，验证一把</p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/bd0e74aebd29620b2ccb1cd97ebf550c.png" alt="bd0e74aebd29620b2ccb1cd97ebf550c.png"> </p><p>这就奇怪了。</p><p>不管在“度娘”还是在“谷爹”最终还是失败。最终还是乖乖的再次仔细的读它的官网(<a href="https://docs.microsoft.com/en-au/dotnet/core/install/linux-centos">https://docs.microsoft.com/en-au/dotnet/core/install/linux-centos</a>)</p><p>看到下图的时候，灵光一闪</p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/75cbb705704bf25d4b6404f1b43796b9.png" alt="75cbb705704bf25d4b6404f1b43796b9.png"> </p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/4fb8dacecb347d4f058cd984f707e53e.png" alt="4fb8dacecb347d4f058cd984f707e53e.png"> </p><p>既然在CentOS 7 上需要，那是不是需要在CentOS8上也需要呢？试试呗</p><p>于是我将它的7改成了8</p><p>1</p><p>sudo rpm -Uvh <a href="https://packages.microsoft.com/config/centos/8/packages-microsoft-prod.rpm">https://packages.microsoft.com/config/centos/8/packages-microsoft-prod.rpm</a></p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/3420df953b4ba31f7c4897066c0dd136.png" alt="3420df953b4ba31f7c4897066c0dd136.png"> </p><p>按下Enter键，本以为又是报错呢</p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/c8f8ecadf07272db55a0188697f6e3fe.png" alt="c8f8ecadf07272db55a0188697f6e3fe.png"> </p><p>。</p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/1d0c72d38c071de9e671ad85d4a9f4f0.png" alt="1d0c72d38c071de9e671ad85d4a9f4f0.png"> </p><p>既然成功了，打铁还需趁热。再次执行</p><p>1</p><p>sudo dnf install aspnetcore-runtime-5.0</p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/5a0c845767ee9ab6a634707bf6b00445.png" alt="5a0c845767ee9ab6a634707bf6b00445.png"> </p><p>果然成功了</p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/53a9d016bba1e0c1f312a9e385134df8.png" alt="53a9d016bba1e0c1f312a9e385134df8.png"> </p><p>。</p><p>那就一路y 呗</p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/6cd0aba7f486709590547487f40f079c.png" alt="6cd0aba7f486709590547487f40f079c.png"> </p><p>Complete！我的天，成功了。</p><p>验证一把呗</p><p>  <img src="https://img-blog.csdnimg.cn/img_convert/3446d70a383d6deb32baf8204955b467.png" alt="3446d70a383d6deb32baf8204955b467.png"> </p><p>成功！</p><h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a><strong>3、总结</strong></h3><p>在CentOS 8.x 下 安装运行时 就记录于此，有帮助到各位的点个</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识ABP vNext</title>
      <link href="2021/03/25/abp/2020abp-bo-ke-xue-xi-dotnet-kua-ping-tai/"/>
      <url>2021/03/25/abp/2020abp-bo-ke-xue-xi-dotnet-kua-ping-tai/</url>
      
        <content type="html"><![CDATA[<h2 id="初识ABP-vNext（1）：开篇计划-amp-基础知识"><a href="#初识ABP-vNext（1）：开篇计划-amp-基础知识" class="headerlink" title="初识ABP vNext（1）：开篇计划&amp;基础知识"></a>初识ABP vNext（1）：开篇计划&amp;基础知识</h2><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png" alt="img"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSnNYaWFZWjYya0Yya0VOZFVIMlY3QkRFZnFIMHJoeGxPOUZmMFlzSFlmUDhpYzhRUWdRUnV6bGljMjJta1VrSzZjN2RHT3AwcnNUR2NVUS82NDA?x-oss-process=image/format,png" alt="img"></p><ul><li>审计(Audit)</li><li>本地化(Localization)</li><li>事件总线(Event Bus)</li><li>多租户(multi-tenancy technology)</li><li>DDD分层</li><li>实体(Entity)</li><li>值对象(Value Object)</li><li>聚合根(Aggregate Root)</li><li>仓储(Repository)</li><li>应用服务(Application Services)</li><li>数据传输对象(DTO)</li><li>工作单元(Unit Of Work)</li></ul><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>ABP vNext（以下简称ABP）的前身是asp.net boilerplate（老版abp），它不是一个简单的版本更新，而是完全基于.NET Core的重写。之前有听说过ABP框架，但是一直没有去详细了解。最近认真学习了一下，准备记录下自己的一些心得，计划分为3部分来进行：</p><ol><li>ABP基础（就是官网上一些基本的功能）</li><li>ABP实战（使用ABP+vue开发一个简单项目）</li><li>ABP模块化（微服务简单介绍）</li></ol><p>首先，这是以一个0基础的视角去写的，所以会比较基础，适合新手。文中如果有不对的地方，大家可以帮我指出来相互学习。。。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>ABP官网：<a href="https://www.abp.io/">https://www.abp.io/</a></p><p>ABP GitHub：<a href="https://github.com/abpframework/abp">https://github.com/abpframework/abp</a></p><p>要学习ABP，首先肯定要认真看一下官方的文档，虽然目前官方文档还不完整；然后对哪一部分不理解的，可以适当的阅读一下源码。</p><p>ABP是基于DDD:Domain-Driven Design（领域驱动设计）去开发的，当然框架本身不强制你使用DDD，但是他建议把DDD作为最佳实践。如果了解DDD，并且使用过老版本abp的话，看官方文档可能就比较轻松，反之则会比较吃力。。。首先DDD理论就非常抽象和复杂，要深刻理解它并不容易；其次是ABP内部使用了很多开源组件，比如EF Core，IdentityServer4，Autofac，AutoMapper，Swagger等等，所以也需要对这些组件有所了解。</p><p>本篇简单介绍一下ABP官方文档上一些重要的关键字，先理解这些关键字，才能更好的进一步学习。</p><h3 id="审计-Audit"><a href="#审计-Audit" class="headerlink" title="审计(Audit)"></a>审计(Audit)</h3><p>审计是用于追踪数据变化的过程。平时开发中，你一定经常见到类似创建时间、创建人、修改时间、修改人等属性，这些属性就是用于数据审计。ABP框架提供了一些接口和基类来标准化这些属性，并自动设置它们的值；并且ABP提供了一个可扩展的审计日志系统，自动化的根据约定记录审计日志，并提供配置来控制审计日志的级别。ABP中审计相关基类/接口有：<code>IAuditedObject</code>、<code>AuditedEntity</code>、<code>AuditedAggregateRoot</code>等等。</p><h3 id="本地化-Localization"><a href="#本地化-Localization" class="headerlink" title="本地化(Localization)"></a>本地化(Localization)</h3><p>使应用程序支持多国语言。ABP的本地化系统与ASP.NET Core的本地化兼容。</p><h3 id="事件总线-Event-Bus"><a href="#事件总线-Event-Bus" class="headerlink" title="事件总线(Event Bus)"></a>事件总线(Event Bus)</h3><blockquote><p>事件总线是对观察者（发布-订阅）模式的一种实现。它是一种集中式事件处理机制，允许不同的组件之间进行彼此通信而又不需要相互依赖，达到一种解耦的目的。</p></blockquote><p>如果没有接触过Event Bus，可能不太好理解。一个不太恰当的例子：A需要租房，B需要把房子租出去，A想直接找到B是比较困难的，A也不想去认识B，所以才有房产中介C，C就是Event Bus；B提前跟C说我的房子需要出租，A跟C说我给你钱你帮我租一个房，那么C很容易就帮A找到B完成租房，A甚至不需要知道B是谁，这里A就是事件的发布者，B是事件的订阅者。ABP支持本地Event Bus和分布式Event Bus。</p><h3 id="多租户-multi-tenancy-technology"><a href="#多租户-multi-tenancy-technology" class="headerlink" title="多租户(multi-tenancy technology)"></a>多租户(multi-tenancy technology)</h3><p>多租户是一种软件架构技术，这种架构可以让多个租户共用相同的系统，并且可以确保各租户间数据的隔离性。相信很多人都遇到过类似需求，同一个系统中根据不同客户区分数据；通常我们会在数据库表中增加一个客户Id作为标识，或者根据不同客户读取不同的数据库，这都是多租户数据隔离的实现方式，想自己很好的实现多租户还是很繁琐的。ABP的多租户模块提供了创建多租户应用程序的基本功能，可以很轻松的帮你实现多租户。</p><h3 id="DDD分层"><a href="#DDD分层" class="headerlink" title="DDD分层"></a>DDD分层</h3><ul><li><strong>表示层</strong>: 为用户提供接口，使用应用层实现与用户交互。</li><li><strong>应用层</strong>: 表示层与领域层的中介，编排业务对象执行特定的应用程序任务，使用应用程序逻辑实现用例。</li><li><strong>领域层</strong>: 包含业务对象以及业务规则，是应用程序的核心。</li><li><strong>基础设施层</strong>: 提供通用的技术功能，支持更高的层，主要使用第三方类库。</li></ul><h3 id="实体-Entity"><a href="#实体-Entity" class="headerlink" title="实体(Entity)"></a>实体(Entity)</h3><blockquote><p>一个没有从其属性，而是通过连续性和身份的线索来定义的对象。</p></blockquote><p>官方文档中这句话非常难理解。。。</p><p>简单来说，当一个对象只能由他的标识（Id）来区分，而不是从其他属性来区分时，这种对象被称为实体。比如有很多叫“张三”的男人，你不能通过姓名和性别来区分到底是哪个张三，只能通过Id。实体是可以持续变化的，我们可以对实体进行多次修改，但是无论怎么修改，实体始终拥有它唯一的标识。DDD中的实体通常都是充血模型，充血模型就是实体中不光有属性，还会包含行为（方法），反之DTO，ViewModel就是典型的贫血模型。实体通常映射到关系型数据库的表中，ABP中实体相关的基类/接口有：<code>Entity</code>、<code>IEntity</code>、<code>AuditedEntity</code>等等。</p><h3 id="值对象-Value-Object"><a href="#值对象-Value-Object" class="headerlink" title="值对象(Value Object)"></a>值对象(Value Object)</h3><p>值对象和实体恰好相反，它不需要唯一标识，并且它不可以被改变。值对象通常是用来度量和描述事物，当你只关注某个对象的属性时，该对象便可以是一个值对象。比如“北京”就是“北京”，不存在Id=1或者Id=2的北京的说法。当然，值对象虽然不存在唯一标识，但是不代表它在数据库中就没有Id主键。。。</p><h3 id="聚合根-Aggregate-Root"><a href="#聚合根-Aggregate-Root" class="headerlink" title="聚合根(Aggregate Root)"></a>聚合根(Aggregate Root)</h3><p>聚合是业务逻辑紧密关联的实体和值对象组合而成，聚合是数据修改和持久化的基本单元，聚合后产生的根实体称为聚合根。若一个聚合仅有一个实体，那这个实体就是聚合根。聚合根被视为一个单元，你不能单独去修改聚合根中的子实体。例如，某个业务流程中，会操作A、B、C、D四个对象（简单理解为数据库表），那么将ABCD聚合，产生一个聚合根E，对外部来说只需要操作E就可以了，领域内部会处理好ABCD。这样一方面避免了多个对象的混乱，另一方面也保证了数据的完整性，不会出现AB操作成功了，CD操作失败了，导致数据库产生脏数据。</p><p>聚合根引用聚合根：通过ID。</p><p>聚合根引用实体：通过对象（导航属性）。</p><p>聚合根引用值对象：通过对象（导航属性）。</p><h3 id="仓储-Repository"><a href="#仓储-Repository" class="headerlink" title="仓储(Repository)"></a>仓储(Repository)</h3><p>仓储用于操作领域对象（实际就是操作数据库），通常会为每个聚合根或不同的实体创建对应的仓储。ABP也提供了通用的泛型仓储：<code>IRepository&lt;TEntity, TKey&gt;</code>，内置了增删改查基本功能，直接注入就可以使用。</p><h3 id="应用服务-Application-Services"><a href="#应用服务-Application-Services" class="headerlink" title="应用服务(Application Services)"></a>应用服务(Application Services)</h3><p>应用层处于展示层与领域层之间，展示层通常调用应用服务，应用服务调用领域然后返回数据给展示层。展示层也可以直接调用领域。APB中应用服务相关的基类/接口有：<code>IApplicationService</code>、<code>ApplicationService</code>、<code>ICrudAppService</code>、<code>CrudAppService</code>等等。</p><h3 id="数据传输对象-DTO"><a href="#数据传输对象-DTO" class="headerlink" title="数据传输对象(DTO)"></a>数据传输对象(DTO)</h3><p>通常领域对象不适合直接在应用层与展示层之间传递，比如User中的Passwod字段，这时候就需要用到DTO，DTO和ViewModel类似。ABP提供了一些DTO基类/接口：<code>IEntityDto</code>、<code>EntityDto</code>、<code>AuditedEntityDto</code>等等。</p><h3 id="工作单元-Unit-Of-Work"><a href="#工作单元-Unit-Of-Work" class="headerlink" title="工作单元(Unit Of Work)"></a>工作单元(Unit Of Work)</h3><p>UOW模式是为了保证一次业务操作的数据完整性。ABP框架的UOW实现提供了对应用程序中的数据库连接和事务范围的抽象和控制，使用ABP的话通常你不用自己去写数据库事务相关代码。实际上工作单元不一定非要创建数据库事务，比如HTTP GET请求就不会启动事务性UOW，它们仍然启动UOW，但不创建数据库事务。这一切都由ABP框架自动完成。</p><h2 id="初识ABP-vNext（2）：ABP启动模板"><a href="#初识ABP-vNext（2）：ABP启动模板" class="headerlink" title="初识ABP vNext（2）：ABP启动模板"></a>初识ABP vNext（2）：ABP启动模板</h2><ul><li>AbpHelper</li><li>模块安装</li></ul><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>上一篇介绍了ABP的一些基础知识，本篇继续介绍ABP的启动模板。使用ABP CLI命令就可以得到这个启动模板，其中包含了一些基础功能模块，你可以基于这个模板来快速开发。</p><h3 id="开始-1"><a href="#开始-1" class="headerlink" title="开始"></a>开始</h3><p>首先ABP CLI的安装以及基本指令这些就不说了，官网上写的很清楚。目前ABP的前端部分只支持ASP.NET Core MVC / Razor Pages和Angular，移动端支持React Native。</p><p>初学者建议跟着官网<a href="https://docs.abp.io/zh-Hans/abp/latest/Tutorials/Part-1?UI=MVC%E8%BF%99%E4%B8%AA%E6%8C%87%E5%BC%95%E5%81%9A%E4%B8%80%E9%81%8D%EF%BC%8C%E4%BD%93%E9%AA%8C%E4%B8%80%E4%B8%8BABP%E5%BC%80%E5%8F%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%EF%BC%8C%E8%99%BD%E7%84%B6ABP%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%87%A0%E4%B9%8E%E9%83%BD%E6%A0%87%E5%87%86%E5%8C%96%E4%BA%86%EF%BC%8C%E7%85%A7%E7%9D%80%E5%AE%98%E7%BD%91%E7%9A%84%E6%B5%81%E7%A8%8B%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%E5%B0%B1%E8%83%BD%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E7%9A%84%E5%BC%80%E5%8F%91%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E6%9C%89%E4%BA%9B%E7%B9%81%E7%90%90%EF%BC%8C%E5%AE%B9%E6%98%93%E5%87%BA%E9%94%99%E3%80%82%E8%BF%99%E9%87%8C%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%9Ahttps://github.com/EasyAbp/AbpHelper.GUI%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AAABP%E5%B8%AE%E5%8A%A9%E5%B7%A5%E5%85%B7%EF%BC%8C%E4%BD%A0%E5%8F%AA%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%EF%BC%8C%E5%89%A9%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%83%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%B8%AE%E4%BD%A0%E7%94%9F%E6%88%90%E3%80%82%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%98%AFhttps://github.com/EasyAbp%E4%B8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AD%90%E9%A1%B9%E7%9B%AE%EF%BC%8CEasyAbp%E6%98%AF%E5%9B%BD%E5%86%85ABP%E7%88%B1%E5%A5%BD%E8%80%85%E5%88%9B%E5%BB%BA%E7%9A%84%EF%BC%8C%E9%87%8C%E9%9D%A2%E8%BF%98%E6%9C%89%E5%BE%88%E5%A4%9A%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%85%B3%E6%B3%A8%E4%B8%80%E4%B8%8B%E3%80%82%E3%80%82%E3%80%82">https://docs.abp.io/zh-Hans/abp/latest/Tutorials/Part-1?UI=MVC这个指引做一遍，体验一下ABP开发的基本流程，虽然ABP开发流程几乎都标准化了，照着官网的流程编写代码就能完成一个功能的开发，但是这个过程有些繁琐，容易出错。这里推荐一个开源项目：https://github.com/EasyAbp/AbpHelper.GUI，这是一个ABP帮助工具，你只需要创建一个实体，剩下的代码它都可以帮你生成。这个项目是https://github.com/EasyAbp下的一个子项目，EasyAbp是国内ABP爱好者创建的，里面还有很多开箱即用的模块，可以关注一下。。。</a></p><h3 id="AbpHelper"><a href="#AbpHelper" class="headerlink" title="AbpHelper"></a>AbpHelper</h3><p>使用AbpHelper来完成官网的例子非常容易，首先创建项目解决方案：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWNodWFmSDBBY0pwWEh6ZGxWTE5wSmJKU2ZYSG5qRGRLY1lnRWF2RDNYMENyYXZtT25Kc0xVOFEvNjQw?x-oss-process=image/format,png" alt="img"> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWNVVEJMblpoOFdHaFpBYlBlQ0IxbmY4U1R0ZmFvMTFqaWNUOHlLdnIyaFY2UnpyNGUyQXJuVG1BLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>AbpHelper提供了图形化配置，自动帮我们执行ABP CLI指令：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWNvYUZ3ZVdOdnNJeDlReXdwcFNlN1lURzY2dXpuOEthMkZUaWEzalpsYTAxdFliUTJPdTNHckpRLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>执行完成后，打开解决方案，先启动Acme.BookStore.DbMigrator项目来初始化数据库：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWNLWW01UUVkUFJlTng0QmhHZ3VqeFY3N2p1ZDJYdlBwM0hwa2I3U1ZhUEZhaWFUZ0tpYUdqRm5ady82NDA?x-oss-process=image/format,png" alt="img"> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWNDbVJ6Z1NCaGZESDMzWVZaYWRXeVBYajVSdmRhMGZhMWFHaWMyc2F3U01BeE1JMlpXSkNpYmlhb2cvNjQw?x-oss-process=image/format,png" alt="img"> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWM4TUVCbnN1NlZHUGVHR2liZDJUejB2SXVLcHIwRDl2b1pNendmN05rWHczWUJKTDJzaEJqR1d3LzY0MA?x-oss-process=image/format,png" alt="img"></p><p>然后就可以启动Acme.BookStore.Web项目，这是APB启动模板的默认界面：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWNFWUZJVFVrYTRRWENZR1hncGdTZW9YSWpJNW1rOVpmWlZjSVZRWWRsZjN6eXJkS1ppY3VqOFBBLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>接下来，在Acme.BookStore.Domain项目中创建Book实体，我直接从官网上复制代码。</p><pre class=" language-go"><code class="language-go">public class Book <span class="token punctuation">:</span> AuditedAggregateRoot<span class="token operator">&lt;</span>Guid<span class="token operator">></span><span class="token punctuation">{</span>    public <span class="token builtin">string</span> Name <span class="token punctuation">{</span> get<span class="token punctuation">;</span> set<span class="token punctuation">;</span> <span class="token punctuation">}</span>     public BookType Type <span class="token punctuation">{</span> get<span class="token punctuation">;</span> set<span class="token punctuation">;</span> <span class="token punctuation">}</span>     public DateTime PublishDate <span class="token punctuation">{</span> get<span class="token punctuation">;</span> set<span class="token punctuation">;</span> <span class="token punctuation">}</span>     public float Price <span class="token punctuation">{</span> get<span class="token punctuation">;</span> set<span class="token punctuation">;</span> <span class="token punctuation">}</span>     protected <span class="token function">Book</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    public <span class="token function">Book</span><span class="token punctuation">(</span>Guid id<span class="token punctuation">,</span> <span class="token builtin">string</span> name<span class="token punctuation">,</span> BookType <span class="token keyword">type</span><span class="token punctuation">,</span> DateTime publishDate<span class="token punctuation">,</span> float price<span class="token punctuation">)</span>        <span class="token punctuation">:</span> <span class="token function">base</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Name <span class="token operator">=</span> name<span class="token punctuation">;</span>        Type <span class="token operator">=</span> <span class="token keyword">type</span><span class="token punctuation">;</span>        PublishDate <span class="token operator">=</span> publishDate<span class="token punctuation">;</span>        Price <span class="token operator">=</span> price<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在Acme.BookStore.Domain.Shared项目中添加枚举类BookType：</p><pre class=" language-go"><code class="language-go">public enum BookType<span class="token punctuation">{</span>    Undefined<span class="token punctuation">,</span>    Adventure<span class="token punctuation">,</span>    Biography<span class="token punctuation">,</span>    Dystopia<span class="token punctuation">,</span>    Fantastic<span class="token punctuation">,</span>    Horror<span class="token punctuation">,</span>    Science<span class="token punctuation">,</span>    ScienceFiction<span class="token punctuation">,</span>    Poetry<span class="token punctuation">}</span></code></pre><p>第一次使用需要安装一下AbpHelper CLI：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWMzaG1LNVVzSFAwekRmd3l4VzkwMEpuRFJUYVhIM21Ua2Z1YTRibWtxMmxjWGRqSDBnNTI4WHcvNjQw?x-oss-process=image/format,png" alt="img"></p><p>选择Generate CRUD，填入实体名称和解决方案路径，然后Execute即可：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWNXMWljVGQ2ZlI0RGxFeDdJVFlLaWFlaWF3Y3ZDR2V2WkdaN3VoUkJ0UDVlWWF2amFHak1XMEpKV2cvNjQw?x-oss-process=image/format,png" alt="img"></p><p>生成代码时可能会报这个错（如果没装ef tools）：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWNYdEVjYmc5TDNJSDc0TlFxOGt6RlA1bU84RVB2a2VMUlV6OW9mUXRIcUJ3NWliUkNrSGliZGhtZy82NDA?x-oss-process=image/format,png" alt="img"></p><p>这时安装一下ef tools就好了，<code>dotnet tool install -g dotnet-ef</code></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWNQS0dpYkppY2p0Mzl2R293cmZ2d2FpYTR1eWlhZGZQNDQ3U20yVk1tRDE3U3ZINW1WQTVBaWJacW9IQS82NDA?x-oss-process=image/format,png" alt="img"></p><p>代码生成完后，运行Acme.BookStore.Web项目：</p><p>使用默认用户 admin/1q2w3E* 登录系统，给admin角色分配BookStore相关权限：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWNEOXVadVF4bVZpYlNHVExDc2s2bENkTlNCY0RXRVk5RTdZNU0zWTdpYTNhODBtS1NhaWNqbmpiUGcvNjQw?x-oss-process=image/format,png" alt="img"></p><p>然后就可以看到book菜单了，包括基本的增删改查界面：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWMzTUZrb3lpY2VOWkhQcEF5Q1JjMmczdFRUdnNsa3h4UFhpYkRTSHdWblI0anRHcHpsZjhvRk1SQS82NDA?x-oss-process=image/format,png" alt="img"></p><p>至此就完成了一个基本功能的开发，AbpHelper确实很方便，他还有CLI版本，直接命令行操作。</p><h3 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h3><p>ABP的模块化可以实现插件式的开发，你可以预先构建一些通用的模块，比如日志模块，用户模块等等，当你以后需要时就可以直接安装到项目中。有一些由ABP社区开发和维护的开源免费的应用程序模块，我们可以直接使用；比如我要使用官方的Blogging模块，Blogging是用于创建精美的博客。</p><p>同样使用AbpHelper来安装：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWNXMURucDVtNkdhZ29Ja2xMWTdSczcwSmNteEVRRmFlTmtJTWp4cGlhalYybFFuZGtOQ09TaWN3dy82NDA?x-oss-process=image/format,png" alt="img"></p><p>安装过程出了点小问题，提示找不到DbContext。。。不过没关系，自己执行一下迁移命令就行。。。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWN4a1lmSGlidk1sQ3MzVzQ1em5XdkZlU2lhWFpPZTFsNEtiUWlhR3FqMFF1aWJZMTZQTzFYdVlPY21RLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>Acme.BookStore.Web项目设为启动项，默认项目为Acme.BookStore.EntityFrameworkCore.DbMigrations，然后执行：</p><pre><code>Add-Migration AddedBloggingUpdate-DataBase</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWN3Nm1URDk3ZXRGbjRRYWFQOThPQ1hOczdsNDYzQlVQVXVndGRjaEVsNW9VYkVmSHRJam9iSncvNjQw?x-oss-process=image/format,png" alt="img"></p><p>接下来再次运行Acme.BookStore.Web项目，为admin角色配置博客相关的权限：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWNRaWNKd0ptUVBFZFZVWFdwSkFhNHNnTUFiaWM5NnhGMnVqYUR6dmxMWE05NjJDdzRpYjBOUmN2c0EvNjQw?x-oss-process=image/format,png" alt="img"></p><p>然后就就可以看到博客的相关功能：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWM0WGVKWWlhMGR0V1pxWDRFeFdJT0oxWk9aQ2t0WlE4cGJqZGdnalhidkg1eWF4UDhaWGxpYTh1US82NDA?x-oss-process=image/format,png" alt="img"></p><p>Swagger：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSW1mTjFSaFRyT2NGQkU5a1ZTU3JIaWNNVlM0TndxMDdVQk9xZWEySHl0OUd3dG1tVlp1a3g1eW5MaWFPRGlieGRKUUdlalpUY2lhak14aWFnLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>当然，这些模块不一定完全符合你的要求，你可能需要稍作修改，ABP也允许你扩展实体，重写服务包括重写用户界面，你可以很方便的修改。这些后面再介绍，包括如何去开发这种模块。。。</p><h2 id="初识ABP-vNext（3）：vue对接ABP基本思路"><a href="#初识ABP-vNext（3）：vue对接ABP基本思路" class="headerlink" title="初识ABP vNext（3）：vue对接ABP基本思路"></a>初识ABP vNext（3）：vue对接ABP基本思路</h2><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png" alt="img"></p><ul><li>登录</li><li>权限</li><li>本地化</li><li>创建项目</li><li><ul><li>ABP</li><li>vue-element-admin</li></ul></li></ul><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>上一篇介绍了ABP的启动模板以及AbpHelper工具的基本使用，这一篇将进入项目实战部分。因为目前ABP的官方模板只支持MVC和Angular，MVC的话咱.NET开发人员来写还可以，专业前端估计很少会用这个。。。Angular我本人不熟，所以选择vue来做UI。</p><h3 id="开始-2"><a href="#开始-2" class="headerlink" title="开始"></a>开始</h3><p>我使用vue-element-admin[1]来作为模板，这个项目貌似很多人用，选择他的i18n[2]分支，因为我需要国际化功能。在开始编码前，需要先分析几个重要问题：</p><ul><li>用户登录/token</li><li>用户权限控制</li><li>应用程序本地化/语言切换</li></ul><p>好在ABP模板提供了Angular版本，我们可以参考Angular版本来做。</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>因为ABP的授权模块是使用IdentityServer4，所以IdentityServer4的一些默认端点在ABP里也是同样有效的，可以参考下IdentityServer4官网[3]。运行ABP模板项目，看一下IdentityServer4发现文档，uri是：<code>/.well-known/openid-configuration</code></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszTDdKSm53cHFDOXpLUERlTWliWmNxZDViaWEySDhWTjNoVlF2Y3ppY0lKcnl4c1k0VkFzcU9udWNVVWlhNTNmZWJvQjZjbmVxU0hpYVNSaWN3QS82NDA?x-oss-process=image/format,png" alt="img"></p><p>可以看到token端点是<code>/connect/token</code>，这是IdentityServer4默认的，通过这个端点就可以登录用户获取token。后面请求接口时，把token放到HTTP Header的authorization字段即可。</p><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>进入ABP的<code>/swagger</code>界面：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszTDdKSm53cHFDOXpLUERlTWliWmNxZDVHWGlheG92NDBoaWNvQjNabGRzYVB5OEpyOE9tWGpuV0tyTUQ3bVVvZGtPVEcwak1oTFAxSkRhZy82NDA?x-oss-process=image/format,png" alt="img"></p><p>ABP内置了一个<code>/api/abp/application-configuration</code>接口，它用于返回本地化文本，权限和一些系统设置信息。看一下数据格式：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszTDdKSm53cHFDOXpLUERlTWliWmNxZDVYTTBnSTZhTzFRbmFNZzNhcWN5ZFhORTlpYWtMNEtQWE0zY250c2p5RlVXbjFqVkVyNnRuektnLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>在<strong>auth.policies</strong>字段中包含了系统的所有权限，<strong>auth.grantedPolicies</strong>字段则包含了当前用户所拥有的权限，因为我现在没登录所以是空的。通过这两个字段就可以和vue-element-admin的菜单权限对应起来，实现权限控制。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszTDdKSm53cHFDOXpLUERlTWliWmNxZDVweVFTRzMyd0tQOGdQcmZOMW1YOERyY0xkUjlpY1hOeVRqaWIyN2ljc0F6WUVBNXF0eWxvOE01M3cvNjQw?x-oss-process=image/format,png" alt="img"></p><p><strong>currentUser</strong>字段表示当前用户信息，没登录时就是空的，<strong>isAuthenticated</strong>为false，这个字段也可以作为用户是否登录（token是否有效）的判断依据。</p><h3 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h3><p>本地化对于大部分的小型系统可能都用不上，不过ABP作为一个优秀且全面的框架，必然会支持本地化功能。同样的，本地化信息也可以通过<code>/api/abp/application-configuration</code>接口来获取：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszTDdKSm53cHFDOXpLUERlTWliWmNxZDVyTlM3NHd2UHpicGNOZnYwQTJaWjFYSDNnZ3U1anFhQWZCMm5wQXNGWWljRkx2TURlSnpjQ0h3LzY0MA?x-oss-process=image/format,png" alt="img"></p><p><strong>localization.languages</strong>字段表示系统所支持的语言类型，前端的语言切换选项就可以使用这个字段。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszTDdKSm53cHFDOXpLUERlTWliWmNxZDVLeGliUHpucXJGenByOXRKVjBhVzdDQmY3SjZuV09aRU5QNFpualhNUHUwRnVpY0pSaWNZSnM3d1EvNjQw?x-oss-process=image/format,png" alt="img"></p><p><strong>localization.values</strong>字段就是本地化的文本信息了，你在后端配置的本地化文本都可以从这里获取到，通过这个字段结合vue-element-admin的国际化功能，就可以让你的系统支持多语言。vue-element-admin的国际化方案是通过 vue-i18n[4]来实现，你也可以直接在前端部分来做国际化，如果你只有一个前端应用的话，但是在后端做复用性更好一些。</p><p>语言切换时只需要把对应的语言名称放到HTTP Header的accept-language字段就行。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在开始编码前，先创建好前后端的模板项目。</p><p>ABP</p><p>这里直接用Abp CLI命令来创建解决方案吧：</p><pre class=" language-go"><code class="language-go">abp <span class="token builtin">new</span> <span class="token string">"Xhznl.HelloAbp"</span><span class="token operator">-</span>t app<span class="token operator">-</span>u none <span class="token operator">--</span>separate<span class="token operator">-</span>identity<span class="token operator">-</span>server<span class="token operator">-</span>m none<span class="token operator">-</span>d ef <span class="token operator">-</span>cs <span class="token string">"Server=localhost;User Id=sa;Password=Password@2020;Database=HelloAbp;MultipleActiveResultSets=true"</span></code></pre><p>创建一个名为”Xhznl.HelloAbp”的解决方案，使用app作为模板，不需要UI，并且将Identity Server应用程序与API host应用程序分开，使用Entity Framework Core作为数据库提供程序，并指定连接字符串。创建完成后会得到一个aspnet-core文件夹。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszTDdKSm53cHFDOXpLUERlTWliWmNxZDV3aWI5cVdhZnJraEJyR3ExNDl1QVJ2NG82WmhMVnNRRzhLdFkwNUxzREc1QTlaUG5LZmRqdmtBLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>项目结构如下，因为指定了<code>--separate-identity-server</code>参数，所以多了个IdentityServer项目，如果不指定的话它是集成在HttpApi.Host中的。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszTDdKSm53cHFDOXpLUERlTWliWmNxZDU2YzVEWmlhRnRpY0hiNkNpYWpEczNWTnB2bG5pY2N4Y01OeHN2RGljenJMUXdqSjdKWUZVTTJ4Ykx6QS82NDA?x-oss-process=image/format,png" alt="img"></p><p>通常小型系统没必要把Identity Server应用程序与API host应用程序分开，会增加运维成本，这里只是为了演示分布式部署的情况，为后面的微服务做准备。</p><p>ABP还支持为每个模块单独配置数据库（如果你不需要分库，可以忽略以下内容），修改DbMigrator、IdentityServer项目的appsettings.json配置文件：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszTDdKSm53cHFDOXpLUERlTWliWmNxZDV6WWljNWRJRzllS2w1c2w5MTBLTE14dFBjYmMyQVpxamdSblVGRXdzM1F4M3BkblJBNkJOTEtnLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>在ConnectionStrings中添加AbpIdentityServer配置，为Identity Server配置独立的数据库连接字符串，不配置的话默认使用Default配置。AbpIdentityServer这个key是来自ABP的IdentityServer模块中的一个常量，具体请参考源码。</p><p>在开发环境光定义连接字符串还不够，因为HelloAbpIdsDB数据库还不存在，需要使用EF Core Code Frist迁移系统创建和维护这个数据库。新建一个项目：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszTDdKSm53cHFDOXpLUERlTWliWmNxZDV4Z1BkN1FKcUtaQ3FIcTIyblZrN2VhaWNSd0lmUUJnRlNCNXZ5Nm9Rb25uakNJNGVwa3RKMGx3LzY0MA?x-oss-process=image/format,png" alt="img"></p><p>步骤比较多，具体流程请参考官网：数据库迁移[5]，这里就不重复介绍了，你也可以选择不分库。</p><p>完成以上步骤，最终会生成2个数据库，并且包含了一些默认的种子数据。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszTDdKSm53cHFDOXpLUERlTWliWmNxZDU2aWN4aWNhTmJrY1NsQXJraWJuS2ZnTGwzN2VpY0xUdFRmMjBzVmppYUdpYTZ0eFdrcFlRYTJjT1M1VlEvNjQw?x-oss-process=image/format,png" alt="img"></p><p>然后验证一下HttpApi.Host和IdentityServer项目是否可以正常运行，前提是你电脑需要有sqlserver，redis。</p><p>HttpApi.Host：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszTDdKSm53cHFDOXpLUERlTWliWmNxZDV6Q0t2Nmo5cHc2aWN5cFVBdXJPQVBVRndhNDExZmhBaWNDTHFSeWlhT1lvRmRRNXoyVlFaU3pCVkEvNjQw?x-oss-process=image/format,png" alt="img"></p><p>IdentityServer：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszTDdKSm53cHFDOXpLUERlTWliWmNxZDV1REw0eUVMU1hxOEczalNVbWlhWXpQTlJ3anZPVVFmc1FYNW9hWE9ucTlHcVB3aWNzRkVCS0pUQS82NDA?x-oss-process=image/format,png" alt="img"></p><h3 id="vue-element-admin"><a href="#vue-element-admin" class="headerlink" title="vue-element-admin"></a>vue-element-admin</h3><p>vue-element-admin的基本使用就不介绍了，相信很多人见过这个，不了解的可以自己去搜索学习一下。</p><p>去GitHub下载i18n[6]分支的代码，或者直接用git clone命令。</p><p>在项目根目录下执行指令：</p><p>安装依赖：<code>npm install</code></p><p>启动项目：<code>npm run dev</code></p><p>启动正常的话可以看到这个界面：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszTDdKSm53cHFDOXpLUERlTWliWmNxZDVyaWFpYmsyNEZoRGdHd0JvbmZWaktYTVBLbVFPa3pidDlIUXQ1ejRZUUkwb0lnZTNrTkhmajZZUS82NDA?x-oss-process=image/format,png" alt="img"></p><h1 id><a href="#" class="headerlink" title></a></h1><h2 id="初识ABP-vNext（6）：vue-ABP实现国际化"><a href="#初识ABP-vNext（6）：vue-ABP实现国际化" class="headerlink" title="初识ABP vNext（6）：vue+ABP实现国际化"></a>初识ABP vNext（6）：vue+ABP实现国际化</h2><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png" alt="img"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSnNYaWFZWjYya0Yya0VOZFVIMlY3QkRFZnFIMHJoeGxPOUZmMFlzSFlmUDhpYzhRUWdRUnV6bGljMjJta1VrSzZjN2RHT3AwcnNUR2NVUS82NDA?x-oss-process=image/format,png" alt="img"></p><ul><li>语言选项</li><li>语言切换</li><li><ul><li>注意</li></ul></li></ul><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>上一篇介绍了ABP扩展实体，并且在前端部分新增了身份认证管理和租户管理的菜单，在实现这两个功能模块前，先来解决一下界面文字国际化的问题。</p><h3 id="开始-3"><a href="#开始-3" class="headerlink" title="开始"></a>开始</h3><p>国际化（简称 I18N），本地化（简称 L10N）；这两者的目的都是用于让你的应用程序支持多个国家和区域的语言，它们看起来很相似，但是有一些细微的区别，本文不对此进行深入探讨，有兴趣的可以自行搜索。ABP后端支持的是本地化，而vue-element-admin支持的是国际化，使用<strong>vue-i18n</strong>实现；本文默认它两者是一回事。</p><p>前面的章节中，已经大概分析了vue+ABP国际化的实现思路。我们可以在后端实现国际化，然后vue从后端获取国际化文本，展示到界面中；另一种方式是直接在前端部分实现国际化。在前端实现就很简单，直接在vue-element-admin的<code>src\lang\</code>目录下配置相应的文本，然后界面使用i18n的<code>$t()</code>方法渲染就可以了，这个不多做介绍。本文只探讨第一种实现方式。</p><h3 id="语言选项"><a href="#语言选项" class="headerlink" title="语言选项"></a>语言选项</h3><p>首先，语言选项列表需要根据后端配置得到。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSTlLazludlRmY2RMVFNMSXJOUmljVkhFbEVlcEppYzVZelFCYUR6cDlzSUI2MTF0dGgwQzM1bDVrd0dIM2phYW92bnJsOEhSQW1zQTZBLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>在后端修改支持的语言类型，这里就只支持中文和英文2种吧，其他的注释掉。</p><p>src\Xhznl.HelloAbp.HttpApi.Host\HelloAbpHttpApiHostModule.cs：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSTlLazludlRmY2RMVFNMSXJOUmljVkhPSkx6anJUVWlhNUtTaWFYTTJGaWE1R09uWW1kd3dtaWE0QUd6MFJNelJMSWtwR01rMDVJUll0dUVRLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>请求<code>abp/application-configuration</code>接口：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSTlLazludlRmY2RMVFNMSXJOUmljVkhZZll5WnFyZnJLdEE5M1RhaWFrSWEzRXhMSXNvaWJJdUQxN0NsOVB0SHRtclhMR01OaWNkaWJCY0FRLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>此时返回的localization.languages属性只有2个语言了，然后只需要把这个数据绑定到界面上就好了。语言切换用的是一个公共组件 src\components\LangSelect\index.vue：</p><pre class=" language-go"><code class="language-go"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>el<span class="token operator">-</span>dropdown    trigger<span class="token operator">=</span><span class="token string">"click"</span>    class<span class="token operator">=</span><span class="token string">"international"</span>    @command<span class="token operator">=</span><span class="token string">"handleSetLanguage"</span>  <span class="token operator">></span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>svg<span class="token operator">-</span>icon class<span class="token operator">-</span>name<span class="token operator">=</span><span class="token string">"international-icon"</span> icon<span class="token operator">-</span>class<span class="token operator">=</span><span class="token string">"language"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>el<span class="token operator">-</span>dropdown<span class="token operator">-</span>menu slot<span class="token operator">=</span><span class="token string">"dropdown"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>el<span class="token operator">-</span>dropdown<span class="token operator">-</span>item        v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item in languages"</span>        <span class="token punctuation">:</span>key<span class="token operator">=</span><span class="token string">"item.cultureName"</span>        <span class="token punctuation">:</span>disabled<span class="token operator">=</span><span class="token string">"language === item.cultureName"</span>        <span class="token punctuation">:</span>command<span class="token operator">=</span><span class="token string">"item.cultureName"</span>      <span class="token operator">></span>        <span class="token punctuation">{</span><span class="token punctuation">{</span> item<span class="token punctuation">.</span>displayName <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>el<span class="token operator">-</span>dropdown<span class="token operator">-</span>item<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>el<span class="token operator">-</span>dropdown<span class="token operator">-</span>menu<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>el<span class="token operator">-</span>dropdown<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span> <span class="token operator">&lt;</span>script<span class="token operator">></span>export <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      languages<span class="token punctuation">:</span> this<span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>abpConfig<span class="token punctuation">.</span>localization<span class="token punctuation">.</span>languages    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">language</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> this<span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>language<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">handleSetLanguage</span><span class="token punctuation">(</span>lang<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//this.$i18n.locale = lang</span>      this<span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">"app/setLanguage"</span><span class="token punctuation">,</span> lang<span class="token punctuation">)</span><span class="token punctuation">;</span>      this<span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">"app/applicationConfiguration"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        this<span class="token punctuation">.</span>$<span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          message<span class="token punctuation">:</span> <span class="token string">"Switch Language Success"</span><span class="token punctuation">,</span>          <span class="token keyword">type</span><span class="token punctuation">:</span> <span class="token string">"success"</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSTlLazludlRmY2RMVFNMSXJOUmljVkhXdmV3b3ZMYmlhQWNjaWNMSGliSXlCOTNERmU5d1BTa3RxQmtvelI5Y0xxWTNUbkt5WnVjT2ZwMWcvNjQw?x-oss-process=image/format,png" alt="img"></p><h3 id="语言切换"><a href="#语言切换" class="headerlink" title="语言切换"></a>语言切换</h3><p>语言切换时，需要再次调用<code>app/applicationConfiguration</code>接口，更新本地化文本。</p><p>src\utils\request.js：</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// request interceptor</span>service<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>  config <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// do something before request is sent</span>    config<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'accept-language'</span><span class="token punctuation">]</span> <span class="token operator">=</span> store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>language     <span class="token keyword">if</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>token<span class="token punctuation">)</span> <span class="token punctuation">{</span>      config<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'authorization'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Bearer '</span> <span class="token operator">+</span> <span class="token function">getToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> config  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token builtin">error</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// do something with request error</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// for debug</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token builtin">error</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>src\store\modules\app.js：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">{</span>  。。。。。。      <span class="token function">applicationConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token builtin">new</span> <span class="token function">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">applicationConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">const</span> data <span class="token operator">=</span> response<span class="token punctuation">;</span>          <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">"SET_ABPCONFIG"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">const</span> language <span class="token operator">=</span> data<span class="token punctuation">.</span>localization<span class="token punctuation">.</span>currentCulture<span class="token punctuation">.</span>cultureName<span class="token punctuation">;</span>          <span class="token keyword">const</span> values <span class="token operator">=</span> data<span class="token punctuation">.</span>localization<span class="token punctuation">.</span>values<span class="token punctuation">;</span>          <span class="token function">setLocale</span><span class="token punctuation">(</span>language<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token builtin">error</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">reject</span><span class="token punctuation">(</span><span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>src\lang\index.js：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">import</span> Vue from <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> VueI18n from <span class="token string">"vue-i18n"</span><span class="token punctuation">;</span><span class="token keyword">import</span> Cookies from <span class="token string">"js-cookie"</span><span class="token punctuation">;</span><span class="token keyword">import</span> elementEnLocale from <span class="token string">"element-ui/lib/locale/lang/en"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// element-ui lang</span><span class="token keyword">import</span> elementZhLocale from <span class="token string">"element-ui/lib/locale/lang/zh-CN"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// element-ui lang</span> Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueI18n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">const</span> messages <span class="token operator">=</span> <span class="token punctuation">{</span>  en<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>elementEnLocale  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"zh-Hans"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>elementZhLocale  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span> export function <span class="token function">getLanguage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> chooseLanguage <span class="token operator">=</span> Cookies<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"language"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>chooseLanguage<span class="token punctuation">)</span> <span class="token keyword">return</span> chooseLanguage<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// if has not choose language</span>  <span class="token keyword">const</span> language <span class="token operator">=</span> <span class="token punctuation">(</span>    navigator<span class="token punctuation">.</span>language <span class="token operator">||</span> navigator<span class="token punctuation">.</span>browserLanguage  <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> locales <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>messages<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> locale of locales<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>language<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>locale<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> locale<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token string">"en"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>export function <span class="token function">setLocale</span><span class="token punctuation">(</span>language<span class="token punctuation">,</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>  i18n<span class="token punctuation">.</span><span class="token function">mergeLocaleMessage</span><span class="token punctuation">(</span>language<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">;</span>  i18n<span class="token punctuation">.</span>locale <span class="token operator">=</span> language<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> i18n <span class="token operator">=</span> <span class="token builtin">new</span> <span class="token function">VueI18n</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// set locale</span>  <span class="token comment" spellcheck="true">// options: en | zh | es</span>  locale<span class="token punctuation">:</span> <span class="token function">getLanguage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// set locale messages</span>  messages<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> export <span class="token keyword">default</span> i18n<span class="token punctuation">;</span></code></pre><p>将后端返回的文本设置到vue-i18n中，就可以使用了。这跟直接在前端做国际化有一点区别就是，后者的文本信息是写在前端，vue-i18n可以直接使用。而这里只是把文本信息改到后端，从后端获取后再设置到i18n中，本质是一样的。</p><p>修改后端的配置文本：</p><p>src\Xhznl.HelloAbp.Domain.Shared\Localization\HelloAbp\zh-Hans.json：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSTlLazludlRmY2RMVFNMSXJOUmljVkhFRENwTFJrZlBGczBLRG1xTlp5VVFScU1TVFhpY1NUUm01N2ZKTTVZQUo1eWlibnJIQTFpYjlVb1EvNjQw?x-oss-process=image/format,png" alt="img"></p><p>src\Xhznl.HelloAbp.Domain.Shared\Localization\HelloAbp\en.json：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSTlLazludlRmY2RMVFNMSXJOUmljVkhOaWN0R0x6eUlPaWNmTXNJMWxQMDRqaWFDbGljcXlvNno3Mjl3cWd1R2VBeU11bERZaWJJMHZUV29ydy82NDA?x-oss-process=image/format,png" alt="img"></p><p>localization.values返回：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSTlLazludlRmY2RMVFNMSXJOUmljVkhZYmIwUHJvbjlFbXQzTVVsdUZ6OUJlWHFIYnpZREFjRTJJVkhUb0FuSURvWURHTk1WSHlJTHcvNjQw?x-oss-process=image/format,png" alt="img"></p><p>接下来只需要把界面上对应的文本使用vue-i18n的<code>$t()</code>方法渲染就好了，比如：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSTlLazludlRmY2RMVFNMSXJOUmljVkhoelRuOHZiMTl1ZHp5ZmRUaE03cFhiazA1WGliaFRpYlRZeUVqeTFJY0xDZ2FaVVFBMGpUUFo4QS82NDA?x-oss-process=image/format,png" alt="img"></p><p>前端需要改动的地方比较多，但都是类似的修改。。。直接看效果：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSTlLazludlRmY2RMVFNMSXJOUmljVkhKZGZMQmlicWJpYTRXWk1lTUpyQVNaYXRyd1k1MDhBWk9mcVFUaWNtajRpYkYwb0hCeExwQm41UU1nLzY0MA?x-oss-process=image/format,png" alt="img"> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSTlLazludlRmY2RMVFNMSXJOUmljVkg2ekFzejY5ZnVyckxpYVZCS0xWZ0tlZ2hpYnNhQmYzQVRIdU00cDlZTE1tQTdUeDBCdTBGRzlxZy82NDA?x-oss-process=image/format,png" alt="img"> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9jSko0amU1TmszSTlLazludlRmY2RMVFNMSXJOUmljVkg2U212eVhHWjNzTU1DaWJINzR5dUVUa2lhSGZXVXZmeWhGM2NzeER3bEJLQWVNRGJtNHBwWmhIUS82NDA?x-oss-process=image/format,png" alt="img"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>因为<code>app/applicationConfiguration</code>接口只有在刷新页面、登录、退出、切换语言等操作的时候才会去调用，所以不用担心请求频繁。</p><p>其实上面有一部分本地化文本还是放在了前端：ElementUI自带的文本。因为ABP的本地化json格式只能有一级，key/value：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSTlLazludlRmY2RMVFNMSXJOUmljVkhqeWljZzExbkhRUXh6YjhpYTFyZ3NZRFMxUjFpYzExM2xyVWJhcE4zdk9sdEZ1SUlhaWNMWWMxRzZnLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>文本只能写在texts属性中，key/value形式，不支持多层级。</p><p>而vue-i18n是支持多层级的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSTlLazludlRmY2RMVFNMSXJOUmljVkh6bWlhRDN4Ymc1QVRPUHNWRlp2UkRGWkEyM0lieTlUSUFIWlZEOHNDN3VDbkVQWEFjVjNSWUZ3LzY0MA?x-oss-process=image/format,png" alt="img"></p><p>所以ElementUI的这部分文本还是放在前端了。</p><h1 id="初识ABP-vNext（9）：ABP模块化开发-文件管理"><a href="#初识ABP-vNext（9）：ABP模块化开发-文件管理" class="headerlink" title="初识ABP vNext（9）：ABP模块化开发-文件管理"></a>初识ABP vNext（9）：ABP模块化开发-文件管理</h1><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png" alt="img"></p><h3 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h3><p>在之前的章节中介绍过ABP扩展实体，当时在用户表扩展了用户头像字段，用户头像就涉及到文件上传和文件存储。文件上传是很多系统都会涉及到的一个基础功能，在ABP的模块化思路下，文件管理可以做成一个通用的模块，便于以后在多个项目中复用。单纯实现一个文件上传的功能并不复杂，本文就借着这个简单的功能来介绍一下ABP模块化开发的最基本步骤。</p><h3 id="开始-4"><a href="#开始-4" class="headerlink" title="开始"></a>开始</h3><h4 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h4><p>首先使用ABP CLI创建一个模块：<code>abp new Xhznl.FileManagement -t module --no-ui</code></p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200910172558639-780117902.png" alt="img"></p><p>创建完成后会得到如下文件：</p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200910172811988-1656283782.png" alt="img"></p><p>在主项目中添加对应模块的引用，Application=&gt;Application，Domain=&gt;Domain，HttpApi=&gt;HttpApi 等等。例如：</p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200910174159657-385790504.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200910174252923-1500539398.png" alt="img"></p><p>需要添加引用的项目：Application、Application.Contracts、Domain、Domain.Shared、EntityFrameworkCore、HttpApi、HttpApi.Client</p><p>手动添加这些引用比较麻烦，你可以搭建自己的私有NuGet服务器，把模块的包发布到私有NuGet上，然后通过NuGet来安装引用。两种方式各有优缺点，具体请参考<a href="https://docs.abp.io/zh-Hans/abp/latest/Customizing-Application-Modules-Guide">自定义现有模块</a>，关于私有NuGet搭建可以参考：<a href="https://www.cnblogs.com/xhznl/p/13426918.html">十分钟搭建自己的私有NuGet服务器-BaGet</a>。</p><p>然后给这些项目的模块类添加对应的依赖，例如：</p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200910194927720-1698177383.png" alt="img"></p><p>通过上面的方式引用模块，使用visual studio是无法编译通过的：</p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200910174502648-1014353291.png" alt="img"></p><p>需要在解决方案目录下，手动执行<code>dotnet restore</code>命令即可：</p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200910175401258-1508422500.png" alt="img"></p><h3 id="模块开发"><a href="#模块开发" class="headerlink" title="模块开发"></a>模块开发</h3><p>接下来关于文件管理功能的开发，都在模块Xhznl.FileManagement中进行，它是一个独立的解决方案。初学ABP，下面就以尽量简单的方式来实现这个模块。</p><h3 id="应用服务"><a href="#应用服务" class="headerlink" title="应用服务"></a>应用服务</h3><p>模块开发通常从Domain层实体建立开始，但是这里先跳过。先在FileManagement.Application.Contracts项目添加应用服务接口和Dto。</p><p>modules\file-management\src\Xhznl.FileManagement.Application.Contracts\Files\IFileAppService.cs：</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IFileAppService</span> <span class="token punctuation">:</span> IApplicationService<span class="token punctuation">{</span>    Task<span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">GetAsync</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>     Task<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span> <span class="token function">CreateAsync</span><span class="token punctuation">(</span>FileUploadInputDto input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>modules\file-management\src\Xhznl.FileManagement.Application.Contracts\Files\FileUploadInputDto.cs：</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileUploadInputDto</span><span class="token punctuation">{</span>    <span class="token punctuation">[</span>Required<span class="token punctuation">]</span>    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> Bytes <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token punctuation">[</span>Required<span class="token punctuation">]</span>    <span class="token keyword">public</span> <span class="token keyword">string</span> Name <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后是FileManagement.Application项目，实现应用服务，先定义一个配置类。</p><p>modules\file-management\src\Xhznl.FileManagement.Application\Files\FileOptions.cs：</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileOptions</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 文件上传目录</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">public</span> <span class="token keyword">string</span> FileUploadLocalFolder <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 允许的文件最大大小</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">public</span> <span class="token keyword">long</span> MaxFileSize <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token number">1048576</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1MB</span>     <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 允许的文件类型</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">public</span> <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> AllowedUploadFormats <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">".jpg"</span><span class="token punctuation">,</span> <span class="token string">".jpeg"</span><span class="token punctuation">,</span> <span class="token string">".png"</span><span class="token punctuation">,</span> <span class="token string">"gif"</span><span class="token punctuation">,</span> <span class="token string">".txt"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>modules\file-management\src\Xhznl.FileManagement.Application\Files\FileAppService.cs：</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileAppService</span> <span class="token punctuation">:</span> FileManagementAppService<span class="token punctuation">,</span> IFileAppService<span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">readonly</span> FileOptions _fileOptions<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token function">FileAppService</span><span class="token punctuation">(</span>IOptions<span class="token operator">&lt;</span>FileOptions<span class="token operator">></span> fileOptions<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        _fileOptions <span class="token operator">=</span> fileOptions<span class="token punctuation">.</span>Value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> Task<span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">GetAsync</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Check<span class="token punctuation">.</span><span class="token function">NotNullOrWhiteSpace</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token function">nameof</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">var</span> filePath <span class="token operator">=</span> Path<span class="token punctuation">.</span><span class="token function">Combine</span><span class="token punctuation">(</span>_fileOptions<span class="token punctuation">.</span>FileUploadLocalFolder<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>File<span class="token punctuation">.</span><span class="token function">Exists</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> Task<span class="token punctuation">.</span><span class="token function">FromResult</span><span class="token punctuation">(</span>File<span class="token punctuation">.</span><span class="token function">ReadAllBytes</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">return</span> Task<span class="token punctuation">.</span><span class="token function">FromResult</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token punctuation">[</span>Authorize<span class="token punctuation">]</span>    <span class="token keyword">public</span> Task<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span> <span class="token function">CreateAsync</span><span class="token punctuation">(</span>FileUploadInputDto input<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span>Bytes<span class="token punctuation">.</span><span class="token function">IsNullOrEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AbpValidationException</span><span class="token punctuation">(</span><span class="token string">"Bytes can not be null or empty!"</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>ValidationResult<span class="token operator">></span>                <span class="token punctuation">{</span>                    <span class="token keyword">new</span> <span class="token class-name">ValidationResult</span><span class="token punctuation">(</span><span class="token string">"Bytes can not be null or empty!"</span><span class="token punctuation">,</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">"Bytes"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span>Bytes<span class="token punctuation">.</span>Length <span class="token operator">></span> _fileOptions<span class="token punctuation">.</span>MaxFileSize<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UserFriendlyException</span><span class="token punctuation">(</span>$<span class="token string">"File exceeds the maximum upload size ({_fileOptions.MaxFileSize / 1024 / 1024} MB)!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_fileOptions<span class="token punctuation">.</span>AllowedUploadFormats<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>Path<span class="token punctuation">.</span><span class="token function">GetExtension</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UserFriendlyException</span><span class="token punctuation">(</span><span class="token string">"Not a valid file format!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">var</span> fileName <span class="token operator">=</span> Guid<span class="token punctuation">.</span><span class="token function">NewGuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token string">"N"</span><span class="token punctuation">)</span> <span class="token operator">+</span> Path<span class="token punctuation">.</span><span class="token function">GetExtension</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> filePath <span class="token operator">=</span> Path<span class="token punctuation">.</span><span class="token function">Combine</span><span class="token punctuation">(</span>_fileOptions<span class="token punctuation">.</span>FileUploadLocalFolder<span class="token punctuation">,</span> fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Directory<span class="token punctuation">.</span><span class="token function">Exists</span><span class="token punctuation">(</span>_fileOptions<span class="token punctuation">.</span>FileUploadLocalFolder<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Directory<span class="token punctuation">.</span><span class="token function">CreateDirectory</span><span class="token punctuation">(</span>_fileOptions<span class="token punctuation">.</span>FileUploadLocalFolder<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         File<span class="token punctuation">.</span><span class="token function">WriteAllBytes</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> input<span class="token punctuation">.</span>Bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> Task<span class="token punctuation">.</span><span class="token function">FromResult</span><span class="token punctuation">(</span><span class="token string">"/api/file-management/files/"</span> <span class="token operator">+</span> fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>服务实现很简单，就是基于本地文件系统的读写操作。</p><p>下面是FileManagement.HttpApi项目，添加控制器，暴露服务API接口。</p><p>modules\file-management\src\Xhznl.FileManagement.HttpApi\Files\FileController.cs：</p><pre class=" language-csharp"><code class="language-csharp"><span class="token punctuation">[</span>RemoteService<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token function">Route</span><span class="token punctuation">(</span><span class="token string">"api/file-management/files"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileController</span> <span class="token punctuation">:</span> FileManagementController<span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">readonly</span> IFileAppService _fileAppService<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token function">FileController</span><span class="token punctuation">(</span>IFileAppService fileAppService<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        _fileAppService <span class="token operator">=</span> fileAppService<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token punctuation">[</span>HttpGet<span class="token punctuation">]</span>    <span class="token punctuation">[</span><span class="token function">Route</span><span class="token punctuation">(</span><span class="token string">"{name}"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>FileResult<span class="token operator">></span> <span class="token function">GetAsync</span><span class="token punctuation">(</span><span class="token keyword">string</span> name<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">var</span> bytes <span class="token operator">=</span> <span class="token keyword">await</span> _fileAppService<span class="token punctuation">.</span><span class="token function">GetAsync</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">File</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> MimeTypes<span class="token punctuation">.</span><span class="token function">GetByExtension</span><span class="token punctuation">(</span>Path<span class="token punctuation">.</span><span class="token function">GetExtension</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token punctuation">[</span>HttpPost<span class="token punctuation">]</span>    <span class="token punctuation">[</span><span class="token function">Route</span><span class="token punctuation">(</span><span class="token string">"upload"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token punctuation">[</span>Authorize<span class="token punctuation">]</span>    <span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>JsonResult<span class="token operator">></span> <span class="token function">CreateAsync</span><span class="token punctuation">(</span>IFormFile file<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>file <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UserFriendlyException</span><span class="token punctuation">(</span><span class="token string">"No file found!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">var</span> bytes <span class="token operator">=</span> <span class="token keyword">await</span> file<span class="token punctuation">.</span><span class="token function">GetAllBytesAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">await</span> _fileAppService<span class="token punctuation">.</span><span class="token function">CreateAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileUploadInputDto</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Bytes <span class="token operator">=</span> bytes<span class="token punctuation">,</span>            Name <span class="token operator">=</span> file<span class="token punctuation">.</span>FileName        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">Json</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h3 id="运行模块"><a href="#运行模块" class="headerlink" title="运行模块"></a>运行模块</h3><p>ABP的模板是可以独立运行的，在FileManagement.HttpApi.Host项目的模块类FileManagementHttpApiHostModule配置FileOptions：</p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200911132722192-254591885.png" alt="img"></p><p>修改FileManagement.HttpApi.Host和FileManagement.IdentityServer项目的数据库连接配置，然后启动这2个项目，不出意外的话可以看到如下界面。</p><p>FileManagement.HttpApi.Host：</p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200911133218273-1796636936.png" alt="img"></p><p>FileManagement.IdentityServer：</p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200911133231215-1422063602.png" alt="img"></p><p>现在你可以使用postman来测试一下File的2个API，当然也可以编写单元测试。</p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200911135241123-1212104739.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200911135304435-1298819144.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200911135517597-557954077.png" alt="img"></p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>更好的方法是编写单元测试，关于如何做好单元测试可以参考ABP源码，下面只做一个简单示例：</p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200911140231014-126474242.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200911140410237-1879670126.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200911140453574-1542444913.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200911140605769-598857386.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200911140922024-290909767.png" alt="img"></p><h3 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h3><p>模块测试通过后，回到主项目。模块引用，模块依赖前面都已经做好了，现在只需配置一下FileOptions，就可以使用了。</p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200911144501836-1823056167.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/610959/202009/610959-20200911144331274-1016096113.png" alt="img"></p><p>目前FileManagement.Domain、FileManagement.Domain.Shared、FileManagement.EntityFrameworkCore这几个项目暂时没用到，项目结构也不是固定的，可以根据自己实际情况来调整。</p><h1 id="初识ABP-vNext（10）：ABP设置管理"><a href="#初识ABP-vNext（10）：ABP设置管理" class="headerlink" title="初识ABP vNext（10）：ABP设置管理"></a>初识ABP vNext（10）：ABP设置管理</h1><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png" alt="img"></p><h3 id="前言-5"><a href="#前言-5" class="headerlink" title="前言"></a>前言</h3><p>上一篇介绍了ABP模块化开发的基本步骤，完成了一个简单的文件上传功能。通常的模块都有一些自己的配置信息，比如上篇讲到的<code>FileOptions</code>类，其中配置了文件的上传目录，允许的文件大小和允许的文件类型。配置信息可以通过Configuration[1]（配置）和Options[2]（选项）来完成，ABP还提供了另一种更灵活的方式：Settings[3]（设置），本篇就来介绍一下ABP的设置管理。</p><h3 id="开始-5"><a href="#开始-5" class="headerlink" title="开始"></a>开始</h3><p>回顾一下上篇的<code>FileOptions</code>：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSjFRd28yY3NRQzBpYzJpYUNNNld5RmF0aG0zZmpFRXJGNU1ZZW41VFVoSnJ1S05SZHc3eG5XRHI2SEs4N3dsa3V6RGhuRHBDTW84ckVnLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>首先定义了一个<code>FileOptions</code>类，其中包含了几个配置，然后在需要的地方中注入<code>IOptions&lt;FileOptions&gt;</code>就可以使用这些信息了。</p><p>当然，模块启动时可以做一些配置修改，比如：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSjFRd28yY3NRQzBpYzJpYUNNNld5RmF0dExTQ3FJd1p1V1pXS2liYnJ0ekJyU1BhdkZYaWNpYW9nUWw1TENub0Z2MjNiZjBhTkVoSTYxazJnLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>无论是配置文件还是这种代码形式的配置，都是程序层面的修改；有些配置不太适合这样做，比如这里的<code>AllowedMaxFileSize</code>和<code>AllowedUploadFormats</code>，它们应该在应用界面上，可以让管理员自行修改。下面就来改造一下程序。</p><h3 id="定义设置"><a href="#定义设置" class="headerlink" title="定义设置"></a>定义设置</h3><p>使用设置之前需要先定义它，不同的模块可以拥有不同的设置。</p><p>modules\file-management\src\Xhznl.FileManagement.Domain\Settings\FileManagementSettingDefinitionProvider.cs：</p><pre class=" language-go"><code class="language-go">public class FileManagementSettingDefinitionProvider <span class="token punctuation">:</span> SettingDefinitionProvider<span class="token punctuation">{</span>    public override void <span class="token function">Define</span><span class="token punctuation">(</span>ISettingDefinitionContext context<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Define module settings here.         * Use names from FileManagementSettings class.         */</span>         context<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token builtin">new</span> <span class="token function">SettingDefinition</span><span class="token punctuation">(</span>            FileManagementSettings<span class="token punctuation">.</span>AllowedMaxFileSize<span class="token punctuation">,</span>            <span class="token string">"1024"</span><span class="token punctuation">,</span>            <span class="token function">L</span><span class="token punctuation">(</span><span class="token string">"DisplayName:FileManagement.AllowedMaxFileSize"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token function">L</span><span class="token punctuation">(</span><span class="token string">"Description:FileManagement.AllowedMaxFileSize"</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">WithProperty</span><span class="token punctuation">(</span><span class="token string">"Group1"</span><span class="token punctuation">,</span> <span class="token string">"File"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">WithProperty</span><span class="token punctuation">(</span><span class="token string">"Group2"</span><span class="token punctuation">,</span> <span class="token string">"Upload"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">WithProperty</span><span class="token punctuation">(</span><span class="token string">"Type"</span><span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             <span class="token builtin">new</span> <span class="token function">SettingDefinition</span><span class="token punctuation">(</span>                FileManagementSettings<span class="token punctuation">.</span>AllowedUploadFormats<span class="token punctuation">,</span>                <span class="token string">".jpg,.jpeg,.png,.gif,.txt"</span><span class="token punctuation">,</span>                <span class="token function">L</span><span class="token punctuation">(</span><span class="token string">"DisplayName:FileManagement.AllowedUploadFormats"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token function">L</span><span class="token punctuation">(</span><span class="token string">"Description:FileManagement.AllowedUploadFormats"</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">WithProperty</span><span class="token punctuation">(</span><span class="token string">"Group1"</span><span class="token punctuation">,</span> <span class="token string">"File"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">WithProperty</span><span class="token punctuation">(</span><span class="token string">"Group2"</span><span class="token punctuation">,</span> <span class="token string">"Upload"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">WithProperty</span><span class="token punctuation">(</span><span class="token string">"Type"</span><span class="token punctuation">,</span> <span class="token string">"text"</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     private static LocalizableString <span class="token function">L</span><span class="token punctuation">(</span><span class="token builtin">string</span> name<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> LocalizableString<span class="token punctuation">.</span>Create<span class="token operator">&lt;</span>FileManagementResource<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上代码定了了2个配置：<code>AllowedMaxFileSize</code>和<code>AllowedUploadFormats</code>，设置了它们的默认值、名称和详细说明。因为本项目使用了EasyAbp的SettingUi模块，所以会有一些<code>Group1</code>，<code>Group2</code>之类的字段，具体介绍可以参考Abp.SettingUi[4]</p><h3 id="使用设置"><a href="#使用设置" class="headerlink" title="使用设置"></a>使用设置</h3><p>想读取设置信息，只需注入<code>ISettingProvider</code>即可。因为父类<code>ApplicationService</code>中已经注入，所以这里直接使用<code>SettingProvider</code>就好。获取到配置，然后就可以做一些逻辑处理，比如判断上传文件的大小和格式是否合法：</p><pre class=" language-go"><code class="language-go">public class FileAppService <span class="token punctuation">:</span> FileManagementAppService<span class="token punctuation">,</span> IFileAppService<span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span>     <span class="token punctuation">[</span>Authorize<span class="token punctuation">]</span>    public virtual async Task<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span> <span class="token function">CreateAsync</span><span class="token punctuation">(</span>FileUploadInputDto input<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">var</span> allowedMaxFileSize <span class="token operator">=</span> await SettingProvider<span class="token punctuation">.</span>GetAsync<span class="token operator">&lt;</span><span class="token builtin">int</span><span class="token operator">></span><span class="token punctuation">(</span>FileManagementSettings<span class="token punctuation">.</span>AllowedMaxFileSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//kb</span>        <span class="token keyword">var</span> allowedUploadFormats <span class="token operator">=</span> <span class="token punctuation">(</span>await SettingProvider<span class="token punctuation">.</span><span class="token function">GetOrNullAsync</span><span class="token punctuation">(</span>FileManagementSettings<span class="token punctuation">.</span>AllowedUploadFormats<span class="token punctuation">)</span><span class="token punctuation">)</span>            ?<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">,</span> StringSplitOptions<span class="token punctuation">.</span>RemoveEmptyEntries<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span>Bytes<span class="token punctuation">.</span>Length <span class="token operator">></span> allowedMaxFileSize <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            throw <span class="token builtin">new</span> <span class="token function">UserFriendlyException</span><span class="token punctuation">(</span>L<span class="token punctuation">[</span><span class="token string">"FileManagement.ExceedsTheMaximumSize"</span><span class="token punctuation">,</span> allowedMaxFileSize<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>allowedUploadFormats <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>allowedUploadFormats<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>Path<span class="token punctuation">.</span><span class="token function">GetExtension</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            throw <span class="token builtin">new</span> <span class="token function">UserFriendlyException</span><span class="token punctuation">(</span>L<span class="token punctuation">[</span><span class="token string">"FileManagement.NotValidFormat"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token operator">...</span><span class="token operator">...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>前端设置界面：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSjFRd28yY3NRQzBpYzJpYUNNNld5RmF0ZFN1MUFHRkVtTk9pYXRRcUhSVGgzN05hRFNRaWFpYW1XTk5ZM1lKZG5jdGJ0YmZmcnhCYVI5OWNBLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>下面可以随便修改下设置，进行测试：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszSjFRd28yY3NRQzBpYzJpYUNNNld5RmF0QUcwaWFNSDJWTlFUMFc1RnFrRkN6TVI1Z05tTDYyaWJlZUplaHRmRk9JS1U0VXpBNUtQdGliTHhRLzY0MA?x-oss-process=image/format,png" alt="img"></p><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h2 id="初识ABP-vNext（11）：聚合根、仓储、领域服务、应用服务、Blob储存"><a href="#初识ABP-vNext（11）：聚合根、仓储、领域服务、应用服务、Blob储存" class="headerlink" title="初识ABP vNext（11）：聚合根、仓储、领域服务、应用服务、Blob储存"></a>初识ABP vNext（11）：聚合根、仓储、领域服务、应用服务、Blob储存</h2><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png" alt="img"></p><ul><li>聚合根</li><li>仓储</li><li>领域服务</li><li><ul><li>BLOB储存</li></ul></li><li>应用服务</li><li>单元测试</li><li>模块引用</li></ul><h3 id="前言-6"><a href="#前言-6" class="headerlink" title="前言"></a>前言</h3><p>在前两节中介绍了ABP模块开发的基本步骤，试着实现了一个简单的文件管理模块；功能很简单，就是基于本地文件系统来完成文件的读写操作，数据也并没有保存到数据库，所以之前只简单使用了应用服务，并没有用到领域层。而在DDD中领域层是非常重要的一层，其中包含了实体，聚合根，领域服务，仓储等等，复杂的业务逻辑也应该在领域层来实现。本篇来完善一下文件管理模块，将文件记录保存到数据库，并使用ABP BLOB系统来完成文件的存储。</p><h3 id="开始-6"><a href="#开始-6" class="headerlink" title="开始"></a>开始</h3><h4 id="聚合根"><a href="#聚合根" class="headerlink" title="聚合根"></a>聚合根</h4><p>首先从实体模型开始，建立File实体。按照DDD的思路，这里的File应该是一个<strong>聚合根</strong>。</p><p>\modules\file-management\src\Xhznl.FileManagement.Domain\Files\File.cs：</p><pre class=" language-go"><code class="language-go">public class File <span class="token punctuation">:</span> FullAuditedAggregateRoot<span class="token operator">&lt;</span>Guid<span class="token operator">></span><span class="token punctuation">,</span> IMultiTenant<span class="token punctuation">{</span>    public virtual Guid? TenantId <span class="token punctuation">{</span> get<span class="token punctuation">;</span> protected set<span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token punctuation">[</span>NotNull<span class="token punctuation">]</span>    public virtual <span class="token builtin">string</span> FileName <span class="token punctuation">{</span> get<span class="token punctuation">;</span> protected set<span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token punctuation">[</span>NotNull<span class="token punctuation">]</span>    public virtual <span class="token builtin">string</span> BlobName <span class="token punctuation">{</span> get<span class="token punctuation">;</span> protected set<span class="token punctuation">;</span> <span class="token punctuation">}</span>     public virtual long ByteSize <span class="token punctuation">{</span> get<span class="token punctuation">;</span> protected set<span class="token punctuation">;</span> <span class="token punctuation">}</span>     protected <span class="token function">File</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>     public <span class="token function">File</span><span class="token punctuation">(</span>Guid id<span class="token punctuation">,</span> Guid? tenantId<span class="token punctuation">,</span> <span class="token punctuation">[</span>NotNull<span class="token punctuation">]</span> <span class="token builtin">string</span> fileName<span class="token punctuation">,</span> <span class="token punctuation">[</span>NotNull<span class="token punctuation">]</span> <span class="token builtin">string</span> blobName<span class="token punctuation">,</span> long byteSize<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">base</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        TenantId <span class="token operator">=</span> tenantId<span class="token punctuation">;</span>        FileName <span class="token operator">=</span> Check<span class="token punctuation">.</span><span class="token function">NotNullOrWhiteSpace</span><span class="token punctuation">(</span>fileName<span class="token punctuation">,</span> <span class="token function">nameof</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BlobName <span class="token operator">=</span> Check<span class="token punctuation">.</span><span class="token function">NotNullOrWhiteSpace</span><span class="token punctuation">(</span>blobName<span class="token punctuation">,</span> <span class="token function">nameof</span><span class="token punctuation">(</span>blobName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ByteSize <span class="token operator">=</span> byteSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在DbContext中<strong>添加DbSet</strong></p><p>\modules\file-management\src\Xhznl.FileManagement.EntityFrameworkCore\EntityFrameworkCore\IFileManagementDbContext.cs：</p><pre class=" language-go"><code class="language-go">public <span class="token keyword">interface</span> IFileManagementDbContext <span class="token punctuation">:</span> IEfCoreDbContext<span class="token punctuation">{</span>    DbSet<span class="token operator">&lt;</span>File<span class="token operator">></span> Files <span class="token punctuation">{</span> get<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>\modules\file-management\src\Xhznl.FileManagement.EntityFrameworkCore\EntityFrameworkCore\FileManagementDbContext.cs：</p><pre class=" language-go"><code class="language-go">public class FileManagementDbContext <span class="token punctuation">:</span> AbpDbContext<span class="token operator">&lt;</span>FileManagementDbContext<span class="token operator">></span><span class="token punctuation">,</span> IFileManagementDbContext<span class="token punctuation">{</span>    public DbSet<span class="token operator">&lt;</span>File<span class="token operator">></span> Files <span class="token punctuation">{</span> get<span class="token punctuation">;</span> set<span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span> </code></pre><p><strong>配置实体</strong></p><p>\modules\file-management\src\Xhznl.FileManagement.EntityFrameworkCore\EntityFrameworkCore\FileManagementDbContextModelCreatingExtensions.cs：</p><pre class=" language-go"><code class="language-go">public static void <span class="token function">ConfigureFileManagement</span><span class="token punctuation">(</span>    this ModelBuilder builder<span class="token punctuation">,</span>    Action<span class="token operator">&lt;</span>FileManagementModelBuilderConfigurationOptions<span class="token operator">></span> optionsAction <span class="token operator">=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span>    builder<span class="token punctuation">.</span>Entity<span class="token operator">&lt;</span>File<span class="token operator">></span><span class="token punctuation">(</span>b <span class="token operator">=</span><span class="token operator">></span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//Configure table &amp; schema name</span>        b<span class="token punctuation">.</span><span class="token function">ToTable</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>TablePrefix <span class="token operator">+</span> <span class="token string">"Files"</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>Schema<span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">ConfigureByConvention</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Properties</span>        b<span class="token punctuation">.</span><span class="token function">Property</span><span class="token punctuation">(</span>q <span class="token operator">=</span><span class="token operator">></span> q<span class="token punctuation">.</span>FileName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">HasMaxLength</span><span class="token punctuation">(</span>FileConsts<span class="token punctuation">.</span>MaxFileNameLength<span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">Property</span><span class="token punctuation">(</span>q <span class="token operator">=</span><span class="token operator">></span> q<span class="token punctuation">.</span>BlobName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">HasMaxLength</span><span class="token punctuation">(</span>FileConsts<span class="token punctuation">.</span>MaxBlobNameLength<span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">Property</span><span class="token punctuation">(</span>q <span class="token operator">=</span><span class="token operator">></span> q<span class="token punctuation">.</span>ByteSize<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="仓储"><a href="#仓储" class="headerlink" title="仓储"></a>仓储</h4><p>ABP为每个聚合根或实体提供了 <strong>默认的通用(泛型)仓储</strong> ，其中包含了标准的CRUD操作，注入<code>IRepository&lt;TEntity, TKey&gt;</code>即可使用。通常来说默认仓储就够用了，有特殊需求时也可以自定义仓储。</p><p>定义<strong>仓储接口</strong></p><p>\modules\file-management\src\Xhznl.FileManagement.Domain\Files\IFileRepository.cs：</p><pre class=" language-go"><code class="language-go">public <span class="token keyword">interface</span> IFileRepository <span class="token punctuation">:</span> IRepository<span class="token operator">&lt;</span>File<span class="token punctuation">,</span> Guid<span class="token operator">></span><span class="token punctuation">{</span>    Task<span class="token operator">&lt;</span>File<span class="token operator">></span> <span class="token function">FindByBlobNameAsync</span><span class="token punctuation">(</span><span class="token builtin">string</span> blobName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>仓储实现</strong></p><p>\modules\file-management\src\Xhznl.FileManagement.EntityFrameworkCore\Files\EfCoreFileRepository.cs：</p><pre class=" language-go"><code class="language-go">public class EfCoreFileRepository <span class="token punctuation">:</span> EfCoreRepository<span class="token operator">&lt;</span>IFileManagementDbContext<span class="token punctuation">,</span> File<span class="token punctuation">,</span> Guid<span class="token operator">></span><span class="token punctuation">,</span> IFileRepository<span class="token punctuation">{</span>    public <span class="token function">EfCoreFileRepository</span><span class="token punctuation">(</span>IDbContextProvider<span class="token operator">&lt;</span>IFileManagementDbContext<span class="token operator">></span> dbContextProvider<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">base</span><span class="token punctuation">(</span>dbContextProvider<span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    public async Task<span class="token operator">&lt;</span>File<span class="token operator">></span> <span class="token function">FindByBlobNameAsync</span><span class="token punctuation">(</span><span class="token builtin">string</span> blobName<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Check<span class="token punctuation">.</span><span class="token function">NotNullOrWhiteSpace</span><span class="token punctuation">(</span>blobName<span class="token punctuation">,</span> <span class="token function">nameof</span><span class="token punctuation">(</span>blobName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> await DbSet<span class="token punctuation">.</span><span class="token function">FirstOrDefaultAsync</span><span class="token punctuation">(</span>p <span class="token operator">=</span><span class="token operator">></span> p<span class="token punctuation">.</span>BlobName <span class="token operator">==</span> blobName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>注册仓储</strong></p><p>\modules\file-management\src\Xhznl.FileManagement.EntityFrameworkCore\EntityFrameworkCore\FileManagementEntityFrameworkCoreModule.cs：</p><pre class=" language-go"><code class="language-go">public class FileManagementEntityFrameworkCoreModule <span class="token punctuation">:</span> AbpModule<span class="token punctuation">{</span>    public override void <span class="token function">ConfigureServices</span><span class="token punctuation">(</span>ServiceConfigurationContext context<span class="token punctuation">)</span>    <span class="token punctuation">{</span> context<span class="token punctuation">.</span>Services<span class="token punctuation">.</span>AddAbpDbContext<span class="token operator">&lt;</span>FileManagementDbContext<span class="token operator">></span><span class="token punctuation">(</span>options <span class="token operator">=</span><span class="token operator">></span>        <span class="token punctuation">{</span>            options<span class="token punctuation">.</span>AddRepository<span class="token operator">&lt;</span>File<span class="token punctuation">,</span> EfCoreFileRepository<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="领域服务"><a href="#领域服务" class="headerlink" title="领域服务"></a>领域服务</h4><p>定义<strong>领域服务接口</strong></p><p>\modules\file-management\src\Xhznl.FileManagement.Domain\Files\IFileManager.cs：</p><pre class=" language-go"><code class="language-go">public <span class="token keyword">interface</span> IFileManager <span class="token punctuation">:</span> IDomainService<span class="token punctuation">{</span>    Task<span class="token operator">&lt;</span>File<span class="token operator">></span> <span class="token function">FindByBlobNameAsync</span><span class="token punctuation">(</span><span class="token builtin">string</span> blobName<span class="token punctuation">)</span><span class="token punctuation">;</span>    Task<span class="token operator">&lt;</span>File<span class="token operator">></span> <span class="token function">CreateAsync</span><span class="token punctuation">(</span><span class="token builtin">string</span> fileName<span class="token punctuation">,</span> <span class="token builtin">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>    Task<span class="token operator">&lt;</span><span class="token builtin">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">GetBlobAsync</span><span class="token punctuation">(</span><span class="token builtin">string</span> blobName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在实现领域服务之前，先来安装一下ABP Blob系统核心包，因为我要使用blob来存储文件，<code>Volo.Abp.BlobStoring</code>包是必不可少的。</p><h4 id="BLOB储存"><a href="#BLOB储存" class="headerlink" title="BLOB储存"></a>BLOB储存</h4><p>BLOB(binary large object)：大型二进制对象；关于BLOB可以参考 BLOB 存储[1] ，这里不多介绍。</p><p>安装<code>Volo.Abp.BlobStoring</code>，在Domain项目目录下执行：<code>abp add-package Volo.Abp.BlobStoring</code></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszS1NGQXI4eWNFOTU2WmVxeU5leHhIZ215MFVhRmlhWWRRVWI1ZzI1eFpDeVlGaWEwRHdzc042czhIS0hhQTNJMFRBYWZ4RFRDdllYR0NBLzY0MA?x-oss-process=image/format,png" alt="img"></p><p><code>Volo.Abp.BlobStoring</code>是BLOB的核心包，它仅包含BLOB的一些基本抽象，想要BLOB系统正常工作，还需要为它配置一个提供程序；这个提供程序暂时不管，将来由模块的具体使用者去提供。这样的好处是模块不依赖特定存储提供程序，使用者可以随意的指定存储到阿里云，Azure，或者文件系统等等。。。</p><p><strong>领域服务实现</strong></p><p>\modules\file-management\src\Xhznl.FileManagement.Domain\Files\FileManager.cs：</p><pre class=" language-go"><code class="language-go">public class FileManager <span class="token punctuation">:</span> DomainService<span class="token punctuation">,</span> IFileManager<span class="token punctuation">{</span>    protected IFileRepository FileRepository <span class="token punctuation">{</span> get<span class="token punctuation">;</span> <span class="token punctuation">}</span>    protected IBlobContainer BlobContainer <span class="token punctuation">{</span> get<span class="token punctuation">;</span> <span class="token punctuation">}</span>    public <span class="token function">FileManager</span><span class="token punctuation">(</span>IFileRepository fileRepository<span class="token punctuation">,</span> IBlobContainer blobContainer<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        FileRepository <span class="token operator">=</span> fileRepository<span class="token punctuation">;</span>        BlobContainer <span class="token operator">=</span> blobContainer<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    public virtual async Task<span class="token operator">&lt;</span>File<span class="token operator">></span> <span class="token function">FindByBlobNameAsync</span><span class="token punctuation">(</span><span class="token builtin">string</span> blobName<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Check<span class="token punctuation">.</span><span class="token function">NotNullOrWhiteSpace</span><span class="token punctuation">(</span>blobName<span class="token punctuation">,</span> <span class="token function">nameof</span><span class="token punctuation">(</span>blobName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> await FileRepository<span class="token punctuation">.</span><span class="token function">FindByBlobNameAsync</span><span class="token punctuation">(</span>blobName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    public virtual async Task<span class="token operator">&lt;</span>File<span class="token operator">></span> <span class="token function">CreateAsync</span><span class="token punctuation">(</span><span class="token builtin">string</span> fileName<span class="token punctuation">,</span> <span class="token builtin">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Check<span class="token punctuation">.</span><span class="token function">NotNullOrWhiteSpace</span><span class="token punctuation">(</span>fileName<span class="token punctuation">,</span> <span class="token function">nameof</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> blobName <span class="token operator">=</span> Guid<span class="token punctuation">.</span><span class="token function">NewGuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token string">"N"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> file <span class="token operator">=</span> await FileRepository<span class="token punctuation">.</span><span class="token function">InsertAsync</span><span class="token punctuation">(</span><span class="token builtin">new</span> <span class="token function">File</span><span class="token punctuation">(</span>GuidGenerator<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CurrentTenant<span class="token punctuation">.</span>Id<span class="token punctuation">,</span> fileName<span class="token punctuation">,</span> blobName<span class="token punctuation">,</span> bytes<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        await BlobContainer<span class="token punctuation">.</span><span class="token function">SaveAsync</span><span class="token punctuation">(</span>blobName<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> file<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    public virtual async Task<span class="token operator">&lt;</span><span class="token builtin">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">GetBlobAsync</span><span class="token punctuation">(</span><span class="token builtin">string</span> blobName<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Check<span class="token punctuation">.</span><span class="token function">NotNullOrWhiteSpace</span><span class="token punctuation">(</span>blobName<span class="token punctuation">,</span> <span class="token function">nameof</span><span class="token punctuation">(</span>blobName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> await BlobContainer<span class="token punctuation">.</span><span class="token function">GetAllBytesAsync</span><span class="token punctuation">(</span>blobName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="应用服"><a href="#应用服" class="headerlink" title="应用服"></a>应用服</h3><p>接下来修改一下应用服务，应用服务通常没有太多业务逻辑，其调用领域服务来完成业务。</p><p><strong>应用服务接口</strong></p><p>\modules\file-management\src\Xhznl.FileManagement.Application.Contracts\Files\IFileAppService.cs：</p><pre class=" language-go"><code class="language-go">public <span class="token keyword">interface</span> IFileAppService <span class="token punctuation">:</span> IApplicationService<span class="token punctuation">{</span>    Task<span class="token operator">&lt;</span>FileDto<span class="token operator">></span> <span class="token function">FindByBlobNameAsync</span><span class="token punctuation">(</span><span class="token builtin">string</span> blobName<span class="token punctuation">)</span><span class="token punctuation">;</span>    Task<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span> <span class="token function">CreateAsync</span><span class="token punctuation">(</span>FileDto input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>应用服务实现</strong></p><p>\modules\file-management\src\Xhznl.FileManagement.Application\Files\FileAppService.cs：</p><pre class=" language-go"><code class="language-go">public class FileAppService <span class="token punctuation">:</span> FileManagementAppService<span class="token punctuation">,</span> IFileAppService<span class="token punctuation">{</span>    protected IFileManager FileManager <span class="token punctuation">{</span> get<span class="token punctuation">;</span> <span class="token punctuation">}</span>    public <span class="token function">FileAppService</span><span class="token punctuation">(</span>IFileManager fileManager<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        FileManager <span class="token operator">=</span> fileManager<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    public virtual async Task<span class="token operator">&lt;</span>FileDto<span class="token operator">></span> <span class="token function">FindByBlobNameAsync</span><span class="token punctuation">(</span><span class="token builtin">string</span> blobName<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Check<span class="token punctuation">.</span><span class="token function">NotNullOrWhiteSpace</span><span class="token punctuation">(</span>blobName<span class="token punctuation">,</span> <span class="token function">nameof</span><span class="token punctuation">(</span>blobName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> file <span class="token operator">=</span> await FileManager<span class="token punctuation">.</span><span class="token function">FindByBlobNameAsync</span><span class="token punctuation">(</span>blobName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> bytes <span class="token operator">=</span> await FileManager<span class="token punctuation">.</span><span class="token function">GetBlobAsync</span><span class="token punctuation">(</span>blobName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token builtin">new</span> FileDto        <span class="token punctuation">{</span>            Bytes <span class="token operator">=</span> bytes<span class="token punctuation">,</span>            FileName <span class="token operator">=</span> file<span class="token punctuation">.</span>FileName        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">[</span>Authorize<span class="token punctuation">]</span>    public virtual async Task<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span> <span class="token function">CreateAsync</span><span class="token punctuation">(</span>FileDto input<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        await <span class="token function">CheckFile</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> file <span class="token operator">=</span> await FileManager<span class="token punctuation">.</span><span class="token function">CreateAsync</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>FileName<span class="token punctuation">,</span> input<span class="token punctuation">.</span>Bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> file<span class="token punctuation">.</span>BlobName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    protected virtual async Task <span class="token function">CheckFile</span><span class="token punctuation">(</span>FileDto input<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span>Bytes<span class="token punctuation">.</span><span class="token function">IsNullOrEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            throw <span class="token builtin">new</span> <span class="token function">AbpValidationException</span><span class="token punctuation">(</span><span class="token string">"Bytes can not be null or empty!"</span><span class="token punctuation">,</span>                <span class="token builtin">new</span> List<span class="token operator">&lt;</span>ValidationResult<span class="token operator">></span>                <span class="token punctuation">{</span>                    <span class="token builtin">new</span> <span class="token function">ValidationResult</span><span class="token punctuation">(</span><span class="token string">"Bytes can not be null or empty!"</span><span class="token punctuation">,</span> <span class="token builtin">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">"Bytes"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> allowedMaxFileSize <span class="token operator">=</span> await SettingProvider<span class="token punctuation">.</span>GetAsync<span class="token operator">&lt;</span><span class="token builtin">int</span><span class="token operator">></span><span class="token punctuation">(</span>FileManagementSettings<span class="token punctuation">.</span>AllowedMaxFileSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//kb</span>        <span class="token keyword">var</span> allowedUploadFormats <span class="token operator">=</span> <span class="token punctuation">(</span>await SettingProvider<span class="token punctuation">.</span><span class="token function">GetOrNullAsync</span><span class="token punctuation">(</span>FileManagementSettings<span class="token punctuation">.</span>AllowedUploadFormats<span class="token punctuation">)</span><span class="token punctuation">)</span>            ?<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">,</span> StringSplitOptions<span class="token punctuation">.</span>RemoveEmptyEntries<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span>Bytes<span class="token punctuation">.</span>Length <span class="token operator">></span> allowedMaxFileSize <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            throw <span class="token builtin">new</span> <span class="token function">UserFriendlyException</span><span class="token punctuation">(</span>L<span class="token punctuation">[</span><span class="token string">"FileManagement.ExceedsTheMaximumSize"</span><span class="token punctuation">,</span> allowedMaxFileSize<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>allowedUploadFormats <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>allowedUploadFormats<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>Path<span class="token punctuation">.</span><span class="token function">GetExtension</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>FileName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            throw <span class="token builtin">new</span> <span class="token function">UserFriendlyException</span><span class="token punctuation">(</span>L<span class="token punctuation">[</span><span class="token string">"FileManagement.NotValidFormat"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>API控制器</strong></p><p>最后记得将服务接口暴露出去，我这里是自己编写Controller，你也可以使用ABP的自动API控制器来完成，请参考 自动API控制器[2]</p><p>\modules\file-management\src\Xhznl.FileManagement.HttpApi\Files\FileController.cs：</p><pre class=" language-go"><code class="language-go"><span class="token punctuation">[</span>RemoteService<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token function">Route</span><span class="token punctuation">(</span><span class="token string">"api/file-management/files"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>public class FileController <span class="token punctuation">:</span> FileManagementController<span class="token punctuation">{</span>    protected IFileAppService FileAppService <span class="token punctuation">{</span> get<span class="token punctuation">;</span> <span class="token punctuation">}</span>    public <span class="token function">FileController</span><span class="token punctuation">(</span>IFileAppService fileAppService<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        FileAppService <span class="token operator">=</span> fileAppService<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">[</span>HttpGet<span class="token punctuation">]</span>    <span class="token punctuation">[</span><span class="token function">Route</span><span class="token punctuation">(</span><span class="token string">"{blobName}"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    public virtual async Task<span class="token operator">&lt;</span>FileResult<span class="token operator">></span> <span class="token function">GetAsync</span><span class="token punctuation">(</span><span class="token builtin">string</span> blobName<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">var</span> fileDto <span class="token operator">=</span> await FileAppService<span class="token punctuation">.</span><span class="token function">FindByBlobNameAsync</span><span class="token punctuation">(</span>blobName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">File</span><span class="token punctuation">(</span>fileDto<span class="token punctuation">.</span>Bytes<span class="token punctuation">,</span> MimeTypes<span class="token punctuation">.</span><span class="token function">GetByExtension</span><span class="token punctuation">(</span>Path<span class="token punctuation">.</span><span class="token function">GetExtension</span><span class="token punctuation">(</span>fileDto<span class="token punctuation">.</span>FileName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">[</span>HttpPost<span class="token punctuation">]</span>    <span class="token punctuation">[</span><span class="token function">Route</span><span class="token punctuation">(</span><span class="token string">"upload"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token punctuation">[</span>Authorize<span class="token punctuation">]</span>    public virtual async Task<span class="token operator">&lt;</span>JsonResult<span class="token operator">></span> <span class="token function">CreateAsync</span><span class="token punctuation">(</span>IFormFile file<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>file <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            throw <span class="token builtin">new</span> <span class="token function">UserFriendlyException</span><span class="token punctuation">(</span><span class="token string">"No file found!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> bytes <span class="token operator">=</span> await file<span class="token punctuation">.</span><span class="token function">GetAllBytesAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> result <span class="token operator">=</span> await FileAppService<span class="token punctuation">.</span><span class="token function">CreateAsync</span><span class="token punctuation">(</span><span class="token builtin">new</span> <span class="token function">FileDto</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Bytes <span class="token operator">=</span> bytes<span class="token punctuation">,</span>            FileName <span class="token operator">=</span> file<span class="token punctuation">.</span>FileName        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">Json</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h3><p>针对以上内容做一个简单的测试，首先为Blob系统配置一个提供程序。</p><p>我这里使用最简单的文件系统来储存，所以需要安装<code>Volo.Abp.BlobStoring.FileSystem</code>。在Application.Tests项目目录下执行：<code>abp add-package Volo.Abp.BlobStoring.FileSystem</code></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszS1NGQXI4eWNFOTU2WmVxeU5leHhIZ3ZoYXFWTGxQcDRocVlpY252YTM1azQ3czlCWXBiY1oxQ2Y4S3J1endJeHhZaGd1WDZpYms4YW93LzY0MA?x-oss-process=image/format,png" alt="img"></p><p><strong>配置默认容器</strong></p><p>\modules\file-management\test\Xhznl.FileManagement.Application.Tests\FileManagementApplicationTestModule.cs：</p><pre class=" language-go"><code class="language-go"><span class="token punctuation">[</span><span class="token function">DependsOn</span><span class="token punctuation">(</span>    <span class="token function">typeof</span><span class="token punctuation">(</span>FileManagementApplicationModule<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">typeof</span><span class="token punctuation">(</span>FileManagementDomainTestModule<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">typeof</span><span class="token punctuation">(</span>AbpBlobStoringFileSystemModule<span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">]</span>public class FileManagementApplicationTestModule <span class="token punctuation">:</span> AbpModule<span class="token punctuation">{</span>    public override void <span class="token function">ConfigureServices</span><span class="token punctuation">(</span>ServiceConfigurationContext context<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Configure<span class="token operator">&lt;</span>AbpBlobStoringOptions<span class="token operator">></span><span class="token punctuation">(</span>options <span class="token operator">=</span><span class="token operator">></span>        <span class="token punctuation">{</span>            options<span class="token punctuation">.</span>Containers<span class="token punctuation">.</span><span class="token function">ConfigureDefault</span><span class="token punctuation">(</span>container <span class="token operator">=</span><span class="token operator">></span>            <span class="token punctuation">{</span>                container<span class="token punctuation">.</span><span class="token function">UseFileSystem</span><span class="token punctuation">(</span>fileSystem <span class="token operator">=</span><span class="token operator">></span>                <span class="token punctuation">{</span>                    fileSystem<span class="token punctuation">.</span>BasePath <span class="token operator">=</span> <span class="token string">"D:\\my-files"</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        base<span class="token punctuation">.</span><span class="token function">ConfigureServices</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>测试用例</strong></p><p>\modules\file-management\test\Xhznl.FileManagement.Application.Tests\Files\FileAppService_Tests.cs：</p><pre class=" language-go"><code class="language-go">public class FileAppService_Tests <span class="token punctuation">:</span> FileManagementApplicationTestBase<span class="token punctuation">{</span>    private readonly IFileAppService _fileAppService<span class="token punctuation">;</span>    public <span class="token function">FileAppService_Tests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        _fileAppService <span class="token operator">=</span> GetRequiredService<span class="token operator">&lt;</span>IFileAppService<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">[</span>Fact<span class="token punctuation">]</span>    public async Task <span class="token function">Create_FindByBlobName_Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">var</span> blobName <span class="token operator">=</span> await _fileAppService<span class="token punctuation">.</span><span class="token function">CreateAsync</span><span class="token punctuation">(</span><span class="token builtin">new</span> <span class="token function">FileDto</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            FileName <span class="token operator">=</span> <span class="token string">"微信图片_20200813165555.jpg"</span><span class="token punctuation">,</span>            Bytes <span class="token operator">=</span> await System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>File<span class="token punctuation">.</span><span class="token function">ReadAllBytesAsync</span><span class="token punctuation">(</span>@<span class="token string">"D:\WorkSpace\WorkFiles\杂项\图片\微信图片_20200813165555.jpg"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        blobName<span class="token punctuation">.</span><span class="token function">ShouldNotBeEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> fileDto <span class="token operator">=</span> await _fileAppService<span class="token punctuation">.</span><span class="token function">FindByBlobNameAsync</span><span class="token punctuation">(</span>blobName<span class="token punctuation">)</span><span class="token punctuation">;</span>        fileDto<span class="token punctuation">.</span><span class="token function">ShouldNotBeNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fileDto<span class="token punctuation">.</span>FileName<span class="token punctuation">.</span><span class="token function">ShouldBe</span><span class="token punctuation">(</span><span class="token string">"微信图片_20200813165555.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>运行测试</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszS1NGQXI4eWNFOTU2WmVxeU5leHhIZ0N2NnpMdVdwY0MxdkFWVjJtZHRxV0llTmliTEc2SnR2T2JpY2ZnbmJNOGZ1WDAxd1hNTWU1M3Z3LzY0MA?x-oss-process=image/format,png" alt="img"></p><p>测试通过，blob也已经存入D:\my-files：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszS1NGQXI4eWNFOTU2WmVxeU5leHhIZzJqOUNJQndtc2c0N2lhd0pDTnJudlpLUFdLN3JuVVJzZ1VWdXl6RlRyeGtPcFNwaWJpYVNielBwZy82NDA?x-oss-process=image/format,png" alt="img"></p><h3 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h3><p>下面回到主项目，前面的章节中已经介绍过，模块的引用依赖都已经添加完成，下面就直接从数据库迁移开始。</p><p>\src\Xhznl.HelloAbp.EntityFrameworkCore.DbMigrations\EntityFrameworkCore\HelloAbpMigrationsDbContext.cs：</p><pre class=" language-go"><code class="language-go">public class HelloAbpMigrationsDbContext <span class="token punctuation">:</span> AbpDbContext<span class="token operator">&lt;</span>HelloAbpMigrationsDbContext<span class="token operator">></span><span class="token punctuation">{</span>    public <span class="token function">HelloAbpMigrationsDbContext</span><span class="token punctuation">(</span>DbContextOptions<span class="token operator">&lt;</span>HelloAbpMigrationsDbContext<span class="token operator">></span> options<span class="token punctuation">)</span>        <span class="token punctuation">:</span> <span class="token function">base</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    protected override void <span class="token function">OnModelCreating</span><span class="token punctuation">(</span>ModelBuilder builder<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token operator">...</span><span class="token operator">...</span>        builder<span class="token punctuation">.</span><span class="token function">ConfigureFileManagement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">...</span><span class="token operator">...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>打开程序包管理器控制台，执行以下命令：</p><pre><code>Add-Migration &quot;Added_FileManagement&quot;Update-Database</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszS1NGQXI4eWNFOTU2WmVxeU5leHhIZ3M4SW1STGNGOXo5N0szZGtzQ3dwYzBxc1RVMnRKaWNkcEZaT1pyUnlTaWFYMzhVS3EyVkdMcDdRLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>此时数据库已经生成了File表：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszS1NGQXI4eWNFOTU2WmVxeU5leHhIZ2IwVmNSZ3FDbXBZaWJjQ0s5Tmt0cUVBckd3ZGZyeUNIOTdpY0Z5dUVnemRVanEwY2xEVWZadzlnLzY0MA?x-oss-process=image/format,png" alt="img"></p><p>还有记得在HttpApi.Host项目配置你想要的blob提供程序。</p><p>最后结合前端测试一下吧：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszS1NGQXI4eWNFOTU2WmVxeU5leHhIZ0hsOEZpY2lhQnRjb3RJc3ZMVXpENGhGbHhJUEtWY1NmTFdVT3pWb3ppY2FEUDlpYXFqQW9XaWI2aFNRLzY0MA?x-oss-process=image/format,png" alt="img"> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9jSko0amU1TmszS1NGQXI4eWNFOTU2WmVxeU5leHhIZ0lycDRBRUN6Y2ljOWlicVlaTlhBOFRSSllaR3g4aWFhR2ZrNkw1NEVxandpYmpDQWxOWHlLTXhONncvNjQw?x-oss-process=image/format,png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> abp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> abp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法--前端1</title>
      <link href="2021/03/25/kaikeba/men-tu-web1/"/>
      <url>2021/03/25/kaikeba/men-tu-web1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构和算法–前端1"><a href="#数据结构和算法–前端1" class="headerlink" title="数据结构和算法–前端1"></a>数据结构和算法–前端1</h1><p>react 和vue 的框架思想</p><p>工程化</p><p>vue源码</p><p>vue3.0用到哪些算法</p><p>vite介绍</p><p>微前端</p><p>网络协议</p><p>频繁缓存数据，如何保证效率和内存空间</p><p>LRU-CACHE  keep-alive</p><p>前端算法书   </p><p>​    学习JavaScript数据结构和算法</p><p>​    labulabu算法小抄</p><p>​    算法第四版</p><p>​    算法导论</p><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><p>​    the-super-tiny-compiler</p><p>​    vue的compiler</p><h2 id="项目做成什么样算合格"><a href="#项目做成什么样算合格" class="headerlink" title="项目做成什么样算合格"></a>项目做成什么样算合格</h2><p>​    一定有特色</p><p>​    怎么做出特色</p><pre><code>      你手里的需求，数据量变大怎么办</code></pre><p>​          网络不稳定怎么办，怎么设计缓存</p><p>​         怎么提高研发效率 or代码执行效率</p><h2 id="如何谈工资"><a href="#如何谈工资" class="headerlink" title="如何谈工资"></a>如何谈工资</h2><p>​    面试学习法</p><p>​    谈工资是一个技能，需要联系，谈工资和谈恋爱差不多</p><p>​    谈判技巧，先出价输</p><p>​    没事出去面试，聊技术，和HR谈钱</p><p>graphql   很好学</p><p>非科班补充计算机基础</p><p>​    先学算法</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表变量与临时表的优缺点？</title>
      <link href="2021/03/24/niuke/sql/sql-you-hua-jian-yi/"/>
      <url>2021/03/24/niuke/sql/sql-you-hua-jian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="表变量与临时表的优缺点？"><a href="#表变量与临时表的优缺点？" class="headerlink" title="表变量与临时表的优缺点？"></a>表变量与临时表的优缺点？</h1><p>什么情况下使用表变量？什么情况下使用临时表？</p><blockquote><p>表变量： </p><p> DECLARE @tb table(id  int  identity(1,1), name  varchar(100))  </p><p> INSERT @tb  </p><p> SELECT id, name  FROM mytable  WHERE name like ‘zhang%’ </p><p>临时表： </p><p> SELECT name, address<br> INTO #ta  FROM mytable<br> WHERE name like ‘zhang%’</p><p>（if exists (select * from tempdb.dbo.sysobjects where id = object_id(N’tempdb..#ta’) and type=’U’)<br>  drop table #ta）</p></blockquote><p>表变量和临时表的比较：</p><ul><li><p>临时表是利用了硬盘(tempdb数据库) ，表名变量是占用内存，因此小数据量当然是内存中的表变量更快。当大数据量时，就不能用表变量了，太耗内存了。大数据量时适合用临时表。</p></li><li><p>表变量缺省放在内存，速度快，所以在触发器，存储过程里如果数据量不大，应该用表变量。</p></li><li><p>临时表缺省使用硬盘，一般来说速度比较慢，那是不是就不用临时表呢？也不是，在数据量比较大的时候，如果使用表变量，会把内存耗尽，然后使用  TEMPDB的空间，这样主要还是使用硬盘空间，但同时把内存基本耗尽，增加了内存调入调出的机会，反而降低速度。这种情况建议先给TEMPDB一次分配合适的空间，然后使用临时表。</p></li><li><p>临时表相对而言表变量主要是多了I/O时间，但少了对内存资源的占用。数据量较大的时候，由于对内存资源的消耗较少，使用临时表比表变量有更好的性能。</p></li><li><p>建议：触发器、自定义函数用表变量；存储过程看情况，大部分用表变量；特殊的应用，大数据量的场合用临时表。</p></li><li><p>表变量有明确的作用域，在定义表变量的函数、存储过程或批处理结束时，会自动清除表变量。</p></li><li><p>在存储过程中使用表变量与使用临时表相比，减少了存储过程的重新编译量。</p></li><li><p>涉及表变量的事务只在表变量更新期间存在。这样就减少了表变量对锁定和记录资源的需求。</p></li><li><p>表变量需要事先知道表结构，普通临时表，只在当前会话中可用与表变量相同into一下就可以了,方便；全局临时表：可在多个会话中使用存在于temp中需显示的drop。（不知道表结构情况下临时表方便一些）</p></li><li><p>全局临时表的功能是表变量没法达到的。</p></li><li><p>表变量不必删除，也就不会有命名冲突，临时表特别是全局临时表用的时候必须解决命名冲突。</p></li><li><p>应避免频繁创建和删除临时表，减少系统表资源的消耗。</p></li><li><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用select into代替create table，避免log，提高速度；如果数据量不大，为了缓和系统表的资源，建议先create table，然后insert。</p></li><li><p>如果临时表的数据量较大，需要建立索引，那么应该将创建临时表和建立索引的过程放在单独一个子存储过程中，这样才能保证系统能够很好的使用到该临时表的索引。</p></li><li><p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先truncate table，然后drop table，这样可以避免系统表的较长时间锁定。</p></li><li><p>慎用大的临时表与其他大表的连接查询和修改，减低系统表负担，因为这种操作会在一条语句中多次使用tempdb的系统表。</p><p> -————————————————-  </p></li></ul><p>**问题 1：为什么在已经有了临时表的情况下还要引入表变量？</p><p>解答 1：**与临时表相比，表变量具有下列优点：</p><table><thead><tr><th>•</th><th>如 SQL Server 联机丛书“表”(Table) 一文中所述，表变量（如局部变量）具有明确定义的范围，在该范围结束时会自动清除这些表变量。</th></tr></thead><tbody><tr><td>•</td><td>与临时表相比，表变量导致存储过程的重新编译更少。</td></tr><tr><td>•</td><td>涉及表变量的事务仅维持表变量上更新的持续时间。因此，使用表变量时，需要锁定和记录资源的情况更少。因为表变量具有有限的范围并且不是持久性数据库的一部分，所以事务回滚并不影响它们。</td></tr></tbody></table><p>**问题 2：如果说使用表变量比使用临时表导致存储过程的重新编译更少，这意味着什么？</p><p>解答 2：**下面的文章讨论了重新编译存储过程的一些原因：   </p><p>​    <a href="http://support.microsoft.com/kb/243586/">243586</a>     (<a href="http://support.microsoft.com/kb/243586/">http://support.microsoft.com/kb/243586/</a>) 存储过程重新编译的疑难解答   </p><p>“由于某些临时表操作引起的重新编译”一节还列出了为避免一些问题（例如使用临时表导致重新编译）而需要满足的一些要求。这些限制不适用于表变量。   </p><p>表变量完全独立于创建这些表变量的批，因此，当执行 CREATE 或 ALTER  语句时，不会发生“重新解析”，而在使用临时表时可能会发生“重新解析”。临时表需要此“重新解析”，以便从嵌套存储过程引用该表。表变量完全避免了此问题，因此存储过程可以使用已编译的计划，从而节省了处理存储过程的资源。   </p><p>**问题 3：表变量有哪些缺陷？</p><p>解答 3：**与临时表相比，它存在下列缺陷：   </p><table><thead><tr><th>•</th><th>在表变量上不能创建非聚集索引（为 PRIMARY 或 UNIQUE 约束创建的系统索引除外）。与具有非聚集索引的临时表相比，这可能会影响查询性能。</th></tr></thead><tbody><tr><td>•</td><td>表变量不像临时表那样可以维护统计信息。在表变量上，不能通过自动创建或使用 CREATE STATISTICS 语句来创建统计信息。因此，在大表上进行复杂查询时，缺少统计信息可能会妨碍优化器确定查询的最佳计划，从而影响该查询的性能。</td></tr><tr><td>•</td><td>在初始 DECLARE 语句后不能更改表定义。</td></tr><tr><td>•</td><td>表变量不能在 INSERT EXEC 或 SELECT INTO 语句中使用。</td></tr><tr><td>•</td><td>表类型声明中的检查约束、默认值以及计算所得的列不能调用用户定义的函数。</td></tr><tr><td>•</td><td>如果表变量是在 EXEC 语句或 <strong>sp_executesql</strong> 存储过程外创建的，则不能使用 EXEC 语句或<strong>sp_executesql</strong> 存储过程来运行引用该表变量的动态 SQL Server 查询。由于表变量只能在它们的本地作用域中引用，因此 EXEC 语句和 <strong>sp_executesql</strong> 存储过程将在表变量的作用域之外。但是，您可以在 EXEC 语句或 <strong>sp_executesql</strong> 存储过程内创建表变量并执行所有处理，因为这样表变量本地作用域将位于 EXEC 语句或 <strong>sp_executesql</strong> 存储过程中。</td></tr></tbody></table><p>**问题 4：与临时表或永久表相比，表变量的仅存在于内存中的结构保证了更好的性能，是否因为它们是在驻留在物理磁盘上的数据库中维护的？</p><p>解答 4：<strong>表变量不是仅存在于内存中的结构。由于表变量可能保留的数据较多，内存中容纳不下，因此它必须在磁盘上有一个位置来存储数据。与临时表类似，表变量是在    **tempdb</strong> 数据库中创建的。如果有足够的内存，则表变量和临时表都在内存（数据缓存）中创建和处理。   </p><p>**问题 5：必须使用表变量来代替临时表吗？</p><p>解答 5：**答案取决于以下三个因素：   </p><table><thead><tr><th>•</th><th>插入到表中的行数。</th></tr></thead><tbody><tr><td>•</td><td>从中保存查询的重新编译的次数。</td></tr><tr><td>•</td><td>查询类型及其对性能的指数和统计信息的依赖性。</td></tr></tbody></table><p>在某些情况下，可将一个具有临时表的存储过程拆分为多个较小的存储过程，以便在较小的单元上进行重新编译。    </p><p>通常情况下，应尽量使用表变量，除非数据量非常大并且需要重复使用表。在这种情况下，可以在临时表上创建索引以提高查询性能。但是，各种方案可能互不相同。Microsoft 建议您做一个测试，来验证表变量对于特定的查询或存储过程是否比临时表更有效。    </p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/24/vue/vue-ji-suan-shu-xing-he-watch/"/>
      <url>2021/03/24/vue/vue-ji-suan-shu-xing-he-watch/</url>
      
        <content type="html"><![CDATA[<h1 id="vue计算属性和watch的区别有哪些？"><a href="#vue计算属性和watch的区别有哪些？" class="headerlink" title="vue计算属性和watch的区别有哪些？"></a>vue计算属性和watch的区别有哪些？</h1><p>区别：</p><p>1、计算属性在调用时需要在模板中渲染，修改计算所依赖元数据；watch在调用时只需修改元数据。</p><p>2、计算属性默认深度依赖，watch默认浅度观测。</p><p>3、计算属性适合做筛选，不可异步；watch适合做执行异步或开销较大的操作。</p><p><strong>computed</strong></p><blockquote><p>computed 是计算属性，它会根据你所依赖的数据动态显示新的计算结果</p></blockquote><p>计算属性将被加入到 Vue 实例中。所有 getter 和 setter 的 this 上下文<strong>自动地绑定为 Vue 实例</strong></p><p>通过计算出来的属性<strong>不需要调用</strong>直接可以在 DOM 里使用</p><pre class=" language-vue"><code class="language-vue">var vm = new Vue({  el: '#app',  data: {    message: 'hello'  },  template: `  <div>  <p>我是原始值: "{{ message }}"</p>  <p>我是计算属性的值: "{{ computedMessage}}"</p> // computed 在 DOM 里直接使用不需要调用  </div>  `,  computed: {    // 计算属性的 getter    computedMessage: function () {      // `this` 指向 vm 实例      return this.message.split('').reverse().join('')    }  }})</code></pre><p>结果：</p><p>我是原始值: “Hello”<br>我是计算属性的值: “olleH”</p><p>如果不使用计算属性，那么 message.split(‘’).reverse().join(‘’) 就会直接写到 template 里，那么在模版中放入太多声明式的逻辑会让模板本身过重，尤其当在页面中使用大量复杂的逻辑表达式处理数据时，<strong>会对页面的可维护性造成很大的影响</strong></p><p><strong>而且计算属性如果依赖不变的话，它就会变成缓存，computed 的值就不会重新计算</strong></p><p>所以，如果数据要通过复杂逻辑来得出结果，那么就推荐使用计算属性</p><p>watch</p><blockquote><p>一个对象，键是 data 对应的数据，值是对应的回调函数。值也可以是方法名，或者包含选项的对象，当 data 的数据发生变化时，就会发生一个回调，他有两个参数，一个 val （修改后的 data 数据），一个 oldVal（原来的 data 数据）<br>Vue 实例将会在实例化时调用<code>$watch()</code>，遍历 watch 对象的每一个属性</p></blockquote><pre class=" language-vue"><code class="language-vue">new Vue({  data: {    n: 0,    obj: {      a: "a"    }  },  template: `    <div>      <button @click="n += 1">n+1</button>      <button @click="obj.a += 'hi'">obj.a + 'hi'</button>      <button @click="obj = {a:'a'}">obj = 新对象</button>    </div>  `,  watch: {    n() {      console.log("n 变了");    },    obj:{      handler: function (val, oldVal) {       console.log("obj 变了")    },      deep: true // 该属性设定在任何被侦听的对象的 property 改变时都要执行 handler 的回调，不论其被嵌套多深    },    "obj.a":{      handler: function (val, oldVal) {       console.log("obj.a 变了")    },      immediate: true // 该属性设定该回调将会在侦听开始之后被立即调用    }  }}).$mount("#app");</code></pre><p>注意：<strong>不应该使用箭头函数来定义 watcher 函数</strong>，因为箭头函数没有 this，它的 this 会继承它的父级函数，但是它的父级函数是 window，导致箭头函数的 this 指向 window，而不是 Vue 实例</p><ul><li><strong>deep 控制是否要看这个对象里面的属性变化</strong></li><li><strong>immediate 控制是否在第一次渲染是执行这个函数</strong></li></ul><p><strong>vm.$watch()</strong> 的用法和 watch 回调类似</p><ul><li>vm.$watch(‘data属性名’, fn, {deep: .., immediate: ..})</li></ul><pre class=" language-vue"><code class="language-vue">vm.$watch("n", function(val, newVal){      console.log("n 变了");},{deep: true, immediate: true})</code></pre><p><strong>vue计算属性和watch的区别</strong></p><table><thead><tr><th><strong>计算属性（computed）</strong></th><th><strong>属性检测（watch）</strong></th></tr></thead><tbody><tr><td>首次运行</td><td>首次不运行</td></tr><tr><td>调用时需要在模板中渲染，修改计算所依赖元数据</td><td>调用时只需修改元数据</td></tr><tr><td>默认深度依赖</td><td>默认浅度观测</td></tr><tr><td>适合做筛选，不可异步</td><td>适合做执行异步或开销较大的操作</td></tr></tbody></table><p>如果一个数据需要经过复杂计算就用 computed</p><p>如果一个数据需要被监听并且对数据做一些操作就用 watch</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/23/vue/qian-duan-wen-ti/"/>
      <url>2021/03/23/vue/qian-duan-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>ueditor修改涂鸦窗口大小</p><p>smile_girl_ha 2017-02-06 18:02:42  1241  收藏<br>分类专栏： web前端 ueditor 文章标签： ueditor<br>版权<br>Ueditor修改涂鸦窗口显示大小</p><ol><li>修改scrawl.html中的宽高</li></ol><div class="drawBoard border_style1"><pre><code>        &lt;canvas id=&quot;J_brushBoard&quot; class=&quot;brushBorad&quot; width=&quot;760&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;        &lt;div id=&quot;J_picBoard&quot; class=&quot;picBoard&quot; style=&quot;width: 760px;height: 400px&quot;&gt;&lt;/div&gt; &lt;/div&gt;</code></pre><ol><li><p>修改scrawl.css中的hot和drawToolbar样式的宽高</p></li><li><p>修改ueditor.all.js中的加载dialog的代码</p></li></ol><p>// ui/dialog.js</p><p>///import core</p><p>///import uicore</p><p>///import ui/mask.js</p><p>///import ui/button.js</p><p> fitSize: function (){</p><pre><code>        var popBodyEl = this.getDom(&#39;body&#39;);</code></pre><p>//            if (!(baidu.editor.browser.ie &amp;&amp; baidu.editor.browser.version == 7)) {</p><p>//                uiUtils.removeStyle(popBodyEl, ‘width’);</p><p>//                uiUtils.removeStyle(popBodyEl, ‘height’);</p><p>//            }</p><pre><code>        var size = this.mesureSize();</code></pre><p>// 涂鸦窗口重新定义宽高</p><pre><code>        if (this.className == &#39;edui-for-scrawl&#39;) &#123;         size.width = &#39;917&#39;;         size.height = &#39;529&#39;;        &#125;        popBodyEl.style.width = size.width + &#39;px&#39;;        popBodyEl.style.height = size.height + &#39;px&#39;;        return size;    &#125;,</code></pre><p>2.给涂鸦框加上自定义颜色（在ueditor.all.js里面修改）</p><p>————————————————<br>版权声明：本文为CSDN博主「smile_girl_ha」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_31879707/article/details/54895512">https://blog.csdn.net/qq_31879707/article/details/54895512</a></p><h2 id="富文本编辑器-UEditor-的使用，参数配置（保存图片路径）"><a href="#富文本编辑器-UEditor-的使用，参数配置（保存图片路径）" class="headerlink" title="富文本编辑器 UEditor 的使用，参数配置（保存图片路径）"></a>富文本编辑器 UEditor 的使用，参数配置（保存图片路径）</h2><p>技术标签： <a href="https://www.pianshen.com/tag/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/">富文本编辑器</a> <a href="https://www.pianshen.com/tag/UEditor/">UEditor</a></p><iframe id="google_ads_iframe_/162717810/pianshen.com/before_content_0" title="3rd party ad content" name="google_ads_iframe_/162717810/pianshen.com/before_content_0" width="740" height="475" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" srcdoc data-google-container-id="2" data-load-complete="true" style="box-sizing: border-box; border: 0px; display: block; vertical-align: bottom; margin: 0px auto; min-width: 100%;"></iframe><p><a href="https://github.com/fex-team/ueditor">下载源代码</a></p><h3 id="1-引入ueditor文件，body中建立富文本容器"><a href="#1-引入ueditor文件，body中建立富文本容器" class="headerlink" title="1.引入ueditor文件，body中建立富文本容器"></a>1.引入ueditor文件，body中建立富文本容器</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/kadmin/zlmm/static/ueditor/ueditor.config.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/kadmin/zlmm/static/ueditor/ueditor.all.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/kadmin/zlmm/static/ueditor/lang/zh-cn/zh-cn.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span> ..... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>layui-form<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>layui-form-item layui-form-text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>layui-input-inline<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>editor<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/plain<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span><span class="token number">450</span>px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--容器建立，script id --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>....<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><h3 id="2-实例化编辑器，以及配置参数（参数可查看源码-ueditor-config-js-配置参数，尽可能不改源码！）"><a href="#2-实例化编辑器，以及配置参数（参数可查看源码-ueditor-config-js-配置参数，尽可能不改源码！）" class="headerlink" title="2.实例化编辑器，以及配置参数（参数可查看源码 ueditor.config.js 配置参数，尽可能不改源码！）"></a>2.实例化编辑器，以及配置参数（参数可查看源码 ueditor.config.js 配置参数，尽可能不改源码！）</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//实例化编辑器</span><span class="token keyword">var</span> ue <span class="token operator">=</span> UE<span class="token punctuation">.</span><span class="token function">getEditor</span><span class="token punctuation">(</span><span class="token string">'editor'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>toolbars<span class="token punctuation">:</span> <span class="token punctuation">[</span>   <span class="token punctuation">[</span>            <span class="token string">'undo'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//撤销</span>            <span class="token string">'bold'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//加粗</span>            <span class="token string">'underline'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//下划线</span>            <span class="token string">'preview'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//预览</span>            <span class="token string">'horizontal'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//分隔线</span>            <span class="token string">'inserttitle'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//插入标题</span>            <span class="token string">'cleardoc'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//清空文档</span>            <span class="token string">'fontfamily'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//字体</span>            <span class="token string">'fontsize'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//字号</span>            <span class="token string">'paragraph'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//段落格式</span>            <span class="token string">'simpleupload'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//单图上传</span>            <span class="token string">'insertimage'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//多图上传</span>            <span class="token string">'attachment'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//附件</span>            <span class="token string">'music'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//音乐</span>            <span class="token string">'inserttable'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//插入表格</span>            <span class="token string">'emotion'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//表情</span>            <span class="token string">'insertvideo'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//视频</span>            <span class="token string">'justifyleft'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//居左对齐</span>            <span class="token string">'justifyright'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//居右对齐</span>            <span class="token string">'justifycenter'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//居中对</span>            <span class="token string">'justifyjustify'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//两端对齐</span>            <span class="token string">'forecolor'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//字体颜色</span>            <span class="token string">'fullscreen'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//全屏</span>            <span class="token string">'edittip '</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//编辑提示</span>            <span class="token string">'customstyle'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//自定义标题</span>            <span class="token string">'template'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//模板</span>            <span class="token string">'source'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//源码</span>             <span class="token punctuation">]</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        elementPathEnabled<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>        autoHeightEnabled<span class="token punctuation">:</span><span class="token boolean">false</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ue<span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//赋值给UEditor</span>        ue<span class="token punctuation">.</span><span class="token function">setContent</span><span class="token punctuation">(</span><span class="token string">'&lt;?php echo $content;?>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//获取html内容，返回: &lt;p>hello&lt;/p></span>        <span class="token keyword">var</span> html <span class="token operator">=</span> ue<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取纯文本内容，返回: hello</span>        <span class="token keyword">var</span> txt  <span class="token operator">=</span> ue<span class="token punctuation">.</span><span class="token function">getContentTxt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="上传功能（主要是存储地址）在各自版本中的config-json中"><a href="#上传功能（主要是存储地址）在各自版本中的config-json中" class="headerlink" title="*上传功能（主要是存储地址）在各自版本中的config.json中"></a>*上传功能（主要是存储地址）在各自版本中的config.json中</h3><p>文件保存到相对于服务器www下地址。在上传成功后返回图片全路径</p><p>（</p><p>“imageUrlPrefix”: “<a href="http://127.0.0.1&quot;/">http://127.0.0.1&quot;</a>, /* 图片访问路径前缀 */</p><p>“imagePathFormat”: “/uploadnew/zlmm/ueditor/image/{yyyy}/{mm}/{dd}/{time}{rand:6}”</p><p>）</p><p>保存成功后返回地址：<a href="http://127.0.0.1/uploadnew/zlmm/ueditor/image/%7Byyyy%7D/%7Bmm%7D/%7Bdd%7D/%7Btime%7D%7Brand:6%7D">http://127.0.0.1/uploadnew/zlmm/ueditor/image/{yyyy}/{mm}/{dd}/{time}{rand:6}</a></p><pre><code>/* 前后端通信相关的配置,注释只允许使用多行方式 */&#123;    /* 上传图片配置项 */    &quot;imageActionName&quot;: &quot;uploadimage&quot;, /* 执行上传图片的action名称 */    &quot;imageFieldName&quot;: &quot;upfile&quot;, /* 提交的图片表单名称 */    &quot;imageMaxSize&quot;: 2048000, /* 上传大小限制，单位B */    &quot;imageAllowFiles&quot;: [&quot;.png&quot;, &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;], /* 上传图片格式显示 */    &quot;imageCompressEnable&quot;: true, /* 是否压缩图片,默认是true */    &quot;imageCompressBorder&quot;: 1600, /* 图片压缩最长边限制 */    &quot;imageInsertAlign&quot;: &quot;none&quot;, /* 插入的图片浮动方式 */    &quot;imageUrlPrefix&quot;: &quot;http://127.0.0.1&quot;, /* 图片访问路径前缀 */    &quot;imagePathFormat&quot;: &quot;/uploadnew/zlmm/ueditor/image/&#123;yyyy&#125;/&#123;mm&#125;/&#123;dd&#125;/&#123;time&#125;&#123;rand:6&#125;&quot;, /* 上传保存路径,可以自定义保存路径和文件名格式 */                                /* &#123;filename&#125; 会替换成原文件名,配置这项需要注意中文乱码问题 */                                /* &#123;rand:6&#125; 会替换成随机数,后面的数字是随机数的位数 */                                /* &#123;time&#125; 会替换成时间戳 */                                /* &#123;yyyy&#125; 会替换成四位年份 */                                /* &#123;yy&#125; 会替换成两位年份 */                                /* &#123;mm&#125; 会替换成两位月份 */                                /* &#123;dd&#125; 会替换成两位日期 */                                /* &#123;hh&#125; 会替换成两位小时 */                                /* &#123;ii&#125; 会替换成两位分钟 */                                /* &#123;ss&#125; 会替换成两位秒 */                                /* 非法字符 \ : * ? &quot; &lt; &gt; | */                                /* 具请体看线上文档: fex.baidu.com/ueditor/#use-format_upload_filename */     /* 涂鸦图片上传配置项 */    &quot;scrawlActionName&quot;: &quot;uploadscrawl&quot;, /* 执行上传涂鸦的action名称 */    &quot;scrawlFieldName&quot;: &quot;upfile&quot;, /* 提交的图片表单名称 */    &quot;scrawlPathFormat&quot;: &quot;/uploadnew/zlmm/ueditor/image/&#123;yyyy&#125;/&#123;mm&#125;/&#123;dd&#125;/&#123;time&#125;&#123;rand:6&#125;&quot;, /* 上传保存路径,可以自定义保存路径和文件名格式 */    &quot;scrawlMaxSize&quot;: 2048000, /* 上传大小限制，单位B */    &quot;scrawlUrlPrefix&quot;: &quot;http://127.0.0.1&quot;, /* 图片访问路径前缀 */    &quot;scrawlInsertAlign&quot;: &quot;none&quot;,     /* 截图工具上传 */    &quot;snapscreenActionName&quot;: &quot;uploadimage&quot;, /* 执行上传截图的action名称 */    &quot;snapscreenPathFormat&quot;: &quot;/uploadnew/zlmm/ueditor/image/&#123;yyyy&#125;/&#123;mm&#125;/&#123;dd&#125;/&#123;time&#125;&#123;rand:6&#125;&quot;, /* 上传保存路径,可以自定义保存路径和文件名格式 */    &quot;snapscreenUrlPrefix&quot;: &quot;http://127.0.0.1&quot;, /* 图片访问路径前缀 */    &quot;snapscreenInsertAlign&quot;: &quot;none&quot;, /* 插入的图片浮动方式 */     /* 抓取远程图片配置 */    &quot;catcherLocalDomain&quot;: [&quot;127.0.0.1&quot;, &quot;localhost&quot;, &quot;img.baidu.com&quot;],    &quot;catcherActionName&quot;: &quot;catchimage&quot;, /* 执行抓取远程图片的action名称 */    &quot;catcherFieldName&quot;: &quot;source&quot;, /* 提交的图片列表表单名称 */    &quot;catcherPathFormat&quot;: &quot;/uploadnew/zlmm/ueditor/image/&#123;yyyy&#125;/&#123;mm&#125;/&#123;dd&#125;/&#123;time&#125;&#123;rand:6&#125;&quot;, /* 上传保存路径,可以自定义保存路径和文件名格式 */    &quot;catcherUrlPrefix&quot;: &quot;http://127.0.0.1&quot;, /* 图片访问路径前缀 */    &quot;catcherMaxSize&quot;: 2048000, /* 上传大小限制，单位B */    &quot;catcherAllowFiles&quot;: [&quot;.png&quot;, &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;], /* 抓取图片格式显示 */     /* 上传视频配置 */    &quot;videoActionName&quot;: &quot;uploadvideo&quot;, /* 执行上传视频的action名称 */    &quot;videoFieldName&quot;: &quot;upfile&quot;, /* 提交的视频表单名称 */    &quot;videoPathFormat&quot;: &quot;/uploadnew/zlmm/ueditor/video/&#123;yyyy&#125;/&#123;mm&#125;/&#123;dd&#125;/&#123;time&#125;&#123;rand:6&#125;&quot;, /* 上传保存路径,可以自定义保存路径和文件名格式 */    &quot;videoUrlPrefix&quot;: &quot;http://127.0.0.1&quot;, /* 视频访问路径前缀 */    &quot;videoMaxSize&quot;: 102400000, /* 上传大小限制，单位B，默认100MB */    &quot;videoAllowFiles&quot;: [        &quot;.flv&quot;, &quot;.swf&quot;, &quot;.mkv&quot;, &quot;.avi&quot;, &quot;.rm&quot;, &quot;.rmvb&quot;, &quot;.mpeg&quot;, &quot;.mpg&quot;,        &quot;.ogg&quot;, &quot;.ogv&quot;, &quot;.mov&quot;, &quot;.wmv&quot;, &quot;.mp4&quot;, &quot;.webm&quot;, &quot;.mp3&quot;, &quot;.wav&quot;, &quot;.mid&quot;], /* 上传视频格式显示 */     /* 上传文件配置 */    &quot;fileActionName&quot;: &quot;uploadfile&quot;, /* controller里,执行上传视频的action名称 */    &quot;fileFieldName&quot;: &quot;upfile&quot;, /* 提交的文件表单名称 */    &quot;filePathFormat&quot;: &quot;/uploadnew/zlmm/ueditor/file/&#123;yyyy&#125;/&#123;mm&#125;/&#123;dd&#125;/&#123;time&#125;&#123;rand:6&#125;&quot;, /* 上传保存路径,可以自定义保存路径和文件名格式 */    &quot;fileUrlPrefix&quot;: &quot;http://127.0.0.1&quot;, /* 文件访问路径前缀 */    &quot;fileMaxSize&quot;: 51200000, /* 上传大小限制，单位B，默认50MB */    &quot;fileAllowFiles&quot;: [        &quot;.png&quot;, &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;,        &quot;.flv&quot;, &quot;.swf&quot;, &quot;.mkv&quot;, &quot;.avi&quot;, &quot;.rm&quot;, &quot;.rmvb&quot;, &quot;.mpeg&quot;, &quot;.mpg&quot;,        &quot;.ogg&quot;, &quot;.ogv&quot;, &quot;.mov&quot;, &quot;.wmv&quot;, &quot;.mp4&quot;, &quot;.webm&quot;, &quot;.mp3&quot;, &quot;.wav&quot;, &quot;.mid&quot;,        &quot;.rar&quot;, &quot;.zip&quot;, &quot;.tar&quot;, &quot;.gz&quot;, &quot;.7z&quot;, &quot;.bz2&quot;, &quot;.cab&quot;, &quot;.iso&quot;,        &quot;.doc&quot;, &quot;.docx&quot;, &quot;.xls&quot;, &quot;.xlsx&quot;, &quot;.ppt&quot;, &quot;.pptx&quot;, &quot;.pdf&quot;, &quot;.txt&quot;, &quot;.md&quot;, &quot;.xml&quot;    ], /* 上传文件格式显示 */    /* 列出指定目录下的图片 */    &quot;imageManagerActionName&quot;: &quot;listimage&quot;, /* 执行图片管理的action名称 */    &quot;imageManagerListPath&quot;: &quot;/uploadnew/zlmm/ueditor/image/&quot;, /* 指定要列出图片的目录 */    &quot;imageManagerListSize&quot;: 20, /* 每次列出文件数量 */    &quot;imageManagerUrlPrefix&quot;: &quot;http://127.0.0.1&quot;, /* 图片访问路径前缀 */    &quot;imageManagerInsertAlign&quot;: &quot;none&quot;, /* 插入的图片浮动方式 */    &quot;imageManagerAllowFiles&quot;: [&quot;.png&quot;, &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;], /* 列出的文件类型 */    /* 列出指定目录下的文件 */    &quot;fileManagerActionName&quot;: &quot;listfile&quot;, /* 执行文件管理的action名称 */    &quot;fileManagerListPath&quot;: &quot;/uploadnew/zlmm/ueditor/file/&quot;, /* 指定要列出文件的目录 */    &quot;fileManagerUrlPrefix&quot;: &quot;http://127.0.0.1&quot;, /* 文件访问路径前缀 */    &quot;fileManagerListSize&quot;: 20, /* 每次列出文件数量 */    &quot;fileManagerAllowFiles&quot;: [        &quot;.png&quot;, &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;,        &quot;.flv&quot;, &quot;.swf&quot;, &quot;.mkv&quot;, &quot;.avi&quot;, &quot;.rm&quot;, &quot;.rmvb&quot;, &quot;.mpeg&quot;, &quot;.mpg&quot;,        &quot;.ogg&quot;, &quot;.ogv&quot;, &quot;.mov&quot;, &quot;.wmv&quot;, &quot;.mp4&quot;, &quot;.webm&quot;, &quot;.mp3&quot;, &quot;.wav&quot;, &quot;.mid&quot;,        &quot;.rar&quot;, &quot;.zip&quot;, &quot;.tar&quot;, &quot;.gz&quot;, &quot;.7z&quot;, &quot;.bz2&quot;, &quot;.cab&quot;, &quot;.iso&quot;,        &quot;.doc&quot;, &quot;.docx&quot;, &quot;.xls&quot;, &quot;.xlsx&quot;, &quot;.ppt&quot;, &quot;.pptx&quot;, &quot;.pdf&quot;, &quot;.txt&quot;, &quot;.md&quot;, &quot;.xml&quot;    ] /* 列出的文件类型 */&#125;</code></pre></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>.Net Core微服务入门全纪录</title>
      <link href="2021/03/23/abp/net-core-wei-fu-wu-ru-men-xiao-hei/"/>
      <url>2021/03/23/abp/net-core-wei-fu-wu-ru-men-xiao-hei/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/eB4h7iCQqA5R08-nkjH_hw">https://mp.weixin.qq.com/s/eB4h7iCQqA5R08-nkjH_hw</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这篇博客主要目的是记录一下自己的学习过程，只能是简单入门级别的，因为水平有限就写到哪算哪吧，写的不对之处欢迎指正。代码放在：</p><p><a href="https://github.com/xiajingren/NetCoreMicroserviceDemo">https://github.com/xiajingren/NetCoreMicroserviceDemo</a></p><h1 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h1><p>关于微服务的概念解释网上有很多… 个人理解，微服务是一种系统架构模式，它和语言无关，和框架无关，和工具无关，和服务器环境无关… 微服务思想是将传统的单体系统按照业务拆分成多个职责单一、且可独立运行的接口服务。至于服务如何拆分，没有明确的定义。几乎任何后端语言都能做微服务开发。微服务也并不是完美无缺的，微服务架构会带来更多的问题，增加系统的复杂度，引入更多的技术栈…</p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSEXLyzxb0wQawlOtqHiboL2prBxj9o6xQaViaDVWgaSySy0w3NnHm77Zw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">一个客户端，一个产品服务，一个订单服务。3个项目都是asp.net core web应用程序。创建项目的时候记得启用一下Docker支持，或者后面添加也行。</p><p>为产品、订单服务添加一些基础代码，就简单的返回一下 服务名称，当前时间，服务的ip、端口。<img src="https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSHyjS2CibgV43lP5mMxticX7kEEibvXewvGhprll7p993EAUOMmI9dHxhQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSo6u6qT92TETncAq3KKSe6Yhl8nRxWWtahSNib6nHpc4tcEADElEPeGg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h1 id="在Docker中运行服务"><a href="#在Docker中运行服务" class="headerlink" title="在Docker中运行服务"></a>在Docker中运行服务</h1><p>为了方便，我使用Docker来运行服务，不用Docker也行，关于docker的安装及基本使用就不介绍了。</p><ul><li>build镜像：</li></ul><p>在项目根目录打开PowerShell窗口执行：<code>docker build -t productapi -f ./Product.API/Dockerfile .</code><img src="https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSgoOyp6bkiaB3CNcEQl15CTN705PD10SAm2s7q3cubRTj5UdeDfB8t2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSFaH0mHKO6SIPTViblC8sascddQ1NXX1GtKb4BwicCAS1lqohLqY2BwKA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">Successfully代表build成功了。</p><ul><li>运行容器:</li></ul><p>执行：<code>docker run -d -p 9050:80 --name productservice productapi</code><img src="https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSpbxFrfy8Y26UAiaIBXbibRZd0zicF5vfz25mMlwNLrJdAoOuCoLiaUT2Sg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>执行：<code>docker ps</code>查看运行的容器：<img src="https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSGOUibySRHobjHD9U4iavIGBkWcVKQ8MedfAaFibud4Qic9URGyNtdnxsnQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>没问题，使用浏览器访问一下接口：<img src="https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSyB7ttFwicbmU5tWcHRNzMia3VIkFSNa9icRH6kqDFySvibYVUwAfYQH5ew/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">也没问题，其中的ip端口是Docker容器内部的ip端口，所以端口是80，这个无所谓。</p><ul><li>产品服务部署好了，下面部署一下订单服务，也是同样的流程，就把指令简单贴一下吧：</li></ul><p>build镜像：<code>docker build -t orderapi -f ./Order.API/Dockerfile .</code>运行容器：<code>docker run -d -p 9060:80 --name orderservice orderapi</code>浏览器访问一下：<img src="https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSia7icGGWJxxUdh6ibLFnQS9nQ4LxibsLE5WEDO8RVuLwibAia4xL5cmHJvaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">OK，订单服务也部署完成了。</p><h1 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h1><p>客户端我这里只做了一个web客户端，实际可能是各种业务系统、什么PC端、手机端、小程序。。。这个明白就好，为了简单就不搞那么多了。</p><ul><li>因为客户端需要http请求服务端接口，所以需要一个http请求客户端，我个人比较习惯RestSharp，安利一波：<a href="https://github.com/restsharp/RestSharp![%E5%9B%BE%E7%89%87](https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSZ0kt7NTA38AibKpn5ndZVm0icftosNsHsySvCYTONwclTbrB2oosedGw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)">https://github.com/restsharp/RestSharp![图片](https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSZ0kt7NTA38AibKpn5ndZVm0icftosNsHsySvCYTONwclTbrB2oosedGw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</a></li><li>添加基础代码：<img src="https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSjkbnGhFficV5eUfzBW2LLMfWc2gibRJgoxg6vOZ6QYibyhicgfm6uia370A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li></ul><p>IServiceHelper.cs：</p><pre><code>    public interface IServiceHelper    &#123;        /// &lt;summary&gt;        /// 获取产品数据        /// &lt;/summary&gt;        /// &lt;returns&gt;&lt;/returns&gt;        Task&lt;string&gt; GetProduct();        /// &lt;summary&gt;        /// 获取订单数据        /// &lt;/summary&gt;        /// &lt;returns&gt;&lt;/returns&gt;        Task&lt;string&gt; GetOrder();    &#125;</code></pre><p>ServiceHelper.cs：</p><pre><code>    public class ServiceHelper : IServiceHelper    &#123;        public async Task&lt;string&gt; GetOrder()        &#123;            string serviceUrl = &quot;http://localhost:9060&quot;;//订单服务的地址，可以放在配置文件或者数据库等等...            var Client = new RestClient(serviceUrl);            var request = new RestRequest(&quot;/orders&quot;, Method.GET);            var response = await Client.ExecuteAsync(request);            return response.Content;        &#125;        public async Task&lt;string&gt; GetProduct()        &#123;            string serviceUrl = &quot;http://localhost:9050&quot;;//产品服务的地址，可以放在配置文件或者数据库等等...            var Client = new RestClient(serviceUrl);            var request = new RestRequest(&quot;/products&quot;, Method.GET);            var response = await Client.ExecuteAsync(request);            return response.Content;        &#125;    &#125;</code></pre><p>Startup.cs：</p><pre><code>    public class Startup    &#123;        public Startup(IConfiguration configuration)        &#123;            Configuration = configuration;        &#125;        public IConfiguration Configuration &#123; get; &#125;        // This method gets called by the runtime. Use this method to add services to the container.        public void ConfigureServices(IServiceCollection services)        &#123;            services.AddControllersWithViews();                        //注入IServiceHelper            services.AddSingleton&lt;IServiceHelper, ServiceHelper&gt;();        &#125;        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)        &#123;            if (env.IsDevelopment())            &#123;                app.UseDeveloperExceptionPage();            &#125;            else            &#123;                app.UseExceptionHandler(&quot;/Home/Error&quot;);            &#125;            app.UseStaticFiles();            app.UseRouting();            app.UseAuthorization();            app.UseEndpoints(endpoints =&gt;            &#123;                endpoints.MapControllerRoute(                    name: &quot;default&quot;,                    pattern: &quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;&quot;);            &#125;);        &#125;    &#125;</code></pre><p>HomeController.cs：</p><pre><code>    public class HomeController : Controller    &#123;        private readonly ILogger&lt;HomeController&gt; _logger;        private readonly IServiceHelper _serviceHelper;        public HomeController(ILogger&lt;HomeController&gt; logger, IServiceHelper serviceHelper)        &#123;            _logger = logger;            _serviceHelper = serviceHelper;        &#125;        public async Task&lt;IActionResult&gt; Index()        &#123;            ViewBag.OrderData = await _serviceHelper.GetOrder();            ViewBag.ProductData = await _serviceHelper.GetProduct();            return View();        &#125;        public IActionResult Privacy()        &#123;            return View();        &#125;        [ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]        public IActionResult Error()        &#123;            return View(new ErrorViewModel &#123; RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier &#125;);        &#125;    &#125;</code></pre><p>Index.cshtml：</p><pre><code>@&#123;    ViewData[&quot;Title&quot;] = &quot;Home Page&quot;;&#125;&lt;div class=&quot;text-center&quot;&gt;    &lt;h1 class=&quot;display-4&quot;&gt;Welcome&lt;/h1&gt;    &lt;p&gt;        @ViewBag.OrderData    &lt;/p&gt;    &lt;p&gt;        @ViewBag.ProductData    &lt;/p&gt;&lt;/div&gt;</code></pre><p>代码比较简单，这里就不用docker了，直接控制台启动，使用浏览器访问：<img src="https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSNgMOWVtvxJJs8ZANkib46aibWbIk6aKNpNSOlVNJ2r1bwccFXdTea4fQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li>一切正常。进行到这里，各个服务也独立运行了，客户端也能正常调用了，貌似算是完成一个简易的微服务了。但是，微服务架构最重要的原则就是——“高可用”。以上的做法明显不能满足高可用性，因为任何一个服务挂掉，所有依赖这个服务的业务系统都会受影响。</li></ul><p>停止一下订单服务：<code>docker stop orderservice</code><img src="https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSf7ytF6RXy3Wsdn3NS0xJRlKTiaul3rAibR4gN81949t3rDfkOcvZWWFQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz_png/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bScKxfeG8RxKrureyUK7rYkteXm1oLfql0kfjCuhiaAmzIL3aCsUAoURw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">订单服务停止，导致客户端业务系统无法获取订单数据。要解决这个问题，很容易想到：集群。</p><h1 id="简单的服务集群"><a href="#简单的服务集群" class="headerlink" title="简单的服务集群"></a>简单的服务集群</h1><p>既然单个服务实例有挂掉的风险，那么部署多个服务实例就好了嘛，只要大家不同时全挂就行。</p><ul><li>使用docker运行多个服务实例：</li></ul><pre><code>docker run -d -p 9061:80 --name orderservice1 orderapidocker run -d -p 9062:80 --name orderservice2 orderapidocker run -d -p 9051:80 --name productservice1 productapidocker run -d -p 9052:80 --name productservice2 productapi</code></pre><p>现在订单服务和产品服务都增加到3个服务实例。</p><ul><li>那么稍微改造一下客户端代码吧：ServiceHelper.cs：</li></ul><pre><code>public class ServiceHelper : IServiceHelper    &#123;        public async Task&lt;string&gt; GetOrder()        &#123;            string[] serviceUrls = &#123; &quot;http://localhost:9060&quot;, &quot;http://localhost:9061&quot;, &quot;http://localhost:9062&quot; &#125;;//订单服务的地址，可以放在配置文件或者数据库等等...            //每次随机访问一个服务实例            var Client = new RestClient(serviceUrls[new Random().Next(0, 3)]);            var request = new RestRequest(&quot;/orders&quot;, Method.GET);            var response = await Client.ExecuteAsync(request);            return response.Content;        &#125;        public async Task&lt;string&gt; GetProduct()        &#123;            string[] serviceUrls = &#123; &quot;http://localhost:9050&quot;, &quot;http://localhost:9051&quot;, &quot;http://localhost:9052&quot; &#125;;//产品服务的地址，可以放在配置文件或者数据库等等...            //每次随机访问一个服务实例            var Client = new RestClient(serviceUrls[new Random().Next(0, 3)]);            var request = new RestRequest(&quot;/products&quot;, Method.GET);            var response = await Client.ExecuteAsync(request);            return response.Content;        &#125;    &#125;</code></pre><p>当然拿到这些服务地址可以自己做复杂的负载均衡策略，比如轮询，随机，权重等等 都行，甚至在中间弄个nginx也可以。这些不是重点，所以就简单做一个随机吧，每次请求来了随便访问一个服务实例。</p><ul><li>浏览器测试一下：<img src="https://mmbiz.qpic.cn/mmbiz_gif/cJJ4je5Nk3JUiaKbcHmISWXkSjhHNj8bSavsibWO5NANJuAXwZETkqGbicgxYfgLbjYu5zu3OKexB4aeyLuyonmaw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片">可以看到请求被随机分配了。但是这种做法依然不安全，如果随机访问到的实例刚好挂掉，那么业务系统依然会出问题。简单处理思路是：1.如果某个地址请求失败了，那么换一个地址接着执行。2.如果某个地址的请求连续多次失败了，那么就移除这个地址，下次就不会访问到它了。。。。。。。业务系统实现以上逻辑，基本上风险就很低了，也算是大大增加了系统可用性了。</li><li>然后思考另一个问题：</li></ul><p>实际应用中，上层的业务系统可能非常多，为了保证可用性，每个业务系统都去考虑服务实例挂没挂掉吗？而且实际应用中服务实例的数量或者地址大多是不固定的，例如双十一来了，流量大了，增加了一堆服务实例，这时候每个业务系统再去配置文件里配置一下这些地址吗？双十一过了又去把配置删掉吗？显然是不现实的，服务必须要做到可灵活伸缩。</p><ul><li>这时候就引入一个名词：服务注册与发现</li></ul>]]></content>
      
      
      <categories>
          
          <category> abp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> abp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/23/abp/abp-shi-zhan-hui-zong/"/>
      <url>2021/03/23/abp/abp-shi-zhan-hui-zong/</url>
      
        <content type="html"><![CDATA[<h2 id="ABP-使用-DontWrapResult-注解去掉接口返回的“-abp”"><a href="#ABP-使用-DontWrapResult-注解去掉接口返回的“-abp”" class="headerlink" title="ABP 使用[DontWrapResult]注解去掉接口返回的“__abp”"></a>ABP 使用[DontWrapResult]注解去掉接口返回的“__abp”</h2><p>Johan. 2020-02-12 19:18:25  20553  收藏<br>分类专栏： ABP 文章标签： ABP _abp 自定义返回 去掉 修改<br>版权<br>在开发过程中可能会遇到接口需要返回自定义数据结构，ABP 在这方面也有考虑到。给方法加上注解即可，代码如下：</p><pre class=" language-c#"><code class="language-c#">[DontWrapResult]public async Task<object> GetCustomInfo(xXxInput input){    return new    {        a = 1,        b = "2",        c = false    };}</code></pre><p>生效的代码是第一行，这样返回的数据结构就是不包含 result ，所见即所得。</p><pre class=" language-c#"><code class="language-c#">{    "a": 1,    "b": "2",    "c": false}</code></pre><p>如果不加，返回结构就会被包裹一层。</p><pre class=" language-c#"><code class="language-c#">{    "result": {        "a": 1,        "b": "2",        "c": false    },    "targetUrl": null,    "success": false,    "error": null,    "unAuthorizedRequest": false,    "__abp": true}</code></pre><p>根据场景实际需求按需选用。<br>————————————————<br>版权声明：本文为CSDN博主「Johan.」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/S2T11Enterprise/article/details/104039673">https://blog.csdn.net/S2T11Enterprise/article/details/104039673</a></p><h2 id="ABP框架中使用MySQL数据库"><a href="#ABP框架中使用MySQL数据库" class="headerlink" title="ABP框架中使用MySQL数据库"></a>ABP框架中使用MySQL数据库</h2><h2 id="1-移除SQL-Server的Nuget包"><a href="#1-移除SQL-Server的Nuget包" class="headerlink" title="1.移除SQL Server的Nuget包"></a>1.移除SQL Server的Nuget包</h2><p>打开程序包管理器控制台，并选中.EntityFrameworkCore</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210324215515447.png" alt="image-20210324215515447"></p><p>然后依次执行：</p><pre class=" language-bash"><code class="language-bash">uninstall-package microsoft.entityframeworkcore.designuninstall-package microsoft.entityframeworkcore.sqlserver</code></pre><h2 id="2-安装MySQL的Nuget包"><a href="#2-安装MySQL的Nuget包" class="headerlink" title="2.安装MySQL的Nuget包"></a>2.安装MySQL的Nuget包</h2><p>依次执行：</p><pre class=" language-bash"><code class="language-bash">install-package pomelo.entityframeworkcore.mysql.designinstall-package pomelo.entityframeworkcore.mysql</code></pre><h2 id="3-更改配置文件"><a href="#3-更改配置文件" class="headerlink" title="3.更改配置文件"></a>3.更改配置文件</h2><p>在解决方案的EntityFrameCore层找到DbContextConfigurer文件，并做如下修改：</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210324215502947.png" alt="image-20210324215502947"></p><h2 id="4-修改数据库连接字符串"><a href="#4-修改数据库连接字符串" class="headerlink" title="4.修改数据库连接字符串"></a>4.修改数据库连接字符串</h2><p>在appsetting.json文件中修改数据库连接字符串：</p><pre><code>&quot;Default&quot;: &quot;Server=localhost;Port=3306;Database=你的数据库名;Uid=数据库用户名;Pwd=密码;&quot;</code></pre><h2 id="5-添加数据迁移"><a href="#5-添加数据迁移" class="headerlink" title="5.添加数据迁移"></a>5.添加数据迁移</h2><p>删除EntityFrameCore层中Migrations文件夹里的所有文件，别删除Migrations文件夹，然后重新生成解决方案，接着打开程序包管理器控制台，选中.EntityFrameworkCore,输入以下命令：</p><pre class=" language-bash"><code class="language-bash">Add-Migration Init</code></pre><p>此时你的Migrations文件夹里会新增几个文件，接着输入命令:</p><pre><code>Update-Database</code></pre><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210324215534296.png" alt="image-20210324215534296"></p><p>数据库更新成功</p><h2 id="配置ABP的redis"><a href="#配置ABP的redis" class="headerlink" title="配置ABP的redis"></a>配置ABP的redis</h2><p>铭毅雨 2020-12-24 09:38:38 95 收藏<br>分类专栏： netcore redis ABP 文章标签： redis ABP<br>版权</p><ol><li>NguGet 引用 Abp.RedisCache</li></ol><p>根据自身ABP框架版本来引用,这边我是4.9版本</p><ol start="2"><li>在 appsettings.json加上Redis服务器配置</li></ol><p>“RedisCache”: {</p><p>“ConnectionString”: “127.0.0.1:6379”,</p><p>“DatabaseId”: “6”</p><p>},</p><ol start="3"><li>配置缓存为redis,不配置的话,走的是内存缓存</li></ol><p>类的头部加入:</p><p>typeof(AbpRedisCacheModule))</p><p>PreInitialize方法中加入:</p><p>Configuration.Caching.UseRedis(option =&gt;</p><p>{</p><p>option.ConnectionString = _appConfiguration.GetSection(“RedisCache:ConnectionString”).Value;</p><p>option.DatabaseId = _appConfiguration.GetValue<int>(“RedisCache:DatabaseId”);</int></p><p>});</p><ol start="4"><li>原有实体取值改造</li></ol><p>var entity = _baseRepository.Get(id);</p><p>改成</p><p>var entity = _cacheManager.GetCache(typeof(TEntity).Name).Get(id, () =&gt; CacheGetEntity(id));</p><p>private TEntity CacheGetEntity(int id)</p><p>{</p><p>var entity = _baseRepository.Get(id);</p><p>if (entity == null) { entity = new TEntity(); }</p><p>return entity;</p><p>}</p><ol start="5"><li>redis的启动 redis-server.exe 双击就启动啦.</li></ol><p>redis-cli.exe 双击启动客户端,可以看见ip</p><ol start="6"><li><p>打开管理工具,清掉影响的数据</p></li><li><p>启动程序访问</p></li></ol><p>增加了两个缓存<br>————————————————</p><p>一开始一直运行不起来，原来是dev里的配置<img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210325232514849.png" alt="image-20210325232514849"></p>]]></content>
      
      
      <categories>
          
          <category> abp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> abp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法--堆栈</title>
      <link href="2021/03/22/kaikeba/suan-fa-lian-biao/"/>
      <url>2021/03/22/kaikeba/suan-fa-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构和算法–堆栈"><a href="#数据结构和算法–堆栈" class="headerlink" title="数据结构和算法–堆栈"></a>数据结构和算法–堆栈</h1><p>[145] 二叉树的后序遍历</p><pre><code>var postorderTraversal = function(root) &#123;    let res = new Array();    return postorderTraversalNode(root, res);&#125;;var postorderTraversalNode = function(node, res) &#123;    if (node) &#123;        postorderTraversalNode(node.left, res);        postorderTraversalNode(node.right, res);        res.push(node.val);    &#125;    return res;&#125;</code></pre><pre><code>var postorderTraversal = function(root) &#123;    let res = [];    if (!root) return res;    let stack = [root];    while (stack.length) &#123;        root = stack.pop();        res.unshift(root.val);        if (root.left) stack.push(root.left);        if (root.right) stack.push(root.right);    &#125;    return res;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>abp学习博客（2016收录）</title>
      <link href="2021/03/22/abp/2016abp-xue-xi-bo-ke-tkb-zhi-jian/"/>
      <url>2021/03/22/abp/2016abp-xue-xi-bo-ke-tkb-zhi-jian/</url>
      
        <content type="html"><![CDATA[<p><strong>作者：<a href="http://farb.cnblogs.com/">tkb至简</a>    来源：<a href="http://farb.cnblogs.com/">http://farb.cnblogs.com/</a></strong></p><h1 id="ABP理论学习之开篇介绍"><a href="#ABP理论学习之开篇介绍" class="headerlink" title="     ABP理论学习之开篇介绍         "></a><a href="https://www.cnblogs.com/farb/p/ABPIntro.html">     ABP理论学习之开篇介绍         </a></h1><p><strong><a href="http://www.cnblogs.com/farb/p/ABPTheory.html">返回总目录</a></strong></p><hr><p>为了和2016年春节赛跑，完成该系列博客，我牺牲了今天中午的时间来完成该系列的第一篇————开篇介绍。开篇介绍嘛，读过大学教材的同学都知道，这玩意总是那么无聊，跟考试没关系，干脆直接跳过，呵呵，多么美好的大学时光啊！不过，现在想想，开篇介绍确实不怎么重要，它只是告诉我们今后我要开始讲什么了，主要讲什么，大概浏览下重点。<br> 哦了，不扯了，时间不多了，干活！</p><hr><h2 id="本篇目录"><a href="#本篇目录" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPIntro.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPIntro.html#sample">快速样例</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPIntro.html#others">其他</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPIntro.html#startup">启动模板</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPIntro.html#touse">如何使用</a></strong></li></ul><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍###"></a>介绍###</h3><p>我们总是基于不同的需求创建不同的应用，但是在一定程度上，总在反复地实现通用而相似的结构。这些通用的结构包括<strong>授权，验证，异常处理，日志，本地化，数据库连接管理，设置管理，审计日志等</strong>。而且，我们总是在构建体系结构和最佳实践，比如<strong>分层</strong>和<strong>模块化</strong>架构，<strong>领域驱动设计（DDD），依赖注入等等</strong>。同时也在尝试基于<strong>惯例</strong>开发应用。</p><p>因为这些都是非常耗时的，并且对于每个项目单独创建是很困难的，所以很多公司都会创建自己私有的框架。通过使用私有的框架，他们总是可以快速地开发新的应用，同时应用的bug又会更少。当然了，不是所有的公司都是那么幸运了，你以为中国所有的公司都是BAT啊？！大多数公司还是没有<strong>时间，预算和团队</strong>来开发他们自己的私人框架。即使他们有可能构建这么一个框架，<strong>写文档，培训开发者以及维护</strong>也是很难的。</p><p>ABP是一个<strong>开源的且文档友好的应用框架</strong>，起始的想法是，“开发一款为所有公司和开发者通用的框架！”。它不仅仅是一个框架，更提供了一个基于<strong>DDD</strong>和<strong>最佳实践</strong>的健壮的<strong>体系模型</strong>。</p><h3 id="快速样例"><a href="#快速样例" class="headerlink" title="快速样例###"></a>快速样例###</h3><p>一起来研究一个简单的类来看看ABP有哪些好处 ：</p><pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService, ITaskAppService{    private readonly IRepository<Task> _taskRepository;    public TaskAppService(IRepository<Task> taskRepository)    {        _taskRepository = taskRepository;    }    [AbpAuthorize(MyPermissions.UpdatingTasks)]    public async Task UpdateTask(UpdateTaskInput input)    {        Logger.Info("Updating a task for input: " + input);        var task = await _taskRepository.FirstOrDefaultAsync(input.TaskId);        if (task == null)        {            throw new UserFriendlyException(L("CouldNotFoundTheTaskMessage"));        }        input.MapTo(task);    }}</code></pre><p>这里我们看到了一个简单的应用服务方法。在DDD中，表现层直接使用应用服务来执行该应用的<strong>用例</strong>（其实就是一些操作方法）。我们还可以考虑使用Ajax调用上面的<em>UpdateTask</em>方法。</p><p>下面让我们总结一下ABP的一些优点：</p><ul><li><strong>依赖注入</strong>：ABP使用并提供了一个健壮而又传统的DI基础设施。因为上面的类是在一个应用服务中定义的，所以它会按照惯例约定短暂地（每个请求创建一次）注册到DI容器中。它也简单地注入了所有依赖（本例中注入了<em>IRepository</em>）。</li><li><strong>仓储</strong>：ABP可以为每一个实体创建一个默认的仓储（本例中是<em>IRepository</em>）。默认的仓储有许多有用的方法，如本例中的 <em>FirstOrDefault</em>。我们也可以根据我们的需求轻易地扩展默认仓储。仓储抽象了DBMS和ORM，并简化了数据的访问逻辑。</li><li><strong>授权</strong>：ABP可以检测权限。如果当前的用户没有“updating task”的权限或者没登录，那么ta不能访问<em>UpdateTask</em>方法。它使用声明式的特性简化了授权，而且还有其他的授权方法。</li><li><strong>验证</strong>：ABP会自动检测输入是否为null。它也基于标准的数据注解特性和自定义的验证规则验证输入对象的所有属性。如果请求不合法，那么它会抛出一个合适的验证异常。</li><li><strong>审计日志</strong>：用户，浏览器，IP地址，调用服务，方法，参数，调用时间，执行时长和其他的一些信息也会基于惯例和配置为每个请求自动地保存。</li><li><strong>工作单元（Unit of Work）</strong>：在ABP中，每个应用服务方法默认视为一个工作单元。它会自动创建一个连接并在方法的开始位置开启一个事务。如果方法不报异常地成功完成了，那么事务会提交并且连接被释放。即使该方法使用了不同的仓储或者方法，它们全部也都是原子的（事务的）。当事务提交时，实体的所有改变都会自动保存。因此，正如这里展示的那样，我们甚至都不用调用**_repository.Update(task)**方法。</li><li><strong>异常处理</strong>：在一个使用了ABP框架的Web应用中，我们基本上不用处理异常。所有的异常都会默认自动处理。如果一个异常发生了，那么ABP会自动地记录它，然后返回给客户端一个合适的结果。比如，如果这是一个Ajax请求，那么它会返回一个JSON到客户端，指明发生了一个错误。本例中使用了一个<em>UserFriendlyException</em>，这样就隐藏了客户端实际的异常信息。它也理解并处理客户端的错误，最后将合适的信息呈现给用户。</li><li><strong>日志</strong>：我们可以使用在基类中定义的Logger来写日志。ABP默认使用了Log4Net，但是它是可改变的或可配置的。</li><li><strong>本地化（Localization）</strong>：注意当抛出异常的时候我们使用了L方法。因此，它会基于当前用户的文化自动进行本地化。当然，我们可以在某些地方定义<em>CouldNotFoundTheTaskMessage</em>。</li><li><strong>自动映射</strong>：上面的最后一行代码，我们使用了ABP的MapTo扩展方法将输入对象的属性映射到实体属性。它使用了AutoMapper库来执行映射。因此，我们可以基于命名惯例轻易地将属性从一个对象上映射到另一个对象上。我的AutoMapper系列学习博客：**<a href="http://www.cnblogs.com/farb/p/AutoMapperContent.html">http://www.cnblogs.com/farb/p/AutoMapperContent.html</a> **。</li><li><strong>动态Web API层</strong>：实际上，<em>TaskAppService</em> 是一个简单的类（甚至不需要从<em>ApplicationService</em> 继承）。我们一般会写一个Web API Controller包装器来将方法暴露给javascript客户端。ABP在运行时会自动完成。这样，我们可以从客户端直接使用应用服务方法。</li><li><strong>动态Ajax代理</strong>：ABP创建了javascript代理方法，它们可以调用应用服务方法就像调用客户端的javascript方法一样简单。</li></ul><p>在这么一个简单的类中，我们看到了ABP的优势。所有的这些任务正常情况下都是要花费很多时间的，但是所有的这些ABP自动帮我们完成了。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他###"></a>其他###</h3><p>除了这个简单的例子，ABP也提供了一个健壮的基础设施和应用模型。下面是ABP的一下其他特征：</p><ul><li>模块化：提供了一个健壮的基础设施来生成可复用的模块。</li><li>数据过滤器：提供了自动的数据过滤来实现一些模式，比如软删除和多租户。</li><li>多租户：支持单数据库、多客户形式的多租户。</li><li>设置管理：提供了健壮的基础设施类获得或者更改应用，租户和用户级别的设置。</li><li>单元测试和集成测试：基于可测试性构建，也提供了一些基类来简化单元测试和集成测试。</li></ul><p>更多的特征，请认真阅读其他文档。</p><h3 id="启动模板"><a href="#启动模板" class="headerlink" title="启动模板###"></a>启动模板###</h3><p>开始一个新的解决方案，创建层，安装nuget包，创建一个简单的布局和菜单…所有的这些都是非常耗时的。</p><p>ABP提供了一个预生成的**<a href="http://www.aspnetboilerplate.com/Templates">启动模板</a><strong>，有了它，创建一个新的解决方案更容易了。模板支持</strong>SPA（单页应用）<strong>和</strong>MPA（多页应用）**。而且，我们可以选择不同的ORM。</p><h1 id="ABP理论学习之N层架构"><a href="#ABP理论学习之N层架构" class="headerlink" title="     ABP理论学习之N层架构         "></a><a href="https://www.cnblogs.com/farb/p/ABPNLayer.html">     ABP理论学习之N层架构         </a></h1><p>自从写这个系列博客之后，发现很多园友还是希望有个直接运行的demo，其实在github上就有官方的demo，我直接把这demo的链接放到这里吧，另外，我分析，这些找不到demo的同学，很可能是不怎么用github，可能的原因就是英文不好。所以还是希望程序员多看看英文文档，一开始看得很慢不要紧，时间久了，速度绝对能上去。因为都是技术性的文章，没有特别难的语法，能让大家退而却步的最多是些生词，这个就要靠大家积累常见的词汇了，一些生僻词的话查一下意思，理解了那句话就可以过了。</p><p>跟ABP相关的所有源码，包括zero，demo，都在这个目录下了，大家可以一个个点击看一下。下面做一稍微解释。</p><p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211000853121-406694237.png" alt="img"><br> <img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211001224840-1457640679.png" alt="img"><br> <img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211001755105-1002490250.png" alt="img"></p><hr><h2 id="本篇目录-1"><a href="#本篇目录-1" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNLayer.html#intro">介绍</a></strong></li><li><a href="https://www.cnblogs.com/farb/p/ABPNLayer.html#abp">ABP架构</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNLayer.html#domain">领域层</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNLayer.html#app">应用层</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNLayer.html#infra">基础设施层</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNLayer.html#ui">Web和展现层</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNLayer.html#other">其他</a></strong></li></ul></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNLayer.html#summary">总结</a></strong></li></ul><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍###"></a>介绍###</h3><p>对应用代码基进行分层可以帮助降低复杂度和提高代码复用性，这已经成为广为接受的技巧。为了实现分层的架构，ABP遵循以下<strong>DDD（领域驱动模型）</strong>的原则。在DDD中，有四个基础层：</p><ul><li><strong>表现层</strong>：用户访问的接口，使用应用层实现用户交互。</li><li><strong>应用层</strong>：表现层和领域层之间的媒介。负责组织业务对象，以执行特定的应用任务。</li><li><strong>领域层</strong>：包括业务对象和原则。这是应用的核心。</li><li><strong>基础设施层</strong>：为支持更高层提供了广泛的技术能力。基础设施层的一个例子是仓储，它可以通过ORM框架和数据库进行交互。</li></ul><p>也可能会加入额外必要的层。以下就是一个例子：</p><ul><li><strong>分布式服务层</strong>：将应用的功能暴露给远程客户端。可以提供这个层的工具包括Asp.Net Web API和WCF。</li></ul><p>这些都是以领域为中心的架构的通用层次。基于实现的话，可能还会稍有不同。</p><h3 id="ABP架构"><a href="#ABP架构" class="headerlink" title="ABP架构###"></a>ABP架构###</h3><p>层次和结构的概览如下图所示：<br> <img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211005057090-801424200.png" alt="img"><br> 实际解决方案中的项目分层如下：<br> <img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211005342715-1812391209.png" alt="img"></p><p>一层可以为一个或多个程序集。对于第三方依赖创建不止一个程序集可能会特别好（比如NHibernate）。</p><h4 id="领域层"><a href="#领域层" class="headerlink" title="领域层"></a>领域层</h4><p>领域层是所有的业务规则实现的地方。</p><p>实体代表了业务领域的数据和操作。在实践中，它们一般会映射到数据库的表中。</p><p>仓储式跟集合很像的对象，使用仓储可以检索数据源（数据库）上的实体，并将实体持久化到数据源上。领域层只是定义了仓储，但是并没有实现它们，它们是在基础设施层实现的。</p><p><strong>领域事件</strong>定义了领域特定的事件，也包括触发和处理这些事件。领域服务借助实体运行，并实现了不属于单个实体的业务规则。</p><p><strong>工作单元</strong>是一种管理实体的设计模式，这些实体受业务逻辑影响，并将状态持久化到数据存储中。</p><p>领域层应该尽可能地独立于第三方的库。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层包含了展现层使用的应用服务。应用服务方法接收一个DTO（数据传输对象）作为输入参数，使用这个输入对象执行一些特定的领域层操作，然后，如果需要的话，可能返回另一个DTO。一般而言，应用服务方法不接收或者返回一个实体对象，这样做的好处就是可以允许展现层可以从领域层中将实体抽象出来，而不受实体的约束。一个应用服务方法一般被看作是一个工作单元。用户输入验证也是在这一层实现的。ABP提供了一个基础设施，因此可以很容易地实现验证。建议使用一个将实体映射为DTO的工具，比如AutoMapper,TinyMapper等。要学习AutoMapper的使用，请查看我的**<a href="http://www.cnblogs.com/farb/p/AutoMapperContent.html">AutoMapper系列博客</a>**吧！</p><h4 id="基础设施层"><a href="#基础设施层" class="headerlink" title="基础设施层"></a>基础设施层</h4><p>虽然领域层定义了仓储接口，但是基础设施层使用诸如NHibernate或者EntityFramework的ORM工具实现了那些仓储接口。ABP提供了使用这两种ORM框架的基类。基础设施层用于抽象来自其他层的第三方类库，数据库迁移（Database Migration）也可以用在这一层。</p><h4 id="Web和展现层"><a href="#Web和展现层" class="headerlink" title="Web和展现层"></a>Web和展现层</h4><p>Web层使用ASP.NET MVC和Web API实现的。这里可以使用两种不同的方式来实现：单页面应用和多页面应用。</p><p>在单页面应用中（SPA）,所有的资源都会一次性加载到客户端（或者只加载核心资源，懒加载其他资源），所有的后续和服务器的交互都是通过Ajax调用。Html代码是使用从服务端接收到的数据在客户端生成的。整个页面不会刷新，视图只是在必要时换入换出。有许多的Javascript SPA框架，比如AngularJs，DurandalJs,BackboneJs和EmberJs。ABP可以使用它们中的任何一个，但是提供了使用 AngularJs和DurandalJs的样例。</p><p>在多页面（经典）应用中(MPA)，客户端向服务端发送请求，服务端代码（ASP.NET MVC 控制器）从数据库中获取数据，然后Razor视图引擎生成html 代码。这些编译后的页面发回给客户端显示。每个新的页面都会导致完整页面的刷新。</p><p>SPA和MPA涉及了完全不同的架构。对于后台管理系统来说，SPA是最好的候选者，另一方面，博客更适合MPA模型，因为博客渴望被搜索引擎抓取数据。虽然有很多工具可以使SPA对于搜索引擎可见，但是目前的一般做法就是使用MPA。</p><p><strong>SignalR</strong>是发送服务端到客户端的推送通知的最好工具，也可以给用户提供一个丰富而且实时的体验。</p><p>在客户端还有很多javascript库和框架。**<a href="http://jquery.com/">jQuery</a><strong>是这个领域最流行的，并伴有成千上万的插件。也有很多很容易就能使用Html和CSS的框架或工具。比如，</strong><a href="http://getbootstrap.com/">Twitter Bootstrap</a>**是非常流行的HTML/CSS框架。</p><p>ABP提供了使用应用服务层自动创建Web API层的基础设施，使用Javascript可以轻松地调用Web API（**<a href="http://www.cnblogs.com/farb/p/4949679.html">看文档</a>**）。而且，还提供了管理管理应用菜单，本地化以及语言切换的基础设施，还包含了统一的Javascript API来简化显示系统的信息和通知。</p><p>ABP自动处理服务端的异常，并给客户端返回一个合适的响应。</p><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><p>ABP通过**<a href="http://docs.castleproject.org/Windsor.MainPage.ashx">Castle Windsor</a>**使用并支持依赖注入，也使用了Log4Net来记录服务端的日志，然而，通过使用Castle的日志设备无需改变代码就可以切换到其他的日志库。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结###"></a>总结###</h3><p>ABP平衡了一些最好的框架或者类库，除此之外，ABP自己的类和系统也提供了一个很好的用于N层架构Web应用构建的基础设施，也提供了很轻松地创建分层的解决方案的**<a href="http://www.aspnetboilerplate.com/Templates">模板</a>**，用作应用的起点</p><h1 id="ABP理论学习之模块系统"><a href="#ABP理论学习之模块系统" class="headerlink" title="ABP理论学习之模块系统"></a><a href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html">ABP理论学习之模块系统</a></h1><p><strong><a href="http://www.cnblogs.com/farb/p/ABPTheory.html">返回总目录</a></strong></p><hr><h2 id="本篇目录-2"><a href="#本篇目录-2" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html#intro">模块介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html#events">生命周期事件</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html#yilai">模块依赖</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html#custom">自定义模块方法</a></strong></li></ul><h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍###"></a>模块介绍###</h3><p>ABP提供了构建模块并将这些模块组合起来创建应用的基础设施。一个模块可以依赖另一个模块。一般来说，一个程序集可以认为是一个模块。一个模块是由一个派生了<strong>AbpModule</strong>的类定义的。比如说我们在开发一个可以用在不同的应用中的博客模块。最简单的模块定义如下：</p><pre class=" language-C#"><code class="language-C#">public class MyBlogApplicationModule : AbpModule{    public override void Initialize()    {        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());    }}</code></pre><p>ABP扫描所有的程序集，并找出所有的派生自AbpModule基类的类。如果你创建了不止一个程序集的应用，那么建议为每个程序集创建一个模块定义。</p><h3 id="生命周期事件"><a href="#生命周期事件" class="headerlink" title="生命周期事件###"></a>生命周期事件###</h3><p>ABP在应用启动和关闭的时候会调用一些特定的模块方法。你可以重写这些方法来执行特定的任务。</p><p>ABP<strong>按照依赖的顺序</strong>调用这些方法。如果模块A依赖于模块B，那么模块B在模块A之前初始化。方法执行的正确顺序是：<strong>PreInitialize-B, PreInitialize-A, Initialize-B, Initialize-A, PostInitialize-B and PostInitialize-A</strong>。这对于所有的依赖图都是成立的。Shutdown方法也是类似的，但顺序相反。</p><h4 id="PreInitialize"><a href="#PreInitialize" class="headerlink" title="PreInitialize"></a>PreInitialize</h4><p>该方法会在应用启动时首先调用。你可以在该方法里面写一些特定的代码，这些代码会在依赖注入注册之前执行。比如，如果你创建了一个传统的注册类，那么你应该把它在这里注册（使用locManager.AddConventionalRegister方法）。你也可以注册到IOC容器的事件…等等。</p><h4 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h4><p>该方法通常是依赖注入注册的地方。一般使用IocManager.RegisterAssemblyByConvention方法完成。如果你想要定义自定义的依赖注册，请看后面的依赖注入文档。</p><h4 id="PostInitialize"><a href="#PostInitialize" class="headerlink" title="PostInitialize"></a>PostInitialize</h4><p>该方法在应用启动的最后调用。在这里可以安全地解析一个依赖。</p><h4 id="Shutdown"><a href="#Shutdown" class="headerlink" title="Shutdown"></a>Shutdown</h4><p>该方法在应用关闭的时候调用。</p><h3 id="模块依赖"><a href="#模块依赖" class="headerlink" title="模块依赖###"></a>模块依赖###</h3><p>一个模块可以独立于另一个模块。ABP会自动地尝试解析这些依赖，但是建议通过重写GetDependencies方法来显式声明依赖，正如下面那样：</p><pre class=" language-C#"><code class="language-C#">[DependsOn(typeof(MyBlogCoreModule))]public class MyBlogApplicationModule : AbpModule{    public override void Initialize()    {        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());    }}</code></pre><p>这样，我们声明ABP：MyBlogApplicationModule依赖于MyBlogCoreModule,因而该核心模块MyBlogCoreModule会在应用模块MyBlogApplicationModule之前进行初始化。</p><h3 id="自定义模块方法"><a href="#自定义模块方法" class="headerlink" title="自定义模块方法###"></a>自定义模块方法###</h3><p>你的模块也可以有一些自定义的方法，这些方法可以被依赖于该模块的其他模块所使用。假设MyModule2依赖于MyModule1，且MyModule2想要在PreInitialize事件中调用一个MyModule1的方法。</p><pre class=" language-C#"><code class="language-C#">public class MyModule1 : AbpModule{    public override void Initialize()    {        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());    }    public void MyModuleMethod1()    {        //这是该模块的自定义方法    }}[DependsOn(typeof(MyModule1))]public class MyModule2 : AbpModule{    private readonly MyModule1 _myModule1;    public MyModule2(MyModule1 myModule1)    {        _myModule1 = myModule1;    }    public override void PreInitialize()    {        _myModule1.MyModuleMethod1(); //Call MyModule1's method    }    public override void Initialize()    {        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());    }}</code></pre><p>这里，我们通过构造函数将MyModule1z注入到了MyModule2，因此MyModule2可以调用MyModule1的自定义方法</p><h1 id="ABP理论学习之启动配置"><a href="#ABP理论学习之启动配置" class="headerlink" title="     ABP理论学习之启动配置         "></a><a href="https://www.cnblogs.com/farb/p/ABPStartupConfig.html">     ABP理论学习之启动配置         </a></h1><p><strong><a href="http://www.cnblogs.com/farb/p/ABPTheory.html">返回总目录</a></strong></p><hr><h2 id="本篇目录-3"><a href="#本篇目录-3" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPStartupConfig.html#abp">配置ABP</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPStartupConfig.html#module">配置模块</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPStartupConfig.html#createSetting">为模块创建配置</a></strong></li></ul><p>为了在应用启动时配置ABP和模块，ABP提供了一个基础设施。</p><h3 id="配置ABP"><a href="#配置ABP" class="headerlink" title="配置ABP###"></a>配置ABP###</h3><p>配置ABP是在模块的<strong>PreInitialize</strong>事件中完成的。下面的代码摘自Github上的Taskever（一个任务系统Demo）:</p><pre class=" language-C#"><code class="language-C#">public class SimpleTaskSystemModule : AbpModule{    public override void PreInitialize()    {        //为应用添加语言        Configuration.Localization.Languages.Add(new LanguageInfo("en", "English", "famfamfam-flag-england", true));        Configuration.Localization.Languages.Add(new LanguageInfo("tr", "Türkçe", "famfamfam-flag-tr"));        //添加本地化资源        Configuration.Localization.Sources.Add(            new XmlLocalizationSource(                "SimpleTaskSystem",                HttpContext.Current.Server.MapPath("~/Localization/SimpleTaskSystem")                )            );        //配置导航菜单        Configuration.Navigation.Providers.Add<SimpleTaskSystemNavigationProvider>();    }    public override void Initialize()    {        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());    }}</code></pre><p>ABP是基于模块化设计的。不同的模块都可以配置ABP。比如，不同的模块可以通过添加导航提供者来给主菜单添加自己的菜单选项。</p><h3 id="配置模块"><a href="#配置模块" class="headerlink" title="配置模块###"></a>配置模块###</h3><p>除了ABP框架自身的启动配置之外，模块也可以实现<strong>IAbpModuleConfigurations</strong>接口来为模块提供配置点。比如：</p><pre class=" language-C#"><code class="language-C#">...using Abp.Web.Configuration;...public override void PreInitialize() {    Configuration.Modules.AbpWeb().SendAllExceptionsToClients = true;}...</code></pre><p>在本例中，我们配置了AbpWeb模块，目的是将所有的异常发送到客户端。</p><p>并不是每一个模块都应该定义这种类型的配置。一般是当一个模块需要在不同的应用中重用的时候，才需要在启动时进行配置。</p><h3 id="为模块创建配置"><a href="#为模块创建配置" class="headerlink" title="为模块创建配置###"></a>为模块创建配置###</h3><p>假设我们有一个叫做“MyModule”的模块，它有一些配置属性。首先，我们为这些配置属性创建一个类MyModuleConfig：</p><pre class=" language-C#"><code class="language-C#">public class MyModuleConfig{    public bool SampleConfig1 { get; set; }    public string SampleConfig2 { get; set; }}</code></pre><p>然后，我们在MyModule的PreInitialize事件中将这个类MyModuleConfig注册到DI中（这样，MyModuleConfig就成为了可注册的类）：</p><pre><code>IocManager.Register&lt;MyModuleConfig&gt;();</code></pre><p>最后，我们创建IModuleConfiguration的扩展方法来获得MyModuleConfig的引用。</p><pre class=" language-C#"><code class="language-C#">public static class MyModuleConfigurationExtensions{    public static MyModuleConfig MyModule(this IModuleConfigurations moduleConfigurations)    {        return moduleConfigurations.AbpConfiguration            .GetOrCreate("MyModuleConfig",                () => moduleConfigurations.AbpConfiguration.IocManager.Resolve<MyModuleConfig>()            );    }}</code></pre><p>现在，在应用启动时，其他的模块就可以配置这个模块了（在需要配置MyModule的模块的PreInitialize事件中）：</p><pre class=" language-C#"><code class="language-C#">Configuration.Modules.MyModule().SampleConfig1 = false;Configuration.Modules.MyModule().SampleConfig2 = "test";</code></pre><p>有时候，MyModule需要这样的配置。你可以注册MyModuleConfig，并使用配置的值。例如：</p><pre class=" language-C#"><code class="language-C#">public class MyService : ITransientDependency{    private readonly MyModuleConfig _configuration;    public MyService(MyModuleConfig configuration)    {        _configuration = configuration;    }    public void DoIt()    {        if (_configuration.SampleConfig2 == "test")        {            //...        }    }}</code></pre><p>这样，在ABP系统中，模块就可以创建集中配置点了，也就是说模块可以集中起来配置了。</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321131332998.png" alt="image-20210321131332998"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321131519767.png" alt="image-20210321131519767"></p><h1 id="ABP理论学习之多租户"><a href="#ABP理论学习之多租户" class="headerlink" title="     ABP理论学习之多租户         "></a><a href="https://www.cnblogs.com/farb/p/ABPMultiTenancy.html">     ABP理论学习之多租户         </a></h1><h1 id><a href="#" class="headerlink" title="         "></a><a href="https://www.cnblogs.com/farb/p/ABPMultiTenancy.html">         </a></h1><p><strong><a href="http://www.cnblogs.com/farb/p/ABPTheory.html">返回总目录</a></strong></p><hr><h2 id="本篇目录-4"><a href="#本篇目录-4" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPMultiTenancy.html#what">什么是多租户</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPMultiTenancy.html#abpMultiTenancy">ABP中的多租户</a></strong></li></ul><h3 id="什么是多租户"><a href="#什么是多租户" class="headerlink" title="什么是多租户###"></a>什么是多租户###</h3><p>维基百科：“软件<strong>多租户</strong>是指一种软件架构，在这种软件架构中，软件的<strong>一个实例</strong>运行在服务器上并且为多个租户服务”。一个租户是一组共享该软件实例特定权限的用户。有了多租户架构，软件应用被设计成为每个租户提供一个 <strong>专用的实例包括该实例的数据的共享</strong>，还可以共享配置，用户管理，租户自己的功能和非功能属性。多租户和多实例架构相比，多租户分离了代表不同的租户操作的多个实例。</p><p>多租户用于创建<strong>Saas（Software as-a service）</strong>应用（云处理）。有几种类型的多租户：</p><h4 id="多部署-多数据库"><a href="#多部署-多数据库" class="headerlink" title="多部署-多数据库"></a>多部署-多数据库</h4><p>这实际上不是多租户。但是，如果我们为<strong>每个</strong>具有<strong>分开数据库的</strong>客户（租户）运行该应用的一个实例，那么我们可以在单个服务器上为<strong>多个租户</strong>提供服务。我们可以确定该应用的多个实例在相同的服务器环境不会相互<strong>冲突</strong>。</p><p>这个对于一个不是为多租户设计的<strong>已存在应用</strong>也是可能的。创建这么一个应用更容易，因为该应用不需要了解多租户。但这种方式存在安装，使用和维护问题。</p><h4 id="单部署-多数据库"><a href="#单部署-多数据库" class="headerlink" title="单部署-多数据库"></a>单部署-多数据库</h4><p>在这种情况下，我们可以在一个服务器上运行应用的<strong>单个实例</strong>。对于每个登录用户，我们从<strong>master database</strong>中检测该用户的租户，并获得该租户的数据库信息（<strong>连接字符串</strong>）。然后我们可以将连接字符串存储到<strong>像session</strong>一样的变量中，同时，使用这个<strong>租户特定的</strong>连接字符串执行所有的数据库操作。</p><p>某种程度上，这样的应用应该设计成多租户。但是大多数的应用都独立于多租户。这种方式也存在一些安装，使用和维护问题。我们应该为每个租户创建并维护一个<strong>分离的数据库</strong>。</p><h4 id="单部署-单数据库"><a href="#单部署-单数据库" class="headerlink" title="单部署-单数据库"></a>单部署-单数据库</h4><p>这是最<strong>真实的多租户</strong>架构：我们只将具有<strong>单个数据库</strong>应用的<strong>单个实例</strong>部署到<strong>单个服务器</strong>上。在（RDBMS）每个表中，都存在一个<strong>TenantId</strong>（或相似）字段，该字段用于分离每个租户之间的数据。</p><p>这种方法安装和维护都很简单，但唯独创建这么一个应用很难，因为我们必须要阻止一个租户读取或写入其他租户的数据。我们可以为每个数据库的读取（select）操作添加一个<strong>TenantId过滤器</strong>。而且，我们可以在每次写入的时候检查一下该实体是否和<strong>当前的租户</strong>相关。这是乏味而易于出错的，但ABP通过使用<strong>自动的数据过滤</strong>帮助我们处理这个事情。</p><p>如果我们有很多具有大量数据的租户，那么这种方法可能会有性能问题。我们可以使用关系型数据库的表分割特征或者将租户按组分到不同的服务器上。</p><h3 id="ABP中的多租户"><a href="#ABP中的多租户" class="headerlink" title="ABP中的多租户###"></a>ABP中的多租户###</h3><p>ABP提供了创建<strong>单部署，单数据库，多租户</strong>架构的基础设施。</p><h4 id="开启多租户"><a href="#开启多租户" class="headerlink" title="开启多租户"></a>开启多租户</h4><p>多租户默认是关闭的。我们可以在模块的PreInitialize方法中开启，如下所示：</p><pre><code>Configuration.MultiTenancy.IsEnabled = true; </code></pre><h4 id="租主vs租户"><a href="#租主vs租户" class="headerlink" title="租主vs租户"></a>租主vs租户</h4><p>首先，我们应该定义多租户系统中的两个条目：</p><ul><li><strong>租主（Host）</strong>:租主是单例的（只有一个租主）。租主会对创建和管理租户负责。因此，一个“<strong>租主用户</strong>”比所有的租户等级更高，并独立于所有租户，同时还能控制他们。</li><li><strong>租户（Tenant）</strong>:租主的一个客户，具有自己的用户角色，权限，设置等。每个租户都可以完全独立于其他租户使用应用。一个多租户应用会有一个或多个租户。如果是一个CRM应用，那么不同的租户也有它们自己的账户，契约，产品和订单。因此，当我们说“**租户用户”的时候，意思就是一个租户拥有的用户。</li></ul><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>ABP定义了一个获取当前<strong>用户</strong>和<strong>租户</strong>id的<strong>IAbpSession</strong>接口。该接口用于多租户获取当前的租户id。因此，它可以基于当前的租户id过滤数据。ABP中有以下规则：</p><ul><li>如果UserId和TenantId都是null，那么当前的用户没有登录到系统。因此，我们可以不知道当前用户是否是一个租主用户还是一个租户用户。在这种情况下，用户不能访问授权的内容。</li><li>如果UserId不是null，TenantId是null，那么当前用户是一个租主用户。</li><li>如果UserId不是null，TenantId也不是null，那么当前用户是租户用户。</li></ul><p>更多关于session的信息请看后面的Session一节。</p><h4 id="数据过滤器"><a href="#数据过滤器" class="headerlink" title="数据过滤器"></a>数据过滤器</h4><p>当从数据库中检索实体时，我们必须添加一个TenantId过滤器来只获得当前的租户实体。当你为实体实现了<strong>IMustHaveTenant和IMayHaveTenant</strong>两个接口之一时，ABP会自动地完成数据过滤。</p><h4 id="IMustHaveTenant接口"><a href="#IMustHaveTenant接口" class="headerlink" title="IMustHaveTenant接口"></a>IMustHaveTenant接口</h4><p>该接口通过定义<strong>TenantId</strong>属性来区分不同租户的实体。一个实现了IMustHaveTenant的实体例子如下：</p><pre class=" language-C#"><code class="language-C#">public class Product : Entity, IMustHaveTenant{    public int TenantId { get; set; }            public string Name { get; set; }        //...其他属性}</code></pre><p>这样，ABP知道这是一个特定租户的实体，并且会自动地将一个租户的实体从其他实体中分离出来。</p><h4 id="IMayHaveTenant接口"><a href="#IMayHaveTenant接口" class="headerlink" title="IMayHaveTenant接口"></a>IMayHaveTenant接口</h4><p>我们可能需要在租户和租户之间共享一个<strong>实体类型</strong>。因此，一个实体可能会被一个租户或租主拥有。IMayHaveTenant接口也定义了<strong>TenantId</strong>(类似于IMustHaveTenant)，但在这种情况下是<strong>nullable</strong>。实现了IMayHaveTenant的一个实体例子：</p><pre class=" language-C#"><code class="language-C#">public class Role : Entity, IMayHaveTenant{    public int? TenantId { get; set; }            public string RoleName { get; set; }        //...其他属性}</code></pre><p>我们可能会使用相同的Role类来存储租主角色和租户角色。这种情况下，TenantId表明这是一个租户实体还是一个租主实体。null值表示这是一个<strong>租主</strong>实体，<strong>非null</strong>值表示这被一个<strong>租户</strong>拥有，该租户的Id是<strong>TenantId</strong>。</p><p>IMayHaveTenant不像IMustHaveTenant一样常用。比如，一个Product类可以不实现IMayHaveTenant接口，因为Product和实际的应用功能相关，和管理租户不相干。因此，要小心使用IMayHaveTenant接口，因为它更难维护租户和租主共享的代码。</p><h4 id="保存实体"><a href="#保存实体" class="headerlink" title="保存实体"></a>保存实体</h4><p>一个租户用户不应该创建或编辑其他租户的实体。如果相关的数据过滤器开启了，那么ABP会检查该实体相对于数据库的改变。</p><p>想要获得更多关于数据过滤器的信息，请看后面关于数据过滤器的博客。</p><h1 id="ABP理论学习之依赖注入"><a href="#ABP理论学习之依赖注入" class="headerlink" title="ABP理论学习之依赖注入"></a><a href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html">ABP理论学习之依赖注入</a></h1><p><strong><a href="http://www.cnblogs.com/farb/p/ABPTheory.html">录</a></strong></p><hr><h2 id="本篇目录-5"><a href="#本篇目录-5" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><a href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#what">什么是依赖注入</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#problem">传统方式产生的问题</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#solution">解决办法</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#framework">依赖注入框架</a></strong></li></ul></li><li><a href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#infra">ABP中的依赖注入基础设施</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#register">注册</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#resolve">解析</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#extra">其他</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#integration">ASP.NET MVC和ASP.NET Web API集成</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#tips">最后提示</a></strong></li></ul></li></ul><h3 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入###"></a>什么是依赖注入###</h3><blockquote><p>维基百科说：“依赖注入是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分。该模式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循了依赖反转和单一职责原则。与服务定位器模式形成直接对比的是，它允许客户端了解客户端如何使用该系统找到依赖”。</p></blockquote><p>不使用依赖注入技巧来管理依赖，并开发一个模块化的，结构友好的应用是非常困难的。</p><h4 id="传统方式产生的问题"><a href="#传统方式产生的问题" class="headerlink" title="传统方式产生的问题"></a>传统方式产生的问题</h4><p>在一个应用中，类相互依赖。假设我们有个应用服务，该应用服务使用了仓储将实体插入数据库。在这种情况下，此应用服务类依赖于仓储类。看下面这个例子：</p><pre class=" language-C#"><code class="language-C#">public class PersonAppService{    private IPersonRepository _personRepository;    public PersonAppService()    {        _personRepository = new PersonRepository();                }    public void CreatePerson(string name, int age)    {        var person = new Person { Name = name, Age = age };        _personRepository.Insert(person);    }}</code></pre><p><strong>PersonAppService</strong>使用了<strong>PersonRepository</strong>将一个 <strong>Person</strong>插入到数据库中。此处代码的问题在于：</p><ul><li>PersonAppService在<strong>CreatePerson</strong>方法中使用了<strong>IPersonRepository</strong>的引用，因此该方法依赖于IPersonRepository,而不是具体的PersonRepository类。但是在PersonAppService的构造函数中仍旧依赖于PersonRepository。而组件应该依赖于接口而不是实现，这就是依赖反转原则。</li><li>如果PersonAppService创建了PersonRepository本身，那么它会依赖于IPersonRepository接口的一个具体实现，这样就造成可能不会和其他实现一起工作。因此，从实现中分离接口就会变得毫无意义。硬依赖使得代码基变得紧耦合，可复用性降低。</li><li>在未来我们可能需要改变PersonRepository的创建。比如，我们可能想要它是单例的（单一公用的实例而不是每次使用都创建一个对象）。或者我们可能不止会创建实现了IPersonRepository的一个类，也可能想要有条件地创建这些实现类中的一个。这种情况下，我们就要改变依赖IPersonRepository的所有类，这样太不方便了，或者说维护难度太大了。</li><li>测试方面，有了这么个依赖，对于PersonAppService的单元测试非常难（或者根本不可能）。</li></ul><p>为了克服这些问题，可以使用工厂模式。因此，仓储类的创建时抽象的。看下面的代码：</p><pre class=" language-C#"><code class="language-C#">public class PersonAppService{    private IPersonRepository _personRepository;    public PersonAppService()    {        _personRepository = PersonRepositoryFactory.Create();                }    public void CreatePerson(string name, int age)    {        var person = new Person { Name = name, Age = age };        _personRepository.Insert(person);    }}</code></pre><p>PersonRepositoryFactory是一个创建并返回一个IPersonRepository的静态类。这就是所谓的<strong>服务定位器模式</strong>。这样创建问题是解决了，因为PersonAppService不知道如何创建一个IPersonRepository的实现，而且它独立于PersonRepository的实现。但是，仍然有下面这些问题：</p><ul><li>这次，PersonAppService依赖于PersonRepositoryFactory。这个较为可接受，但是仍然有硬依赖。</li><li>为每个仓储或者依赖写一个工厂类或方法太繁琐了。</li><li>还是不太好测试，因为让PersonAppService使用一些IPersonRepository的伪造实现还是很困难。</li></ul><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>要依赖其他的类有一些最佳实践（模式）。</p><h5 id="构造函数注入模式"><a href="#构造函数注入模式" class="headerlink" title="构造函数注入模式"></a>构造函数注入模式</h5><p>上面的例子可以重写为下面的代码：</p><pre class=" language-C#"><code class="language-C#">public class PersonAppService{    private IPersonRepository _personRepository;    public PersonAppService(IPersonRepository personRepository)    {        _personRepository = personRepository;    }    public void CreatePerson(string name, int age)    {        var person = new Person { Name = name, Age = age };        _personRepository.Insert(person);    }}</code></pre><p>这就是所谓的<strong>构造函数注入</strong>。现在，PersonAppService不知道哪一个类实现了IPersonRepository,也不知道如何创建的它。谁要使用PersonAppService，首先要创建一个IPersonRepository,并将它传给PersonAppService的构造函数，如下所示：</p><pre class=" language-C#"><code class="language-C#">var repository = new PersonRepository();var personService = new PersonAppService(repository);personService.CreatePerson("Yunus Emre", 19);</code></pre><p>构造函数注入是使类独立于依赖对象创建的一种完美方式，但是，上面的代码存在一些问题：</p><ul><li>创建一个PersonAppService变得更加困难。试想如果它有4个依赖，那么我们必须创建这4个依赖的对象，然后把它们传入PersonAppService的构造函数中。</li><li>依赖的类可能有其它的依赖（这里，PersonRepository可能有依赖）。因此，我们必须创建PersonAppService的所有依赖，依赖的所有依赖等等。这样的话，我们甚至可能不再创建单一对象，因为依赖图太复杂了。</li></ul><p>幸运的是，ABP有依赖注入框架自动管理依赖。</p><h5 id="属性注入模式"><a href="#属性注入模式" class="headerlink" title="属性注入模式"></a>属性注入模式</h5><p>构造函数注入是提供一个类的依赖的完美模式。用这种方式，你可以不需要提供依赖就能创建一个类的实例，它也是显示声明该类需要满足什么要求才能正确工作的强大方式。</p><p>但在某些情况下，该类依赖于其他的类而且其他的类没有它也能工作。这对于关注度分离（比如日志记录）来说经常是成立的。一个类可以离开logging工作，但如果提供了logger，那它就能记录日志。这种情况下，你可以定义将依赖定义为公共的属性而不是在构造函数中获得这些依赖。试想如果我们要在PersonAppService中记录日志，那么我们可以重写该类为：</p><pre class=" language-C#"><code class="language-C#">public class PersonAppService{    public ILogger Logger { get; set; }    private IPersonRepository _personRepository;    public PersonAppService(IPersonRepository personRepository)    {        _personRepository = personRepository;        Logger = NullLogger.Instance;    }    public void CreatePerson(string name, int age)    {        Logger.Debug("Inserting a new person to database with name = " + name);        var person = new Person { Name = name, Age = age };        _personRepository.Insert(person);        Logger.Debug("Successfully inserted!");    }}</code></pre><p>NullLogger.Instance是一个实现了ILogger的单例对象，但实际上什么都没做（没有记录日志，它使用了空的方法体实现了ILogger）。因此，如果你在创建PersonAppService对象之后，并像下面那样设置了Logger，PersonAppService就可以记录日志了：</p><pre class=" language-C#"><code class="language-C#">var personService = new PersonAppService(new PersonRepository());personService.Logger = new Log4NetLogger();personService.CreatePerson("Yunus Emre", 19);</code></pre><p>假设Log4NetLogger实现了ILogger并使用Log4Net类库记录日志。这样，PersonAppService实际上就可以记录日志了。如果没有设置Logger，那么它就不会记录日志。因此，我们可以说ILogger是PersonAppService的一个<strong>可选依赖</strong>。</p><p>几乎所有的依赖注入框架都支持属性注入模式。</p><h4 id="依赖注入框架"><a href="#依赖注入框架" class="headerlink" title="依赖注入框架"></a>依赖注入框架</h4><p>有很多自动解析依赖的依赖注入框架。它们能够使用所有的依赖（包括依赖的依赖）创建对象。因此，你只需要使用构造和属性注入模式编写你的类，DI框架会处理剩下的事情。在一个优秀的应用中，你的类甚至独立于DI框架。在整个应用中，有许多显式和DI框架交互的代码行或者类。</p><p>ABP使用Castle Windsor框架处理依赖注入。它是最成熟的DI框架之一。还有很多其他的框架，如Unity，Ninject,StructureMap，Autofac等等。</p><p>在依赖注入框架中，你首先要将你的接口或者类注册到其中，然后才可以解析（创建）一个对象。在Castle Windsor中，有点像下面那样：</p><pre class=" language-C#"><code class="language-C#">var container = new WindsorContainer();container.Register(        Component.For<IPersonRepository>().ImplementedBy<PersonRepository>().LifestyleTransient(),        Component.For<IPersonAppService>().ImplementedBy<PersonAppService>().LifestyleTransient()    );var personService = container.Resolve<IPersonAppService>();personService.CreatePerson("Yunus Emre", 19);</code></pre><p>上面的代码中，首先创建了<strong>WindsorContainer</strong>，然后使用PersonRepository和PersonAppService的接口注册了它们，再然后我们要求容器创建一个IPersonAppService。容器使用依赖创建了PersonAppService并返回，也许在这个简单的例子中使用DI框架的优势不是很明显，但是想象一下你在一个真实的企业应用中会有很多类和依赖。当然，也会在别的地方使用对象来注册依赖，这个在应用启动时只会做一次。</p><p>注意，我们也将对象的<strong>生命周期</strong>声明为<strong>transient</strong>。这意味着，无论何时解析这些类型的一个对象，都会创建一个新的实例。当然还有很多不同的生命周期（像singleton）。</p><h3 id="ABP中的依赖注入基础设施"><a href="#ABP中的依赖注入基础设施" class="headerlink" title="ABP中的依赖注入基础设施###"></a>ABP中的依赖注入基础设施###</h3><p>当你通过下面的最佳实践和一些惯例编写你的应用时，ABP几乎让使用DI框架变得不可见了。</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>在ABP中，将你的类注册到DI系统有几种不同的方式。大多数情况下，按照惯例注册已经足够了。</p><h5 id="惯例注册"><a href="#惯例注册" class="headerlink" title="惯例注册"></a>惯例注册</h5><p>ABP会按照惯例自动注册所有的仓储，领域服务，应用服务，MVC控制器和Web API控制器。比如，你可能有一个IPersonAppService接口和一个实现了该接口的PersonAppService类：</p><pre class=" language-C#"><code class="language-C#">public interface IPersonAppService : IApplicationService{    //...}public class PersonAppService : IPersonAppService{    //...}</code></pre><p>因为它实现了<strong>IApplicationService</strong>接口（只是一个空接口），所以ABP会自动注册它，并注册为<strong>transient</strong>（每次使用创建一个实例）。当你使用构造函数注入IPersonAppService接口到一个类中时，一个PersonAppService对象会自动地创建并传入该类的构造函数中。</p><p><strong>命名规范</strong>在ABP中非常重要。比如，你可以将PersonAppService更名为MyPersonAppService或是其他包含了“PersonAppService”后缀的名字，因为IPersonAppService接口有这个后缀。但你不能将它命名为PeopleService。如果你没有按照这种命名规范来操作的话，那么IPersonAppService不会自动地注册（但是它已经以自注册的方式注入到DI框架，而不是接口方式），因此如果你想要以接口方式注册的话，那么你应该手动注册。</p><p>ABP按照惯例注册程序集。因此，你应该按照惯例告诉ABP注册你的程序集。这个相当简单：</p><pre><code>IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());</code></pre><p>Assembly.GetExecutingAssembly()会获得包含这句代码的程序集的引用。你也可以将其他的程序集传入RegisterAssemblyByConvention 方法中。这个操作通常在你的模块初始化的时候完成的。查看**<a href="http://www.cnblogs.com/farb/p/ABPModuleSystem.html">《模块系统》</a>**博文获得更多信息。</p><p>通过实现<strong>IConventionalRegister</strong>接口和调用<strong>IocManager.AddConventionalRegister</strong>方法，你可以用你的类编写你自己的惯例注册类。你要做的就是在模块的PreInitialize方法中加入它。</p><h5 id="帮助接口"><a href="#帮助接口" class="headerlink" title="帮助接口"></a>帮助接口</h5><p>你可能想要注册一个特殊的类，但是它不符合惯例注册的原则。为此，ABP提供了<strong>ITransientDependency</strong> 和 <strong>ISingletonDependency</strong>接口。比如：</p><pre class=" language-C#"><code class="language-C#">public interface IPersonManager{    //...}public class MyPersonManager : IPersonManager, ISingletonDependency{    //...}</code></pre><p>用这种方式，你可以轻松地注册MyPersonManager。当需要注入IPersonManager的时候，就会使用MyPersonManager。注意依赖声明为<strong>Singleton</strong>。这样，MyPersonManager的单例就被创建了，并且相同的对象也被传入到所有的类中。只有在第一次使用时才会创建，以后再整个应用的生命周期都会使用相同的实例。</p><h5 id="自定义-直接注册"><a href="#自定义-直接注册" class="headerlink" title="自定义/直接注册"></a>自定义/直接注册</h5><p>如果之前描述的方法还不能满足你，那么你可以直接使用<strong>Castle Windsor</strong>来注册你的类和依赖。这样，你就在Castle Windsor中注册任何东西。</p><p>Castle Windsor有一个为了注册而要实现的接口<strong>IWindsorInstaller</strong>。你可以在应用中创建实现了IWindsorInstaller接口的类：</p><pre class=" language-C#"><code class="language-C#">public class MyInstaller : IWindsorInstaller{    public void Install(IWindsorContainer container, IConfigurationStore store)    {        container.Register(Classes.FromThisAssembly().BasedOn<IMySpecialInterface>().LifestylePerThread().WithServiceSelf());    }}</code></pre><p>ABP会自动找到并执行这个类。最后，可以使用<strong>IIocManager.IocContainer</strong>属性到达WindsorContainer。获取更多Windsor信息，请查看**<a href="http://docs.castleproject.org/Default.aspx?Page=MainPage">官方文档</a>**。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>注册会将你的类，类的依赖和生命周期通知给IOC（控制反转）容器。接下来，你需要在应用中的某些地方使用IOC容器创建对象。ABP针对依赖的解析提供了很多选项。</p><h5 id="构造函数-amp-属性注入"><a href="#构造函数-amp-属性注入" class="headerlink" title="构造函数&amp;属性注入"></a>构造函数&amp;属性注入</h5><p>你可以将使用构造函数和属性注入获得类的依赖作为最佳实践。无论在哪里，你都应该这样做。例如：</p><pre class=" language-C#"><code class="language-C#">public class PersonAppService{    public ILogger Logger { get; set; }    private IPersonRepository _personRepository;    public PersonAppService(IPersonRepository personRepository)    {        _personRepository = personRepository;        Logger = NullLogger.Instance;    }    public void CreatePerson(string name, int age)    {        Logger.Debug("Inserting a new person to database with name = " + name);        var person = new Person { Name = name, Age = age };        _personRepository.Insert(person);        Logger.Debug("Successfully inserted!");    }}</code></pre><p>IPersonRepository从构造函数注入，ILogger使用公共属性注入。这样的话，你的代码根本意识不到依赖注入系统的存在，也就是说，依赖系统对于我们开发者完全是透明的，我们可以不考虑依赖系统内部的实现细节。这是使用DI系统最合适的方式。</p><p>IIocResolver和IIocManager</p><p>有时，你可能必须要直接解析依赖而不是通过构造函数和属性注入。这种情况要尽可能地避免，但这种情况也是有可能的。ABP提供了很多可以轻松注入并使用的服务。例如：</p><pre class=" language-C#"><code class="language-C#">public class MySampleClass : ITransientDependency{    private readonly IIocResolver _iocResolver;    public MySampleClass(IIocResolver iocResolver)    {        _iocResolver = iocResolver;    }    public void DoIt()    {        //手动解析        var personService1 = _iocResolver.Resolve<PersonAppService>();        personService1.CreatePerson(new CreatePersonInput { Name = "Yunus", Surname = "Emre" });        _iocResolver.Release(personService1);        //安全地解析并使用        using (var personService2 = _iocResolver.ResolveAsDisposable<PersonAppService>())        {            personService2.Object.CreatePerson(new CreatePersonInput { Name = "Yunus", Surname = "Emre" });        }    }}</code></pre><p>在以上例子中的MySampleClass通过构造函数注入<strong>IIocResolver</strong>并用它来解析和释放对象。<strong>Resolve</strong>方法有许多重载可供使用。<strong>Release</strong>方法用来释放组件（对象）。调用Release来手动解析一个对象是很关键的，否则，应用会有内存泄漏问题。为了确保释放对象，要尽可能使用<strong>ResolveAsDisPosable</strong>(如例子中演示的那样)。在using块的末尾会自动地调用Release。</p><p>如果你想要直接使用IOC容器（Castle Windor）来解析依赖，那么你可以构造函数注入<strong>IIocManager</strong>并使用IIocManager.IocContainer属性。如果你处于静态上下文或者不能注入IIocManager，那么最后的机会就是，你可以使用单例对象<strong>IocManager.Instance</strong>。但是，这种情况不容易测试。</p><h4 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h4><h5 id="IShouldInitialize接口"><a href="#IShouldInitialize接口" class="headerlink" title="IShouldInitialize接口"></a>IShouldInitialize接口</h5><p>某些类在第一次使用前就要初始化。IShouldInitialize接口有一个Initialize方法。如果实现了该接口，那么在创建对象之后（使用前）就会自动地调用Initialize方法。当然，为了使该功能有效，你应该注入/解析该对象。</p><h4 id="ASP-NET-MVC和ASP-NET-Web-API集成"><a href="#ASP-NET-MVC和ASP-NET-Web-API集成" class="headerlink" title="ASP.NET MVC和ASP.NET Web API集成"></a>ASP.NET MVC和ASP.NET Web API集成</h4><p>当然，为了解析依赖图中的根对象，我们必须调用依赖注入系统。在ASP.NET MVC应用中，根对象一般是一个<strong>Controller</strong>类。我们也可以在控制器中使用构造函数注入和属性注入模式。当一个请求到达应用时，IOC容器创建了控制器对象，然后所有的依赖递归地解析出来。那么，谁处理的这个呢？这是ABP通过扩展了ASP.NET MVC默认的控制器工厂自动完成的。相似地，对于ASP.Net Web API也是如此。你不必关心创建和释放对象的事情。</p><h4 id="最后提示"><a href="#最后提示" class="headerlink" title="最后提示"></a>最后提示</h4><p>只要你遵循规则并使用上面的结构，ABP就能简化并自动化依赖注入的使用。大多数情况下，这些已经够用了。但是，如果你需要的话，你可以直接使用所有Castle Windsor的能力来执行任何任务（如自定义注册，注入钩子，拦截器等等）<img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321131043687.png" alt="image-20210321131043687"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321131205896.png" alt="image-20210321131205896"></p><h1 id="ABP理论学习之Abp-Session"><a href="#ABP理论学习之Abp-Session" class="headerlink" title="ABP理论学习之Abp Session"></a><a href="https://www.cnblogs.com/farb/p/ABPSession.html">ABP理论学习之Abp Session</a></h1><hr><h2 id="本篇目录-6"><a href="#本篇目录-6" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPSession.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPSession.html#injection">注入Session</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPSession.html#property">使用Session属性</a></strong></li></ul><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍###"></a>介绍###</h3><p>当应用程序要求用户登录时，那么应用程序也需要知道当前用户正在执行的操作。虽然ASP.NET本身在展现层提供了Session对象，但ABP也提供了在任何需要获得当前用户和租户的地方都可以使用的<strong>IAbpSession</strong>接口。</p><blockquote><h4 id="关于IAbpSession"><a href="#关于IAbpSession" class="headerlink" title="关于IAbpSession"></a>关于IAbpSession</h4><p>为了获得实际的session信息，必须要实现IAbpSession接口。虽然你可以用自己的方式实现它，但在<strong>module-zero</strong>项目中已经完全实现。</p></blockquote><p>IAbpSession已经完全集成到ABP（实例的设置系统和授权系统）中。</p><h3 id="注入Session"><a href="#注入Session" class="headerlink" title="注入Session###"></a>注入Session###</h3><p>IAbpSession一般<strong>属性注入</strong>到需要的类中，除非没有Session信息导致IAbpSession不可能工作。如果我们使用了属性注入，那么我们可以使用<strong>NullAbpSession.Instance</strong>作为默认值，如下所示：</p><pre class=" language-C#"><code class="language-C#">public class MyClass : ITransientDependency{    public IAbpSession AbpSession { get; set; }    public MyClass()    {        AbpSession = NullAbpSession.Instance;    }    public void MyMethod()    {        var currentUserId = AbpSession.UserId;        //...    }}</code></pre><p>因为授权是应用层的事儿，所以建议<strong>在应用层和更高的层使用IAbpSession</strong>(一般我们不再领域层使用)。<strong>ApplicationService，AbpController，AbpApiController</strong>已经注入了 <strong>AbpSession</strong>。因此，你可以直接在应用层服务方法中为实例使用AbpSession属性。</p><h3 id="使用Session属性"><a href="#使用Session属性" class="headerlink" title="使用Session属性###"></a>使用Session属性###</h3><p>AbpSession定义了一些key属性：</p><ul><li><strong>UserId</strong>:当前用户的Id。值为null，表示当前的用户不存在。如果调用的代码授权给某个用户的话，那么值不为null。</li><li><strong>TenantId</strong>:当前租户的Id。如果当前的租户不存在，值就为null。</li><li><strong>MultiTenancySide</strong>:可能是Host（租主）或者Tenant（租户）。</li></ul><p>UserId和TenantId是<strong>nullable(可空的)**，也存在不可空的</strong>GetUserId()**和 **GetTenantId()**方法。如果你确定当前的用户存在，那么你可以调用GetUserId()。如果当前的用户为null，那么该方法就会抛异常。GetTanantId()也是类似的。</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321114918477.png" alt="image-20210321114918477"></p><h1 id="ABP理论学习之缓存Caching"><a href="#ABP理论学习之缓存Caching" class="headerlink" title="ABP理论学习之缓存Caching"></a><a href="https://www.cnblogs.com/farb/p/ABPCaching.html">ABP理论学习之缓存Caching</a></h1><hr><h2 id="本篇目录-7"><a href="#本篇目录-7" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPCaching.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPCaching.html#ICacheManager">ICacheManager</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPCaching.html#ICache">ICache</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPCaching.html#ITypedCache">ITypedCache</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPCaching.html#config">配置</a></strong></li></ul><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍###"></a>介绍###</h3><p>ABP提供了缓存的抽象，它内部使用了这个缓存抽象。虽然默认的实现使用了MemoryCache，但是也可以为其他的缓存提供者进行实现和改变。</p><h3 id="ICacheManager"><a href="#ICacheManager" class="headerlink" title="ICacheManager###"></a>ICacheManager###</h3><p>缓存的主要接口是<strong>ICacheManager</strong>。我们可以注入该接口，然后使用该接口获得一个缓存对象。例如：</p><pre class=" language-C#"><code class="language-C#">public class TestAppService : ApplicationService{    private readonly ICacheManager _cacheManager;    public TestAppService(ICacheManager cacheManager)    {        _cacheManager = cacheManager;    }    public Item GetItem(int id)    {        //从缓存中获取        return _cacheManager                .GetCache("MyCache")                .Get(id.ToString(), () => GetFromDatabase(id)) as Item;    }    public Item GetFromDatabase(int id)    {        //... 从数据库中检索    }}</code></pre><p>在这个例子中，我们注入了<strong>ICacheManager</strong>，并获取了一个叫做<strong>MyCache</strong>的缓存对象。</p><blockquote><h4 id="警告：GetCache方法"><a href="#警告：GetCache方法" class="headerlink" title="警告：GetCache方法"></a>警告：GetCache方法</h4><p>不要在构造函数中使用GetCache方法。如果你的类是transient（每次使用都会创建）的，那么这可能会释放缓存，因为第二次创建类的对象时，会再次调用构造函数，之前的第一次的缓存可能会被释放。</p></blockquote><h3 id="ICache"><a href="#ICache" class="headerlink" title="ICache###"></a>ICache###</h3><p>ICacheManager.GetCache方法返回一个<strong>ICache</strong>。缓存对象是单例的，第一次请求时会创建缓存，以后都是返回相同的缓存对象。因此，我们可以在不同的类（客户端）中共享具有相同名字的相同缓存。</p><p>在样例代码中，我们看到了ICache.Get方法的简单使用。它有两个参数：</p><ul><li><strong>key</strong>：缓存中一个条目的唯一字符串键。</li><li><strong>工厂</strong>：没有找到给定key的缓存条目时调用的action。工厂方法应该创建并返回实际的条目。如果给定的key在缓存中找到了，那么不会调用该action。</li></ul><p>ICache接口也有像<strong>GetOrDefault,Set,Remove,Clear</strong>的方法。同时，这些方法也有<strong>异步（async）</strong>版本。</p><h3 id="ITypedCache"><a href="#ITypedCache" class="headerlink" title="ITypedCache###"></a>ITypedCache###</h3><p><strong>ICache</strong>接口的key为string类型，value为object类型。<strong>ITypeCache</strong>是ICache的包装器，提供<strong>类型安全</strong>、泛型的cache。为了将ICache转为ITypedCache，我们可以使用<strong>AsTyped</strong>扩展方法，如下所示：</p><pre class=" language-C#"><code class="language-C#">ITypedCache<int, Item> myCache = _cacheManager.GetCache("MyCache").AsTyped<int, Item>();</code></pre><p>这样，我们不需要转换就可以使用Get方法。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置###"></a>配置###</h3><p>默认的缓存有效期是60min。因此，如果你在60min内都没有使用缓存中的元素，那么它会自动从缓存中移除。对于所有的缓存或者特定的某个缓存，你都可以配置有效期。</p><pre class=" language-C#"><code class="language-C#">//为所有缓存配置有效期Configuration.Caching.ConfigureAll(cache =>{    cache.DefaultSlidingExpireTime = TimeSpan.FromHours(2);});//为特定的缓存配置有效期Configuration.Caching.Configure("MyCache", cache =>{    cache.DefaultSlidingExpireTime = TimeSpan.FromHours(8);});</code></pre><p>这些代码应该放到模块中的<strong>PreInitialize</strong>方法中。有了这样的配置，MyCache会有8小时的有效期，而其他cache会有2小时有效期。</p><p>一旦cache首次创建（第一次请求时），就会调用配置的action。配置并不只局限于DefaultSlidingExpireTime（默认滚动有效期），因为cache对象是一个ICache，你可以使用它的属性和方法自由地配置并初始化。</p><h1 id="ABP理论学习之日志记录"><a href="#ABP理论学习之日志记录" class="headerlink" title="ABP理论学习之日志记录"></a><a href="https://www.cnblogs.com/farb/p/ABPLogging.html">ABP理论学习之日志记录</a></h1><hr><h2 id="本篇目录-8"><a href="#本篇目录-8" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><a href="https://www.cnblogs.com/farb/p/ABPLogging.html#server">服务端</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPLogging.html#get">获取Logger</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPLogging.html#base">基类中的Logger</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPLogging.html#config">配置</a></strong></li></ul></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPLogging.html#client">客户端</a></strong></li></ul><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端###"></a>服务端###</h3><p>ABP使用的是Castle Windsor的**<a href="http://docs.castleproject.org/Windsor.Logging-Facility.ashx">日志记录设备</a><strong>。它可以和不同的日志类库一起工作，比如</strong>Log4Net,NLog，Serilog等等<strong>。Castle为所有的日志类库提供了一个</strong>公共的接口**。因此，你完全独立于特定的日志记录类库，而且，如果需要的话，你可以轻松地改变应用程序的日志类库。</p><p>**<a href="http://logging.apache.org/log4net/">Log4Net</a>**是.Net中最流行的日志类库之一。ABP模板中自带了经过合适配置的Log4Net。但是，只存在一行log4net的依赖（看下面），因此，你可以将它改为你最喜欢的类库。</p><h4 id="获取Logger"><a href="#获取Logger" class="headerlink" title="获取Logger"></a>获取Logger</h4><p>无论你选择了什么日志类库，最终要记录的日志代码都是相同的（这得感谢Castle公共的ILogger接口）。</p><p>一开始，我们要处理一下记录日志的Logger对象。因为ABP强烈推荐使用依赖注入，所以我们可以使用属性注入模式轻松地注入一个Logger对象。如下所示：</p><pre class=" language-C#"><code class="language-C#">using Castle.Core.Logging; //1: 导入 Logging 命名空间public class TaskAppService : ITaskAppService{        //2: 使用属性注入获得 logger    public ILogger Logger { get; set; }        public TaskAppService()    {        //3: 如果没有提供Logger，就不能记录日志        Logger = NullLogger.Instance;    }    public void CreateTask(CreateTaskInput input)    {        //4: 记录日志        Logger.Info("Creating a new task with description: " + input.Description);        //TODO: 保存到数据库...    }}</code></pre><ol><li>导入Castle的ILogger接口的命名空间。</li><li>定义一个公有的叫做Logger的<strong>ILogger</strong>对象。这是记录日志的对象。创建TaskAppService对象之后，依赖注入系统会设置（注入）这个属性。这就是所谓的属性注入模式。</li><li>将Logger设置为<strong>NullLogger.Instance</strong>。即使没有这行代码，系统也会工作地很好。但是这是属性注入模式的最佳实践。如果没给Logger设置任何值，那么当我们使用它的时候会因为它是null而抛出“空指针”异常。这个保证了它不为null。因此，如果没有给Logger设置值，那么它是NullLogger。这就是所谓的null对象模式。NullLogger实际上什么都没做，也没有记录任何日志。因此，我们的类要不要一个实际的logger都能工作。</li><li>最后，我们记录了一个<strong>info</strong>等级的日志文本。存在多种不同的等级（看下面）。</li></ol><p>如果我们调用了CreateTask方法，并检查日志文件，就会看到像下面一样的一长行字符串。</p><pre><code>INFO  2014-07-13 13:40:23,360 [8    ] SimpleTaskSystem.Tasks.TaskAppService    - Creating a new task with description: Remember to drink milk before sleeping!</code></pre><h4 id="基类中的Logger"><a href="#基类中的Logger" class="headerlink" title="基类中的Logger"></a>基类中的Logger</h4><p>ABP为MVC控制器，Web API控制器和应用服务类提供了基类。比如，Web层对应的基类是XXXControllerBase(后缀为ControllerBase)。这些基类中都声明了<strong>Logger</strong>属性。因此你可以直接使用Logger来记录日志，无需注入。例子：</p><pre class=" language-C#"><code class="language-C#">public class HomeController : SimpleTaskSystemControllerBase{    public ActionResult Index()    {         Logger.Debug("A sample log message...");        return View();    }}</code></pre><p>注意，SimpleTaskSystemControllerBase是继承了<strong>AbpController</strong>的应用基类控制器。因此，可以在控制器中直接使用Logger。Logger也存在于Web Api控制器的<strong>AbpApiController</strong>基类，以及应用服务层的基类（后缀为AppServiceBase的类）。你也可以为其他的类编写自己的公共基类，这样，你就不需要每次注入logger了。</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>当你从ABP模板创建应用程序时，Log4Net的所有配置已经完成了。</p><p>默认的日志格式配置如下：</p><ul><li><strong>日志级别</strong>：DEBUG, INFO, WARN, ERROR或者FATAL。</li><li><strong>日期和时间</strong>：记录日志的时间。</li><li><strong>线程号</strong>:记录日志的线程号码。</li><li><strong>Logger名称</strong>：通常是记录日志的类名。</li><li><strong>日志文本</strong>：实际记录的日志文本。</li></ul><p>配置定义在应用的<strong>log4net.config</strong>文件中，如下所示：</p><pre class=" language-web.config"><code class="language-web.config"><?xml version="1.0" encoding="utf-8" ?><log4net>  <appender name="RollingFileAppender" type="log4net.Appender.RollingFileAppender" >    <file value="Logs/Logs.txt" />    <appendToFile value="true" />    <rollingStyle value="Size" />    <maxSizeRollBackups value="10" />    <maximumFileSize value="10000KB" />    <staticLogFileName value="true" />    <layout type="log4net.Layout.PatternLayout">        <conversionPattern value="%-5level %date [%-5.5thread] %-40.40logger - %message%newline" />    </layout>  </appender>  <root>    <appender-ref ref="RollingFileAppender" />    <level value="DEBUG" />  </root>  <logger name="NHibernate">    <level value="WARN" />  </logger></log4net></code></pre><p>Log4Net是高度可配置的、健壮的日志记录类库。你可以使用不同的格式将日志记录到不同的目标上（文本文件，数据库等）。你也可以设置最小日志等级（正如此配置中为NHibernate配置的那样）。你也可以记录不同的日志到不同的文件中。当到达一个指定的大小时，它会自动备份并创建一个新的日志文件等等（本例中，滚动文件适配器的每个文件大小是10MB）。为了更好配置你的log4net，请查看**<a href="http://logging.apache.org/log4net/release/config-examples.html">官方文档</a>**。</p><p>最后，我们在Global.asax文件中，声明了要使用log4net.config文件中的Log4Net。</p><pre class=" language-C#"><code class="language-C#">public class MvcApplication : AbpWebApplication{    protected override void Application_Start(object sender, EventArgs e)    {        IocManager.Instance.IocContainer.AddFacility<LoggingFacility>(f => f.UseLog4Net().WithConfig("log4net.config"));        base.Application_Start(sender, e);    }}</code></pre><p>这是<strong>我们直接依赖log4net的唯一代码行</strong>。而且，只有web项目依赖log4net类库的nuget包。因此，你可以轻松地切换到其他日志类库，而且不需要改变记录日志的代码。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端###"></a>客户端###</h3><p>ABP为客户端定义了一个javascript日志记录API。默认会将日志记录到浏览器的控制台。记录日志的javascript代码样例如下：</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321130900892.png" alt="image-20210321130900892"></p><h1 id="ABP理论学习之设置管理"><a href="#ABP理论学习之设置管理" class="headerlink" title="ABP理论学习之设置管理"></a><a href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html">ABP理论学习之设置管理</a></h1><hr><h2 id="本篇目录-9"><a href="#本篇目录-9" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#defSetting">定义设置</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#getSetting">获取设置值</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#changeSetting">更改设置</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#aboutCache">关于缓存</a></strong></li></ul><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍###"></a>介绍###</h3><p>每个应用程序都需要存储一些设置信息，然后在应用程序中的某个地方使用这些设置。ABP提供了健壮的基础设施来存储或检索服务端和客户端的<strong>应用程序，租户，用户</strong>级别的可用设置。</p><p>一个设置一般是存储在数据库（或其他源）的<strong>name-value</strong>字符串对。我们可以将非字符串的值转换成字符串。</p><blockquote><h4 id="关于ISettingStore"><a href="#关于ISettingStore" class="headerlink" title="关于ISettingStore"></a>关于ISettingStore</h4><p>为了使用设置系统，必须要实现<strong>ISettingStore</strong>。虽然你可以用自己的方式实现，但是它已完全实现在<strong>module-zero</strong>中了。</p></blockquote><h3 id="定义设置"><a href="#定义设置" class="headerlink" title="定义设置###"></a>定义设置###</h3><p>一个设置使用前必须先定义。ABP是模块化设计的，因此，不同的模块可以有不同的设置。要定义一个设置，一个模块应该创建一个派生于<strong>SettingProvider</strong>（设置提供器）的类。设置提供器的一个例子如下所示：</p><pre class=" language-C#"><code class="language-C#">public class MySettingProvider : SettingProvider{    public override IEnumerable<SettingDefinition> GetSettingDefinitions(SettingDefinitionProviderContext context)    {        return new[]                {                    new SettingDefinition(                        "SmtpServerAddress",                        "127.0.0.1"                        ),                    new SettingDefinition(                        "PassiveUsersCanNotLogin",                        "true",                        scopes: SettingScopes.Application | SettingScopes.Tenant                        ),                    new SettingDefinition(                        "SiteColorPreference",                        "red",                        scopes: SettingScopes.User,                        isVisibleToClients: true                        )                };    }}</code></pre><p><strong>GetSettingDefinitions</strong>方法应该返回<strong>SettingDefinition</strong>集合。SettingDefinition类的构造函数有一些参数：</p><ul><li><strong>Name</strong>(必须)：一个设置的名称，在系统中名称必须唯一。最好为每个设置名定义一个常量字符串。</li><li><strong>Default值</strong>：设置的默认值。可以为null或空字符串。</li><li><strong>Scopes</strong>：一个设置应该定义它的范围（看下面）。</li><li><strong>Dispaly name</strong>：在UI上显示的本地化的设置名。</li><li><strong>Description</strong>：在UI上显示的本地化的设置描述。</li><li><strong>Group</strong>：用于组合设置。这个用于UI而不是设置管理。</li><li><strong>IsVisibleToClients</strong>：客户端是否可见。</li></ul><p>创建一个设置提供器之后，我们应该在模块的PreInitialize方法中注册。</p><pre><code>Configuration.Settings.Providers.Add&lt;MySettingProvider&gt;();</code></pre><p>这样，设置提供器就自动注册到依赖注入系统中了。因此，设置提供器可以使用一些其他的资源注入任何依赖（如仓储）来生成设置定义。</p><h4 id="设置范围"><a href="#设置范围" class="headerlink" title="设置范围"></a>设置范围</h4><p>在<strong>SettingScope</strong>枚举类中定义了三种<strong>设置范围（或者说等级）</strong>：</p><ul><li><strong>Application</strong>：一个应用范围的setting对象用于用户或者租户独立的设置。比如，我们可以定义一个叫做“SmtpServerAddress”的设置来获取发送邮件时服务端的IP地址。如果该setting有一个单一值（基于用户不会改变），那么我们可以把它定义为应用范围的。</li><li><strong>Tenant</strong>：如果应用程序时多租户的，那么我们可以定义租户特定的setting。</li><li><strong>User</strong>：我们可以定义存储或者获取特定用户的设置。</li></ul><p>SettingScopes枚举类型有<strong>Flags</strong>特性，因此我们可以定义一个<strong>不止一个范围</strong>的setting。</p><p>设置范围是有层次的，比如，如果我们定义的设置范围是“Application | Tenant | User”，并尝试获取该设置<strong>当前的值</strong>，那么：</p><ul><li>如果已定义了该用户的setting，那么就会获得该用户特定的值。</li><li>如果上面的条件不成立，并且已经定义了该用户所属租户的setting，那么会获得该租户特定的值。</li><li>如果上面的条件还不成立，如果定义了应用的值，那么会获得该应用的值。</li><li>最后，我们会获得<strong>默认值</strong>。</li></ul><p>默认值可能是null或者空字符串。如果可能的话，建议为setting的默认值提供默认值。</p><h3 id="获取设置值"><a href="#获取设置值" class="headerlink" title="获取设置值###"></a>获取设置值###</h3><p>定义了一个setting之后，我们就可以在客户端和服务端获得它当前的值。</p><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><p><strong>ISettingManager</strong>用于执行setting操作。我们可以在应用中的任何地方注入并使用它。ISettingManager定义了许多获取一个setting值的方法。</p><p>用的最多的方法是<strong>GetSettingValue</strong>(或者异步调用GetSettingValueAsync)。它会返回基于默认值，应用程序，租户和用户setting的当前的值（正如上面提到的）。例如：</p><pre class=" language-C#"><code class="language-C#">//获取一个bool值（异步调用）var value1 = await SettingManager.GetSettingValueAsync<bool>("PassiveUsersCanNotLogin");//获取一个string值（同步调用）var value2 = SettingManager.GetSettingValue("SmtpServerAddress");</code></pre><p>GetSettingValue有泛型和异步版本，如上面所示。也有获得特定租户或者用户的setting值或者所有setting值的列表的方法。</p><p>因为ISettingManager使用广泛，所以一些特殊的基类（如ApplicationService，DomainService和AbpController）就有了一个叫做<strong>SettingManager</strong>的属性。如果我们从这些类中派生，那么就不需要显式注入它了。</p><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p>当定义一个setting时，如果将<strong>IsVisibleToClients</strong>设置为true，那么可以使用javascript在客户端获得当前的值。<strong>abp.setting</strong>命名空间定义了一些用得到的函数和对象。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> currentColor <span class="token operator">=</span> abp<span class="token punctuation">.</span>setting<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"SiteColorPreference"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>也有<strong>getInt</strong>和 <strong>getBoolean</strong> 方法。你可以使用<strong>abp.setting.values</strong>获得所有的值。注意：如果在服务端更改了一个setting，那么如果页面没有更新，setting没有重新加载或者通过代码手动更新的话，那么客户端就不知道该setting是否发生了变化。</p><h3 id="更改设置"><a href="#更改设置" class="headerlink" title="更改设置###"></a>更改设置###</h3><p>ISettingManager为应用程序，租户和用户分别定义了<strong>ChangeSettingForApplicationAsync, ChangeSettingForTenantAsync和ChangeSettingForUserAsync</strong>方法来更改setting。</p><h3 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存###"></a>关于缓存###</h3><p>Setting Manager(管理者)缓存到了服务端的setting了。因此，我们不应该使用仓储或者数据库更新来直接更改一个setting的值。</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321130753223.png" alt="image-20210321130753223"></p><h1 id="领域层-1"><a href="#领域层-1" class="headerlink" title="领域层"></a>领域层</h1><h1 id="ABP理论学习之实体类"><a href="#ABP理论学习之实体类" class="headerlink" title="ABP理论学习之实体类"></a><a href="https://www.cnblogs.com/farb/p/ABPEntity.html">ABP理论学习之实体类</a></h1><hr><h2 id="本篇目录-10"><a href="#本篇目录-10" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEntity.html#entity">实体类</a></strong></li><li><a href="https://www.cnblogs.com/farb/p/ABPEntity.html#guanli">惯例接口</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEntity.html#Auditing">审计</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEntity.html#softDelete">软删除</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEntity.html#active">激活/未激活</a></strong></li></ul></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEntity.html#IEntity">IEntity接口</a></strong></li></ul><blockquote><p>实体是DDD（领域驱动设计）的核心概念之一。Eirc Evans是这样描述的实体的：“它根本上不是通过属性定义的，而是通过一系列连续性和标识定义的”。因此，实体都有Id属性并且都存储到数据库中。一个实体一般会映射到数据库的一张表。</p></blockquote><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类###"></a>实体类###</h3><p>在ABP中，实体派生自<strong>Entity</strong>类，看下面的例子：</p><pre class=" language-C#"><code class="language-C#">public class Person : Entity{    public virtual string Name { get; set; }    public virtual DateTime CreationTime { get; set; }    public Person()    {        CreationTime = DateTime.Now;    }}</code></pre><p>上面定义了一个<strong>Person</strong>实体类，而且在Entity类中定义了一个<strong>Id</strong>属性，它是该Entity类的 <strong>主键</strong>。因此，所有实体的主键名都是相同的，都是<strong>Id</strong>。</p><p>Id（主键）的类型是可以改变的，默认是int(int32)的。如果你想将Id定义为其他类型，可以像下面那样显示声明：</p><pre class=" language-C#"><code class="language-C#">public class Person : Entity<long>{    public virtual string Name { get; set; }    public virtual DateTime CreationTime { get; set; }    public Person()    {        CreationTime = DateTime.Now;    }}</code></pre><p>而且，你也可以把它设置为string,Guid或其他类型的。</p><p>Entity类重写了<strong>等号</strong>运算符（==），可以轻松地检查两个实体是否相同了（实体的Id相同则认为它们相同）。它也定义了<strong>IsTransient</strong>方法来检测它是否有Id。</p><h3 id="惯例接口"><a href="#惯例接口" class="headerlink" title="惯例接口###"></a>惯例接口###</h3><p>在许多应用中，使用了相似的实体属性（和数据表中的字段），如CreationTime表明该实体是何时创建的。ABP提供了很多有用的接口来使得这些通用的属性变得明确并富有表现力。此外，这也为实现了这些接口的实体类提供了一种编写通用代码的方式。</p><h4 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h4><p><strong>IHasCreationTime</strong>使得使用一个通用的属性来描述一个实体的<strong>“创建时间”</strong>信息成为可能。当实现了该接口的实体类插入到数据库中时，ABP会自动地将<strong>当前的时间</strong>设置给CreationTime。</p><pre class=" language-C#"><code class="language-C#">public interface IHasCreationTime{    DateTime CreationTime { get; set; }}</code></pre><p>Person类可以通过实现<strong>IHasCreationTime</strong>接口来重写，如下所示：</p><pre class=" language-C#"><code class="language-C#">public class Person : Entity<long>, IHasCreationTime{    public virtual string Name { get; set; }    public virtual DateTime CreationTime { get; set; }    public Person()    {        CreationTime = DateTime.Now;    }}</code></pre><p><strong>ICreationAudited</strong>通过增加了<strong>CreatorUserId</strong>扩展了IHasCreationTime:</p><pre class=" language-C#"><code class="language-C#">public interface ICreationAudited : IHasCreationTime{    long? CreatorUserId { get; set; }}</code></pre><p>当保存一个新的实体时，ABP会自动地将<strong>当前的用户Id</strong>设置为CreatorUserId。</p><p>你也可以通过从<strong>CreationAuditedEntity</strong>类派生实体，从而轻易地实现ICreationAudited。</p><p>对于修改也有相似的接口：</p><pre class=" language-C#"><code class="language-C#">public interface IModificationAudited{    DateTime? LastModificationTime { get; set; }    long? LastModifierUserId { get; set; }}</code></pre><p>当更新一个实体的时候，ABP也会自动地设置这些属性。你只需要为你的实体实现这些接口即可。</p><p>如果你想实现所有的审计属性，那么你可以直接实现<strong>IAudited</strong>接口：</p><pre class=" language-C#"><code class="language-C#">public interface IAudited : ICreationAudited, IModificationAudited{        }</code></pre><p>作为一个快捷方式，你可以从<strong>AuditedEntity</strong>类派生，而不需要直接实现<strong>IAudited</strong>。AuditedEntity类对于不同类型的Id属性也有泛型的版本。</p><h4 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h4><p>软删除是将一个实体标记为已删除的通常使用的模式，而不是直接从数据库中删除。比如，你可能不想从数据库中硬删除一个User，因为它可能关联其他的表。<strong>ISoftDelete</strong>接口用于下面的目的：</p><pre class=" language-C#"><code class="language-C#">public interface ISoftDelete{    bool IsDeleted { get; set; }}</code></pre><p>ABP实现了开箱即用的软删除模式。当一个软删除实体被删除后，ABP检测到之后，会阻止删除，将IsDeleted设置为true并更新数据库中的实体。而且，它会自动地过滤数据库中软删除的实体，不会检索（select）它们。</p><p>如果使用了软删除，那么你可能想存储一些信息，比如何时删除以及谁删除了一个实体等等。你可以实现下面演示的<strong>IDeletionAudited</strong>接口：</p><pre class=" language-C#"><code class="language-C#">public interface IDeletionAudited : ISoftDelete{    long? DeleterUserId { get; set; }    DateTime? DeletionTime { get; set; }}</code></pre><p>IDeletionAudited扩展了ISoftDelete，当删除一个实体时，ABP会自动设置这些属性。</p><p>如果你想为一个实体实现所有的审计接口（创建，修改和删除），那么可以直接实现<strong>IFullAudited</strong>,因为它继承了所有的这些接口：</p><pre class=" language-C#"><code class="language-C#">public interface IFullAudited : IAudited, IDeletionAudited{        }</code></pre><p>同样的，作为一个快捷方式，你可以从<strong>FullAuditedEntity</strong>类派生你的实体类从而实现所有的审计接口。</p><p>注意：所有的审计接口和类都有一个定义导航属性到<strong>User</strong>实体的泛型版本（比如ICreationAudited和FullAuditedEntity&lt;TPrimaryKey,TUser&gt;）。</p><h4 id="激活-未激活"><a href="#激活-未激活" class="headerlink" title="激活/未激活"></a>激活/未激活</h4><p>一些实体需要标记为激活的或未激活的。这样，你就可以根据实体的激活或者未激活状态来采取行动。你可以实现<strong>IPassivable</strong>接口来达到目的。该接口定义了<strong>IsActive</strong>属性。</p><p>如果实体在第一次创建时是激活的，那么你可以在构造函数中将IsActive设置为true。</p><p>这与软删除（IsDeleted）是不同的。如果一个实体是软删除的，那么它就不会从数据库中检索到了（ABP默认会阻止），但是，对于激活或者未激活的实体，控制获取实体完全取决于你。</p><h3 id="IEntity接口"><a href="#IEntity接口" class="headerlink" title="IEntity接口###"></a>IEntity接口###</h3><p>实际上，<strong>Entity</strong>类实现了<strong>IEntity</strong>接口（且<strong>Entity</strong>实现了<strong>IEntity</strong>）。如果不想从Entity类中派生，那么可以直接实现这些接口。但是，除非你有一个好的原因不从Entity类派生，否则，不建议这么做。</p><h1 id="ABP理论学习之仓储"><a href="#ABP理论学习之仓储" class="headerlink" title="ABP理论学习之仓储"></a><a href="https://www.cnblogs.com/farb/p/ABPRepository.html">ABP理论学习之仓储</a></h1><hr><h2 id="本篇目录-11"><a href="#本篇目录-11" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><a href="https://www.cnblogs.com/farb/p/ABPRepository.html#IRepository">IRepository接口</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPRepository.html#query">查询</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPRepository.html#insert">插入</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPRepository.html#update">更新</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPRepository.html#delete">删除</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPRepository.html#others">其他</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPRepository.html#async">关于异步方法</a></strong></li></ul></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPRepository.html#repository">仓储实现</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPRepository.html#mdbcon">管理数据库连接</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPRepository.html#repositoryLife">仓储的生命周期</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPRepository.html#repositoryBestDo">仓储最佳实践</a></strong></li></ul><blockquote><h4 id="Martin-Fowler对仓储的定义"><a href="#Martin-Fowler对仓储的定义" class="headerlink" title="Martin Fowler对仓储的定义"></a>Martin Fowler对仓储的定义</h4><p>位于领域层和数据映射层之间，使用类似集合的接口来访问领域对象。</p></blockquote><p>在实践中，仓储是执行领域对象（实体和值对象）的数据库操作。一般地，一个分离的仓储用于一个实体（或者聚合根）。</p><h3 id="IRepository接口"><a href="#IRepository接口" class="headerlink" title="IRepository接口###"></a>IRepository接口###</h3><p>在ABP中，一个仓储类应该实现一个<strong>IRepository</strong>接口。为每一个仓储定义一个接口是一个好的做法。</p><p>一个Person实体的仓储定义如下：</p><pre class=" language-C#"><code class="language-C#">public interface IPersonRepository : IRepository<Person>{}</code></pre><p>IPersonRepository扩展了<strong>IRepository</strong>，它用于定义拥有主键类型为int32的实体。如果你的实体不是int，那么可以扩展**IRepository&lt;TEntity,TPrimaryKey&gt;**接口，如下所示：</p><pre class=" language-C#"><code class="language-C#">public interface IPersonRepository : IRepository<Person, long>{}</code></pre><p>IRepository为仓储类定义了最通用的方法，如select，insert，update和delete方法（CRUD操作）。大多数情况下，这些方法对于简单的实体是足够了。如果这些方法对于一个实体来说已经足够了，那么就没有必要为这个实体创建仓储接口和仓储类了。看下面。</p><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>IRepository定义了通用的方法，从数据库中检索实体。</p><h5 id="获得单个实体"><a href="#获得单个实体" class="headerlink" title="获得单个实体"></a>获得单个实体</h5><pre class=" language-C#"><code class="language-C#">TEntity Get(TPrimaryKey id);Task<TEntity> GetAsync(TPrimaryKey id);TEntity Single(Expression<Func<TEntity, bool>> predicate);Task<TEntity> SingleAsync(Expression<Func<TEntity, bool>> predicate);TEntity FirstOrDefault(TPrimaryKey id);Task<TEntity> FirstOrDefaultAsync(TPrimaryKey id);TEntity FirstOrDefault(Expression<Func<TEntity, bool>> predicate);Task<TEntity> FirstOrDefaultAsync(Expression<Func<TEntity, bool>> predicate);TEntity Load(TPrimaryKey id);</code></pre><p><strong>Get</strong>方法用于获得一个给定主键（Id）的实体。如果在数据库中没有找到这个实体，就会抛出异常。<strong>Single</strong>方法和Get类似，但是它的参数是一个表达式而不是一个Id。因此，你可以使用Lambda表达式获得一个实体。样例用法：</p><pre class=" language-C#"><code class="language-C#">var person = _personRepository.Get(42);var person = _personRepository.Single(p => p.Name == "Halil İbrahim Kalkan");</code></pre><p>注意：如果根据给定的条件没有查找出实体或者查出不止一个实体，那么<strong>Single</strong>方法会抛出异常。</p><p><strong>FirstOrDefault</strong>是相似的，但是如果根据给的的Id或者表达式没有找到实体，那么就会返回<strong>null</strong>。如果对于给定的条件存在不止一个实体，那么会返回找到的第一个实体。</p><p><strong>Load</strong>方法不会从数据库中检索实体，但是会创建一个用于懒加载的代理对象。如果你只用了Id属性，那么Entity实际上并没有检索到。只有你访问实体的其他属性，才会从数据库中检索。考虑到性能因素，这个就可以替换Get方法。这在NHiberbate中也实现了。如果ORM提供者没有实现它，那么Load方法会和Get方法一样地工作。</p><p>一些方法有用于async编程模型的<strong>异步（async）</strong>版本。</p><p>获得实体的列表</p><pre class=" language-C#"><code class="language-C#">List<TEntity> GetAllList();Task<List<TEntity>> GetAllListAsync();List<TEntity> GetAllList(Expression<Func<TEntity, bool>> predicate);Task<List<TEntity>> GetAllListAsync(Expression<Func<TEntity, bool>> predicate);IQueryable<TEntity> GetAll();</code></pre><p><strong>GetAllList</strong>从数据库中检索所有的实体。该方法的重载可以用于过滤实体。例子如下：</p><pre class=" language-C#"><code class="language-C#">var allPeople = _personRepository.GetAllList();var somePeople = _personRepository.GetAllList(person => person.IsActive && person.Age > 42);</code></pre><p><strong>GetAll</strong>返回的类型是IQueryable。因此，你可以在此方法之后添加Linq方法。例子如下：</p><pre class=" language-C#"><code class="language-C#">//Example 1var query = from person in _personRepository.GetAll()            where person.IsActive            orderby person.Name            select person;var people = query.ToList();//Example 2:List<Person> personList2 = _personRepository.GetAll().Where(p => p.Name.Contains("H")).OrderBy(p => p.Name).Skip(40).Take(20).ToList();</code></pre><p>有了GetAll方法，几乎所有的查询都可以使用Linq重写。甚至可以用在一个连接表达式中。</p><blockquote><h4 id="关于IQueryable"><a href="#关于IQueryable" class="headerlink" title="关于IQueryable"></a>关于IQueryable</h4><p>脱离了仓储方法调用GetAll()方法时，数据库连接必须要打开。这是因为IQueryable的延迟执行。直到调用ToList()方法或者在foreach循环中使用IQueryable(或者访问查询到的元素)时，才会执行数据库查询操作。因此，当调用ToList()方法时。数据库连接必须打开。这可以通过ABP中的<strong>UnitOfWork</strong>特性标记调用者方法来实现。注意：应用服务方法默认已经是UnitOfWork，因此，即使没有为应用服务层方法添加UnitOfWork特性，GetAll()方法也会正常工作。</p></blockquote><p>这些方法也存在用于异步编程模型的asyn版本。</p><h5 id="自定义返回值"><a href="#自定义返回值" class="headerlink" title="自定义返回值"></a>自定义返回值</h5><p>也存在提供了IQueryable的额外方法，在调用的方法中不需要使用UnitOfWork。</p><pre><code>T Query&lt;T&gt;(Func&lt;IQueryable&lt;TEntity&gt;, T&gt; queryMethod);</code></pre><p>Query方法接受一个接收IQueryable的lambda(或方法)，并返回任何对象的类型。例子如下：</p><pre class=" language-C#"><code class="language-C#">var people = _personRepository.Query(q => q.Where(p => p.Name.Contains("H")).OrderBy(p => p.Name).ToList());</code></pre><p>在该仓储方法中，因为执行了给定的lambda(或方法)，它是在数据库连接打开的时候执行的。你可以返回实体列表，单个实体，一个投影或者执行了该查询的其他东西。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>IRepository接口定义了将一个实体插入数据库的简单方法：</p><pre class=" language-C#"><code class="language-C#">TEntity Insert(TEntity entity);Task<TEntity> InsertAsync(TEntity entity);TPrimaryKey InsertAndGetId(TEntity entity);Task<TPrimaryKey> InsertAndGetIdAsync(TEntity entity);TEntity InsertOrUpdate(TEntity entity);Task<TEntity> InsertOrUpdateAsync(TEntity entity);TPrimaryKey InsertOrUpdateAndGetId(TEntity entity);Task<TPrimaryKey> InsertOrUpdateAndGetIdAsync(TEntity entity);</code></pre><p><strong>Insert</strong>方法简化了将一个实体插入数据库，并将刚刚插入的实体返回。<strong>InsertAndGetId</strong>方法返回了新插入实体的Id。如果实体的Id是自动增长的并且需要最新插入实体的Id，那么该方法很有用。<strong>InsertOrUpdate</strong>方法通过检查Id的值插入或更新给定的实体。最后，当插入或者更新之后，<strong>InsertOrUpdateAndGetId</strong>返回该实体的值。</p><p>所有的方法都存在用于异步编程模型的async版本。</p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>IRepository定义了一个方法来更新数据库中已存在的实体。它可以获得要更新的实体并返回相同的实体对象。</p><pre class=" language-C#"><code class="language-C#">TEntity Update(TEntity entity);Task<TEntity> UpdateAsync(TEntity entity);</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>IRepository定义了从数据库中删除一个已存在的实体的方法。</p><pre class=" language-C#"><code class="language-C#">void Delete(TEntity entity);Task DeleteAsync(TEntity entity);void Delete(TPrimaryKey id);Task DeleteAsync(TPrimaryKey id);void Delete(Expression<Func<TEntity, bool>> predicate);Task DeleteAsync(Expression<Func<TEntity, bool>> predicate);</code></pre><p>第一个方法接受一个已存在的实体，第二个方法接受一个要删除的实体的Id。</p><p>最后一个方法接受一个删除符合给定条件的所有实体的方法。注意，匹配给定谓词的所有实体都会从数据库中检索到然后被删除。因此，小心使用它，如果给定的条件存在太多的实体，那么可能会造成性能问题。</p><h4 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h4><p>IRepository也提供了获得表中实体数量的方法。</p><pre class=" language-C#"><code class="language-C#">int Count();Task<int> CountAsync();int Count(Expression<Func<TEntity, bool>> predicate);Task<int> CountAsync(Expression<Func<TEntity, bool>> predicate);long LongCount();Task<long> LongCountAsync();long LongCount(Expression<Func<TEntity, bool>> predicate);Task<long> LongCountAsync(Expression<Func<TEntity, bool>> predicate);</code></pre><h4 id="关于异步方法"><a href="#关于异步方法" class="headerlink" title="关于异步方法"></a>关于异步方法</h4><p>ABP支持异步编程模型（APM）。因此，仓储方法有异步版本。下面是一个使用了异步模型的应用服务方法样例：</p><pre class=" language-C#"><code class="language-C#">public class PersonAppService : AbpWpfDemoAppServiceBase, IPersonAppService{    private readonly IRepository<Person> _personRepository;    public PersonAppService(IRepository<Person> personRepository)    {        _personRepository = personRepository;    }    public async Task<GetPeopleOutput> GetAllPeople()    {        var people = await _personRepository.GetAllListAsync();                    return new GetPeopleOutput        {            People = Mapper.Map<List<PersonDto>>(people)        };    }}</code></pre><p>GetAllPeople方法是异步的，并使用了具有await关键字的GetAllListAsync方法。</p><p>也许不是所有的ORM框架都支持Async，但是EntityFramework支持。如果不支持，异步仓储方法就会同步进行。比如，在EF中，InsertAsync和Insert是等效的，因为直到工作单元完成（Dbcontext.SaveChanges），EF才会将新的实体写入数据库。</p><h3 id="仓储实现"><a href="#仓储实现" class="headerlink" title="仓储实现###"></a>仓储实现###</h3><p>ABP的设计独立于一个特定的ORM(对象/关系映射)框架或者访问数据库的其他技术。通过实现仓储接口，可以使用任何框架。</p><p>ABP使用<strong>NHibernate</strong>和 <strong>EntityFramework</strong>实现了开箱即用的仓储。关于这两个ORM框架可以关注后面的文档。</p><p>当使用NHibernate或EntityFramework时，如果标准方法是足够使用的话，那么不必为实体类创建仓储了。你可以直接注入<strong>IRepository</strong>(或IRepository&lt;TEntity，TPrimaryKey&gt;)。下面是使用了一个仓储将一个实体插入数据库的应用服务例子：</p><pre class=" language-c#"><code class="language-c#">public class PersonAppService : IPersonAppService{    private readonly IRepository<Person> _personRepository;    public PersonAppService(IRepository<Person> personRepository)    {        _personRepository = personRepository;    }    public void CreatePerson(CreatePersonInput input)    {                person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };                _personRepository.Insert(person);    }}</code></pre><p>PersonAppService构造注入了<strong>IRepository</strong>，并使用了<strong>Insert</strong>方法。这样，当你需要为一个实体创建一个自定义仓储方法时，你才应该为该实体创建一个仓储类。</p><h3 id="管理数据库连接"><a href="#管理数据库连接" class="headerlink" title="管理数据库连接###"></a>管理数据库连接###</h3><p>在仓储方法中，数据库连接是没有打开的或是关闭的。ABP对于数据库连接的管理是自动处理的。</p><p>当将要进入一个仓储方法时，数据库连接会自动打开，并且<strong>事务</strong>自动开始。当仓储方法结束并返回的时候，ABP会自动完成：保存所有的更改，完成事务的提交和关闭数据库连接。如果仓储方法抛出任何类型的异常，那么事务会自动<strong>回滚</strong>并关闭数据库。这对于所有的实现了IRepository接口的类的公共方法都是成立的。</p><p>如果一个仓储方法调用了其他的仓储方法，那么它们会共享相同的连接和事务。进入仓储的第一个方法会管理数据库的连接。更多信息，请留意后面博客的工作单元。</p><p>一篇不错的数据库连接博客：**<a href="http://www.cnblogs.com/liuhaorain/archive/2012/02/19/2353110.html">细说数据库连接</a>**</p><h3 id="仓储的生命周期"><a href="#仓储的生命周期" class="headerlink" title="仓储的生命周期###"></a>仓储的生命周期###</h3><p>所有的仓储实例都是<strong>Transient</strong>(每次使用时都会实例化)的。ABP强烈推荐使用依赖注入技术。当一个仓储类需要注入时，依赖注入的容器会自动创建该类的新实例。</p><h3 id="仓储最佳实践"><a href="#仓储最佳实践" class="headerlink" title="仓储最佳实践###"></a>仓储最佳实践###</h3><ul><li>对于一个T类型的实体，使用IRepository仓储接口。除非真的需要，否则不要创建自定义的仓储。预定义的仓储方法对于很多情况足够用了。</li><li>如果你正在创建一个自定义的仓储（通过扩展IRepository）： 仓储类应该是无状态的。这意味着，你不应该定义仓储级别的状态对象，而且一个仓储方法调用不应该影响其他的调用。 自定义仓储方法不应该包含业务逻辑或者应用逻辑，而应该只执行数据相关的或者orm特定的任务。 当仓储使用依赖注入时，给其他服务定义更少的或者不要定义依赖。</li></ul><h1 id="ABP理论学习之领域服务（重点）"><a href="#ABP理论学习之领域服务（重点）" class="headerlink" title="ABP理论学习之领域服务（重点）"></a><a href="https://www.cnblogs.com/farb/p/ABPDomainService.html">ABP理论学习之领域服务（重点）</a></h1><hr><h2 id="本篇目录-12"><a href="#本篇目录-12" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDomainService.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDomainService.html#IDomain">IDomainService接口和DomainService类</a></strong></li><li><a href="https://www.cnblogs.com/farb/p/ABPDomainService.html#sample">样例</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDomainService.html#create">创建一个接口</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDomainService.html#service">服务实现</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDomainService.html#call">调用应用服务</a></strong></li></ul></li><li><a href="https://www.cnblogs.com/farb/p/ABPDomainService.html#discussion">一些讨论</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDomainService.html#whynot">何不只使用应用服务</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDomainService.html#forceUse">如何强制使用领域服务</a></strong></li></ul></li></ul><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍###"></a>介绍###</h3><p>领域服务（或DDD中的服务）用于执行领域操作和业务规则。Eric Evans描述了一个好的服务应该具备下面三个特征：</p><ol><li>和领域概念相关的操作不是一个实体或者值对象的本质部分。</li><li>接口定义在领域模型其他元素的条款中。</li><li>操作是无状态的。</li></ol><p>跟获得或返回一个数据传输对象的应用服务方法（DTO）不同，领域服务获得或者返回一个<strong>领域对象</strong>（比如实体或值类型）。</p><p>一个领域服务可以用于应用服务，也可以用于其他的领域服务，但不能直接用于展现层，服务层才直接用于展现层。</p><h3 id="IDomainService接口和DomainService类"><a href="#IDomainService接口和DomainService类" class="headerlink" title="IDomainService接口和DomainService类###"></a>IDomainService接口和DomainService类###</h3><p>ABP定义了<strong>IDomainService</strong>接口，所有的领域服务都按照惯例实现了该接口。当实现时，领域服务会以<strong>transient自动注册</strong>到依赖注入系统。</p><p>此外，领域服务（可选地）可以从<strong>DomainService类</strong>继承。因此，它可以使用一些继承的属性，比如logging，本地化等等。当然，如果没有继承，如果需要的话也可以注入这些属性。</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例###"></a>样例###</h3><p>假设我们有一个任务管理系统并且有将一个任务派给一个人的业务规则。</p><h4 id="创建一个接口"><a href="#创建一个接口" class="headerlink" title="创建一个接口"></a>创建一个接口</h4><p>首先我们为该服务定义一个接口（不是必须的，但是这样是一个好的实践）：</p><pre class=" language-C#"><code class="language-C#">public interface ITaskManager : IDomainService{    void AssignTaskToPerson(Task task, Person person);}</code></pre><p>可以看到，<strong>TaskManager</strong>服务使用领域对象工作：一个<strong>Task</strong> 和一个<strong>Person</strong>。命名领域服务时存在一些惯例。它可以是TaskManager，TaskService或者TaskDomainService…</p><h4 id="服务实现"><a href="#服务实现" class="headerlink" title="服务实现"></a>服务实现</h4><p>先来看看下面这个实现：</p><pre class=" language-C#"><code class="language-C#">public class TaskManager : DomainService, ITaskManager{    public const int MaxActiveTaskCountForAPerson = 3;    private readonly ITaskRepository _taskRepository;    public TaskManager(ITaskRepository taskRepository)    {        _taskRepository = taskRepository;    }    public void AssignTaskToPerson(Task task, Person person)    {        if (task.AssignedPersonId == person.Id)        {            return;        }        if (task.State != TaskState.Active)        {            throw new ApplicationException("Can not assign a task to a person when task is not active!");        }        if (HasPersonMaximumAssignedTask(person))        {            throw new UserFriendlyException(L("MaxPersonTaskLimitMessage", person.Name));        }        task.AssignedPersonId = person.Id;    }    private bool HasPersonMaximumAssignedTask(Person person)    {        var assignedTaskCount = _taskRepository.Count(t => t.State == TaskState.Active && t.AssignedPersonId == person.Id);        return assignedTaskCount >= MaxActiveTaskCountForAPerson;    }}</code></pre><p>上面的代码定义了两个业务规则：</p><ul><li>一个任务为了能够派给一个新人，它应该是<strong>Active（激活）的状态</strong></li><li>一个人可以<strong>最多可以有3个</strong>激活的任务。</li></ul><p>你可能想知道为啥第一次检测时抛出了一个<strong>ApplicationException</strong>，而第二次检查时抛出了<strong>UserFriendlyException</strong>，请关注后面博客的异常处理。这根领域服务根本无关。这里这样处理的想法是这样的，UI必须先要检查一个任务的状态，否则不应该允许我们将它派给一个人。这是一个应用程序的错误，并且我们可以向用户隐藏这个错误。对于第二个友好的异常信息，UI检查更加困难，而且我们可以向用户显示一个可读的错误信息。这只是一个例子而已。</p><h4 id="调用应用服务"><a href="#调用应用服务" class="headerlink" title="调用应用服务"></a>调用应用服务</h4><p>现在，来看看如何在一个应用服务中使用TaskManager:</p><pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService, ITaskAppService{    private readonly IRepository<Task, long> _taskRepository;    private readonly IRepository<Person> _personRepository;    private readonly ITaskManager _taskManager;    public TaskAppService(IRepository<Task, long> taskRepository, IRepository<Person> personRepository , ITaskManager taskManager)    {        _taskRepository = taskRepository;        _personRepository = personRepository;        _taskManager = taskManager;    }    public void AssignTaskToPerson(AssignTaskToPersonInput input)    {        var task = _taskRepository.Get(input.TaskId);        var person = _personRepository.Get(input.PersonId);        _taskManager.AssignTaskToPerson(task, person);    }}</code></pre><p>Task<strong>应用服务</strong>使用给定的<strong>DTO</strong>(输入)和<strong>仓储</strong>来检索相关的<strong>task</strong>和 <strong>person</strong>，并将它们传给 <strong>TaskManager</strong>(领域服务)。</p><h3 id="一些讨论"><a href="#一些讨论" class="headerlink" title="一些讨论###"></a>一些讨论###</h3><p>基于上面的例子，你可能会存在下面的疑问。</p><h4 id="何不只使用应用服务"><a href="#何不只使用应用服务" class="headerlink" title="何不只使用应用服务"></a>何不只使用应用服务</h4><p>你可能会问，为什么不使用应用服务实现领域服务中的逻辑呢？</p><p>我们可以简单地说，它不是应用服务要干的活。因为领域逻辑不是一个<strong>用例（use-case）</strong>，而是一个 <strong>业务操作</strong>。我们可以在不同的用例中使用相同的“将一个任务派给一个人”的逻辑。比如说我们以后会更新这个任务，并且将这个任务派给其他人。因此，我们可以使用相同的领域逻辑，这个逻辑就是“将一个任务派给一个人”，我们不用考虑这个具体的人和具体的任务。此外，我们可能有两个不同的UI（一个移动端应用和一个web应用）来共享相同的领域。</p><p>下面根据个人的理解来画个图：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151222234720249-1003510440.png" alt="img"></p><p>如上图，应用服务层中有一个应用服务方法，但却使用到了领域层的三个业务逻辑，因为在领域层中，获取单个task和person都各自为一个业务逻辑，将一个任务派给一个人又是一个业务逻辑。在应用服务层，我们只需要获得一个人和一个任务就行，然后将该任务派给这个人，根本不需要考虑这个人和这个任务的获取细节，也不用考虑任务派发的细节，因为这完全不是应用层考虑的事儿。</p><p>如果你的领域很简单，只有一个UI并且将一个任务派发给一个人在单点处就可以完成，那么你可以跳过领域服务，然后在应用服务层实现该逻辑。虽然这不是DDD的最佳实践，但是ABP不会强制你这么设计。</p><h4 id="如何强制使用领域服务"><a href="#如何强制使用领域服务" class="headerlink" title="如何强制使用领域服务"></a>如何强制使用领域服务</h4><p>你可以看到，应用服务只能做下面的事情：</p><pre class=" language-C#"><code class="language-C#">public void AssignTaskToPerson(AssignTaskToPersonInput input){    var task = _taskRepository.Get(input.TaskId);    task.AssignedPersonId = input.PersonId;}</code></pre><p>开发这个应用服务的开发者可能不知道存在一个<strong>TaskManager</strong>，而且可以直接将给定的 <strong>PersonId</strong>设置给任务的 <strong>AssignedPersonId</strong>。那么，如何阻止他这样做呢？基于这些，在DDD领域中存在很多讨论和使用到的模式。我们不会涉及得很深，但是可以提供<br> 一种简单的方式。</p><p>我们可以将<strong>Task</strong>改成下面这样：</p><pre class=" language-C#"><code class="language-C#">public class Task : Entity<long>{    public virtual int? AssignedPersonId { get; protected set; }    //...其他成员    public void AssignToPerson(Person person, ITaskPolicy taskPolicy)    {        taskPolicy.CheckIfCanAssignTaskToPerson(this, person);        AssignedPersonId = person.Id;    }}</code></pre><p>可以将<strong>AssignedPersonId</strong>的setter改成protected。这样，它就不能在Task实体类之外改变了。添加一个需要一个Person和ITaskPolicy的参数。<strong>CheckIfCanAssignTaskToPerson</strong>方法检查这是否是一个有效的派发，如果无效就抛出一个适当的异常。最后，应用服务方法应该是这个样子的：</p><pre class=" language-C#"><code class="language-C#">public void AssignTaskToPerson(AssignTaskToPersonInput input){    var task = _taskRepository.Get(input.TaskId);    var person = _personRepository.Get(input.PersonId);    task.AssignToPerson(person, _taskPolicy);}</code></pre><p>现在，不存在将一个任务派给一个人的第二种方法了。我们应该总是要使用AssignToPerson方法，而且不能跳过业务规则了。</p><h1 id="ABP理论学习之工作单元-Unit-of-Work-（重要）"><a href="#ABP理论学习之工作单元-Unit-of-Work-（重要）" class="headerlink" title="ABP理论学习之工作单元(Unit of Work)（重要）"></a><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html">ABP理论学习之工作单元(Unit of Work)（重要）</a></h1><hr><h2 id="本篇目录-13"><a href="#本篇目录-13" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#ways">公共连接和事务管理方法</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#abpConn">ABP中的连接和事务管理</a></strong><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#repo">仓储类</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#appService">应用服务</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#uow">工作单元</a></strong></li></ul></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#uowDetail">工作单元详解</a></strong><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#disable">关闭工作单元</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#nonTrans">非事务的工作单元</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#callAnother">工作单元方法调用其它</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#scope">工作单元作用域</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#autoSaving">自动保存</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#getAll">IRepository.GetAll()方法</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#restrictions">UnitOfWork特性的限制</a></strong></li></ul></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#options">选项</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#methods">方法</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#events">事件</a></strong></li></ul><h3 id="公共连接和事务管理方法"><a href="#公共连接和事务管理方法" class="headerlink" title="公共连接和事务管理方法"></a>公共连接和事务管理方法</h3><p>在使用了数据库的应用中，连接和事务管理是最重要的概念之一。何时打开一个连接,何时开始一个事务，如何释放连接等等。</p><p>你可能已经知道，Net使用了连接池。因此，创建一个连接实际上是从连接池中获取一个连接，因为因为创建一个连接是有消耗的。如果在连接池中没有可用的连接，那么会创建一个新的连接，并将该连接加入连接池。当你释放连接时，实际上是将该连接发送回给连接池，并没有完全释放。这种机制是.Net提供的立即可用的功能。因此，在我们使用完一个连接后应该立即释放，在需要的时候才创建一个新的连接。总之，最佳实践记住这八个字足矣：<strong>尽晚打开，尽早释放</strong>。</p><p>这里我推荐一篇关于数据库连接的文章，写得很浅显易懂：**<a href="http://www.cnblogs.com/liuhaorain/archive/2012/02/19/2353110.html">《细说数据库连接》</a>**</p><p>在一个应用中创建或者释放一个数据库连接，通常有2种方法。</p><p><strong>第一种方法</strong>：当Web请求开始（在Global.asax的Application_BeginRequest事件中）的时候创建一个连接，在所有的数据库操作时使用相同的连接，并且在请求结束（Application_EndRequest）时关闭或者释放该连接。这种方法很简单但是不够高效。为啥呢？</p><ul><li>在一个请求中也许没有数据库操作，但是连接已经打开了。这造成了连接池的无效使用。</li><li>在一次请求中，可能请求需要消耗很长的时间而数据库操作只花费很短的时间，这也会造成连接池的无效使用。</li><li>这只在Web应用中是可行的。如果应用是一个Windows服务，那么可能不会实现。</li></ul><p>以<strong>事务</strong>的方式执行数据库操作已被认为是一种最佳实践。如果一个操作失败了，那么所有的操作都会回滚。因为一个事务可以锁定数据库中的一些行（甚至表），所以它必须是短暂存活的。</p><p><strong>第二种方法</strong>：当需要时（仅在使用前）创建一个连接，使用后立即关闭。这是最有效的，但是到处创建或者释放连接是一项重复乏味的工作。</p><h3 id="ABP中的连接和事务管理"><a href="#ABP中的连接和事务管理" class="headerlink" title="ABP中的连接和事务管理"></a>ABP中的连接和事务管理</h3><p>ABP兼备了这两种方法并且提供了一个简单而又有效的模型。</p><h4 id="仓储类"><a href="#仓储类" class="headerlink" title="仓储类"></a>仓储类</h4><p>仓储式执行数据库操作主要的类。当进入一个仓储方法时，ABP会打开一个数据库连接（可能不是立即打开，但是在第一次使用数据库时肯定是打开的，取决于ORM提供者的实现）并开始一个事务。因此，在一个仓储方法中可以安全地使用连接。在方法的结束，事务被提交并且连接被释放。如果仓储方法抛出任何异常，那么事务都会<strong>回滚</strong>且连接被释放。这样一来，仓储方法就是<strong>原子的（一个工作单元）</strong>。ABP对于这些会自动处理。这里是一个简单的仓储：</p><pre class=" language-C#"><code class="language-C#">public class ContentRepository : NhRepositoryBase<Content>, IContentRepository{    public List<Content> GetActiveContents(string searchCondition)    {        var query = from content in Session.Query<Content>()                    where content.IsActive && !content.IsDeleted                    select content;        if (!string.IsNullOrEmpty(searchCondition))        {            query = query.Where(content => content.Text.Contains(searchCondition));        }        return query.ToList();    }}</code></pre><p>这个例子使用了NHibernate作为ORM。正如上面演示的，没有编写数据库连接（在NHibernate中是Session）打开或者关闭的代码。</p><p>如果一个仓储方法调用了其他的仓储方法（一般而言，如果一个工作单元调用了其他的工作单元方法），那么它们共享相同的连接和事务。第一个进入的方法管理连接和事务，其他方法使用相同的连接和事务。</p><h4 id="应用服务"><a href="#应用服务" class="headerlink" title="应用服务"></a>应用服务</h4><p>一个应用服务也被认为是一个工作单元。假设我们有一个像下面的应用服务：</p><pre class=" language-C#"><code class="language-C#">public class PersonAppService : IPersonAppService{    private readonly IPersonRepository _personRepository;    private readonly IStatisticsRepository _statisticsRepository;    public PersonAppService(IPersonRepository personRepository, IStatisticsRepository statisticsRepository)    {        _personRepository = personRepository;        _statisticsRepository = statisticsRepository;    }    public void CreatePerson(CreatePersonInput input)    {        var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };        _personRepository.Insert(person);        _statisticsRepository.IncrementPeopleCount();    }}</code></pre><p>在CreatePerson方法中，我们使用了person仓储插入了一个person，而且使用statistics仓储增加总人数。在这里例子中，这两个仓储共享相同的连接和事务，因为它们在一个应用服务方法中。ABP在进入CreatePerson方法时打开一个数据库连接并开始一个事务，如果没有抛出异常事务会在方法结尾时提交，如果有任何异常发生，将会回滚。这样一来，在CreatePerson方法中的所有数据库操作都成了<strong>原子的（工作单元）</strong>。</p><h4 id="工作单元"><a href="#工作单元" class="headerlink" title="工作单元"></a>工作单元</h4><p>工作单元对于仓储和应用服务方法<strong>隐式</strong>有效。如果你想在其他地方控制数据库连接和事务，那么可以<strong>显式</strong>使用它。</p><h5 id="UnitOfWork特性"><a href="#UnitOfWork特性" class="headerlink" title="UnitOfWork特性"></a>UnitOfWork特性</h5><p>最受人欢迎的方法是使用<strong>UnitOfWorkAttribute</strong>。例如：</p><pre class=" language-C#"><code class="language-C#">[UnitOfWork]public void CreatePerson(CreatePersonInput input){    var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };    _personRepository.Insert(person);    _statisticsRepository.IncrementPeopleCount();}</code></pre><p>这样，CreatePerson方法变成了工作单元并且管理数据库连接和事务，两个仓储使用相同的工作单元，注意的是，如果这是一个应用服务方法，就不需要UnitOfWork特性。</p><h5 id="IUnitOfWorkManager"><a href="#IUnitOfWorkManager" class="headerlink" title="IUnitOfWorkManager"></a>IUnitOfWorkManager</h5><p>第二种方法是使用**IUnitOfWorkManager.Begin()**方法，如下所示：</p><pre class=" language-C#"><code class="language-C#">public class MyService{    private readonly IUnitOfWorkManager _unitOfWorkManager;    private readonly IPersonRepository _personRepository;    private readonly IStatisticsRepository _statisticsRepository;    public MyService(IUnitOfWorkManager unitOfWorkManager, IPersonRepository personRepository, IStatisticsRepository statisticsRepository)    {        _unitOfWorkManager = unitOfWorkManager;        _personRepository = personRepository;        _statisticsRepository = statisticsRepository;    }    public void CreatePerson(CreatePersonInput input)    {        var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };        using (var unitOfWork = _unitOfWorkManager.Begin())        {            _personRepository.Insert(person);            _statisticsRepository.IncrementPeopleCount();            unitOfWork.Complete();        }    }}</code></pre><p>你可以注入然后使用IUnitOfWork，正如这里演示的这样（如果你的应用继承自ApplicationService类，那么你可以直接使用<strong>CurrentUnitOfWork</strong>属性。如果没有，你要先注入IUnitOfWorkManager）。这样，你就可以创建更多的<strong>限制作用域</strong>的工作单元。用这种方法，你应该手动调用<strong>Complete</strong>方法。如果没有调用，事务就会回滚，改变就不会保存。</p><p>Begin方法有很多重载来设置<strong>工作单元选项</strong>。</p><p>如果找不到一个很好的理由，建议还是使用<strong>UnitOfWork特性</strong>，因为代码越短越好。</p><h3 id="工作单元详解"><a href="#工作单元详解" class="headerlink" title="工作单元详解"></a>工作单元详解</h3><h4 id="关闭工作单元"><a href="#关闭工作单元" class="headerlink" title="关闭工作单元"></a>关闭工作单元</h4><p>有时候你可能想关闭应用服务方法的工作单元（因为默认是开启的），此时，可以使用UnitOfWorkAttribute的IsDisabled属性。用法如下：</p><pre class=" language-C#"><code class="language-C#">[UnitOfWork(IsDisabled = true)]public virtual void RemoveFriendship(RemoveFriendshipInput input){    _friendshipRepository.Delete(input.Id);}</code></pre><p>正常情况下，不需要关闭数据单元，因为应用服务方法应该是原子的且一般都会使用数据库。但也有些例外情况让你想要关闭应用服务方法的工作单元：</p><ul><li>方法不执行任何数据库操作而且你也不想打开一个没有必要的数据库连接。</li><li>如上面描述的，你想要在一个UnitOfWorkScope类的有限作用域内使用工作单元。</li></ul><p><strong>注意：</strong>如果一个工作单元方法调用了这个<em>RemoveFriendship</em>方法，那么后者的关闭工作单元的功能将会失效，并且也会使用和调用者方法相同的工作单元。因此，要小心使用工作单元的关闭功能。</p><h4 id="非事务的工作单元"><a href="#非事务的工作单元" class="headerlink" title="非事务的工作单元"></a>非事务的工作单元</h4><p>工作单元默认是事务的（本质如此）。因此，ABP会开始-&gt;提交-&gt;回滚一个显式的数据库级别的事务。在一些特殊场合，事务可能会造成问题，因为它可能会锁住数据库中的一些行或者表。在这种情况下，你可能想关闭数据库级别的事务。UnitOfWork特性可以在构造函数中获得一个布尔值，从而以非事务形式工作。用法如下：</p><pre class=" language-C#"><code class="language-C#">[UnitOfWork(isTransactional: false)]public GetTasksOutput GetTasks(GetTasksInput input){    var tasks = _taskRepository.GetAllWithPeople(input.AssignedPersonId, input.State);    return new GetTasksOutput            {                Tasks = Mapper.Map<List<TaskDto>>(tasks)            };}</code></pre><p>建议使用**[UnitOfWork(isTransactional: false)]**，因为它是更具可读性的，但你也可以使用[UnitOfWork(false)]。</p><p>注意ORM框架（如EF和NH）内部使用了一条单一命令来保存更改。假设你以非事务的UOW（工作单元）更新了一些实体的情景，甚至在这种情况下所有的更新都是在工作单元结束时以一个单一的数据库命令执行的。但是如果你直接执行一个SQL查询，它会立即执行。</p><p>非事务的UOW有一个限制。如果你已经处于一个事务的工作单元的作用域内，那么将isTransactional设置为false将会被忽略。</p><p>使用非事务的工作单元要小心，因为大多数时候对于数据的集成是事务的。如果你的方法只是读数据，不需要改变数据，当然该方法是可以为非事务的了。</p><h4 id="工作单元方法调用其它"><a href="#工作单元方法调用其它" class="headerlink" title="工作单元方法调用其它"></a>工作单元方法调用其它</h4><p>如果一个工作单元的方法（使用了UnitOfWork特性声明的方法）调用另一个工作单元的方法，那么它们共享相同的连接和事务。第一个方法管理连接，其他方法使用连接。这个对于运行在相同<strong>线程</strong>的方法是成立的（对于web应用则是相同的请求）。实际上，当一个工作单元作用域开始时，在同一线程执行的所有代码都共享同一个连接和事务，直到工作单元作用域结束。这对于UnitOfWork特性和UnitOfWorkScope类都是成立的。</p><h4 id="工作单元作用域"><a href="#工作单元作用域" class="headerlink" title="工作单元作用域"></a>工作单元作用域</h4><p>在其他事务中可以创建一个不同而又隔离的事务，或者可以在一个事务中创建一个非事务的作用域。.Net中定义了**<a href="https://msdn.microsoft.com/en-us/library/system.transactions.transactionscopeoption(v=vs.110).aspx">TransactionScopeOption</a>**，你可以为工作单元设置作用域选项。</p><h4 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h4><p>当我们为一个方法使用了工作单元时，ABP会在该方法结束时自动保存所有的更改。假设我们有一个更新person的name的方法：</p><pre class=" language-C#"><code class="language-C#">[UnitOfWork]public void UpdateName(UpdateNameInput input){    var person = _personRepository.Get(input.PersonId);    person.Name = input.NewName;}</code></pre><p>你要做的就这么多，person的name就改变了。我们甚至不用调用<strong>_personRepository.Update</strong>方法。ORM框架会跟踪工作单元中实体的所有改变，并将改变反应给数据库。</p><p>注意没有必要为应用服务方法声明<strong>UnitOfWork</strong>特性，因为它们默认已经是工作单元了。</p><h4 id="IRepository-GetAll-方法"><a href="#IRepository-GetAll-方法" class="headerlink" title="IRepository.GetAll()方法"></a>IRepository.GetAll()方法</h4><p>当在一个仓储方法之外调用GetAll()时，必须存在一个打开的数据库连接，因为GetAll返回了<strong>IQueryable</strong>，而且IQueryable会延迟执行。直到调用ToList()方法或者在foreach循环中使用IQueryable,才会真正执行数据库查询。因此，调用ToList()方法时，数据库连接必须是活着的（alive）。</p><p>考虑一下下面的例子：</p><pre class=" language-C#"><code class="language-C#">[UnitOfWork]public SearchPeopleOutput SearchPeople(SearchPeopleInput input){    //返回IQueryable<Person>    var query = _personRepository.GetAll();    //添加一些过滤    if (!string.IsNullOrEmpty(input.SearchedName))    {        query = query.Where(person => person.Name.StartsWith(input.SearchedName));    }    if (input.IsActive.HasValue)    {        query = query.Where(person => person.IsActive == input.IsActive.Value);    }    //获得分页结果列表    var people = query.Skip(input.SkipCount).Take(input.MaxResultCount).ToList();    return new SearchPeopleOutput { People = Mapper.Map<List<PersonDto>>(people) };}</code></pre><p>这里，SearchPeople方法必须是工作单元，因为IQueryable的ToList()在方法体内调用了，当执行IQueryable.ToList()执行时，数据库连接必须是打开的状态。</p><p>就像GetAll()方法一样，如果在仓储之外需要数据库连接，那么必须使用工作单元。注意，应用服务方法默认是工作单元。</p><h4 id="UnitOfWork特性的限制"><a href="#UnitOfWork特性的限制" class="headerlink" title="UnitOfWork特性的限制"></a>UnitOfWork特性的限制</h4><p>UnitOfWork可以用于以下几个条件：</p><ul><li>所有用于接口的类的<strong>public或public virtual</strong>方法（如用于用于服务接口的应用服务类的方法）。</li><li>自注入类的所有<strong>public virtual</strong>（如MVC 控制器和Web Api控制器）。</li><li>所有的<strong>protected virtual</strong>方法。</li></ul><p>建议总是将方法声明为<strong>virtual</strong>，但是<strong>不能用于private方法</strong>。因为ABP为virtual方法私有了动态代理，private方法不能被派生的类访问到。如果你没有使用依赖注入且实例化类，那么UnitOfWork特性（和任何代理）就不能工作。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>有很多可以用于改变工作单元行为的选项。</p><p>首先，我们可以在启动配置中更改所有工作单元的默认值。这通常是在模块的PreInitialize方法中处理的。</p><pre class=" language-C#"><code class="language-C#">public class SimpleTaskSystemCoreModule : AbpModule{    public override void PreInitialize()    {        Configuration.UnitOfWork.IsolationLevel = IsolationLevel.ReadCommitted;        Configuration.UnitOfWork.Timeout = TimeSpan.FromMinutes(30);    }    //...其他模块方法}</code></pre><p>其次，我们可以为一个特定的工作单元重写默认值。比如，<strong>UnitOfWork</strong>特性的构造函数和IUnitOfWorkManager的<strong>Begin</strong>方法都有获得选项的重载。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>UnitOfWork系统无缝而不可见地工作。但是在某些场合，你需要调用它的方法。</p><h4 id="SaveChanges"><a href="#SaveChanges" class="headerlink" title="SaveChanges"></a>SaveChanges</h4><p>ABP会在工作单元结束时保存所有更改，我们根本不用做任何事情。但是有时候你可能想在工作单元操作的中间将更改保存到数据库中。在这种情况下，你可以注入IUnitOfWorkManager，然后调用IUnitOfWorkManager.Current.**SaveChanges()**方法。注意：如果当前的工作单元是事务的，那么如果有异常发生了，事务中的所有改变都会回滚，即使是已保存的改变。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>工作单元有<strong>Completed,Failed和Disposed</strong>事件。你可以注册这些事件，然后执行需要的操作。通过注入IUnitOfWorkManager然后使用IUnitOfWorkManager.Current属性来获得激活的工作单元，然后注册到它的事件。</p><p>在当前的工作单元成功完成时，你可能想运行一些代码，下面是一个例子：</p><pre class=" language-C#"><code class="language-C#">public void CreateTask(CreateTaskInput input){    var task = new Task { Description = input.Description };    if (input.AssignedPersonId.HasValue)    {        task.AssignedPersonId = input.AssignedPersonId.Value;        _unitOfWorkManager.Current.Completed += (sender, args) => { /* TODO: 给派发的人发送邮件*/ };    }    _taskRepository.Insert(task);}</code></pre><h2 id="事务与锁（补充：重要）"><a href="#事务与锁（补充：重要）" class="headerlink" title="事务与锁（补充：重要）"></a>事务与锁（补充：重要）</h2><h3 id="事务的级别"><a href="#事务的级别" class="headerlink" title="事务的级别"></a>事务的级别</h3><p>事务的隔离级别</p><p>事务的四大特性分别是：原子性、一致性、隔离性、持久性</p><p>幻读和不可重复读都是在同一个事务中多次读取了其他事务已经提交的事务的数据导致每次读取的数据不一致，所不同的是不可重复读读取的是同一条数据，而幻读针对的是一批数据整体的统计(比如数据的个数)</p><p>以MYSQL数据库来分析四种隔离级别</p><p>第一种隔离级别：Read uncommitted(读未提交)<br>如果一个事务已经开始写数据，则另外一个事务不允许同时进行写操作，但允许其他事务读此行数据，该隔离级别可以通过“排他写锁”，但是不排斥读线程实现。这样就避免了更新丢失，却可能出现脏读，也就是说事务B读取到了事务A未提交的数据</p><p>解决了更新丢失，但还是可能会出现脏读</p><p>第二种隔离级别：Read committed(读提交)<br>如果是一个读事务(线程)，则允许其他事务读写，如果是写事务将会禁止其他事务访问该行数据，该隔离级别避免了脏读，但是可能出现不可重复读。事务A事先读取了数据，事务B紧接着更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。</p><p>解决了更新丢失和脏读问题</p><p>第三种隔离级别：Repeatable read(可重复读取)<br>可重复读取是指在一个事务内，多次读同一个数据，在这个事务还没结束时，其他事务不能访问该数据(包括了读写)，这样就可以在同一个事务内两次读到的数据是一样的，因此称为是可重复读隔离级别，读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务(包括了读写)，这样避免了不可重复读和脏读，但是有时可能会出现幻读。(读取数据的事务)可以通过“共享读镜”和“排他写锁”实现。</p><p>解决了更新丢失、脏读、不可重复读、但是还会出现幻读</p><p>第四种隔离级别：Serializable(可序化)<br>提供严格的事务隔离，它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行，如果仅仅通过“行级锁”是无法实现序列化的，必须通过其他机制保证新插入的数据不会被执行查询操作的事务访问到。序列化是最高的事务隔离级别，同时代价也是最高的，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻读</p><p>解决了更新丢失、脏读、不可重复读、幻读(虚读)<br>————————————————<br>在这里插入图片描述<br>以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低，像Serializeble这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况来，在MYSQL数据库中默认的隔离级别是Repeatable read（可重复读）。</p><p>在MYSQL数据库中，支持上面四种隔离级别，默认的为Repeatable read(可重复读)；而在Oracle数据库中，只支持Serializeble(串行化)级别和Read committed(读已提交)这两种级别，其中默认的为Read committed级别</p><p>在MYSQL数据库中查看当前事务的隔离级别</p><p>SELECT @@tx_isolation;</p><pre><code>1</code></pre><p>在MYSQL数据库中设置事务的隔离级别：<br>在这里插入图片描述<br>在这里插入图片描述<br>在这里插入图片描述<br>记住：设置数据库的隔离级别一定要是在开启事务之前：</p><p>如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connecton对象的setAutoCommit(false)方法之前，调用Connection对象的setTransactionIsolation(level)即可设置当前连接的隔离级别，至于参数level，可以使用Connection对象的字段：<br>在这里插入图片描述<br>在JDBC中设置隔离级别的部分代码：<br>在这里插入图片描述<br>隔离级别的设置只对当前连接有效，对于使用MYSQL命令窗口而言，一个窗口就相当于一个连接，当前窗口设置的隔离级别只对当前窗口中的事务有效，对于JDBC操作数据库来说，一个Connection对象相当与一个连接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他连接Connection对象无关<br>————————————————<br>版权声明：本文为CSDN博主「zhouym_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/zhouym_/article/details/90381606">https://blog.csdn.net/zhouym_/article/details/90381606</a></p><h3 id="什么时候事务会发生锁定事件"><a href="#什么时候事务会发生锁定事件" class="headerlink" title="什么时候事务会发生锁定事件"></a>什么时候事务会发生锁定事件</h3><h4 id="Mysql数据库锁定机制详细介绍"><a href="#Mysql数据库锁定机制详细介绍" class="headerlink" title="Mysql数据库锁定机制详细介绍"></a>Mysql数据库锁定机制详细介绍</h4><p>  更新时间：2014年12月01日 10:58:48  投稿：junjie  </p><p>这篇文章主要介绍了Mysql数据库锁定机制详细介绍,本文用大量内容讲解了Mysql中的锁定机制,例如MySQL锁定机制简介、合理利用锁机制优化MySQL等内容,需要的朋友可以参考下</p><p><strong>前言</strong></p><p>为了保证数据的一致完整性，任何一个数据库都存在锁定机制。锁定机制的优劣直接应想到一个数据库系统的并发处理能力和性能，所以锁定机制的实现也就成为了各种数据库的核心技术之一。本章将对MySQL中两种使用最为频繁的存储引擎MyISAM和Innodb各自的锁定机制进行较为详细的分析。</p><p><strong>MySQL锁定机制简介</strong></p><p>数据库锁定机制简单来说就是数据库为了保证数据的一致性而使各种共享资源在被并发访问访问变得有序所设计的一种规则。对于任何一种数据库来说都需要有相应的锁定机制，所以MySQL自然也不能例外。MySQL数据库由于其自身架构的特点，存在多种数据存储引擎，每种存储引擎所针对的应用场景特点都不太一样，为了满足各自特定应用场景的需求，每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别。</p><p>总的来说，MySQL各存储引擎使用了三种类型（级别）的锁定机制：行级锁定，页级锁定和表级锁定。下面我们先分析一下MySQL这三种锁定的特点和各自的优劣所在。</p><p><strong>行级锁定（row-level）</strong></p><p>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。</p><p>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。</p><p><strong>表级锁定（table-level）</strong></p><p>和行级锁定相反，表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。</p><p>当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。</p><p><strong>页级锁定（page-level）</strong></p><p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。</p><p>在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。</p><p>在MySQL数据库中，使用表级锁定的主要是MyISAM，Memory，CSV等一些非事务性存储引擎，而使用行级锁定的主要是Innodb存储引擎和NDBCluster存储引擎，页级锁定主要是BerkeleyDB存储引擎的锁定方式。</p><p>MySQL的如此的锁定机制主要是由于其最初的历史所决定的。在最初，MySQL希望设计一种完全独立于各种存储引擎的锁定机制，而且在早期的MySQL数据库中，MySQL的存储引擎（MyISAM和Momery）的设计是建立在“任何表在同一时刻都只允许单个线程对其访问（包括读）”这样的假设之上。但是，随着MySQL的不断完善，系统的不断改进，在MySQL3.23版本开发的时候，MySQL开发人员不得不修正之前的假设。因为他们发现一个线程正在读某个表的时候，另一个线程是可以对该表进行insert操作的，只不过只能INSERT到数据文件的最尾部。这也就是从MySQL从3.23版本开始提供的我们所说的Concurrent Insert。</p><p>当出现Concurrent  Insert之后，MySQL的开发人员不得不修改之前系统中的锁定实现功能，但是仅仅只是增加了对Concurrent  Insert的支持，并没有改动整体架构。可是在不久之后，随着BerkeleyDB存储引擎的引入，之前的锁定机制遇到了更大的挑战。因为BerkeleyDB存储引擎并没有MyISAM和Memory存储引擎同一时刻只允许单一线程访问某一个表的限制，而是将这个单线程访问限制的颗粒度缩小到了单个page，这又一次迫使MySQL开发人员不得不再一次修改锁定机制的实现。</p><p>由于新的存储引擎的引入，导致锁定机制不能满足要求，让MySQL的人意识到已经不可能实现一种完全独立的满足各种存储引擎要求的锁定实现机制。如果因为锁定机制的拙劣实现而导致存储引擎的整体性能的下降，肯定会严重打击存储引擎提供者的积极性，这是MySQL公司非常不愿意看到的，因为这完全不符合MySQL的战略发展思路。所以工程师们不得不放弃了最初的设计初衷，在锁定实现机制中作出修改，允许存储引擎自己改变MySQL通过接口传入的锁定类型而自行决定该怎样锁定数据。</p><p><strong>表级锁定</strong></p><p>MySQL的表级锁定主要分为两种类型，一种是读锁定，另一种是写锁定。在MySQL中，主要通过四个队列来维护这两种锁定：两个存放当前正在锁定中的读和写锁定信息，另外两个存放等待中的读写锁定信息，如下：</p><p>复制代码 代码如下:</p><p> Current read-lock queue (lock-&gt;read)<br> Pending read-lock queue (lock-&gt;read_wait)<br> Current write-lock queue (lock-&gt;write)<br> Pending write-lock queue (lock-&gt;write_wait)</p><p>当前持有读锁的所有线程的相关信息都能够在Currentread-lockqueue中找到，队列中的信息按照获取到锁的时间依序存放。而正在等待锁定资源的信息则存放在Pendingread-lockqueue里面，另外两个存放写锁信息的队列也按照上面相同规则来存放信息。</p><p>虽然对于我们这些使用者来说MySQL展现出来的锁定（表锁定）只有读锁定和写锁定这两种类型，但是在MySQL内部实现中却有多达11种锁定类型，由系统中一个枚举量（thr_lock_type）定义，各值描述如下：</p><table><thead><tr><th>锁定类型</th><th>说明</th></tr></thead><tbody><tr><td>IGNORE</td><td>当发生锁请求的时候内部交互使用，在锁定结构和队列中并不会有任何信息存储</td></tr><tr><td>UNLOCK</td><td>释放锁定请求的交互用所类型</td></tr><tr><td>READ</td><td>普通读锁定</td></tr><tr><td>WRITE</td><td>普通写锁定</td></tr><tr><td>READ_WITH_SHARED_LOCKS</td><td>在Innodb中使用到，由如下方式产生如：SELECT…LOCKINSHAREMODE</td></tr><tr><td>READ_HIGH_PRIORITY</td><td>高优先级读锁定</td></tr><tr><td>READ_NO_INSERT</td><td>不允许ConcurentInsert的锁定</td></tr><tr><td>WRITE_ALLOW_WRITE</td><td>这个类型实际上就是当由存储引擎自行处理锁定的时候，mysqld允许其他的线程再获取读或者写锁定，因为即使资源冲突，存储引擎自己也会知道怎么来处理</td></tr><tr><td>WRITE_ALLOW_READ</td><td>这种锁定发生在对表做DDL（ALTERTABLE…）的时候，MySQL可以允许其他线程获取读锁定，因为MySQL是通过重建整个表然后再RENAME而实现的该功能，所在整个过程原表仍然可以提供读服务</td></tr><tr><td>WRITE_CONCURRENT_INSERT</td><td>正在进行ConcurentInsert时候所使用的锁定方式，该锁定进行的时候，除了READ_NO_INSERT之外的其他任何读锁定请求都不会被阻塞</td></tr><tr><td>WRITE_DELAYED</td><td>在使用INSERTDELAYED时候的锁定类型</td></tr><tr><td>WRITE_LOW_PRIORITY</td><td>显示声明的低级别锁定方式，通过设置LOW_PRIORITY_UPDAT=1而产生</td></tr><tr><td>WRITE_ONLY</td><td>当在操作过程中某个锁定异常中断之后系统内部需要进行CLOSETABLE操作，在这个过程中出现的锁定类型就是WRITE_ONLY</td></tr></tbody></table><p><strong>读锁定</strong></p><p>一个新的客户端请求在申请获取读锁定资源的时候，需要满足两个条件：</p><p>1、请求锁定的资源当前没有被写锁定；<br> 2、写锁定等待队列（Pendingwrite-lockqueue）中没有更高优先级的写锁定等待；</p><p>如果满足了上面两个条件之后，该请求会被立即通过，并将相关的信息存入Currentread-lockqueue中，而如果上面两个条件中任何一个没有满足，都会被迫进入等待队列Pendingread-lockqueue中等待资源的释放。</p><p><strong>写锁定</strong></p><p>当客户端请求写锁定的时候，MySQL首先检查在Currentwrite-lockqueue是否已经有锁定相同资源的信息存在。</p><p>如果Currentwrite-lockqueue没有，则再检查Pendingwrite-lockqueue，如果在Pendingwrite-lockqueue中找到了，自己也需要进入等待队列并暂停自身线程等待锁定资源。反之，如果Pendingwrite-lockqueue为空，则再检测Currentread-lockqueue，如果有锁定存在，则同样需要进入Pendingwrite-lockqueue等待。当然，也可能遇到以下这两种特殊情况：</p><p>\1. 请求锁定的类型为WRITE_DELAYED;<br> \2. 请求锁定的类型为WRITE_CONCURRENT_INSERT或者是TL_WRITE_ALLOW_WRITE，同时Currentreadlock是READ_NO_INSERT的锁定类型。</p><p>当遇到这两种特殊情况的时候，写锁定会立即获得而进入Current write-lock queue 中</p><p>如果刚开始第一次检测就Currentwrite-lockqueue中已经存在了锁定相同资源的写锁定存在，那么就只能进入等待队列等待相应资源锁定的释放了。</p><p>读请求和写等待队列中的写锁请求的优先级规则主要为以下规则决定：</p><p>\1. 除了READ_HIGH_PRIORITY的读锁定之外，Pendingwrite-lockqueue中的WRITE写锁定能够阻塞所有其他的读锁定；<br> \2. READ_HIGH_PRIORITY读锁定的请求能够阻塞所有Pendingwrite-lockqueue中的写锁定；<br> \3. 除了WRITE写锁定之外，Pendingwrite-lockqueue中的其他任何写锁定都比读锁定的优先级低。</p><p>写锁定出现在Currentwrite-lockqueue之后，会阻塞除了以下情况下的所有其他锁定的请求：</p><p>\1. 在某些存储引擎的允许下，可以允许一个WRITE_CONCURRENT_INSERT写锁定请求<br> \2. 写锁定为WRITE_ALLOW_WRITE的时候，允许除了WRITE_ONLY之外的所有读和写锁定请求<br> \3. 写锁定为WRITE_ALLOW_READ的时候，允许除了READ_NO_INSERT之外的所有读锁定请求<br> \4. 写锁定为WRITE_DELAYED的时候，允许除了READ_NO_INSERT之外的所有读锁定请求<br> \5. 写锁定为WRITE_CONCURRENT_INSERT的时候，允许除了READ_NO_INSERT之外的所有读锁定请求</p><p>随着MySQL存储引擎的不断发展，目前MySQL自身提供的锁定机制已经没有办法满足需求了，很多存储引擎都在MySQL所提供的锁定机制之上做了存储引擎自己的扩展和改造。</p><p>MyISAM存储引擎基本上可以说是对MySQL所提供的锁定机制所实现的表级锁定依赖最大的一种存储引擎了，虽然MyISAM存储引擎自己并没有在自身增加其他的锁定机制，但是为了更好的支持相关特性，MySQL在原有锁定机制的基础上为了支持其ConcurrentInsert的特性而进行了相应的实现改造。</p><p>而其他几种支持事务的存储存储引擎，如Innodb，NDBCluster以及BerkeleyDB存储引擎则是让MySQL将锁定的处理直接交给存储引擎自己来处理，在MySQL中仅持有WRITE_ALLOW_WRITE类型的锁定。</p><p>由于MyISAM存储引擎使用的锁定机制完全是由MySQL提供的表级锁定实现，所以下面我们将以MyISAM存储引擎作为示例存储引擎，来实例演示表级锁定的一些基本特性。由于，为了让示例更加直观，我将使用显示给表加锁来演示：RITE_ALLOW_READ 类型的写锁定。</p><table><thead><tr><th>刻</th><th>Session a</th><th>Session b</th></tr></thead><tbody><tr><td></td><td>行锁定基本演示</td><td></td></tr><tr><td>1</td><td>mysql&gt; set autocommit=0;      Query OK, 0 rows affected (0.00 sec)</td><td>mysql&gt; set autocommit=0;      Query OK, 0 rows affected (0.00 sec)</td></tr><tr><td></td><td>mysql&gt; update test_innodb_lock set b = ‘b1’ where a = 1;      Query OK, 1 row affected (0.00 sec)      Rows matched: 1 Changed: 1 Warnings: 0      更新，但是不提交</td><td></td></tr><tr><td>2</td><td></td><td>mysql&gt; update test_innodb_lock set b = ‘b1’ where a = 1;      被阻塞，等待</td></tr><tr><td>3</td><td>mysql&gt; commit; Query OK, 0 rows affected (0.05 sec) 提交</td><td></td></tr><tr><td>4</td><td></td><td>mysql&gt; update test_innodb_lock set b = ‘b1’ where a = 1;      Query OK, 0 rows affected (36.14 sec)      Rows matched: 1 Changed: 0 Warnings: 0      解除阻塞，更新正常进行</td></tr><tr><td></td><td>无索引升级为表锁演示</td><td></td></tr><tr><td>5</td><td>mysql&gt; update test_innodb_lock set b = ‘2’ where b = 2000;      Query OK, 1 row affected (0.02 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td><td>mysql&gt; update test_innodb_lock set b = ‘3’ where b = 3000;      被阻塞，等待</td></tr><tr><td>6</td><td></td><td></td></tr><tr><td>7</td><td>mysql&gt; commit; Query OK, 0 rows affected (0.10 sec)</td><td></td></tr><tr><td>8</td><td></td><td>mysql&gt; update test_innodb_lock set b = ‘3’ where b = 3000;      Query OK, 1 row affected (1 min 3.41 sec)      Rows matched: 1 Changed: 1 Warnings: 0      阻塞解除，完成更新</td></tr><tr><td></td><td>间隙锁带来的插入问题演示</td><td></td></tr><tr><td>9</td><td>mysql&gt; select * from test_innodb_lock;      +——+——+ | a | b |+——+——+      | 1 | b2 |      | 3 | 3 |      | 4 | 4000 |      | 5 | 5000 |      | 6 | 6000 |      | 7 | 7000 |      | 8 | 8000 |      | 9 | 9000 |      | 1 | b1 |      +——+——+      9 rows in set (0.00 sec)      mysql&gt; update test_innodb_lock set b = a * 100 where a &lt; 4 and a &gt; 1;      Query OK, 1 row affected (0.02 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td><td></td></tr><tr><td>10</td><td></td><td>mysql&gt; insert into test_innodb_lock values(2,’200’);      被阻塞，等待</td></tr><tr><td>11</td><td>mysql&gt; commit;      Query OK, 0 rows affected (0.02 sec)</td><td></td></tr><tr><td>12</td><td></td><td>mysql&gt; insert into test_innodb_lock values(2,’200’);      Query OK, 1 row affected (38.68 sec)      阻塞解除，完成插入</td></tr><tr><td></td><td>使用共同索引不同数据的阻塞示例</td><td></td></tr><tr><td>13</td><td>mysql&gt; update test_innodb_lock set b = ‘bbbbb’ where a = 1 and b = ‘b2’;      Query OK, 1 row affected (0.00 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td><td></td></tr><tr><td>14</td><td></td><td>mysql&gt; update test_innodb_lock set b = ‘bbbbb’ where a = 1 and b = ‘b1’; 被阻塞</td></tr><tr><td>15</td><td>mysql&gt; commit;      Query OK, 0 rows affected (0.02 sec)</td><td></td></tr><tr><td>16</td><td></td><td>mysql&gt; update test_innodb_lock set b = ‘bbbbb’ where a = 1 and b = ‘b1’; Query OK, 1 row affected (42.89 sec)      Rows matched: 1 Changed: 1 Warnings: 0      session 提交事务，阻塞去除，更新完成</td></tr><tr><td></td><td>死锁示例</td><td></td></tr><tr><td>17</td><td>mysql&gt; update t1 set id = 110 where id = 11;      Query OK, 0 rows affected (0.00 sec)      Rows matched: 0 Changed: 0 Warnings: 0</td><td></td></tr><tr><td>18</td><td></td><td>mysql&gt; update t2 set id = 210 where id = 21;      Query OK, 1 row affected (0.00 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td></tr><tr><td>19</td><td>mysql&gt;update t2 set id=2100 where id=21;      等待sessionb释放资源，被阻塞</td><td></td></tr><tr><td>20</td><td></td><td>mysql&gt;update t1 set id=1100 where id=11;      Query OK,0 rows affected (0.39sec)      Rows matched: 0 Changed: 0 Warnings:0      等待sessiona释放资源，被阻塞</td></tr><tr><td></td><td>两个 session 互相等等待对方的资源释放之后才能释放自己的资源,造成了死锁</td><td></td></tr></tbody></table><p><strong>行级锁定</strong></p><p>行级锁定不是MySQL自己实现的锁定方式，而是由其他存储引擎自己所实现的，如广为大家所知的Innodb存储引擎，以及MySQL的分布式存储引擎NDBCluster等都是实现了行级锁定。</p><p><strong>Innodb 锁定模式及实现机制</strong></p><p>考虑到行级锁定君由各个存储引擎自行实现，而且具体实现也各有差别，而Innodb是目前事务型存储引擎中使用最为广泛的存储引擎，所以这里我们就主要分析一下Innodb的锁定特性。</p><p>总的来说，Innodb的锁定机制和Oracle数据库有不少相似之处。Innodb的行级锁定同样分为两种类型，共享锁和排他锁，而在锁定机制的实现过程中为了让行级锁定和表级锁定共存，Innodb也同样使用了意向锁（表级锁定）的概念，也就有了意向共享锁和意向排他锁这两种。</p><p>当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。所以，可以说Innodb的锁定模式实际上可以分为四种：共享锁（S），排他锁（X），意向共享锁（IS）和意向排他锁（IX），我们可以通过以下表格来总结上面这四种所的共存逻辑关系：</p><table><thead><tr><th>共享锁（S）</th><th>排他锁（X）</th><th>意向共享锁（IS）</th><th>意向排他锁（IX）</th><th></th></tr></thead><tbody><tr><td>共享锁（S）</td><td>兼容</td><td>冲突</td><td>兼容</td><td>冲突</td></tr><tr><td>排他锁（X）</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>意向共享锁（IS）</td><td>兼容</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>意向排他锁（IX）</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>虽然Innodb的锁定机制和Oracle有不少相近的地方，但是两者的实现确是截然不同的。总的来说就是Oracle锁定数据是通过需要锁定的某行记录所在的物理block上的事务槽上表级锁定信息，而Innodb的锁定则是通过在指向数据记录的第一个索引键之前和最后一个索引键之后的空域空间上标记锁定信息而实现的。Innodb的这种锁定实现方式被称为“NEXT-KEYlocking”（间隙锁），因为Query执行过程中通过过范围查找的华，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。</p><p>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。而Innodb给出的解释是为了组织幻读的出现，所以他们选择的间隙锁来实现锁定。</p><p>除了间隙锁给Innodb带来性能的负面影响之外，通过索引实现锁定的方式还存在其他几个较大的性能隐患：</p><p>当Query无法利用索引的时候，Innodb会放弃使用行级别锁定而改用表级别的锁定，造成并发性能的降低；</p><p>当Quuery使用的索引并不包含所有过滤条件的时候，数据检索使用到的索引键所只想的数据可能有部分并不属于该Query的结果集的行列，但是也会被锁定，因为间隙锁锁定的是一个范围，而不是具体的索引键；</p><p>当Query在使用索引定位数据的时候，如果使用的索引键一样但访问的数据行不同的时候（索引只是过滤条件的一部分），一样会被锁定</p><p><strong>Innodb 各事务隔离级别下锁定及死锁</strong></p><p>Innodb实现的在ISO／ANSISQL92规范中所定义的ReadUnCommited，ReadCommited，RepeatableRead和Serializable这四种事务隔离级别。同时，为了保证数据在事务中的一致性，实现了多版本数据访问。</p><p>之前在第一节中我们已经介绍过，行级锁定肯定会带来死锁问题，Innodb也不可能例外。至于死锁的产生过程我们就不在这里详细描述了，在后面的锁定示例中会通过一个实际的例子为大家爱展示死锁的产生过程。这里我们主要介绍一下，在Innodb中当系检测到死锁产生之后是如何来处理的。</p><p>在Innodb的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在。当Innodb检测到系统中产生了死锁之后，Innodb会通过相应的判断来选这产生死锁的两个事务中较小的事务来回滚，而让另外一个较大的事务成功完成。那Innodb是以什么来为标准判定事务的大小的呢？MySQL官方手册中也提到了这个问题，实际上在Innodb发现死锁之后，会计算出两个事务各自插入、更新或者删除的数据量来判定两个事务的大小。也就是说哪个事务所改变的记录条数越多，在死锁中就越不会被回滚掉。但是有一点需要注意的就是，当产生死锁的场景中涉及到不止Innodb存储引擎的时候，Innodb是没办法检测到该死锁的，这时候就只能通过锁定超时限制来解决该死锁了。另外，死锁的产生过程的示例将在本节最后的Innodb锁定示例中演示。</p><p><strong>Innodb 锁定机制示例</strong></p><p>复制代码 代码如下:</p><p> mysql&gt; create table test_innodb_lock (a int(11),b varchar(16)) engine=innodb;<br> Query OK, 0 rows affected (0.02 sec)</p><p>mysql&gt; create index test_innodb_a_ind on test_innodb_lock(a);<br> Query OK, 0 rows affected (0.05 sec)<br> Records: 0 Duplicates: 0 Warnings: 0</p><p>mysql&gt; create index test_innodb_lock_b_ind on test_innodb_lock(b);<br> Query OK, 11 rows affected (0.01 sec)<br> Records: 11 Duplicates: 0 Warnings: 0</p><table><thead><tr><th>时刻</th><th>Session a</th><th>Session b</th></tr></thead><tbody><tr><td></td><td>行锁定基本演示</td><td></td></tr><tr><td>1</td><td>mysql&gt; set autocommit=0;      Query OK, 0 rows affected (0.00 sec)</td><td>mysql&gt; set autocommit=0;      Query OK, 0 rows affected (0.00 sec)</td></tr><tr><td></td><td>mysql&gt; update test_innodb_lock set b = ‘b1’ where a = 1;      Query OK, 1 row affected (0.00 sec)      Rows matched: 1 Changed: 1 Warnings: 0      更新，但是不提交</td><td></td></tr><tr><td>2</td><td></td><td>mysql&gt; update test_innodb_lock set b = ‘b1’ where a = 1;      被阻塞，等待</td></tr><tr><td>3</td><td>mysql&gt; commit; Query OK, 0 rows affected (0.05 sec) 提交</td><td></td></tr><tr><td>4</td><td></td><td>mysql&gt; update test_innodb_lock set b = ‘b1’ where a = 1;      Query OK, 0 rows affected (36.14 sec)      Rows matched: 1 Changed: 0 Warnings: 0      解除阻塞，更新正常进行</td></tr><tr><td></td><td>无索引升级为表锁演示</td><td></td></tr><tr><td>5</td><td>mysql&gt; update test_innodb_lock set b = ‘2’ where b = 2000;      Query OK, 1 row affected (0.02 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td><td>mysql&gt; update test_innodb_lock set b = ‘3’ where b = 3000;      被阻塞，等待</td></tr><tr><td>6</td><td></td><td></td></tr><tr><td>7</td><td>mysql&gt; commit; Query OK, 0 rows affected (0.10 sec)</td><td></td></tr><tr><td>8</td><td></td><td>mysql&gt; update test_innodb_lock set b = ‘3’ where b = 3000;      Query OK, 1 row affected (1 min 3.41 sec)      Rows matched: 1 Changed: 1 Warnings: 0      阻塞解除，完成更新</td></tr><tr><td></td><td>间隙锁带来的插入问题演示</td><td></td></tr><tr><td>9</td><td>mysql&gt; select * from test_innodb_lock;      +——+——+ | a | b |+——+——+      | 1 | b2 |      | 3 | 3 |      | 4 | 4000 |      | 5 | 5000 |      | 6 | 6000 |      | 7 | 7000 |      | 8 | 8000 |      | 9 | 9000 |      | 1 | b1 |      +——+——+      9 rows in set (0.00 sec)      mysql&gt; update test_innodb_lock set b = a * 100 where a &lt; 4 and a &gt; 1;      Query OK, 1 row affected (0.02 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td><td></td></tr><tr><td>10</td><td></td><td>mysql&gt; insert into test_innodb_lock values(2,’200’);      被阻塞，等待</td></tr><tr><td>11</td><td>mysql&gt; commit;      Query OK, 0 rows affected (0.02 sec)</td><td></td></tr><tr><td>12</td><td></td><td>mysql&gt; insert into test_innodb_lock values(2,’200’);      Query OK, 1 row affected (38.68 sec)      阻塞解除，完成插入</td></tr><tr><td></td><td>使用共同索引不同数据的阻塞示例</td><td></td></tr><tr><td>13</td><td>mysql&gt; update test_innodb_lock set b = ‘bbbbb’ where a = 1 and b = ‘b2’;      Query OK, 1 row affected (0.00 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td><td></td></tr><tr><td>14</td><td></td><td>mysql&gt; update test_innodb_lock set b = ‘bbbbb’ where a = 1 and b = ‘b1’; 被阻塞</td></tr><tr><td>15</td><td>mysql&gt; commit;      Query OK, 0 rows affected (0.02 sec)</td><td></td></tr><tr><td>16</td><td></td><td>mysql&gt; update test_innodb_lock set b = ‘bbbbb’ where a = 1 and b = ‘b1’; Query OK, 1 row affected (42.89 sec)      Rows matched: 1 Changed: 1 Warnings: 0      session 提交事务，阻塞去除，更新完成</td></tr><tr><td></td><td>死锁示例</td><td></td></tr><tr><td>17</td><td>mysql&gt; update t1 set id = 110 where id = 11;      Query OK, 0 rows affected (0.00 sec)      Rows matched: 0 Changed: 0 Warnings: 0</td><td></td></tr><tr><td>18</td><td></td><td>mysql&gt; update t2 set id = 210 where id = 21;      Query OK, 1 row affected (0.00 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td></tr><tr><td>19</td><td>mysql&gt;update t2 set id=2100 where id=21;      等待sessionb释放资源，被阻塞</td><td></td></tr><tr><td>20</td><td></td><td>mysql&gt;update t1 set id=1100 where id=11;      Query OK,0 rows affected (0.39sec)      Rows matched: 0 Changed: 0 Warnings:0      等待sessiona释放资源，被阻塞</td></tr><tr><td></td><td>两个 session 互相等等待对方的资源释放之后才能释放自己的资源,造成了死锁</td><td></td></tr></tbody></table><p><strong>合理利用锁机制优化MySQL</strong></p><p><strong>MyISAM 表锁优化建议</strong></p><p>对于MyISAM存储引擎，虽然使用表级锁定在锁定实现的过程中比实现行级锁定或者页级锁所带来的附加成本都要小，锁定本身所消耗的资源也是最少。但是由于锁定的颗粒度比较到，所以造成锁定资源的争用情况也会比其他的锁定级别都要多，从而在较大程度上会降低并发处理能力。</p><p>所以，在优化MyISAM存储引擎锁定问题的时候，最关键的就是如何让其提高并发度。由于锁定级别是不可能改变的了，所以我们首先需要尽可能让锁定的时间变短，然后就是让可能并发进行的操作尽可能的并发。</p><p> <strong>1、缩短锁定时间</strong></p><p>缩短锁定时间，短短几个字，说起来确实听容易的，但实际做起来恐怕就并不那么简单了。如何让锁定时间尽可能的短呢？唯一的办法就是让我们的Query执行时间尽可能的短。</p><p>尽两减少大的复杂Query，将复杂Query分拆成几个小的Query分布进行；</p><p>尽可能的建立足够高效的索引，让数据检索更迅速；</p><p>尽量让MyISAM存储引擎的表只存放必要的信息，控制字段类型；</p><p>利用合适的机会优化MyISAM表数据文件；</p><p><strong>2、分离能并行的操作</strong></p><p>说到MyISAM的表锁，而且是读写互相阻塞的表锁，可能有些人会认为在MyISAM存储引擎的表上就只能是完全的串行化，没办法再并行了。大家不要忘记了，MyISAM的存储引擎还有一个非常有用的特性，那就是ConcurrentInsert（并发插入）的特性。</p><p>MyISAM存储引擎有一个控制是否打开Concurrent Insert功能的参数选项：concurrent_insert，可以设置为0，1或者2。三个值的具体说明如下：</p><p>concurrent_insert=2，无论MyISAM存储引擎的表数据文件的中间部分是否存在因为删除数据而留下的空闲空间，都允许在数据文件尾部进行ConcurrentInsert;</p><p>concurrent_insert=1，当MyISAM存储引擎表数据文件中间不存在空闲空间的时候，可以从文件尾部进行ConcurrentInsert;</p><p>concurrent_insert=0，无论MyISAM存储引擎的表数据文件的中间部分是否存在因为删除数据而留下的空闲空间，都不允许ConcurrentInsert。</p><p><strong>3、合理利用读写优先级</strong></p><p>在本章各种锁定分析一节中我们了解到了MySQL的表级锁定对于读和写是有不同优先级设定的，默认情况下是写优先级要大于读优先级。所以，如果我们可以根据各自系统环境的差异决定读与写的优先级。如果我们的系统是一个以读为主，而且要优先保证查询性能的话，我们可以通过设置系统参数选项low_priority_updates=1，将写的优先级设置为比读的优先级低，即可让告诉MySQL尽量先处理读请求。当然，如果我们的系统需要有限保证数据写入的性能的话，则可以不用设置low_priority_updates参数了。</p><p>这里我们完全可以利用这个特性，将concurrent_insert参数设置为1，甚至如果数据被删除的可能性很小的时候，如果对暂时性的浪费少量空间并不是特别的在乎的话，将concurrent_insert参数设置为2都可以尝试。当然，数据文件中间留有空域空间，在浪费空间的时候，还会造成在查询的时候需要读取更多的数据，所以如果删除量不是很小的话，还是建议将concurrent_insert设置为1更为合适。</p><p><strong>Innodb 行锁优化建议</strong></p><p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p><p>要想合理利用Innodb的行级锁定，做到扬长避短，我们必须做好以下工作：</p><p>尽可能让所有的数据检索都通过索引来完成，从而避免Innodb因为无法通过索引键加锁而升级为表级锁定；</p><p>合理设计索引，让Innodb在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他Query的执行；</p><p>尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录；</p><p>尽量控制事务的大小，减少锁定的资源量和锁定时间长度；</p><p>在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少MySQL因为实现事务隔离级别所带来的附加成本；</p><p>由于Innodb的行级锁定和事务性，所以肯定会产生死锁，下面是一些比较常用的减少死锁产生概率</p><p>的的小建议，读者朋友可以根据各自的业务特点针对性的尝试：a)类似业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁；b)在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；c)对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p><p>系统锁定争用情况查询对于两种锁定级别，MySQL内部有两组专门的状态变量记录系统内部锁资源争用情况，我们先看看</p><p>MySQL 实现的表级锁定的争用状态变量：</p><p>复制代码 代码如下:</p><p> mysql&gt; show status like ‘table%’;<br> +———————–+——-+ | Variable_name | Value | +———————–+——-+<br> | Table_locks_immediate | 100 |<br> | Table_locks_waited | 0 |<br> +———————–+——-+</p><p>这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下：</p><p>Table_locks_immediate：产生表级锁定的次数；</p><p>Table_locks_waited：出现表级锁定争用而发生等待的次数；</p><p>两个状态值都是从系统启动后开始记录，没出现一次对应的事件则数量加1。如果这里的Table_locks_waited状态值比较高，那么说明系统中表级锁定争用现象比较严重，就需要进一步分析为什么会有较多的锁定资源争用了。</p><p>对于Innodb所使用的行级锁定，系统中是通过另外一组更为详细的状态变量来记录的，如下：</p><p>复制代码 代码如下:</p><p> mysql&gt;showstatuslike’innodb_row_lock%’;<br> +——————————-+——–+|Variable_name|Value|+——————————-+——–+<br> |Innodb_row_lock_current_waits|0|<br> |Innodb_row_lock_time|490578|<br> |Innodb_row_lock_time_avg|37736|<br> |Innodb_row_lock_time_max|121411|<br> |Innodb_row_lock_waits|13|<br> +——————————-+——–+</p><p>Innodb 的行级锁定状态变量不仅记录了锁定等待次数，还记录了锁定总时长，每次平均时长，以及最大时长，此外还有一个非累积状态量显示了当前正在等待锁定的等待数量。对各个状态量的说明如下：</p><p>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</p><p>Innodb_row_lock_time：从系统启动到现在锁定总时间长度；</p><p>Innodb_row_lock_time_avg：每次等待所花平均时间；</p><p>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</p><p>Innodb_row_lock_waits：系统启动后到现在总共等待的次数；</p><p>对于这5个状态变量，比较重要的主要是Innodb_row_lock_time_avg（等待平均时长），Innodb_row_lock_waits（等待总次数）以及Innodb_row_lock_time（等待总时长）这三项。尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。</p><p>此外，Innodb出了提供这五个系统状态变量之外，还提供的其他更为丰富的即时状态信息供我们分析使用。可以通过如下方法查看：</p><p><strong>1.通过创建InnodbMonitor表来打开Innodb的monitor功能：</strong></p><p>复制代码 代码如下:</p><p> mysql&gt; create table innodb_monitor(a int) engine=innodb;</p><p>Query OK, 0 rows affected (0.07 sec)</p><p><strong>2.然后通过使用“SHOWINNODBSTATUS”查看细节信息（由于输出内容太多就不在此记录了）；</strong></p><p>可能会有读者朋友问为什么要先创建一个叫innodb_monitor的表呢？因为创建该表实际上就是告诉Innodb我们开始要监控他的细节状态了，然后Innodb就会将比较详细的事务以及锁定信息记录进入MySQL的errorlog中，以便我们后面做进一步分析使用。</p><p><strong>小结</strong></p><p>本章以MySQLServer中的锁定简介开始，分析了当前MySQL中使用最为广泛的锁定方式表级锁定和行级锁定的基本实现机制，并通过MyISAM和Innodb这两大典型的存储引擎作为示例存储引擎所使用的表级锁定和行级锁定做了较为详细的分析和演示。然后，再通过分析两种锁定方式的特性，给出相应的优化建议和策略。最后了解了一下在MySQLServer中如何获得系统当前各种锁定的资源争用状况。希望本章内容能够对各位读者朋友在理解MySQL锁定机制方面有一定的帮助。</p><h4 id="SQLServer之数据库行锁"><a href="#SQLServer之数据库行锁" class="headerlink" title="SQLServer之数据库行锁"></a>SQLServer之数据库行锁</h4><p>行锁使用注意事项</p><p>1、ROWLOCK行级锁确保在用户取得被更新的行，到该行进行更新，这段时间内不被其它用户所修改。因而行级锁即可保证数据的一致性，又能提高数据操作的并发性。</p><p>2、ROWLOCK告诉SQL Server只使用行级锁，ROWLOCK语法可以使用在SELECT,UPDATE和DELETE语句中。</p><p>3、ROWLOCK指定通常采用页锁或表锁时，采用行锁。 在从 SNAPSHOT 隔离级别操作的事务中指定时，除非将 ROWLOCK 与需要锁的其他表提示（例如，UPDLOCK 和 HOLDLOCK）组合，否则不会取得行锁。</p><p>4、UPDLOCK指定采用更新锁并保持到事务完成。UPDLOCK 仅对行级别或页级别的读操作采用更新锁。 如果将 UPDLOCK 与  TABLOCK 组合使用或出于一些其他原因采用表级锁，将采用排他 (X) 锁。指定 UPDLOCK 时，忽略 READCOMMITTED 和  READCOMMITTEDLOCK 隔离级别提示。 例如，如果将会话的隔离级别设置为 SERIALIZABLE 且查询指定 (UPDLOCK,  READCOMMITTED)，则忽略 READCOMMITTED 提示且使用 SERIALIZABLE 隔离级别运行事务。</p><p>5、HOLDLOCK等同于SERIALIZABLE。HOLDLOCK 仅应用于那些为其指定了 HOLDLOCK  的表或视图，并且仅在使用了 HOLDLOCK 的语句定义的事务的持续时间内应用。 HOLDLOCK 不能被用于包含 FOR BROWSE 选项的 SELECT 语句。</p><h5 id="使用T-SQL脚本创建数据库表锁"><a href="#使用T-SQL脚本创建数据库表锁" class="headerlink" title="使用T-SQL脚本创建数据库表锁"></a>使用T-SQL脚本创建数据库表锁</h5><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p>第一步：在当前会话中锁定数据行。</p><p>–声明数据库引用</p><p>use testss;</p><p>go</p><p>–声明数据库行锁</p><p>begin tran tran1</p><p>select * from test1 with(rowlock,updlock) where id=’1’;</p><p>waitfor delay ‘00:00:10’;</p><p>commit tran;</p><p>go</p><p>第二步：开启新会话，进行更新锁定数据行。</p><p>update test1 set sex=’女’ where id=’1’;</p><h5 id="示例结果：事务延迟提交十秒，在事务未提交之前进行更新会发生进程阻塞，更新是失败的，事务提交完成后行锁被释放更新才能成功。"><a href="#示例结果：事务延迟提交十秒，在事务未提交之前进行更新会发生进程阻塞，更新是失败的，事务提交完成后行锁被释放更新才能成功。" class="headerlink" title="示例结果：事务延迟提交十秒，在事务未提交之前进行更新会发生进程阻塞，更新是失败的，事务提交完成后行锁被释放更新才能成功。"></a>示例结果：事务延迟提交十秒，在事务未提交之前进行更新会发生进程阻塞，更新是失败的，事务提交完成后行锁被释放更新才能成功。</h5><p>如何避免锁定的发生</p><h1 id="ABP理论学习之事件总线和领域事件"><a href="#ABP理论学习之事件总线和领域事件" class="headerlink" title="ABP理论学习之事件总线和领域事件"></a><a href="https://www.cnblogs.com/farb/p/ABPEventBus.html">ABP理论学习之事件总线和领域事件</a></h1><hr><h2 id="本篇目录-14"><a href="#本篇目录-14" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEventBus.html#eventBus">事件总线</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEventBus.html#define">定义事件</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEventBus.html#trigger">触发事件</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEventBus.html#handle">处理事件</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEventBus.html#handler">句柄注册</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEventBus.html#unregister">取消注册</a></strong></li></ul><p>在C#中，我们可以在一个类中定义自己的事件，而其他的类可以注册该事件，当某些事情发生时，可以通知到该类。这对于桌面应用或者独立的windows服务来说是非常有用的。但对于一个web应用来说是有点问题的，因为对象都是在web请求中创建的，而且这些对象生命周期都很短，因而注册某些类的事件是很困难的。此外，注册其他类的事件会使得类紧耦合。</p><p>领域事件用于解耦并重复利用应用中的逻辑。</p><h3 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线###"></a>事件总线###</h3><p>事件总线是被所有触发并处理事件的其他类共享的单例对象。要使用事件总线，首先应该获得它的一个引用。下面有两种方法来处理：</p><h4 id="创建默认实例"><a href="#创建默认实例" class="headerlink" title="创建默认实例"></a>创建默认实例</h4><p>你可以直接使用 <strong>EventBus.Default</strong>。这是全局的事件总线，用法如下所示：</p><pre><code>EventBus.Default.Trigger(...); //触发一个事件</code></pre><h4 id="注入IEventBus"><a href="#注入IEventBus" class="headerlink" title="注入IEventBus"></a>注入IEventBus</h4><p>不直接使用EventBus.Default，你也可以使用依赖注入来获得<strong>IEventBus</strong>的引用。这有利于单元测试。这里我们使用属性注入模式：</p><pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService{    public IEventBus EventBus { get; set; }            public TaskAppService()    {        EventBus = NullEventBus.Instance;    }}</code></pre><p>对于注入事件总线这件事，属性注入比构造函数注入更合适。这样，你的类离开事件总线还能工作。NullEventBus实现了**<a href="https://en.wikipedia.org/wiki/Null_Object_pattern">null对象模式</a>**。当你调用上面的构造函数时，实际上啥都没做。</p><h3 id="定义事件"><a href="#定义事件" class="headerlink" title="定义事件###"></a>定义事件###</h3><p>触发事件之前，应该先要定义该事件。事件是使用派生自<strong>EventData</strong>的类来表示的。假设我们想当一个任务task完成时触发一个事件：</p><pre class=" language-C#"><code class="language-C#">public class TaskCompletedEventData : EventData{    public int TaskId { get; set; }}</code></pre><p>该类包含了类处理事件需要的属性。<strong>EventData</strong>类定义了 <strong>EventSource</strong>（事件源）和 <strong>EventTime</strong>(事件触发时间)属性。</p><h4 id="预定义事件"><a href="#预定义事件" class="headerlink" title="预定义事件"></a>预定义事件</h4><p>ABP定义了<strong>AbpHandleExceptionData</strong>，当自动处理任何异常时都会触发这个事件。如果你想要获得更多的关于异常的信息（甚至ABP会自动记录所有的异常），那么这是特别有用的。注册这个事件之后，异常发生时就会通知你。</p><p>对于实体的更改也有泛型的事件数据类：<strong>EntityCreatedEventData，EntityUpdateEventData</strong>和 <strong>EntityDeletedEventData</strong>。它们都定义在 <strong>Abp.Event.Bus.Entities</strong>命名空间中。当一个实体插入，更新或者删除时，ABP会自动地触发这些事件。比如，如果你有一个Person实体，将它注册到EntityCreatedEventData，那么当创建的新的Person实体对象插入数据库时，会收到通知。这些事件也支持继承。如果Student类派生自Person类，而且你将它注册到EntityCreatedEventData，那么当一个Person或者Student插入时，你会收到通知。</p><h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件###"></a>触发事件###</h3><p>触发一个事件很简单，如下所示：</p><pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService{    public IEventBus EventBus { get; set; }            public TaskAppService()    {        EventBus = NullEventBus.Instance;    }    public void CompleteTask(CompleteTaskInput input)    {        //TODO: 完成task的数据库操作...        EventBus.Trigger(new TaskCompletedEventData {TaskId = 42});    }}</code></pre><p>下面是Trigger方法的一些重载：</p><pre class=" language-C#"><code class="language-C#">EventBus.Trigger<TaskCompletedEventData>(new TaskCompletedEventData { TaskId = 42 }); //显示声明为泛型参数EventBus.Trigger(this, new TaskCompletedEventData { TaskId = 42 }); //将 '事件源'设置为'this'EventBus.Trigger(typeof(TaskCompletedEventData), this, new TaskCompletedEventData { TaskId = 42 });//调用非泛型版本（第一个参数是事件类的类型）</code></pre><h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件###"></a>处理事件###</h3><p>要处理一个事件，应该要实现<strong>IEventHandler</strong>接口，如下所示：</p><pre class=" language-C#"><code class="language-C#">public class ActivityWriter : IEventHandler<TaskCompletedEventData>, ITransientDependency{    public void HandleEvent(TaskCompletedEventData eventData)    {        WriteActivity("A task is completed by id = " + eventData.TaskId);    }}</code></pre><p>事件总线（EventBus）已经集成到ABP的依赖注入系统中。正如上面实现ITransientDependency一样，当TaskCompleted事件发生时，它会创建ActivityWriter类的一个新实例，然后调用HandleEvent方法，最后释放它。更多知识请查看**<a href="http://www.cnblogs.com/farb/p/ABPDependencyInjection.html">依赖注入</a>**。</p><h4 id="处理基事件"><a href="#处理基事件" class="headerlink" title="处理基事件"></a>处理基事件</h4><p>事件总线支持事件的<strong>继承</strong>。比如，你创建了一个<strong>TaskEventData</strong>和它的两个子类： <strong>TaskCompletedEventData</strong>和 <strong>TaskCreatedEventData</strong>:</p><pre class=" language-C#"><code class="language-C#">public class TaskEventData : EventData{    public Task Task { get; set; }}public class TaskCreatedEventData : TaskEventData{    public User CreatorUser { get; set; }}public class TaskCompletedEventData : TaskEventData{    public User CompletorUser { get; set; }}</code></pre><p>然后你可以实现<strong>IEventHandler</strong>来处理这两个事件：</p><pre class=" language-C#"><code class="language-C#">public class ActivityWriter : IEventHandler<TaskEventData>, ITransientDependency{    public void HandleEvent(TaskEventData eventData)    {        if (eventData is TaskCreatedEventData)        {            //...        }        else if (eventData is TaskCompletedEventData)        {            //...        }    }}</code></pre><p>当然了，你可以实现IEventHandler来处理所有你想要处理的事件。</p><h4 id="处理多事件"><a href="#处理多事件" class="headerlink" title="处理多事件"></a>处理多事件</h4><p>在一个单一的处理句柄中，可以处理多个事件。这时，你应该为每个事件实现IEventHandler。比如：</p><pre class=" language-C#"><code class="language-C#">public class ActivityWriter :     IEventHandler<TaskCompletedEventData>,     IEventHandler<TaskCreatedEventData>,     ITransientDependency{    public void HandleEvent(TaskCompletedEventData eventData)    {        //TODO: 处理事件...    }    public void HandleEvent(TaskCreatedEventData eventData)    {        //TODO: 处理事件...    }}</code></pre><h3 id="句柄注册"><a href="#句柄注册" class="headerlink" title="句柄注册###"></a>句柄注册###</h3><p>为了处理事件，我们必须将事件句柄注册给事件总线。</p><h4 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h4><p>ABP会自动扫描所有的实现了IEventHandler的类，并<strong>自动</strong>将它们注册到事件总线上。当一个事件发生时，它会使用依赖注入获得该句柄的一个引用，而且在处理该事件之后就会释放该句柄。建议这样使用ABP中的事件总线。</p><h4 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h4><p>也可能会手动注册到事件，但是要小心使用。在一个web应用中，事件注册应该在应用启动时完成。在web请求时注册到一个事件不是一个好的方法，因为请求完成之后注册的类仍旧是注册的，而且对于每个请求继续再次注册。这可能会对你的应用造成问题，因为注册的类可能被调用多次。而且要记住手动注册不会使用依赖注入系统。</p><p>这里有一些事件总线的方法的重载。最简单的一个等待了一个委托（或者一个lambda）：</p><pre class=" language-C#"><code class="language-C#">EventBus.Register<TaskCompletedEventData>(eventData =>    {        WriteActivity("A task is completed by id = " + eventData.TaskId);    });</code></pre><p>这样，当“一个task完成”事件发生时，这个lambda方法就会调用。第二个等待一个实现了IEventHandler的对象：</p><pre class=" language-C#"><code class="language-C#">EventBus.Register<TaskCompletedEventData>(new ActivityWriter());</code></pre><p>事件会调用ActivityWriter的相同实例。该方法也有一个非泛型的重载。另一个重载接受两个泛型的参数：</p><pre class=" language-C#"><code class="language-C#">EventBus.Register<TaskCompletedEventData, ActivityWriter>();</code></pre><p>此时，事件总线会为每个事件创建一个新的ActivityWriter。如果它是可释放的，那么会调用ActivityWriter.Dispose方法。</p><p>最后，为了处理句柄的创建，你可以注册一个<strong>事件句柄工厂</strong>。句柄工厂有两个方法：<strong>GetHandler和ReleaseHandler</strong>。例如：</p><pre class=" language-C#"><code class="language-C#">public class ActivityWriterFactory : IEventHandlerFactory{    public IEventHandler GetHandler()    {        return new ActivityWriter();    }    public void ReleaseHandler(IEventHandler handler)    {        //TODO:释放ActivityWriter实例 (handler)    }}</code></pre><p>还有一个特殊的工厂类<strong>IocHandlerFactory</strong>，它可以使用依赖注入系统创建或者释放句柄。ABP在自动注册模式中使用了这个类。因此，如果你想使用依赖注入系统，直接使用自动注册。</p><h3 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册###"></a>取消注册###</h3><p>手动注册到事件总线时，你可能会在以后想要取消注册该事件。取消注册一个事件的最简单方法是释放该<strong>注册</strong>方法的返回值。如下所示：</p><pre class=" language-C#"><code class="language-C#">//注册到一个事件...var registration = EventBus.Register<TaskCompletedEventData>(eventData => WriteActivity("A task is completed by id = " + eventData.TaskId) );//取消注册事件registration.Dispose();</code></pre><p>当然了，注销注册会在某个地方和某个时间。保留注册对象并在想要取消注册时释放它。所有注册方法的重载都会返回一个可释放的对象以取消注册该事件。</p><p>事件总线也提供了<strong>Unregister</strong>方法。样例用法：</p><pre class=" language-C#"><code class="language-C#">//创建一个句柄var handler = new ActivityWriter();            //注册到事件EventBus.Register<TaskCompletedEventData>(handler);//从事件取消注册EventBus.Unregister<TaskCompletedEventData>(handler);</code></pre><p>它也提供了重载来注销委托和工厂，注销句柄对象必须是之前注册的相同对象。</p><p>最后，事件总线提供了<strong>UnregisterAll</strong>方法来注销一个事件的所有句柄，**RegisterAll()**方法会注销所有事件的所有句柄</p><h1 id="ABP理论学习之数据过滤器"><a href="#ABP理论学习之数据过滤器" class="headerlink" title="ABP理论学习之数据过滤器"></a><a href="https://www.cnblogs.com/farb/p/ABPDataFilters.html">ABP理论学习之数据过滤器</a></h1><hr><h2 id="本篇目录-15"><a href="#本篇目录-15" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#predefined">预定义过滤器</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#disable">关闭过滤器</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#enable">开启过滤器</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#set">设置过滤器参数</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#custom">定义自定义过滤器</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#other">其他ORM</a></strong></li></ul><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍###"></a>介绍###</h3><p><strong>软删除</strong>模式通常用于不会真正从数据库删除一个实体而是仅仅将它标记为”已删除的”。这样，如果一个实体是软删除的，那么它不应该在应用中检索到。为了实现这个目的，我们应该在每一个select实体查询操作中添加一个SQL <strong>where</strong>条件，如“IsDeleted=false”。这是乏味但是很重要的一项容易忘记的任务。因此，这项工作应该自动完成。</p><p>ABP提供了<strong>数据过滤器</strong>，它们可以基于某些规则自动过滤查询。有很多预定义的过滤器，但你也可以创建自己的过滤器。</p><h3 id="预定义过滤器"><a href="#预定义过滤器" class="headerlink" title="预定义过滤器###"></a>预定义过滤器###</h3><h4 id="ISoftDelete"><a href="#ISoftDelete" class="headerlink" title="ISoftDelete"></a>ISoftDelete</h4><p>软删除过滤器用于当查询数据库时自动过滤（从结果中提取）已经删除的实体。如果实体应该是软删除的，那么它必须实现只定义了<strong>IsDelete</strong>属性的 <strong>ISoftDelete</strong>接口，例如：</p><pre class=" language-C#"><code class="language-C#">public class Person : Entity, ISoftDelete{    public virtual string Name { get; set; }    public virtual bool IsDeleted { get; set; }}</code></pre><p>实际上，<strong>Person</strong>实体并没有从数据库中删除，只是当要删除它时将它的 <strong>IsDelete</strong>属性设置成了true。当使用 <strong>IRepository.Delete</strong>方法时，ABP会自动处理（你可以手动设置IsDelete为true，但是Delete方法更自然且更受人欢迎）。</p><p>实现了ISoftDelete之后，当从数据库获取Person的列表时，已经软删除的person是不会检索到的。这里有一个使用了person仓储获得所有person的例子：</p><pre class=" language-C#"><code class="language-C#">public class MyService{    private readonly IRepository<Person> _personRepository;    public MyService(IRepository<Person> personRepository)    {        _personRepository = personRepository;    }    public List<Person> GetPeople()    {        return _personRepository.GetAllList();    }}</code></pre><p>GetPeople方法只会获得IsDeleted=false（没有删除）的Person实体。所有的仓储方法和导航属性都会正确工作。我们也可以添加一些其他的Where条件，连接等等。它会自动将IsDeleted=false添加到生成的Sql查询中。</p><blockquote><h4 id="何时开启ISoftDelete呢？"><a href="#何时开启ISoftDelete呢？" class="headerlink" title="何时开启ISoftDelete呢？"></a>何时开启ISoftDelete呢？</h4><p>ISoftDelete过滤器始终是开启的，除非你显式关闭了它。</p></blockquote><p>额外注意：如果实现了<strong>IDeletionAudited</strong>(它继承了ISoftDelete)，那么ABP会自动设置删除时间和删除者的id。</p><h4 id="IMustHaveTenant"><a href="#IMustHaveTenant" class="headerlink" title="IMustHaveTenant"></a>IMustHaveTenant</h4><p>如果你生成的是多租户应用（在一个数据库中存储所有租户的数据），那么你肯定不想一个租户意外地看到了其他租户的数据。这种情况你可以实现<strong>IMustHaveTenant</strong>。例如：</p><pre class=" language-C#"><code class="language-C#">public class Product : Entity, IMustHaveTenant{    public int TenantId { get; set; }            public string Name { get; set; }}</code></pre><p><strong>IMustHaveTenant</strong>定义了 <strong>TenantId</strong>来区分不同的租户实体。ABP使用了 <strong>IAbpSession</strong>来获得当前的TenantId，而且自动过滤当前租户的查询。</p><blockquote><h4 id="何时开启IMustHaveTenant呢？"><a href="#何时开启IMustHaveTenant呢？" class="headerlink" title="何时开启IMustHaveTenant呢？"></a>何时开启IMustHaveTenant呢？</h4><p>IMustHaveTenant默认是开启的。<br> 如果当前的用户没有登录到系统或者当前的用户是一个租主用户（租主用户是可以管理租户和租户数据的更高级用户），ABP会自动关闭IMustHaveTenant过滤器。因此，所有租户的所有数据都可以被检索到。注意这是没有涉及到安全的情况，你应该总是要对敏感的数据进行授权。</p></blockquote><h4 id="IMayHaveTenant"><a href="#IMayHaveTenant" class="headerlink" title="IMayHaveTenant"></a>IMayHaveTenant</h4><p>如果一个实体类是租户和租主共享的（这意味着一个实体对象可能被一个租户或者租主拥有），那么你可以使用IMayHaveTenant过滤器。<strong>IMayHaveTenant</strong>接口定义了<strong>ITenantId</strong>但是它是 <strong>nullable</strong>。</p><pre class=" language-C#"><code class="language-C#">public class Role : Entity, IMayHaveTenant{    public int? TenantId { get; set; }            public string RoleName { get; set; }}</code></pre><p>如果TenantId的值是<strong>null</strong>，就意味着这是一个 <strong>租主</strong>实体；如果值不为null，就意味着该实体被一个 <strong>租户</strong>拥有，该租户的Id就是该TenantId。ABP使用了IAbpSession来获得当前的TenantId。IMayHaveTenant过滤器不像IMustHaveTenant过滤器那样常用，但是，对于租户和租户公用的结构，你可能需要它。</p><blockquote><h4 id="何时开启IMayHaveTenant呢？"><a href="#何时开启IMayHaveTenant呢？" class="headerlink" title="何时开启IMayHaveTenant呢？"></a>何时开启IMayHaveTenant呢？</h4><p>IMayHaveTenant总是开启的，除非你显式关闭了它。</p></blockquote><h3 id="关闭过滤器"><a href="#关闭过滤器" class="headerlink" title="关闭过滤器###"></a>关闭过滤器###</h3><p>你可以通过调用<strong>DisableFilter</strong>方法来为每个工作单元关闭过滤器，如下所示：</p><pre class=" language-C#"><code class="language-C#">var people1 = _personRepository.GetAllList();using (_unitOfWorkManager.Current.DisableFilter(AbpDataFilters.SoftDelete)){    var people2 = _personRepository.GetAllList();                }var people3 = _personRepository.GetAllList();</code></pre><p>DisableFilter方法以字符串获得一个或更多的过滤器。AbpDataFilters.SoftDelete包含了ABP标准软删除过滤器的名称的常量字符串。</p><p><strong>people2</strong>可以获得已经删除的person实体，然而people1和people3只会获得没有删除的实体。使用 <strong>using</strong>语句，你可以在一个 <strong>作用域（scope）</strong>中关闭过滤器。如果你没有使用using语句，那么过滤器在当前工作单元结束前都是关闭的，除非你显式再次开启它。</p><p>你可以像上面的例子那样注入<strong>IUnitOfWorkManager</strong>使用。此外，你也可以在应用服务（它派生自ApplicationService类）中使用<strong>CurrentUnitOfWork</strong>属性作为快捷方式。</p><blockquote><h4 id="关于using语句"><a href="#关于using语句" class="headerlink" title="关于using语句"></a>关于using语句</h4><p>如果过滤器是开启的，当你在using语句中调用DisableFilter方法时，那么过滤器会关闭，然后，当using语句结束时，它会自动再次开启。但是如果在使用using语句之前过滤器已经关闭了，那么DisableFilter实际上什么都不会做，而且在using语句结束后仍然是关闭的。</p></blockquote><h3 id="开启过滤器"><a href="#开启过滤器" class="headerlink" title="开启过滤器###"></a>开启过滤器###</h3><p>你可以在工作单元中使用<strong>EnableFilter</strong>方法来开启一个过滤器，和DisableFilter很相似。EnableFilter也返回disable来自动再次关闭该过滤器。</p><h3 id="设置过滤器参数"><a href="#设置过滤器参数" class="headerlink" title="设置过滤器参数###"></a>设置过滤器参数###</h3><p>过滤器是可以带参数的。IMustHaveTenant过滤器就是这些过滤器类型的一个例子，因为当前的租户Id要在运行时确定。对于这些过滤器，如果需要的话，我们可以改变过滤器的值。例如：</p><pre class=" language-C#"><code class="language-C#">CurrentUnitOfWork.SetFilterParameter("PersonFilter", "personId", 42);</code></pre><p>另一个例子：为IMayHaveTenant过滤器设置tenantId值：</p><pre><code>CurrentUnitOfWork.SetFilterParameter(AbpDataFilters.MayHaveTenant, AbpDataFilters.Parameters.TenantId, 42);</code></pre><p>SetFilterParameter方法也返回一个IDisposable。因此，我们可以在一个using语句中使用它，在using语句结束时自动<strong>还原旧值</strong>。</p><h3 id="定义自定义过滤器"><a href="#定义自定义过滤器" class="headerlink" title="定义自定义过滤器###"></a>定义自定义过滤器###</h3><p>要创建一个自定义过滤器并集成到ABP中，我们首先应该定义一个接口，该接口会被使用这个过滤器的实体实现。假设我们想要通过PersonId自动过滤实体。例如：</p><pre class=" language-C#"><code class="language-C#">public interface IHasPerson{    int PersonId { get; set; }}</code></pre><p>然后，为需要的实体实现该接口。例如：</p><pre class=" language-C#"><code class="language-C#">public class Phone : Entity, IHasPerson{    [ForeignKey("PersonId")]    public virtual Person Person { get; set; }    public virtual int PersonId { get; set; }    public virtual string Number { get; set; }}</code></pre><p>因为ABP使用了**<a href="https://github.com/jcachat/EntityFramework.DynamicFilters">EntityFramework.DynamicFilters</a><strong>，因此我们可以使用它的规则来定义该过滤器。在我们的 **DbContext</strong>类中，我们重写了 <strong>OnModelCreating</strong>，而且定义过滤器如下所示：</p><pre class=" language-C#"><code class="language-C#">protected override void OnModelCreating(DbModelBuilder modelBuilder){    base.OnModelCreating(modelBuilder);    modelBuilder.Filter("PersonFilter", (IHasPerson entity, int personId) => entity.PersonId == personId, 0);}</code></pre><p>这里，“PersonFilter”是过滤器唯一的名字。第二个参数定义了过滤器接口和personId过滤器参数（如果过滤器没有参数那么就不需要了）。最后一个参数是personId的默认值。</p><p>最后一件事，我们应该在模块的PreInitialize方法中将该过滤器注册到ABP的工作单元系统中。</p><pre class=" language-c#"><code class="language-c#">Configuration.UnitOfWork.RegisterFilter("PersonFilter", false);</code></pre><p>第一个参数是我们上面定义的过滤器的唯一的名字。第二个参数表明默认是开启的还是关闭的。声明这么一个参数化的过滤器之后，我们可以通过在运行时给它提供值来使用了。</p><pre class=" language-C#"><code class="language-C#">using (CurrentUnitOfWork.EnableFilter("PersonFilter")){    CurrentUnitOfWork.SetFilterParameter("PersonFilter", "personId", 42);    var phones = _phoneRepository.GetAllList();    //...}</code></pre><p>我们可以从一些源中获得personId而不是静态代码中。上面的例子是对于参数化的过滤器来说的。过滤器可以有零个或更多的参数。如果它没有参数，就不需要设置过滤器的值了。此外，如果它默认是开启的，它就不需要手动开启了（当然，我们还可以关闭它）。</p><blockquote><h4 id="EntityFramework-DynamicFilters文档"><a href="#EntityFramework-DynamicFilters文档" class="headerlink" title="EntityFramework.DynamicFilters文档"></a>EntityFramework.DynamicFilters文档</h4><p>关于动态数据过滤器的更多信息，请看**<a href="https://github.com/jcachat/EntityFramework.DynamicFilters">github上的文档</a>**。</p></blockquote><p>我们也可以为安全，激活/未激活的实体等创建自定义的过滤器。</p><h3 id="其他ORM"><a href="#其他ORM" class="headerlink" title="其他ORM###"></a>其他ORM###</h3><p>ABP已经实现了EF和NH的数据过滤。对于其他的ORM还不可用。但是实际上，只要你使用<strong>仓储</strong>获得数据，你就可以为绝大多数情况模拟数据过滤。对于这种情况，如果需要的话，你可以创建自定义的仓储，然后重写   <strong>GetAll</strong>和其他的数据检索方法。</p><h1 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h1><h1 id="ABP理论学习之应用服务"><a href="#ABP理论学习之应用服务" class="headerlink" title="ABP理论学习之应用服务"></a><a href="https://www.cnblogs.com/farb/p/ABPApplicationService.html">ABP理论学习之应用服务</a></h1><hr><h2 id="本篇目录-16"><a href="#本篇目录-16" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><a href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#IApplicationService">IApplicationService接口</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#ApplicationService">ApplicationService类</a></strong></li></ul></li><li><a href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#Uow">工作单元</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#sbConn">数据库连接和事务管理</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#saving">自动保存更改</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#more">更多</a></strong></li></ul></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#lifecycle">应用服务的生命周期</a></strong></li></ul><p>应用服务用于将领域逻辑暴露给展现层。展现层调用具有DTO参数的应用服务，使用领域对象来执行一些特定的业务逻辑并返回给展现层一个DTO。这样，展现层就完全独立于领域层了。在一个理想的分层应用中，展现层永远不直接和领域对象打交道。</p><h3 id="IApplicationService接口"><a href="#IApplicationService接口" class="headerlink" title="IApplicationService接口###"></a>IApplicationService接口###</h3><p>在ABP中，应用服务<strong>应该</strong>实现 <strong>IApplicationService</strong>接口。建议为每个应用服务创建一个接口。这样一来，我们先要为一个应用定义一个接口，如下所示：</p><pre class=" language-C#"><code class="language-C#">public interface IPersonAppService : IApplicationService{    void CreatePerson(CreatePersonInput input);}</code></pre><p><strong>IPersonAppService</strong>只有一个方法。展现层用它来创建一个新的person。<strong>CreatePersonInput</strong>是如下所示的一个DTO对象：</p><pre class=" language-C#"><code class="language-C#">public class CreatePersonInput : IInputDto{    [Required]    public string Name { get; set; }    public string EmailAddress { get; set; }}</code></pre><p>然后我可以实现IPersonAppService:</p><pre class=" language-C#"><code class="language-C#">public class PersonAppService : IPersonAppService{    private readonly IRepository<Person> _personRepository;    public PersonAppService(IRepository<Person> personRepository)    {        _personRepository = personRepository;    }    public void CreatePerson(CreatePersonInput input)    {        var person = _personRepository.FirstOrDefault(p => p.EmailAddress == input.EmailAddress);        if (person != null)        {            throw new UserFriendlyException("There is already a person with given email address");        }        person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };        _personRepository.Insert(person);    }}</code></pre><p>这里是一些重点：</p><ul><li>PersonAppService使用<strong>IRepository</strong>执行数据库操作。这里使用了依赖注入，而且使用了 <strong>构造函数注入</strong>的模式。</li><li>PersonAppService实现了<strong>IApplicationService</strong>，它是通过ABP自动注册到依赖注入系统的，然后被其他的类注入并使用。</li><li><strong>CreatePerson</strong>方法以 <strong>CreatePersonInput</strong>作为参数。它是一个输入DTO，会被ABP自动验证。</li></ul><h4 id="ApplicationService类"><a href="#ApplicationService类" class="headerlink" title="ApplicationService类"></a>ApplicationService类</h4><p>应用服务类应该实现应用服务接口（IApplicationService）。此外，还可以选择从<strong>ApplicationService</strong>基类派生。这样，IApplicationService也被继承实现了。而且，ApplicationService有一些基本功能，使得<strong>logging</strong>和 <strong>本土化</strong>更加简单。建议为你的继承了ApplicationService的应用服务创建一个特殊的基类。这样，你就可以为所有的应用服务添加一些通用功能。一个应用服务类的例子如下所示：</p><pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService, ITaskAppService{    public TaskAppService()    {        LocalizationSourceName = "SimpleTaskSystem";    }    public void CreateTask(CreateTaskInput input)    {        //记录日志 (Logger 定义在 ApplicationService 类中)        Logger.Info("Creating a new task with description: " + input.Description);        //获取本地化文本 (L 是LocalizationHelper.GetString(...)的简写, 定义在 ApplicationService类中)        var text = L("SampleLocalizableTextKey");        //TODO: Add new task to database...    }}</code></pre><p>你可以定义一个基类，在该基类中的构造函数中定义LocalizationSourceName。这样，就不用为所有的服务类重复定义了。</p><h3 id="工作单元-1"><a href="#工作单元-1" class="headerlink" title="工作单元###"></a>工作单元###</h3><p>在ABP中，应用服务方法默认是一个工作单元。</p><h4 id="数据库连接和事务管理"><a href="#数据库连接和事务管理" class="headerlink" title="数据库连接和事务管理"></a>数据库连接和事务管理</h4><p>假如说我们想要在一个必须是事务的应用服务方法中调用两个仓储方法。例如：</p><pre class=" language-C#"><code class="language-C#">public void CreatePerson(CreatePersonInput input){    var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };        _personRepository.Insert(person);    _statisticsRepository.IncrementPeopleCount();}</code></pre><p>我们将一个person实体插入到People表中，然后总人数自增，并保存到另一个表的字段中。这个方法都是用不同的仓储实现的，但是共享了相同的连接和事务。</p><p>在CreatePerson方法开始时，ABP会自动打开数据库连接并开始事务。在方法结束时，如果没有异常发生，会自动提交事务并关闭数据库连接。这样，在CreatePerson方法中的所有数据库操作都是<strong>事务的（原子的）</strong>，如果有任何异常抛出，操作就会回滚。因此，在这个方法中的两个仓储共享相同的连接和事务。</p><p>当调用仓储的**GetAll()**方法时，会返回一个IQueryable。数据库连接应该在调用该方法后打开。这是因为IQueryable和Linq会延迟执行。数据库真正查询是在调用 **ToList()**方法时发生的。看下面的例子：</p><pre class=" language-C#"><code class="language-C#">public SearchPeopleOutput SearchPeople(SearchPeopleInput input){    //获得 IQueryable<Person>    var query = _personRepository.GetAll();    //添加过滤    if (!string.IsNullOrEmpty(input.SearchedName))    {        query = query.Where(person => person.Name.StartsWith(input.SearchedName));    }    if (input.IsActive.HasValue)    {        query = query.Where(person => person.IsActive == input.IsActive.Value);    }    //获取分页结果list    var people = query.Skip(input.SkipCount).Take(input.MaxResultCount).ToList();    return new SearchPeopleOutput {People = Mapper.Map<List<PersonDto>>(people)};}</code></pre><p>因为一个应用服务方法是一个工作单元，所以在执行这个方法期间数据库连接是打开的。如果在一个不是应用服务的类中调用了GetAll()方法，那么应该显式使用<strong>工作单元</strong>。</p><p>注意这里使用了AutoMapper类库将 List转成List。更多细节请看下一篇DTO博客。</p><h4 id="自动保存更改"><a href="#自动保存更改" class="headerlink" title="自动保存更改"></a>自动保存更改</h4><p>对于工作单元方法，ABP会在方法结束时自动保存所有的更改。假设我们有一个更新一个人的名字的应用服务方法：</p><pre class=" language-C#"><code class="language-C#">public void UpdateName(UpdateNameInput input){    var person = _personRepository.Get(input.PersonId);    person.Name = input.NewName;}</code></pre><p>只需要这样，name字段就改变了。我们甚至都不要调用_personRepository.Update方法。ORM框架会跟踪工作单元内的实体的所有更改，并将更改反映给数据库。</p><h1 id="ABP理论学习之数据传输对象-DTO"><a href="#ABP理论学习之数据传输对象-DTO" class="headerlink" title="ABP理论学习之数据传输对象(DTO)"></a><a href="https://www.cnblogs.com/farb/p/ABPDTO.html">ABP理论学习之数据传输对象(DTO)</a></h1><hr><h2 id="本篇目录-17"><a href="#本篇目录-17" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><a href="https://www.cnblogs.com/farb/p/ABPDTO.html#whyDTO">为何需要DTO</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDTO.html#abstraction">领域层抽象</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDTO.html#dataHide">数据隐藏</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDTO.html#lazyLoading">序列化和懒加载问题</a></strong></li></ul></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDTO.html#validation">DTO惯例和验证</a></strong></li><li><a href="https://www.cnblogs.com/farb/p/ABPDTO.html#autoMapping">DTO和实体的自动映射</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDTO.html#attribute">使用特性和扩展方法进行映射</a></strong></li></ul></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDTO.html#helper">帮助接口</a></strong></li></ul><p>DTO用于<strong>应用层</strong>和 <strong>展现层</strong>间的数据传输。</p><p>展现层调用具有DTO参数的**<a href="http://www.cnblogs.com/farb/p/ABPApplicationService.html">应用服务</a>**方法，然后应用服务使用领域对象来执行一些特定的业务逻辑，最后返回给展现层一个DTO。因此，展现层完全独立于领域层。在一个理想的分层应用中，展现层不直接和领域对象打交道（仓储，实体…）。</p><h3 id="为何需要DTO"><a href="#为何需要DTO" class="headerlink" title="为何需要DTO###"></a>为何需要DTO###</h3><p>为每个应用服务方法创建一个DTO起初可能被看作是一项乏味而又耗时的事情。但如果正确地使用它，那么DTOs可能会拯救你应用。为啥呢？</p><h4 id="领域层抽象"><a href="#领域层抽象" class="headerlink" title="领域层抽象"></a>领域层抽象</h4><p>DTO为展现层抽象领域对象提供了一种有效方式。这样，层与层之间就正确分离了。即使你想完全分离展现层，仍然可以使用已存在的应用层和领域层。相反，只要领域服务的契约（方法签名和DTOs）保持不变，即使重写领域层，完全改变数据库模式，实体和ORM框架，也不需要在展现层做任何改变。</p><h4 id="数据隐藏"><a href="#数据隐藏" class="headerlink" title="数据隐藏"></a>数据隐藏</h4><p>试想你有一个User实体，包含Id，Name，EmailAddress和Password字段。如果UserAppService的GetAllUsers()方法返回一个List，即使你没有在屏幕上显示它，那么任何人也都能看到所有user的密码。它不是涉及安全的，而是与数据隐藏相关的。应用服务都应该返回给展现层需要的，不要更多，也不很少，要的是恰到好处。</p><h4 id="序列化和懒加载问题"><a href="#序列化和懒加载问题" class="headerlink" title="序列化和懒加载问题"></a>序列化和懒加载问题</h4><p>当返回给展现层一个对象时，它很可能在某个地方序列化。比如，一个MVC方法返回JSON，一个对象会被序列化成JSON，然后发送到客户端。在那种情况，将一个实体返回到展现层是有问题的。这是怎么回事呢？</p><p>在一个真实应用中，实体之间是相互引用的。User实体可能有一个Role的引用。因此，如果你想序列化User，那么Role也会序列化。而且，如果Role有一个List且Permission类有一个PermissionGroup类的引用等等。你能想象所有的对象都会被序列化的那种场景吗？你可能会意外地序列化整个数据库。那么解决方案是什么呢？把属性标记为NonSerilized吗?不，你可能不知道它何时应该序列化，何时不应该。它可能在一个应用方法中需要，可能在另一个就不需要了。因此，在这种情景中，设计一个可安全序列化的，特别设计的DTOs是一种好的选择。</p><p>几乎所有的ORM框架都支持懒加载。它的特征是当需要时才从数据库中加载实体。假如说User类有一个Role类的引用。当从数据库中获得一个User时，此时Role属性还没有填充，当第一次读该Role属性时，它才从数据库中加载。因此，不要将这样的一个实体直接返回给展现层，它可能会轻易造成从数据库检索额外的实体。如果序列化工具读到了该实体，它会递归地读取所有属性，最终整个数据库可能会被检索（如果实体间有合适的关系）。</p><p>在展现层使用实体还会有更多的问题。最好压根不要在将包含领域（业务）层的程序集引用到展现层上。</p><h3 id="DTO惯例和验证"><a href="#DTO惯例和验证" class="headerlink" title="DTO惯例和验证###"></a>DTO惯例和验证###</h3><p>ABP高度支持DTOs，它提供了一些符合惯例的类和接口，并且对于DTO的命名和用法提出了一些建议。当按照下面描述的那样编写代码时，ABP会轻易地自动处理一些事情。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>让我们看一个完整的例子。假如我们想要开发一个应用服务方法，作用是使用一个名字来搜索人，并返回一个人的集合。这种情况下，我们可能会有一个如下的Person实体：</p><pre class=" language-C#"><code class="language-C#">public class Person : Entity{    public virtual string Name { get; set; }    public virtual string EmailAddress { get; set; }    public virtual string Password { get; set; }}</code></pre><p>首先，我们定义一个应用服务的接口：</p><pre class=" language-C#"><code class="language-C#">public interface IPersonAppService : IApplicationService{    SearchPeopleOutput SearchPeople(SearchPeopleInput input);}</code></pre><p>ABP建议将input/output参数命名为MethodName<strong>Input</strong>和   MethodName<strong>Output</strong>，并为每个应用服务方法定义一个单独的input和output DTO。即使你的方法只需要或返回一个参数，最好也创建一个DTO类。这样，你的代码回更具有扩展性。以后你可以添加更多的属性而不用改变方法的签名，而且也不用使已存在的客户端应用发生重大变化。</p><p>当然，如果你的方法没有返回值，那么方法可以返回<strong>void</strong>。如果以后添加了一个返回值，也不会打破已存在的应用。如果你的方法不需要任何参数，那么你也不必定义一个输入DTO。但是如果未来很可能添加参数，那么也许最好还是编写一个输入DTO。这取决于你。</p><p>让我们看一下为这个例子定义的输入和输出的DTO：</p><pre class=" language-C#"><code class="language-C#">public class SearchPeopleInput : IInputDto{    [StringLength(40, MinimumLength = 1)]    public string SearchedName { get; set; }}public class SearchPeopleOutput : IOutputDto{    public List<PersonDto> People { get; set; }}public class PersonDto : EntityDto{    public string Name { get; set; }    public string EmailAddress { get; set; }}</code></pre><p><strong>验证：</strong>按照惯例，输入DTO实现了 <strong>IInputDto</strong>接口，输出DTO实现了 <strong>IOutputDto</strong>接口。当实现了IInputDto时，ABP会在方法执行前自动验证输入。这和ASP.NET MVC的验证很相似，但是注意应用服务不是控制器，它是纯粹的C#类。ABP使用拦截来自动检查输入。关于更多的验证，请看下篇DTO验证。</p><p><strong>EntityDto</strong>是一个声明了Id属性的简单类。因为这对于所有的实体都是公用的。如果你的实体的主键不是int的，那么还有一个泛型版本。PersonDto不包含Password属性，因为表现层不需要。甚至将所有人的密码都发送到展现层可能是很危险的。想象一下，如果Javascript客户端发送请求，任何人就会轻易地抓取到所有的密码。</p><p>接下来进一步实现之前的<strong>IPersonAppService</strong>。</p><pre class=" language-C#"><code class="language-C#">public class PersonAppService : IPersonAppService{    private readonly IPersonRepository _personRepository;    public PersonAppService(IPersonRepository personRepository)    {        _personRepository = personRepository;    }    public SearchPeopleOutput SearchPeople(SearchPeopleInput input)    {        //Get entities        var peopleEntityList = _personRepository.GetAllList(person => person.Name.Contains(input.SearchedName));        //Convert to DTOs        var peopleDtoList = peopleEntityList            .Select(person => new PersonDto                                {                                    Id = person.Id,                                    Name = person.Name,                                    EmailAddress = person.EmailAddress                                }).ToList();        return new SearchPeopleOutput { People = peopleDtoList };    }}</code></pre><p>我们从数据库中获得实体，再将它们转成DTOs，然后返回到输出。注意我们没有验证输入，因为ABP会自动验证。ABP甚至会检查输入参数是否为null，如果为null，就会抛出异常。</p><p>但是很可能你不喜欢从一个Person实体到一个PersonDto对象的转换代码。这是相当无聊的事情，而且，Person实体可能会有更多的属性。</p><h3 id="DTO和实体的自动映射"><a href="#DTO和实体的自动映射" class="headerlink" title="DTO和实体的自动映射###"></a>DTO和实体的自动映射###</h3><p>幸好，我们有工具可以让这个变得很简单。<strong>AutoMapper</strong>就是之一（要学习AutoMapper，请看我的**<a href="http://www.cnblogs.com/farb/p/AutoMapperContent.html">AutoMapper系列教程</a>**。它已经发布到Nuget上了，你可以轻松地将它添加到项目中。让我们再次写一下SearchPeople方法，但是这次是用AutoMapper：</p><pre class=" language-C#"><code class="language-C#">public SearchPeopleOutput SearchPeople(SearchPeopleInput input){    var peopleEntityList = _personRepository.GetAllList(person => person.Name.Contains(input.SearchedName));    return new SearchPeopleOutput { People = Mapper.Map<List<PersonDto>>(peopleEntityList) };}</code></pre><p>这样就ok了。你可以给实体和DTO添加更多的属性而不需要转换代码做任何改变。唯一要做的事情就是在使用前定义一个映射：</p><pre class=" language-C#"><code class="language-C#">Mapper.CreateMap<Person, PersonDto>();</code></pre><p>AutoMapper创建了映射代码。这样，动态映射就不会成为性能问题了。它既快速又容易。AutoMapper为Person实体创建了PersonDto，并使用命名规范赋予DTO属性。命名规范可能是复杂的且可配置的。此外，你还可以定义自定义映射以及更多。</p><h4 id="使用特性和扩展方法进行映射"><a href="#使用特性和扩展方法进行映射" class="headerlink" title="使用特性和扩展方法进行映射"></a>使用特性和扩展方法进行映射</h4><p>ABP提供了若干特性和扩展方法来定义映射。首先，要将Abp.AutoMapper nuget包添加到项目中。然后，<strong>AutoMap</strong>特性是双向映射方式， <strong>AutoMapFrom</strong>和 <strong>AutoMapTo</strong>是单向映射方式。最后，使用<strong>MapTo</strong>扩展方法将一个对象映射到另一个对象。映射定义的例子如下：</p><pre class=" language-C#"><code class="language-C#">[AutoMap(typeof(MyClass2))] //定义双向映射public class MyClass1{    public string TestProp { get; set; }}public class MyClass2{    public string TestProp { get; set; }}</code></pre><p>定义了上面的代码之后，就可以使用MapTo扩展方法映射它们了：</p><pre class=" language-C#"><code class="language-C#">var obj1 = new MyClass1 { TestProp = "Test value" };var obj2 = obj1.MapTo<MyClass2>(); //从obj1的副本创建一个新的MyClass2对象</code></pre><p>上面的代码从MyClass1的对象创建了MyClass2一个新的对象。此外，你可以像下面那样，映射到一个已存在的对象：</p><pre class=" language-C#"><code class="language-C#">var obj1 = new MyClass1 { TestProp = "Test value" };var obj2 = new MyClass2();obj1.MapTo(obj2);</code></pre><h3 id="帮助接口-1"><a href="#帮助接口-1" class="headerlink" title="帮助接口###"></a>帮助接口###</h3><p>ASP.NET 提供了一些实现标准化公共DTO属性名称的帮助接口。</p><p><strong>ILimitedResultRequest</strong>定义了 <strong>MaxResultCount</strong>属性。这样你就可以在你的输入DTO中实现它来标准化有限的结果集。</p><p><strong>IPagedResultRequest</strong>通过添加了 <strong>SkipCount</strong>扩展了 <strong>ILimitedResultRequest</strong>。这样，我们可以在SearchPeopleInput中为分页显示实现这个接口：</p><pre class=" language-C#"><code class="language-C#">public class SearchPeopleInput : IInputDto, IPagedResultRequest{    [StringLength(40, MinimumLength = 1)]    public string SearchedName { get; set; }    public int MaxResultCount { get; set; }    public int SkipCount { get; set; }}</code></pre><p>对于一个分页请求的结果，你可以返回一个实现了<strong>IHasTotalCount</strong>的输出DTO。命名标准化帮助我们创建可重复使用的代码和惯例。你也可以在 <strong>Abp.Application.Services.Dto</strong>命名空间下看到其他的接口和类。</p><h1 id="ABP理论学习之验证DTO"><a href="#ABP理论学习之验证DTO" class="headerlink" title="ABP理论学习之验证DTO"></a><a href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html">ABP理论学习之验证DTO</a></h1><hr><h2 id="本篇目录-18"><a href="#本篇目录-18" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html#intro">验证介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html#annotaion">使用数据注解</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html#custom">自定义验证</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html#normalization">标准化</a></strong></li></ul><h3 id="验证介绍"><a href="#验证介绍" class="headerlink" title="验证介绍###"></a>验证介绍###</h3><p>首先应该验证应用的输入。用户或者其它应用都可以向该应用发送输入。在一个web应用中，验证通常要实现两次：在客户端和服务器端。客户端的验证大多数情况下是为用户体验而实现的。在客户端最好先检查一下表单，并向用户展示不合法的字段。但是服务端的验证更关键且不可避免。</p><p>服务端的验证通常实现在应用服务层。应用服务方法应首先检查（验证）输入然后再使用它。ABP提供了一个很好的基础设施来验证应用服务方法的输入。</p><p>应用服务方法接收一个DTO（数据传输对象）作为输入。ABP有一个<strong>IValidate</strong>接口，凡是实现了该接口的DTO都可以自动地进行验证。因为<strong>IInputDto</strong>继承了IValidate，因此只要为输入DTOs实现IInputDto就可以确保验证了。</p><h3 id="使用数据注解"><a href="#使用数据注解" class="headerlink" title="使用数据注解###"></a>使用数据注解###</h3><p>ABP支持数据注解特性。假设我们要开发一个任务（Task）应用服务，该服务用于创建一个任务，它的输入参数类型如下所示：</p><pre class=" language-C#"><code class="language-C#">public class CreateTaskInput : IInputDto{    public int? AssignedPersonId { get; set; }    [Required]    public string Description { get; set; }}</code></pre><p>这里，<strong>Description</strong>属性标记为 <strong>Required</strong>。AssignedPersonId是可选的。在 <strong>System.ComponentModel.DataAnnotations</strong>命名空间中也有很多特性（如MaxLength,MinLength,RegularExpression等等）。来看一下任务应用服务的实现：</p><pre class=" language-C#"><code class="language-C#">public class TaskAppService : ITaskAppService{    private readonly ITaskRepository _taskRepository;    private readonly IPersonRepository _personRepository;    public TaskAppService(ITaskRepository taskRepository, IPersonRepository personRepository)    {        _taskRepository = taskRepository;        _personRepository = personRepository;    }    public void CreateTask(CreateTaskInput input)    {        var task = new Task { Description = input.Description };        if (input.AssignedPersonId.HasValue)        {            task.AssignedPerson = _personRepository.Load(input.AssignedPersonId.Value);        }        _taskRepository.Insert(task);    }}</code></pre><p>正如你所看到的，这里没写验证代码，因为ABP会自动进行验证。ABP也会检查输入是否为<strong>null</strong>。如果为null，就会抛出 <strong>AbpValidationException</strong>。因此，你也不用写检测null的代码（保卫语句）。如果输入的属性有任何一个是非法的，那么就会抛出相同的异常。</p><p>该机制和ASP.NET MVC的验证相似，但是注意的是应用服务类不是派生自Controller，而只是一个纯粹的类并且在web应用之外工作。</p><h3 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证###"></a>自定义验证###</h3><p>如果数据注解还不能满足你的情况，那么你可以实现<strong>ICustomValidate</strong>接口，如下所示：</p><pre class=" language-C#"><code class="language-C#">public class CreateTaskInput : IInputDto, ICustomValidate{    public int? AssignedPersonId { get; set; }    public bool SendEmailToAssignedPerson { get; set; }    [Required]    public string Description { get; set; }    public void AddValidationErrors(List<ValidationResult> results)    {        if (SendEmailToAssignedPerson && (!AssignedPersonId.HasValue || AssignedPersonId.Value <= 0))        {            results.Add(new ValidationResult("AssignedPersonId must be set if SendEmailToAssignedPerson is true!"));        }    }}</code></pre><p>ICustomValidate接口声明了要实现的<strong>AddValidationErrors</strong>方法。这里，我们有一个 <strong>SendEmailToAssignedPerson</strong>属性。如果它的值是true， 而且没有提供<strong>AssignedPersonId</strong>或值是负数，那么我们就认为这里发生了验证错误，我们必须将<strong>ValidationResult</strong>对象添加到 <strong>results</strong>集合中。</p><h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化###"></a>标准化###</h3><p>我们可能在验证之后执行一个额外的操作来排列DTO参数。ABP定义了<strong>IShouldNormalize</strong>接口， 该接口中定义了<strong>Normalize</strong>方法来达到排列DTO参数的目的。如果你实现了该接口，那么就应该在验证之后（方法调用之前）调用Normalize方法。假如我们的DTO要有一个排序（Sorting）方向，如果没有提供的话，我们就要设置一个默认值：</p><pre class=" language-C#"><code class="language-C#">public class GetTasksInput : IInputDto, IShouldNormalize{    public string Sorting { get; set; }            public void Normalize()    {        if (string.IsNullOrWhiteSpace(Sorting))        {            Sorting = "Name ASC";        }    }}</code></pre><h1 id="ABP理论学习之授权（Authorization）"><a href="#ABP理论学习之授权（Authorization）" class="headerlink" title="ABP理论学习之授权（Authorization）"></a><a href="https://www.cnblogs.com/farb/p/ABPAuthorization.html">ABP理论学习之授权（Authorization）</a></h1><hr><h2 id="本篇目录-19"><a href="#本篇目录-19" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#define">定义权限</a></strong></li><li><a href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#check">检查权限</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#AbpAuthorize">使用AbpAuthorize特性</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#IPermissionChecker">使用IPermissionChecker</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#Razor">Razor视图</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#Javascript">客户端（Javascript）</a></strong></li></ul></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#permissionManager">权限管理者</a></strong></li></ul><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍###"></a>介绍###</h3><p>几乎所有的企业应用都在不同程度使用了授权。授权的目的在于检查是否允许用户在应用程序中执行特定的操作。ABP定义了一个<strong>基于权限的</strong>基础设施来实现授权。</p><blockquote><h4 id="关于IPermissionChecker"><a href="#关于IPermissionChecker" class="headerlink" title="关于IPermissionChecker"></a>关于IPermissionChecker</h4><p>授权系统使用了<strong>IPermissionChecker</strong>来检查权限。虽然你可以用自己的方式实现该接口，但是它已完全实现在了 <strong>module-zero</strong>项目中。如果没有实现该接口，那么系统会默认使用NullPermissionChecker将所有的权限授予给每个人。</p></blockquote><h3 id="定义权限"><a href="#定义权限" class="headerlink" title="定义权限###"></a>定义权限###</h3><p>一个唯一的权限是为需要授权的每个操作定义的。我们应该在使用权限之前定义一个权限。ABP的设计是模块化的，因此不同的模块可以有不同的权限。为了定义模块的权限，应该创建一个派生自<strong>AuthorizationProvider（以下翻译为授权提供者）</strong>的类。一个授权提供者的例子如下所示：</p><pre class=" language-C#"><code class="language-C#">public class MyAuthorizationProvider : AuthorizationProvider{    public override void SetPermissions(IPermissionDefinitionContext context)    {        var administration = context.CreatePermission("Administration");        var userManagement = administration.CreateChildPermission("Administration.UserManagement");        userManagement.CreateChildPermission("Administration.UserManagement.CreateUser");        var roleManagement = administration.CreateChildPermission("Administration.RoleManagement");    }}</code></pre><p><strong>IPermissionDefinitionContext</strong>有创建和获取权限的方法。</p><p>一个权限定义了一些属性：</p><ul><li><strong>Name：</strong>系统中 <strong>唯一的</strong>名字。最好为权限的名字定义一个const字符串而不是变量字符串。我们偏向使用“.”符号用于有层次的名字，但这不是强制的。你可以设置任何你喜欢的名字，唯一的一点是保证它必须是唯一的。</li><li>**DisplayName:**用于以后在UI上显示权限的本地化字符串。</li><li><strong>Description：</strong>用于以后在UI上显示权限定义的本地化字符串。</li><li><strong>IsGrantedByDefault：</strong>表示该权限是否授予给所有登录的用户，除非该权限显式禁止未授予给用户。该值一般默认为false。</li><li><strong>MultiTenancySides：</strong>对于多租户应用，租户或者租主可以使用同一个权限。这是一个<strong>Flags</strong>枚举，因此一个权限可以用于租户和租主。</li><li><strong>dependedFeature：</strong>可以用于声明一个功能的依赖。因此，只有功能依赖满足了，该权限才会被授予。</li></ul><p>一个权限可以有父权限和子权限。虽然这不会影响权限检查，但是在UI上组合权限有所帮助。</p><p>当创建了授权提供者之后，我们应该在模块的PreIntialize方法中注册它：</p><pre class=" language-C#"><code class="language-C#">Configuration.Authorization.Providers.Add<MyAuthorizationProvider>();</code></pre><p>因为授权提供者会自动地注册到依赖注入系统中，所以，授权提供者通过一些其他资源，可以注入任何依赖（比如仓储）来生成权限定义。</p><h3 id="检查权限"><a href="#检查权限" class="headerlink" title="检查权限###"></a>检查权限###</h3><h4 id="使用AbpAuthorize特性"><a href="#使用AbpAuthorize特性" class="headerlink" title="使用AbpAuthorize特性"></a>使用AbpAuthorize特性</h4><p><strong>AbpAuthorize</strong>（MVC控制器是AbpMvcAuthorize，Web API控制器是AbpApiAuthorize）是最简单也是最普通的检查权限的方式。思考一下下面的应用服务方法：</p><pre class=" language-C#"><code class="language-C#">[AbpAuthorize("Administration.UserManagement.CreateUser")]public void CreateUser(CreateUserInput input){    //如果一个用户没有被授予 "Administration.UserManagement.CreateUser" 权限，那么ta就不能执行此方法}</code></pre><p>AbpAuthorize特性也会检查当前的用户是否已经登录（使用**<a href="http://www.cnblogs.com/farb/p/ABPSession.html">IAbpSession.UserId</a>**）。因此，如果我们为一个方法声明了AbpAuthorize，它至少会检查登录情况：</p><pre class=" language-C#"><code class="language-C#">[AbpAuthorize]public void SomeMethod(SomeMethodInput input){    //如果用户没有登录，那么ta就不能执行此方法}</code></pre><p><strong>AbpAuthorize特性需要注意的地方</strong></p><p>ABP对于授权使用了强大的动态方法拦截（interception）。因此，使用AbpAuthorize特性有一些限制：</p><ul><li>不能用于私有方法。</li><li>不能用于静态方法。</li><li>不能用于非注入类的方法（我们必须要使用依赖注入）。</li></ul><p>此外，</p><ul><li>可以用于任何 <strong>public</strong>方法，如果该方法是通过接口调用的（比如应用服务通过接口使用）。</li><li>方法应该是<strong>virtual</strong>的，如果它是从类的引用直接调用的（比如ASP.Net MVC或者Web API的控制器）。</li><li>如果方法是<strong>protected</strong>的，那么它应该是 <strong>virtual</strong>的。</li></ul><p><strong>注意：</strong>AbpAuthorize特性有三个：</p><p>在应用服务中（应用层），我们使用<strong>Abp.Authorization.AbpAuthorize</strong>类。<br> 在MVC控制器中（Web层），我们使用 <strong>Abp.Web.Mvc.Authorization.AbpMvcAuthorize</strong>类。<br> 在ASP.NET Web API中，我们使用 <strong>Abp.WebApi.Authorization.AbpApiAuthorize</strong>特性。<br> 这写特性的差异来自继承。在MVC端，派生自MVC自己的Authorize类。在Web API端，它派生自Web API的Authorize类。因此，它已经很好地集成到了MVC和Web API。但是在应用层，它完全是ABP自己的实现而没有扩展任何类。</p><h4 id="使用IPermissionChecker"><a href="#使用IPermissionChecker" class="headerlink" title="使用IPermissionChecker"></a>使用IPermissionChecker</h4><p>虽然AbpAuthorize特性对于大多数情况相当够用了，但是肯定存在我们会在一个方法体内检查权限的情况。我们可以注入并使用<strong>IPermissionChecker</strong>，如下面的例子所示：</p><pre class=" language-C#"><code class="language-C#">public void CreateUser(CreateOrUpdateUserInput input){    if (!PermissionChecker.IsGranted("Administration.UserManagement.CreateUser"))    {        throw new AbpAuthorizationException("You are not authorized to create user!");    }        //如果一个用户没有"Administration.UserManagement.CreateUser" 权限，那么ta不能到达该点。}</code></pre><p>当然，你可以编写任何逻辑代码，因为<strong>IsGranted</strong>仅仅返回true或者false（也有Async版本）。如果你只是检查一个权限然后抛出一个如上所示的异常，那么你可以使用 <strong>Authorize</strong>方法：</p><pre class=" language-C#"><code class="language-C#">public void CreateUser(CreateOrUpdateUserInput input){    PermissionChecker.Authorize("Administration.UserManagement.CreateUser");    //如果一个用户没有"Administration.UserManagement.CreateUser" 权限，那么ta不能到达该点。}</code></pre><p>因为授权一般在应用层实现，所以<strong>ApplicationService</strong>基类注入并定义了PermissionChecker属性。这样，权限检查者不需要在应用服务类中注入就可以使用了。</p><h4 id="Razor视图"><a href="#Razor视图" class="headerlink" title="Razor视图"></a>Razor视图</h4><p>视图基类定义了IsGranted方法来检查当前用户是否具有权限。因此，我们可以有条件地渲染该视图。例子：</p><pre class=" language-C#"><code class="language-C#">@if (IsGranted("Administration.UserManagement.CreateUser")){    <button id="CreateNewUserButton" class="btn btn-primary"><i class="fa fa-plus"></i> @L("CreateNewUser")</button>}</code></pre><h4 id="客户端（Javascript）"><a href="#客户端（Javascript）" class="headerlink" title="客户端（Javascript）"></a>客户端（Javascript）</h4><p>在客户端，我们可以使用定义在<strong>abp.auth</strong>命名空间下的API。在大多数情况，我们需要检查当前的用户是否具有特定的权限（使用权限名字）。例子：</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>auth<span class="token punctuation">.</span><span class="token function">hasPermission</span><span class="token punctuation">(</span><span class="token string">'Administration.UserManagement.CreateUser'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>你也可以使用<strong>abp.auth.grantedPermissions</strong>来获得所有授权的权限或者使用 <strong>abp.auth.allPermissions</strong>来获取所有应用中可用的权限名。</p><p>注意：自ABP 0.7.8版本开始，<strong>将javascript端的abp.auth.hasPermission更名为abp.auth.isGranted。hasPermission已经过时了。在新的项目中不要使用abp.auth.hasPermission</strong>。</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321205113812.png" alt="image-20210321205113812"></p><h1 id="ABP理论学习之功能管理"><a href="#ABP理论学习之功能管理" class="headerlink" title="ABP理论学习之功能管理"></a><a href="https://www.cnblogs.com/farb/p/ABPFeatures.html">ABP理论学习之功能管理</a></h1><hr><h2 id="本篇目录-20"><a href="#本篇目录-20" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPFeatures.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPFeatures.html#funcType">功能类型</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPFeatures.html#defineFunc">定义功能</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPFeatures.html#checkFunc">检查功能</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPFeatures.html#manager">功能管理者</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPFeatures.html#edition">版本说明</a></strong></li></ul><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍###"></a>介绍###</h3><p>大多数的<strong>Saas</strong>(多租户)应用都有不同 <strong>功能</strong>的 <strong>版本</strong>（包）。因此，他们可以给租户（客户）提供不同的 <strong>价格和功能选项</strong>。</p><p>ABP提供了<strong>功能系统</strong>使得这个更简单。我们可以 <strong>定义</strong>功能，然后检查某个功能是否对一个租户 <strong>开启</strong>了，最后将功能系统 <strong>集成</strong>到其他的ABP概念中（如权限和菜单）。</p><blockquote><h4 id="关于IFeatureValueStore"><a href="#关于IFeatureValueStore" class="headerlink" title="关于IFeatureValueStore"></a>关于IFeatureValueStore</h4><p>功能系统使用了<strong>IFeatureValueStore</strong>来获得功能的值。虽然你可以用自己的方式实现该接口，但是它已经完全实现在了 <strong>module-zero</strong>项目中。如果没有实现该接口，那么默认会使用NullFeatureValueStore对所有的功能返回null（此时使用默认的功能值）。</p></blockquote><h3 id="功能类型"><a href="#功能类型" class="headerlink" title="功能类型###"></a>功能类型###</h3><p>有两种基本功能类型。</p><h4 id="布尔功能"><a href="#布尔功能" class="headerlink" title="布尔功能"></a>布尔功能</h4><p>可以是”true”或”false”。这种类型的功能（对于一个版本或者一个租户）可能是<strong>开启的</strong>或者 <strong>关闭的</strong>。</p><h4 id="值功能"><a href="#值功能" class="headerlink" title="值功能"></a>值功能</h4><p>可以是<strong>任意值</strong>。虽然它是以字符串存储和检索的，但是数值也可以轻松地存储为字符串。</p><p>比如，我们的应用程序可能是一个任务管理应用，我们可能在一个月内对于创建任务会有限制。假如说我们有两个不同的版本：一个版本每个月允许创建1000个任务，但是另一个每个月允许创建5000个任务。因此，这个功能应该存储为值，而不是简单的true或false。</p><h3 id="定义功能"><a href="#定义功能" class="headerlink" title="定义功能###"></a>定义功能###</h3><p>在检查功能之前应该先定义功能。一个模块可以通过从<strong>FeatureProvider</strong>类派生来定义自己的功能。这里有一个定义了3个功能的非常简单的功能提供者：</p><pre class=" language-c#"><code class="language-c#">public class AppFeatureProvider : FeatureProvider{    public override void SetFeatures(IFeatureDefinitionContext context)    {        var sampleBooleanFeature = context.Create("SampleBooleanFeature", defaultValue: "false");        sampleBooleanFeature.CreateChildFeature("SampleNumericFeature", defaultValue: "10");        context.Create("SampleSelectionFeature", defaultValue: "B");    }}</code></pre><p>创建功能提供者之后，我们应该在模块的PreInitialize方法中注册，如下所示：</p><pre class=" language-C#"><code class="language-C#">Configuration.Features.Providers.Add<AppFeatureProvider>();</code></pre><h4 id="基本功能属性"><a href="#基本功能属性" class="headerlink" title="基本功能属性"></a>基本功能属性</h4><p>一个功能的定义至少要求两个属性：</p><ul><li><strong>Name：</strong>识别该功能唯一的名字（字符串）。</li><li>**DefaultValue:**默认值。当我们需要该功能的值时会用到该属性，而且对于当前的租户不可用。</li></ul><p>上面的代码样例中，我们定义了一个名为”SampleBooleanFeature”布尔功能，它的默认值是”false”（不可用）。我们也定义了两个值功能（SampleNumericFeature定义为SampleBooleanFeature的孩子）。</p><p>提示：为功能名称创建一个常量字符串，然后在任何地方使用时会防止拼写失误。</p><h4 id="其他功能属性"><a href="#其他功能属性" class="headerlink" title="其他功能属性"></a>其他功能属性</h4><p>虽然对于ABP来说一个唯一的名称和默认值属性已经足够了，但是对于细节的控制还有许多其他的功能属性。</p><ul><li><strong>Scope：</strong>FeatureScope枚举值之一。它可以是<strong>Edition</strong>（如果只为版本级别设置该功能）， <strong>Tenant</strong>（如果只为租户级别设置该功能），或者 <strong>All</strong>(如果为版本和租户都可以设置该功能，这种情况下，租户的设置会覆盖版本的设置)。默认值是All。</li><li>**DisplayName:**给用户显示该功能名称的本地化字符串。</li><li><strong>Description：</strong>给用户显示该功能细节描述的本地化字符串。</li><li>**InputType:**该功能的UI输入类型。</li><li>**Attributes:**任意的自定义键值对字典，可以和该功能关联起来。</li></ul><p>让我们看一下该功能的细节定义：</p><pre class=" language-C#"><code class="language-C#">public class AppFeatureProvider : FeatureProvider{    public override void SetFeatures(IFeatureDefinitionContext context)    {        var sampleBooleanFeature = context.Create(            AppFeatures.SampleBooleanFeature,            defaultValue: "false",            displayName: L("Sample boolean feature"),            inputType: new CheckboxInputType()            );        sampleBooleanFeature.CreateChildFeature(            AppFeatures.SampleNumericFeature,            defaultValue: "10",            displayName: L("Sample numeric feature"),            inputType: new SingleLineStringInputType(new NumericValueValidator(1, 1000000))            );        context.Create(            AppFeatures.SampleSelectionFeature,            defaultValue: "B",            displayName: L("Sample selection feature"),            inputType: new ComboboxInputType(                new StaticLocalizableComboboxItemSource(                    new LocalizableComboboxItem("A", L("Selection A")),                    new LocalizableComboboxItem("B", L("Selection B")),                    new LocalizableComboboxItem("C", L("Selection C"))                    )                )            );    }    private static ILocalizableString L(string name)    {        return new LocalizableString(name, AbpZeroTemplateConsts.LocalizationSourceName);    }}</code></pre><p>注意：ABP没有使用这里的InputType。当为功能创建输入时，应用程序会使用它们。ABP只是提供了这些选项使得它更容易。</p><h4 id="功能层次"><a href="#功能层次" class="headerlink" title="功能层次"></a>功能层次</h4><p>正如样例功能提供者所示，一个功能可以有<strong>子功能</strong>。一个父母功能一般定义为 <strong>布尔</strong>功能。只有父母功能可用时，孩子功能才可用。ABP不强制这样做，但是建议这样做。</p><h3 id="检查功能"><a href="#检查功能" class="headerlink" title="检查功能###"></a>检查功能###</h3><h4 id="使用RequireFeature特性"><a href="#使用RequireFeature特性" class="headerlink" title="使用RequireFeature特性"></a>使用RequireFeature特性</h4><p>我们可以为方法或类使用<strong>RequiredFeature</strong>特性，如下所示：</p><pre class=" language-C#"><code class="language-C#">[RequiresFeature("ExportToExcel")]public async Task<FileDto> GetReportToExcel(...){    ...}</code></pre><p>该方法只有在”ExportToExcel”功能对<strong>当前租户</strong>开启时才会执行（当前租户从IAbpSession中获得）。如果没有开启该功能，那么就会自动抛出 <strong>AbpAuthorizationException</strong>。</p><p>当然，RequiresFeature特性应该用于<strong>布尔类型功能</strong>。否则，你会得到异常。</p><p><strong>RequiresFeature特性注意点</strong><br> ABP对于功能检查使用了强大的动态方法拦截（interception）。因此，为方法使用RequiresFeature特性时有一些限制条件：</p><ul><li>不能用于私有方法。</li><li>不能用于静态方法。</li><li>不能用于非注入类的方法（我们必须使用DI）。</li></ul><p>此外，</p><ul><li>如果该方法是通过一个<strong>接口</strong>（如应用服务通过接口调用）调用的，那么我们可以将它用于任何  <strong>public</strong>的方法。</li><li>如果一个方法直接从类的引用调用（如MVC或Web API控制器），那么它应该是<strong>virtual</strong>的。</li><li>如果一个方法是<strong>protected</strong>，那么该方法应该是 <strong>virtual</strong>。</li></ul><h4 id="使用IFeatureChecker"><a href="#使用IFeatureChecker" class="headerlink" title="使用IFeatureChecker"></a>使用IFeatureChecker</h4><p>我们可以注入并使用IFeatureChecker来手动检查一个功能（对于应用服务，MVC和Web API控制器，它会自动注入而且直接可以使用）。</p><p><strong>IsEnabled</strong></p><p>用于简单地检查给定的功能是否开启。例子：</p><pre class=" language-C#"><code class="language-C#">public async Task<FileDto> GetReportToExcel(...){    if (await FeatureChecker.IsEnabledAsync("ExportToExcel"))    {        throw new AbpAuthorizationException("You don't have this feature: ExportToExcel");    }        ...}</code></pre><p>IsEnabledAsync和其他方法都有同步版本。</p><p>当然，IsEnabled方法应该用于<strong>布尔类型功能</strong>。否则可能会抛异常。</p><p>如果你只想检查一个功能，然后抛出例子中的异常，那么你只需要使用<strong>CheckEnabled</strong>方法就行了。</p><p><strong>GetValue</strong></p><p>用于获得值类型功能的当前值，例子：</p><pre class=" language-C#"><code class="language-C#">var createdTaskCountInThisMonth = GetCreatedTaskCountInThisMonth();if (createdTaskCountInThisMonth >= FeatureChecker.GetValue("MaxTaskCreationLimitPerMonth").To<int>()){    throw new AbpAuthorizationException("You exceed task creation limit for this month, sorry :(");}</code></pre><p>FeatureChecker方法也有对于特定租户的重载，不仅仅只对于当前的租户。</p><h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><p>在客户端，我们使用<strong>abp.features</strong>命名空间来获得该功能的当前值。</p><p><strong>isEnabled</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> isEnabled <span class="token operator">=</span> abp<span class="token punctuation">.</span>features<span class="token punctuation">.</span><span class="token function">isEnabled</span><span class="token punctuation">(</span><span class="token string">'SampleBooleanFeature'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>getValue</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> value <span class="token operator">=</span> abp<span class="token punctuation">.</span>features<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token string">'SampleNumericFeature'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="功能管理者"><a href="#功能管理者" class="headerlink" title="功能管理者###"></a>功能管理者###</h3><p>如果需要定义功能，可以注入并使用<strong>IFeatureManager</strong>。</p><h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明###"></a>版本说明###</h3><p>ABP没有内置的版本系统，因为这么个系统要求数据库（存储版本，版本功能，租户-版本映射等等）。因此，版本系统实现在了module-zero中了。使用它你可以轻松地拥有一个版本系统，要不然你可以自己实现。</p><h1 id="ABP理论学习之审计日志"><a href="#ABP理论学习之审计日志" class="headerlink" title="ABP理论学习之审计日志"></a><a href="https://www.cnblogs.com/farb/p/ABPAuditLog.html">ABP理论学习之审计日志</a></h1><hr><h2 id="本篇目录-21"><a href="#本篇目录-21" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#config">配置</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#attribute">通过特性开启/关闭</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#notes">注意</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#sample">我项目中的例子</a></strong></li></ul><hr><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>维基百科说： “审计跟踪（也叫审计日志）是与安全相关的按照时间顺序的记录，记录集或者记录源，它们提供了活动序列的文档证据，这些活动序列可以在任何时间影响一个特定的操作，步骤或其他”。</p></blockquote><p>ABP提供了一个基础设施，它可以自动记录所有和应用程序交互的日志。它可以记录具有调用者信息和参数的方法调用。</p><p>一般地，要保存的字段是：相关的<strong>租户Id</strong>，调用者的<strong>用户Id</strong>，调用的 <strong>服务名称</strong>（调用方法的类名），调用的<strong>方法名</strong> ， 执行<strong>方法名</strong>（序列化成Json） ， <strong>执行时间</strong> ， 执行<strong>时长</strong>（单位毫秒），客户端<strong>IP地址</strong> ，客户端<strong>计算机名称</strong>和<strong>异常</strong>（抛出异常的情况下）。</p><p>有了这些信息，我们不仅知道谁进行了该操作，而且可以测量应用的<strong>性能</strong>以及观察抛出的异常。甚至，你可以获得应用使用情况的<strong>统计数据（statistics）</strong>。</p><p>审计系统使用**<a href="http://www.cnblogs.com/farb/p/ABPSession.html">IAbpSession</a>**来获得当前的UserId和TenantId。</p><blockquote><h4 id="关于-IAuditingStore"><a href="#关于-IAuditingStore" class="headerlink" title="关于 IAuditingStore"></a>关于 IAuditingStore</h4><p>审计系统使用了IAuditingStore来存储信息。虽然你可以用你自己的方式来实现该接口，但是它已经完全实现在<strong>module-zero</strong>项目中。如果你没有实现该接口，那么默认会使用SimpleLogAuditingStore，并且它会将审计信息记录到日志中（log）。</p></blockquote><h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p>要配置审计，可以在模块的PreInitialize方法中使用<strong>Configuration.Auditing</strong>属性。审计是<strong>默认开启的</strong>。可以像下面那样关闭它：</p><pre class=" language-C#"><code class="language-C#">public class MyModule : AbpModule{    public override void PreInitialize()    {        Configuration.Auditing.IsEnabled = false;    }    //...}</code></pre><p>这儿是审计配置属性的列表：</p><ul><li><p><strong>IsEnabled</strong>:用于完全开启或关闭审计系统。默认为true。</p></li><li><p><strong>IsEnabledForAnonymousUsers</strong>:如果此值为true,那么没有登录到系统的用户的审计日志也会保存。默认为false。</p></li><li><p>MvcControllers</p><p>:用于为ASP.NET MVC控制器配置审计。</p><ul><li><strong>IsEnabled</strong>:用于为MVC控制器开启或关闭审计。默认为true</li><li><strong>IsEnabledForChildActions</strong>:用于为子MVC action开启或关闭审计。默认为false。</li></ul></li><li><p><strong>Selectors</strong>:用于选择其他的类保存审计日志。</p></li></ul><p>可以看到，对于MVC控制器的审计是单独配置的，因为它用到了不同的技术。</p><p><strong>Selectors</strong>是选择其他的类型来保存审计日志的谓词列表。一个选择器有一个唯一的名字和一个谓词。这个列表中唯一的默认选择器用于选择<strong>应用服务类</strong>。它是如下定义的：</p><pre class=" language-C#"><code class="language-C#">Configuration.Auditing.Selectors.Add(    new NamedTypeSelector(        "Abp.ApplicationServices",        type => typeof (IApplicationService).IsAssignableFrom(type)    ));</code></pre><p>你可以将你的选择器添加到模块的PreInitialize方法中。而且，如果你不喜欢为应用服务保存审计日志，那么你可以通过名称移除选择器。那就是为什么要有一个唯一名称的原因（使用简单的linq找出该选择器，然后可以移除它）。</p><h3 id="通过特性开启-关闭"><a href="#通过特性开启-关闭" class="headerlink" title="通过特性开启/关闭"></a>通过特性开启/关闭</h3><p>虽然可以通过配置选择审计类，但是也可以为一个单独的类或方法使用<strong>Audited</strong>和 <strong>DisableAuditing</strong>特性。举个例子：</p><pre class=" language-C#"><code class="language-C#">[Audited]public class MyClass{    public void MyMethod1(int a)    {        //...    }    [DisableAuditing]    public void MyMethod2(string b)    {        //...    }    public void MyMethod3(int a, int b)    {        //...    }}</code></pre><p>除了MyMethod2方法之外，MyClass的所有方法都参与审计了，因为MyMethod2显式关闭了。审计特性可以用于想要参与审计的方法保存审计日志。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>为了保存审计日志，方法必须是<strong>public</strong>的。私有的和受保护的方法会被忽略。</li><li>如果方法是通过类的引用调用的，那么该方法必须是<strong>virtual</strong>的。因为ABP使用了动态代理和拦截，所以需要满足该条件。如果使用了接口（比如注入IPersonService接口使用PersonService类）注入，就不必满足“virtual”的条件了。对于MVC控制器的action不一定要满足，它们可以不是“virtual”的。</li></ul><h3 id="我项目中的例子"><a href="#我项目中的例子" class="headerlink" title="我项目中的例子"></a>我项目中的例子</h3><p>下面的代码是点击登录按钮提交表单数据的action方法：</p><pre class=" language-C#"><code class="language-C#">[HttpPost][UnitOfWork][DisableAuditing]public virtual async Task<JsonResult> Login(LoginViewModel loginModel, string returnUrl = ""){    CheckModelState();    _unitOfWorkManager.Current.DisableFilter(AbpDataFilters.MayHaveTenant);    var loginResult = await GetLoginResultAsync(        loginModel.UsernameOrEmailAddress,        loginModel.Password,        loginModel.TenancyName        );    await SignInAsync(loginResult.User, loginResult.Identity, loginModel.RememberMe);    if (string.IsNullOrWhiteSpace(returnUrl))    {        returnUrl = Request.ApplicationPath;    }    return Json(new MvcAjaxResponse { TargetUrl = returnUrl });}</code></pre><p>下面的截图是数据库中的审计日志信息，大家可以看到今天还没有数据，最晚的数据是2015-12-18的数据：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151221133123781-741090354.png" alt="img"></p><p>登录系统之后，依然没有记录审计日志，下面统一截图。</p><p>下面我将上面的代码的特性**[DisableAuditing]**去掉，再次登录系统，可以看到有了审计记录，截图如下：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151221133942234-1080323149.png" alt="img"></p><p>分别按序号解释一下：</p><ol><li>首次到达登录页面；</li><li>登录成功，到达系统首页Index;</li><li>去掉**[DisableAuditing]**特性后，到达登陆页面；</li><li>将数据post提交到Login方法，记录了审计日志，包含各种登录参数；</li><li>登录成功，返回系统首页Index。</li></ol><p>从我的例子可以很明显地看出，默认情况下，ABP会自动记录所有的控制器，除非你给它加上**[DisableAuditing]**特性，否则，始终会记录审计日志。</p><h1 id="分布式服务层"><a href="#分布式服务层" class="headerlink" title="分布式服务层"></a>分布式服务层</h1><hr><h2 id="本篇目录-22"><a href="#本篇目录-22" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#intro">介绍</a></strong></li><li><a href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#base">AbpApiController基类</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#localization">本地化</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#auditLogging">审计日志</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#authorization">授权</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#uow">工作单元</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#others">其他</a></strong></li></ul></li></ul><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍###"></a>介绍###</h3><p>ABP通过<strong>Abp.Web.Api</strong>Nuget包集成了 <strong>ASP.NET Web API</strong>控制器。你可以像以往创建Asp.Net Web API控制器那样创建Web API控制器。依赖注入对于有规律的ApiController（其实就是继承自AbpApiController的控制器）是有效的。</p><p>但是你应该从<strong>AbpApiController</strong>派生控制器，它提供了许多有用的东西，并且更好地集成到了ABP中。</p><h3 id="AbpApiController基类"><a href="#AbpApiController基类" class="headerlink" title="AbpApiController基类###"></a>AbpApiController基类###</h3><p>下面是一个派生于AbpApiController的简单api控制器：</p><pre class=" language-C#"><code class="language-C#">public class UsersController : AbpApiController{        }</code></pre><h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>AbpApiController定义了<strong>L</strong>方法使得本地化更为简单。例子：</p><pre class=" language-C#"><code class="language-C#">public class UsersController : AbpApiController{    public UsersController()    {        LocalizationSourceName = "MySourceName";    }    public UserDto Get(long id)    {        var helloWorldText = L("HelloWorld");        //...    }}</code></pre><p>要使L方法生效，必须设置<strong>LocalizationSourceName</strong>。你可以在自己的api控制器基类中设置而不用在每个api控制器中都重复设置。</p><h4 id="审计日志"><a href="#审计日志" class="headerlink" title="审计日志"></a>审计日志</h4><p>审计日志不会为api控制器自动记录。如果你要为api控制器记录日志的话，应该在控制器或者它的action方法上声明<strong>Audited</strong>特性。请查看**<a href="http://www.cnblogs.com/farb/p/ABPAuditLog.html">审计日志</a>**获取更多信息。</p><h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>你可以为api控制器或者action方法使用<strong>AbpApiAuthorize</strong>特性来阻止未授权的用户使用控制器和action方法。例子：</p><pre class=" language-C#"><code class="language-C#">public class UsersController : AbpApiController{    [AbpApiAuthorize("MyPermissionName")]    public UserDto Get(long id)    {        //...    }}</code></pre><p>AbpApiController也定义了检查权限的<strong>IsGranted方法</strong>作为快捷方式。请查看**<a href="http://www.cnblogs.com/farb/p/ABPAuthorization.html">授权</a>**一节获取更多信息。</p><h4 id="工作单元-2"><a href="#工作单元-2" class="headerlink" title="工作单元"></a>工作单元</h4><p>Web API的action方法默认不是工作单元。例如，如果你需要在action方法中打开数据库连接，就需要像下面那样声明<strong>UnitOfWork</strong>特性：</p><pre class=" language-C#"><code class="language-C#">public class UsersController : AbpApiController{    private readonly IRepository<User, long> _userRepository;    public UsersController(IRepository<User, long> userRepository)    {        _userRepository = userRepository;    }    [UnitOfWork]    public virtual List<UserDto> Users(string filter)    {        var users = _userRepository            .GetAll()            .Where(u => u.UserName.StartsWith(filter))            .ToList();        //...    }}</code></pre><p>这里我们声明了<strong>UnitOfWork</strong>特性。因为仓储的 <strong>GetAll()**方法返回了 **IQueryable</strong>，而当它使用 <strong>ToList()**方法（由于IQueryable的延迟执行）时需要一个打开的数据库连接，所以这里需要声明该特性。注意该action方法应该声明为</strong>virtual**（否则拦截无法工作）。</p><p>请查看**<a href="http://www.cnblogs.com/farb/p/ABPUnitofWork.html">工作单元</a>**获取更多。</p><h4 id="其他-4"><a href="#其他-4" class="headerlink" title="其他"></a>其他</h4><p>你还可以使用预注入的 <strong><a href="http://www.cnblogs.com/farb/p/ABPSession.html">AbpSession</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ABPEventBus.html">EventBus</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ModuleZeroPermissonManagement.html">PermissionManager</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ModuleZeroPermissonManagement.html">PermissionChecker</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ABPSettingManagement.html#getSetting">SettingManager</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ABPFeatures.html#manager">FeatureManager</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ABPFeatures.html#checkFunc">FeatureChecker</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ABPLocalization.html#text">LocalizationManager</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ABPLogging.html">Logger</a></strong>, **<a href="http://www.cnblogs.com/farb/p/ABPUnitofWork.html#uow">CurrentUnitOfWork</a>**等基属性以及更多。</p><h1 id="动态Web-API层"><a href="#动态Web-API层" class="headerlink" title="动态Web API层"></a><a href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html">动态Web API层</a></h1><h2 id="本篇目录-23"><a href="#本篇目录-23" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><a href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#build">构建动态Web API控制器</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#ForAll">ForAll 方法</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#OverrideForAll">重写ForAll 方法</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#httpVerbs">Http动词</a></strong></li></ul></li><li><a href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#proxy">动态Javascript代理</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#ajax">Ajax参数</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#single">单一服务脚本</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#angular">Angular支持</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#Durandal">Durandal支持</a></strong></li><li>**<a href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#wrap">返回结果封装</a>**【2016/3/28 更新】</li></ul></li><li><a href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#paramBinding">关于参数绑定</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#FromUri">FromUri和FromBody特性</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#DTOs">DTOs vs 原始类型</a></strong></li></ul></li></ul><h3 id="构建动态Web-API控制器"><a href="#构建动态Web-API控制器" class="headerlink" title="构建动态Web API控制器"></a>构建动态Web API控制器</h3><p>ABP可以自动地为应用层生成<strong>Web API 层</strong>。比如说我们有一个应用层如下所示：</p><pre class=" language-C#"><code class="language-C#">public interface ITaskAppService : IApplicationService{    GetTasksOutput GetTasks(GetTasksInput input);    void UpdateTask(UpdateTaskInput input);    void CreateTask(CreateTaskInput input);}</code></pre><p>我们想把这个服务作为Web API控制器暴露给客户端。ABP只需要一行配置就可以为该应用服务创建一个Web API控制器：</p><pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder.For<ITaskAppService>("tasksystem/task").Build();</code></pre><p>OK了！在地址为**’/api/services/tasksystem/task’**的地方就创建了一个API控制器，现在客户端可以使用该应用服务的所有方法。这个配置应该在模块的Initlize方法中完成。</p><p>我们使用一个API控制器封装的<strong>ITaskAppService</strong>是一个应用服务。使用API控制器对应用服务进行封装不是强制的，但是这是传统推荐的方式。 <strong>“tasksystem/task”**一个具有随机命名空间的API控制器的名字。你应该至少定义一级的命名空间，但是你也可以定义更深层次的命名空间，比如 <em>“myCompany/myApplication/myNamespace1/myNamespace2/myServiceName”*。 *</em>‘/api/services’**是所有动态生成的Web API控制器的前缀。因此，该API控制器的地址将会是这个样子的 <em>‘/api/services/tasksystem/task’*，而GetTasks方法的地址将会是 *’/api/services/tasksystem/task/getTasks’*。因为在javascript中惯例遵循 *</em>camelCase</strong>规则，所以方法名都转成了camelCase格式。</p><h4 id="ForAll-方法"><a href="#ForAll-方法" class="headerlink" title="ForAll 方法"></a>ForAll 方法</h4><p>在应用服务层可能会有很多的应用服务，如果要为这些应用服务都构建API控制器的话，一个一个地构建简直是费时费力的事情。没关系，ABP中的DynamicApiControllerBuilder提供了一个为所有应用服务构建Web API控制器的方法，这样我们只需要调用一次就行了。例如：</p><pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder    .ForAll<IApplicationService>(Assembly.GetAssembly(typeof(SimpleTaskSystemApplicationModule)), "tasksystem")    .Build();</code></pre><p>ForAll方法是接收接口类型的泛型方法。第一个参数是一个程序集，该程序集中含有派生自给定接口的类。最后一个参数是服务前缀的命名空间。比如说我们在给定的程序集中有ITaskAppService和IPersonAppService，对于这个配置的话，服务地址将会是 ‘/api/services/tasksystem/task’ 和  ‘/api/services/tasksystem/person’。计算服务名称的方法是：移除Service或者AppService后缀，以及I前缀（对于接口来说）。此外，服务名称会转成camel  Case(驼峰命名)的格式。如果你不喜欢这种转换，那么使用’WithServiceName’来决定服务发名称。此外，还有一个过滤服务的Where方法。除了个别应用服务之外，这个方法在你为其他所有的应用服务构建API控制器时很有用。</p><h4 id="重写ForAll-方法"><a href="#重写ForAll-方法" class="headerlink" title="重写ForAll 方法"></a>重写ForAll 方法</h4><p>在ForAll方法之后我们可以重写配置。例如：</p><pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder    .ForAll<IApplicationService>(Assembly.GetAssembly(typeof(SimpleTaskSystemApplicationModule)), "tasksystem")    .Build();DynamicApiControllerBuilder    .For<ITaskAppService>("tasksystem/task")    .ForMethod("CreateTask").DontCreateAction()    .Build();</code></pre><p>在上面的代码中，我们为一个程序集中所有的应用服务构建了动态的Web API控制器。然后又为一个应用服务（ITaskAppService）重写了配置，目的是忽略该应用服务中的CreateTask方法。</p><h4 id="Http动词"><a href="#Http动词" class="headerlink" title="Http动词"></a>Http动词</h4><p>默认情况下，创建的方法都只能<strong>POST</strong>请求。我们也可以使用不同的方法来改变这种行为。<br> <strong>WithVerb方法</strong></p><p>我们可以为一个方法使用WithVerb，像下面那样：</p><pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder    .For<ITaskAppService>("tasksystem/task")    .ForMethod("GetTasks").WithVerb(HttpVerb.Get)    .Build();</code></pre><p><strong>HTTP特性</strong></p><p>我们可以在应用服务的接口的方法上添加HttpGet，HttpPost等特性。</p><pre class=" language-C#"><code class="language-C#">public interface ITaskAppService : IApplicationService{    [HttpGet]    GetTasksOutput GetTasks(GetTasksInput input);    [HttpPut]    void UpdateTask(UpdateTaskInput input);    [HttpPost]    void CreateTask(CreateTaskInput input);}</code></pre><p>使用这些特性之前，应该在项目中添加**<a href="https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Core">Microsoft.AspNet.WebApi.Core</a>**Nuget包的引用。</p><p><strong>命名规范</strong></p><p>不用为每个方法都声明HTTP动词，你可以使用如下所示的<strong>WithConventionalVerbs</strong>方法：</p><pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder    .ForAll<IApplicationService>(Assembly.GetAssembly(typeof(SimpleTaskSystemApplicationModule)), "tasksystem")    .WithConventionalVerbs()    .Build();</code></pre><p>在这种情况下，Http动词会由方法名的前缀决定：</p><ul><li><strong>Get</strong>：方法名以Get开头。</li><li><strong>Put</strong>：方法名以Put或Update开头。</li><li><strong>Delete</strong>：方法名以Delete或Remove开头。</li><li><strong>Post</strong>：方法名以Post或Create开头。</li><li>其他情况，Post是HTTP动词的默认值</li></ul><p>我们可以通过对特定的方法使用WithVerb方法或者HTTP特性来覆盖上述惯例。</p><h3 id="动态Javascript代理"><a href="#动态Javascript代理" class="headerlink" title="动态Javascript代理"></a>动态Javascript代理</h3><p>在Javascript中，可以经由Ajax使用动态创建的web api控制器。ABP通过为动态的web  api控制器创建动态的Javascript代理简化了这个。因此，可以在Javascript中像调用一个function一样来调用一个动态的web api 控制器action：</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>services<span class="token punctuation">.</span>tasksystem<span class="token punctuation">.</span>task<span class="token punctuation">.</span><span class="token function">getTasks</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    state<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//use result.tasks here...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Javascript代理是动态创建的。使用之前应该将下面动态的脚本包括在页面上。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/api/AbpServiceProxies/GetAll<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>服务方法返回了promise（查看**<a href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</a>**）。可以在返回的promise后面继续注册done，fail，then等回调函数。服务方法内部使用了abp.ajax。如果需要的话，它们会处理错误并显示错误信息。</p><h4 id="Ajax参数"><a href="#Ajax参数" class="headerlink" title="Ajax参数"></a>Ajax参数</h4><p>你可以把一个自定义的ajax参数作为第二个参数传给代理方法。</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>services<span class="token punctuation">.</span>tasksystem<span class="token punctuation">.</span>task<span class="token punctuation">.</span><span class="token function">createTask</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    assignedPersonId<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>    description<span class="token punctuation">:</span> <span class="token string">'a new task description...'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//override jQuery's ajax parameters</span>    <span class="token keyword">async</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    timeout<span class="token punctuation">:</span> <span class="token number">30000</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">'successfully created a task!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>**<a href="http://api.jquery.com/jQuery.ajax/">jQuery.ajax</a>**的所有参数在这里都是有效的。</p><h4 id="单一服务脚本"><a href="#单一服务脚本" class="headerlink" title="单一服务脚本"></a>单一服务脚本</h4><p>‘/api/AbpServiceProxies/GetAll’会在一个文件中生成所有的服务代理。使用’/api/AbpServiceProxies/Get?name=serviceName’也可以生成一个单独的服务代理，只需要在页面中包括下面的代码：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/api/AbpServiceProxies/Get?name<span class="token punctuation">=</span>tasksystem/task<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h4 id="Angular支持"><a href="#Angular支持" class="headerlink" title="Angular支持"></a>Angular支持</h4><p>ABP可以将动态的API控制器暴露给AngularJs服务。思考下面的例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    angular<span class="token punctuation">.</span><span class="token function">module</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">controller</span><span class="token punctuation">(</span><span class="token string">'TaskListController'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>        <span class="token string">'$scope'</span><span class="token punctuation">,</span> <span class="token string">'abp.services.tasksystem.task'</span><span class="token punctuation">,</span>        <span class="token keyword">function</span><span class="token punctuation">(</span>$scope<span class="token punctuation">,</span> taskService<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>            vm<span class="token punctuation">.</span>tasks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            taskService<span class="token punctuation">.</span><span class="token function">getTasks</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                state<span class="token punctuation">:</span> <span class="token number">0</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>                vm<span class="token punctuation">.</span>tasks <span class="token operator">=</span> result<span class="token punctuation">.</span>tasks<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们可以使用服务的名字（包含命名空间）注射一个服务。然后，可以作为正常的Javascript函数调用它的function。注意，我们注册到了success句柄上（而不是done），因为它就像在angular的$http服务中。ABP使用AngularJs的$http服务。如果</p><p>你想要传递$http配置，可以作为服务方法的最后一个参数传递一个配置对象。</p><p>要使用自动生成的服务，应该在页面中包含需要的脚本：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>~/Abp/Framework/scripts/libs/angularjs/abp.ng.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>~/api/AbpServiceProxies/GetAll?type<span class="token punctuation">=</span>angular<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h4 id="Durandal支持"><a href="#Durandal支持" class="headerlink" title="Durandal支持"></a>Durandal支持</h4><p>ABP可以在一个**<a href="http://durandaljs.com/">Durandal</a>**应用的模块中注入服务代理。看下面的viewmodel:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'service!tasksystem/task'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token keyword">function</span> <span class="token punctuation">(</span>taskService<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//taskService can be used here</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>ABP配置Durandal(实际上是Require.js)来理解这个’service!’前缀，然后注入合适的javascript服务代理。</p><h4 id="返回结果封装"><a href="#返回结果封装" class="headerlink" title="返回结果封装"></a>返回结果封装</h4><p>ABP通过 <strong>AjaxResponse</strong>封装了动态Web  API的action的返回值。查看《**<a href="http://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#Ajax">Ajax文档</a>**》获取更多关于封装的信息。你可以为每个应用服务或者每个方法开启或者禁用封装。看下面这个应用服务的例子：</p><pre class=" language-C#"><code class="language-C#">public interface ITestAppService : IApplicationService{    [DontWrapResult]    DoItOutput DoIt(DoItInput input);}</code></pre><p>这里我们为DoIt方法禁用了封装。这个特性应该为接口声明而不是实现类。</p><p>如果你想更好地控制客户端的返回值，那么不封装返回的结果可能是很有用的。特别地，当使用不能和ABP标准的AjaxResponse协作的<strong>第三方客户端库</strong>时，可能需要禁用封装。这种情况下，你要自己处理异常。</p><p>注意：动态javascript代理可以理解返回的结果是否封装和运行正常。</p><h3 id="关于参数绑定"><a href="#关于参数绑定" class="headerlink" title="关于参数绑定"></a>关于参数绑定</h3><p>ABP在运行时创建了API控制器。因此，ASP.NET Web API的**<a href="http://www.asp.net/web-api/overview/formats-and-model-binding/parameter-binding-in-aspnet-web-api">模型和参数绑定</a>**可以用于绑定模型和参数。</p><h4 id="FromUri和FromBody特性"><a href="#FromUri和FromBody特性" class="headerlink" title="FromUri和FromBody特性"></a>FromUri和FromBody特性</h4><p>为了在绑定时进行高级控制，可以在服务接口上使用FromUri和FromBody特性。</p><h4 id="DTOs-vs原始类型"><a href="#DTOs-vs原始类型" class="headerlink" title="DTOs vs原始类型"></a>DTOs vs原始类型</h4><p>我们强烈建议为应用服务和Web  API控制器的方法使用DTO作为参数类型，但是你也可以使用原始类型（如string，int，bool或者可空的类型如int?，bool?）作为参数类型。虽然可以在应用服务中使用不止一个参数，但是最好用一个复杂的类型将多个参数整合起来，否则客户端就不会生成动态代理服务。在日志记录中就会看到如下图所示的错误：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160107164212918-348748482.png" alt="img"></p><h2 id="ABP理论学习之OData集成-新增"><a href="#ABP理论学习之OData集成-新增" class="headerlink" title="ABP理论学习之OData集成(新增)"></a><a href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html">ABP理论学习之OData集成(新增)</a></h2><hr><h2 id="本篇目录-24"><a href="#本篇目录-24" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#setup">安装</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#controller">创建控制器</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#example">例子</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#sample">样例项目</a></strong></li></ul><h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍###"></a>介绍###</h3><blockquote><p><strong>OData</strong>在**<a href="http://www.odata.org/">其官网</a><strong>的定义是：<br> 允许以一种 **简单且标准</strong>的方式创建和使用<strong>可查询的、可互操作的</strong>RESTful APIs。</p></blockquote><p>在ABP中也可以使用OData。**<a href="https://www.nuget.org/packages/Abp.Web.Api.OData">Abp.Web.Api.OData</a>** nuget包简化了它的使用。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装###"></a>安装###</h3><h4 id="安装Nuget包"><a href="#安装Nuget包" class="headerlink" title="安装Nuget包"></a>安装Nuget包</h4><p>我们应该首先将Abp.Web.Api.OData nuget包安装到WebApi项目中：<br> <code>Install-Package Abp.Web.Api.OData</code></p><h4 id="设置模块依赖"><a href="#设置模块依赖" class="headerlink" title="设置模块依赖"></a>设置模块依赖</h4><p>给我们的WebApi项目设置的模块设置AbpWebApiODataModule的依赖。例如：</p><pre class=" language-C#"><code class="language-C#">[DependsOn(typeof(AbpWebApiODataModule))]public class MyProjectWebApiModule : AbpModule{    ...}</code></pre><p>请查看**<a href="http://www.cnblogs.com/farb/p/ABPModuleSystem.html">模块系统</a>**来理解模块依赖。</p><h4 id="配置实体类"><a href="#配置实体类" class="headerlink" title="配置实体类"></a>配置实体类</h4><p>OData要求声明那些可以用作OData资源的实体。我们应该在WebApi项目模块的PreInitialize方法中处理这件事，如下所示：</p><pre class=" language-C#"><code class="language-C#">[DependsOn(typeof(AbpWebApiODataModule))]public class MyProjectWebApiModule : AbpModule{    public override void PreInitialize()    {        var builder = Configuration.Modules.AbpWebApiOData().ODataModelBuilder;        //Configure your entities here...        builder.EntitySet<Person>("People");    }    ...}</code></pre><p>这里，我们得到了ODataModelBuilder的引用并设置了Person实体。类似地，你可以使用EntitySet来添加其他的实体。这里格外需要注意的是，括号里面的字符串People是指的控制器的前缀，这里我的控制器是PeopleController，当然你也可以设置为Persons等，我这里只是想说明要填的字符串更数据库的表名和自己定义的实体名没有关系。</p><p>查看**<a href="http://www.cnblogs.com/farb/p/ODataAspNetWebAPI.html">使用ASP.NET Web API 2创建OData v4 终结点</a>**获取更多关于builder的信息。</p><h3 id="创建控制器"><a href="#创建控制器" class="headerlink" title="创建控制器###"></a>创建控制器###</h3><p>Abp.Web.Api.OData nuget包 包括了<strong>AbpODataEntityController</strong>基类（它扩展了标准的ODataController），这样就可以更容易地创建控制器了。下面是一个为Person实体创建一个OData终端（endpoint）的例子：</p><pre class=" language-C#"><code class="language-C#">public class PersonsController : AbpODataEntityController<Person>{    public PersonsController(IRepository<Person> repository)        : base(repository)    {    }}</code></pre><p>就是这么简单，AbpODataEntityController的所有方法都是<strong>virtual</strong>声明的。这意味着你可以重写 ** Get, Post, Put, Patch, Delete**和其他的action方法以及添加自己的逻辑。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子###"></a>例子###</h3><p>下面看一个例子：<br> 我的应用的端口是：localhost:61759。这里我只演示一些基本的东西，因为OData是一个标准的协议，所以你可以在网上轻松地找到更高级的例子。</p><p>数据库中People表的数据如下图：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160121153817328-1398128883.png" alt="img"></p><h4 id="获取实体列表"><a href="#获取实体列表" class="headerlink" title="获取实体列表"></a>获取实体列表</h4><p>这里我来获取所有的Person:</p><p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122174713984-423656261.png" alt="img"></p><h4 id="获取单个实体"><a href="#获取单个实体" class="headerlink" title="获取单个实体"></a>获取单个实体</h4><p>获取Id=2的那个Person的数据：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122174940953-254380383.png" alt="img"></p><h4 id="获取具有导航属性的单个实体"><a href="#获取具有导航属性的单个实体" class="headerlink" title="获取具有导航属性的单个实体"></a>获取具有导航属性的单个实体</h4><p>修改实体类的定义，重新定义如下：</p><p>Person实体的定义：</p><pre class=" language-C#"><code class="language-C#">namespace ABPMVCTest.Entities{    [Table("Persons")]    public class Person:Entity    {        public virtual string Name { get; set; }        public virtual bool Gender { get; set; }        public virtual string UserName { get; set; }        public virtual ICollection<Car> Cars { get; set; }        public Person()        {        }        public Person(string name, params Car[] cars)        {            Name = name;            if (cars!=null)            {                Cars=new Collection<Car>();                foreach (var car in cars)                {                    car.Person = this;                    Cars.Add(car);                }            }        }    }}</code></pre><p>Car实体的定义：</p><pre class=" language-C#"><code class="language-C#">namespace ABPMVCTest.Entities{    [Table("Cars")]    public class Car:Entity    {        public virtual Person Person{ get; set; }        public virtual int PersonId { get; set; }        public virtual CarBrand Brand { get; set; }        public virtual int Price{ get; set; }        public Car()        {        }        public Car(CarBrand brand, int price)        {            Brand = brand;            Price = price;        }    }}</code></pre><p>CarBrand（汽车品牌）实体的定义：</p><pre class=" language-C#"><code class="language-C#">namespace ABPMVCTest.Entities{    public enum CarBrand    {        Jeep,        Buick,        Lincoln,        Kia,        LandRover    }}</code></pre><p>修改实体类之后，接下来给数据库填充数据。新增了3个人，Id分别是7，6，9；在Car表中分别给这三个人分配了汽车，如下图：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122183825828-1873120117.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122183922390-1076933148.png" alt="img"></p><p>比如获取小明（Id=7）的数据，它具有一个Car导航属性，该属性代表此人的汽车对象：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122183715906-1511156500.png" alt="img"></p><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><p>下面将数据库的数据进行修改，如下图：<br> Persons表的数据：<br> <img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123182609422-9276329.png" alt="img"></p><p>Cars表的数据：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123180543562-2039656379.png" alt="img"></p><p>这里演示一个更高级的查询，包括过滤，排序和获取前2个结果，借助postman来演示：<br> 查询条件是：Id&lt;4，OrderBy UserName Desc，取前两条数据</p><p><strong>请求</strong><br> <code>http://localhost:61759/odata/People?$filter=Id lt 4&amp;$orderby=UserName&amp;$top=2</code></p><p><strong>响应</strong></p><p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123183405843-395742129.png" alt="img"></p><p>可以看到，只过滤出来了小红和小刚的数据。</p><p>OData支持分页，排序，过滤，投影以及更多。<br> 请查看**<a href="http://www.odata.org/">官方文档</a>**获取更多信息。</p><h4 id="创建一个新实体"><a href="#创建一个新实体" class="headerlink" title="创建一个新实体"></a>创建一个新实体</h4><p>在这个例子中，我们将创建一个新的Person，借助postman，很容易发送一个post请求。</p><p><strong>请求</strong><br> 注意这里的报文头为Content-Type:”application/json”<br> <img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123185400562-1792073851.png" alt="img"></p><p><strong>响应</strong><br> <img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123185407437-1943751319.png" alt="img"></p><p>去数据库查看一下，发现已经多了一条刚才post的数据：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123185642172-1269839742.png" alt="img"></p><p>当然了，我们也可以更新和删除实体，这里就不再做演示了，大家自行练习。</p><h4 id="获取元数据【MetaData】"><a href="#获取元数据【MetaData】" class="headerlink" title="获取元数据【MetaData】"></a>获取元数据【MetaData】</h4><p>我们还可以获得实体的元数据，如下所示：</p><p><strong>请求</strong></p><pre><code>http://localhost:61759/odata/$metadata</code></pre><p><strong>响应</strong></p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">edmx:</span>Edmx</span> <span class="token attr-name">Version</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>edmx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://docs.oasis-open.org/odata/ns/edmx<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">edmx:</span>DataServices</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Schema</span> <span class="token attr-name">Namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ABPMVCTest.Entities<span class="token punctuation">"</span></span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://docs.oasis-open.org/odata/ns/edm<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EntityType</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Key</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PropertyRef</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Key</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.String<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Gender<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Boolean<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UserName<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.String<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Int32<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>NavigationProperty</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Cars<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Collection(ABPMVCTest.Entities.Car)<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EntityType</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EntityType</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Car<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Key</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PropertyRef</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Key</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>PersonId<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Int32<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Brand<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ABPMVCTest.Entities.CarBrand<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Price<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Int32<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Int32<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>NavigationProperty</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Person<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ABPMVCTest.Entities.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ReferentialConstraint</span> <span class="token attr-name">Property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>PersonId<span class="token punctuation">"</span></span> <span class="token attr-name">ReferencedProperty</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>NavigationProperty</span><span class="token punctuation">></span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EntityType</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EnumType</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CarBrand<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Jeep<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Buick<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Lincoln<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Kia<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>LandRover<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EnumType</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Schema</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Schema</span> <span class="token attr-name">Namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Default<span class="token punctuation">"</span></span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://docs.oasis-open.org/odata/ns/edm<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EntityContainer</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EntitySet</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>People<span class="token punctuation">"</span></span> <span class="token attr-name">EntityType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ABPMVCTest.Entities.Person<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EntityContainer</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Schema</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">edmx:</span>DataServices</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">edmx:</span>Edmx</span><span class="token punctuation">></span></span></code></pre><h3 id="样例项目"><a href="#样例项目" class="headerlink" title="样例项目###"></a>样例项目###</h3><p>你可以在Github上获得样例代码，**<a href="https://github.com/aspnetboilerplate/sample-odata">点击查看</a>**</p><h1 id="展现层"><a href="#展现层" class="headerlink" title="展现层"></a>展现层</h1><hr><h2 id="本篇目录-25"><a href="#本篇目录-25" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPMVCController.html#intro">介绍</a></strong></li><li><a href="https://www.cnblogs.com/farb/p/ABPMVCController.html#base">AbpController基类</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPMVCController.html#localization">本地化</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPMVCController.html#exceptionHandling">异常处理</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPMVCController.html#wrapping">响应结果的包装</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPMVCController.html#auditLogging">审计日志</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPMVCController.html#authorization">授权</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPMVCController.html#uow">工作单元</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPMVCController.html#others">其他</a></strong></li></ul></li></ul><h3 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍###"></a>介绍###</h3><p>ABP通过Abp.Web.Mvc nuget包集成了<strong>ASP.NET MVC控制器</strong>。你可以像常规那样创建MVC控制器。依赖注入对于常规的MVC控制器可以正确地工作。</p><p>但是，你应该让你的控制器继承于<strong>AbpController</strong>，该基类控制器提供了很多有用的东西，而且更好地集成到了ABP中。</p><h3 id="AbpController基类"><a href="#AbpController基类" class="headerlink" title="AbpController基类"></a>AbpController基类</h3><p>下面是一个派生自AbpController的简单控制器：</p><pre class=" language-C#"><code class="language-C#">public class HomeController : AbpController{    public ActionResult Index()    {        return View();    }}</code></pre><h4 id="本地化-1"><a href="#本地化-1" class="headerlink" title="本地化"></a>本地化</h4><p>AbpController中定义了<strong>L</strong>方法使得本地化更加简单。例子：</p><pre class=" language-C#"><code class="language-C#">public class HomeController : AbpController{    public HomeController()    {        LocalizationSourceName = "MySourceName";    }        public ActionResult Index()    {        var helloWorldText = L("HelloWorld");                return View();    }}</code></pre><p>要使L方法生效，必须设置LocalizationSourceName。你可以在自己的控制器基类中设置而不用在每个控制器中都重复设置。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>异常都是自动处理的，自动记录日志，而且会给客户端返回一个合适的响应。</p><p>查看**<a href="http://www.cnblogs.com/farb/p/ABPException.html">异常处理</a>**博客获得更多信息。</p><h4 id="响应结果的包装"><a href="#响应结果的包装" class="headerlink" title="响应结果的包装"></a>响应结果的包装</h4><p>如果返回类型是<strong>JsonResult</strong>（或者异步action方法的Task），ABP会默认封装该action方法的响应结果。你可以通过为控制器或者actions使用<strong>WrapResult和DontWrapResult</strong>特性来更改默认的封装（注意：以前有园友经常问到这个）。</p><p>查看**<a href="http://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#Ajax">ajax</a>**博客获取更多信息。</p><h4 id="审计日志-1"><a href="#审计日志-1" class="headerlink" title="审计日志"></a>审计日志</h4><p>如果你从AbpController派生控制器的话，那么审计日志会自动记录。</p><p>查看**<a href="http://www.cnblogs.com/farb/p/ABPAuditLog.html">审计日志</a>**博客获取更多信息。</p><h4 id="授权-1"><a href="#授权-1" class="headerlink" title="授权"></a>授权</h4><p>你可以为控制器或者action方法使用<strong>AbpMvcAuthorize</strong>特性来阻止未授权的用户使用控制器和action方法。例子：</p><pre class=" language-C#"><code class="language-C#">public class HomeController : AbpController{    [AbpMvcAuthorize("MyPermissionName")]    public ActionResult Index()    {        return View();    }}</code></pre><p>AbpApiController也定义了检查权限的<strong>IsGranted方法</strong>作为快捷方式。请查看**<a href="http://www.cnblogs.com/farb/p/ABPAuthorization.html">授权</a>**一节获取更多信息。</p><h4 id="工作单元-3"><a href="#工作单元-3" class="headerlink" title="工作单元"></a>工作单元</h4><p>MVC的action方法默认不是工作单元。例如，如果你需要在action方法中打开数据库连接，就需要像下面那样声明<strong>UnitOfWork</strong>特性：</p><pre class=" language-C#"><code class="language-C#">public class HomeController : AbpController{    private readonly IRepository<User, long> _userRepository;    public HomeController(IRepository<User, long> userRepository)    {        _userRepository = userRepository;    }    [UnitOfWork]    public virtual ActionResult Users(string filter)    {        var users = _userRepository            .GetAll()            .Where(u => u.UserName.StartsWith(filter))            .ToList();        return View(users);    }}</code></pre><p>这里我们声明了<strong>UnitOfWork</strong>特性。因为仓储的 <strong>GetAll()**方法返回了 **IQueryable</strong>，而当它使用 <strong>ToList()**方法（由于IQueryable的延迟执行）时需要一个打开的数据库连接，所以这里需要声明该特性。注意该action方法应该声明为</strong>virtual**（否则拦截无法工作）。</p><p>请查看**<a href="http://www.cnblogs.com/farb/p/ABPUnitofWork.html">工作单元</a>**获取更多。</p><h4 id="其他-5"><a href="#其他-5" class="headerlink" title="其他"></a>其他</h4><p>你还可以使用预注入的 <strong><a href="http://www.cnblogs.com/farb/p/ABPSession.html">AbpSession</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ABPEventBus.html">EventBus</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ModuleZeroPermissonManagement.html">PermissionManager</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ModuleZeroPermissonManagement.html">PermissionChecker</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ABPSettingManagement.html#getSetting">SettingManager</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ABPFeatures.html#manager">FeatureManager</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ABPFeatures.html#checkFunc">FeatureChecker</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ABPLocalization.html#text">LocalizationManager</a></strong>, <strong><a href="http://www.cnblogs.com/farb/p/ABPLogging.html">Logger</a></strong>, **<a href="http://www.cnblogs.com/farb/p/ABPUnitofWork.html#uow">CurrentUnitOfWork</a>**等基属性以及更多。</p><p>要了解以上属性，请查阅其他相应博客。</p><h1 id="ABP理论学习之Javascript-API-理论完结篇"><a href="#ABP理论学习之Javascript-API-理论完结篇" class="headerlink" title="ABP理论学习之Javascript API(理论完结篇)"></a><a href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html">ABP理论学习之Javascript API(理论完结篇)</a></h1><h1 id="-1"><a href="#-1" class="headerlink" title="         "></a><a href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html">         </a></h1><p><strong><a href="http://www.cnblogs.com/farb/p/ABPTheory.html">返回总目录</a></strong></p><hr><h2 id="本篇目录-26"><a href="#本篇目录-26" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#Ajax">Ajax</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#Notification">Notification</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#Message">Message</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#block">UI block和busy</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#eventBus">事件总线</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#Logging">Logging</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#other">其他工具功能</a></strong></li></ul><hr><blockquote><h4 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h4><p>不知不觉，我们送走了2015，同时迎来了2016。我相信，每一个人，都会在过去的一年有所失，但我更相信，我们所得到的更多。过去的就过去了，不要再计较了，但要从过去的各种不顺中汲取经验，这样，在全新的2016年里继续留下2015年遗憾的概率才会大大降低！祝大家在新的一年里，代码bug越来越少！</p><p>本来给这个**<a href="http://www.cnblogs.com/farb/p/ABPTheory.html">ABP理论学习系列</a>**的预算时间是2016年春节前完成，当时还恐怕完成不了任务，现在没想到在2016年元旦假期就完成了。原本计划两个月的完成的任务，结果用了不到一个月就完成了，我的效率还是蛮高的嘛！不过，这多亏了各位园友的鼓励和支持，才让我有了坚持下去的动力，在此谢谢了！</p><p>ABP理论学习完了，基本上的东西也就懂了！接下来，就需要好好地实战一把了！虽然我写了**<a href="http://www.cnblogs.com/farb/p/ABPPracticeContent.html">一步一步使用ABP搭建正式项目教程</a><strong>，但是那完全是让新手能迅速使用ABP搭建的项目跑起来。接下来，我会写一个</strong><a href="http://www.cnblogs.com/farb/category/773197.html">ABP项目进阶教程</a>**系列，教大家使用ABP框架搭建一个完整的例子，实战的同时，讲解一些难点的基本原理，也希望热爱ABP的园友们多多关注。</p><p>先声明一下，这篇文章稍长，希望大家多点耐心。</p></blockquote><hr><p>ABP提供了一些对象和函数集，使得了javascript开发简单且标准化。</p><p>下面，我们一一讲解ABP中的这些javascript API。</p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax##"></a>Ajax##</h2><p>使用Ajax调用服务端的服务，并返回服务端响应的内容。因为ABP对于Ajax调用会返回一个标准的响应，因此，建议使用该方法处理标准的返回值。</p><h3 id="Ajax操作的问题"><a href="#Ajax操作的问题" class="headerlink" title="Ajax操作的问题"></a>Ajax操作的问题</h3><p>现代应用程序频繁使用Ajax调用，特别是在SPA中，它几乎是和服务器交互的唯一方式。</p><p>Ajax调用包含了许多重复性的步骤：</p><p>一般来讲，在客户端javascript代码应该提供一个URL，data是否提供是可选的，以及选择一个执行Ajax调用的方法（Post,Get…）。必须等待然后才能处理返回的值。当向服务端发起调用时可能会发生错误（一般是网络错误）。服务端也可能发生错误，服务器可能发送了一个具有错误信息的失败响应。客户端代码应该处理服务端响应的错误，并选择性地通知用户（可能展示一个error对话框）。如果没有错误，且服务器返回了数据，客户端也必须处理。此外，一般它会阻塞一些（或者整个）屏幕区域，并展示一个繁忙的指示标志，直到Ajax操作结束。</p><p>服务端应该接收请求，然后执行服务端的代码，捕获任何异常并返回一个有效的响应给客户端。在发生错误的情况下，它可以有选择地发送一个错误消息给客户端；成功时，它可以返回数据给客户端。</p><h3 id="ABP采用的方式"><a href="#ABP采用的方式" class="headerlink" title="ABP采用的方式"></a>ABP采用的方式</h3><p>ABP通过使用<strong>abp.ajax</strong>函数封装Ajax的调用，自动化了这其中的一些步骤。一个ajax调用的例子如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> newPerson <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'Dougles Adams'</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">;</span>abp<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    url<span class="token punctuation">:</span> <span class="token string">'/People/SavePerson'</span><span class="token punctuation">,</span>    data<span class="token punctuation">:</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>newPerson<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">'created new person with id = '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>personId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>abp.ajax以一个对象作为接收<strong>选项</strong>。你可以传递任何在jQuery的$.ajax方法中有效的任何参数。这里有一些 <strong>默认</strong>的值：dataType是‘json’，type是‘POST’，contentType是‘application/json’（因此，在发送到服务器之前，我们可以调用JSON.stringify将javascript对象转成JSON字符串）。你可以通过将选项传给abp.ajax重写默认值。</p><p>abp.ajax返回了**<a href="http://api.jquery.com/deferred.promise/">promise</a><strong>。因此，你可以写done,fail,then等处理函数。上面的例子中，我们向 **PeopleController的SavePerson</strong>的action发送了简单的Ajax请求。在 <strong>done</strong>处理函数中，我们获得了新添加的person的数据库Id，而且展示了一个成功的通知。让我们看一下该Ajax请求的 <strong>MVC控制器</strong>：</p><pre class=" language-C#"><code class="language-C#">public class PeopleController : AbpController{    [HttpPost]    public JsonResult SavePerson(SavePersonModel person)    {        //TODO:将新的person保存到数据库，并返回该person的Id        return Json(new {PersonId = 42});    }}</code></pre><p><strong>SavePersonModel</strong>包含了Name和Age属性。SavePerson标记有 <strong>HttpPost</strong>特性，因为abp.ajax默认的方法是POST。这里通过返回一个匿名的对象简化了方法的实现。</p><p>这个看上去简单明了，但是ABP背后处理了许多重要的事情。让我们深入细节看一下：</p><h3 id="Ajax返回的消息"><a href="#Ajax返回的消息" class="headerlink" title="Ajax返回的消息"></a>Ajax返回的消息</h3><p>虽然我们直接返回了一个具有PersonId=2的对象，但是ABP会使用一个<strong>MVCAjaxResponse</strong>对象封装了它。实际的Ajax响应是像下面那样的：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"result"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"personId"</span><span class="token operator">:</span> <span class="token number">42</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"error"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>  <span class="token property">"targetUrl"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>  <span class="token property">"unAuthorizedRequest"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span></code></pre><p>这里，所有的属性都是camelCase的（因为在javascript中这是惯例），即使在服务端代码中是PascalCased的。下面解释一下所有的字段：</p><ul><li><strong>success</strong>:一个布尔值，表示操作的成功状态。如果是true，abp.ajax会解析该promise，并调用 <strong>done</strong>处理函数。如果是false（如果在方法调用中发生了异常），它会调用 <strong>fail</strong>处理函数并使用abp.message.error函数展示一个 <strong>error</strong>消息。</li><li><strong>result</strong>：控制器的action返回的实际值。如果success是true，而且服务器发送了一个返回值，它才有效。</li><li><strong>error</strong>：如果success是false，那么该字段是一个包含了 <strong>message</strong>和 <strong>detail</strong>字段的对象。</li><li><strong>targetUrl</strong>:这为服务器提供了一种重定向客户端到其他Url的可能性。</li><li><strong>unAuthorizedRequest</strong>:这为服务器提供了通知客户端该操作没有授权或者用户没有认证的可能性。如果该值是true，那么abp.ajax会 <strong>重新加载</strong>当前的页面。</li></ul><p>通过从<strong>AbpController</strong>类中派生就可以将返回值转换成一个封装的Ajax响应。 <strong>abp.ajax</strong>会识别并计算该响应。因此，它们成对工作。如果没有发生错误的话，那么abp.ajax的done处理函数会获得控制器返回的实际值（一个具有personId属性的对象）。</p><p>当从<strong>AbpApiController</strong>类派生时，也会存在相同的机制。</p><h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>正如上面描述的，ABP会处理服务器中的所有异常，并返回一个具有错误信息的对象，如下所示：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"targetUrl"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>  <span class="token property">"result"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"error"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"An internal error occured during your request!"</span><span class="token punctuation">,</span>    <span class="token property">"details"</span><span class="token operator">:</span> <span class="token string">"..."</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"unAuthorizedRequest"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span></code></pre><p>可以看到，success是false，result是null。abp.ajax处理该对象，而且使用abp.message.error函数展示一个错误信息给用户。如果你的服务端代码抛出了一个<strong>UserFriendlyException</strong>类型的异常，它会直接给用户显示异常信息。否则，它会隐藏实际的错误（将错误写到日志中），并展示一个标准的“服务器内部错误…”信息给用户。所有的这些都是ABP自动处理的。</p><h3 id="动态Web-API-层"><a href="#动态Web-API-层" class="headerlink" title="动态Web API 层"></a>动态Web API 层</h3><p>虽然ABP提供了一种使得调用Ajax很简单的机制，但是在真实世界的应用中，为每个Ajax调用编写javascript函数是很经典的，比如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//创建一个抽象了Ajax调用的function</span><span class="token keyword">var</span> savePerson <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> abp<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        url<span class="token punctuation">:</span> <span class="token string">'/People/SavePerson'</span><span class="token punctuation">,</span>        data<span class="token punctuation">:</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建一个新的 person</span><span class="token keyword">var</span> newPerson <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'Dougles Adams'</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存该person</span><span class="token function">savePerson</span><span class="token punctuation">(</span>newPerson<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">'created new person with id = '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>personId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>对于每个Ajax调用都写个函数是个好的做法，但是这耗时且乏味。ASP.NET为应用服务层方法提供了自动生成这些类型的函数机制。请阅读**<a href="http://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html">《动态Web API层》</a>**</p><h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification##"></a>Notification##</h2><p>展示自动关闭的通知。</p><p>我们喜欢一些事情发生时展示一些精致的自动消失的通知，比如当保存一条记录或者问题发生时。ABP为这个定义了标准的APIs。</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">'a message text'</span><span class="token punctuation">,</span> <span class="token string">'optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'a message text'</span><span class="token punctuation">,</span> <span class="token string">'optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'a message text'</span><span class="token punctuation">,</span> <span class="token string">'optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'a message text'</span><span class="token punctuation">,</span> <span class="token string">'optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>通知API默认是使用**<a href="http://codeseven.github.io/toastr/demo.html">toastr</a>**库实现的。要使toastr生效，你应该引用toastr的css和javascript文件，然后再在页面中包含abp.toastr.js作为适配器。一个toastr成功通知如下所示：</p><p><img src="http://i.imgur.com/xjBHBtD.png" alt="img"></p><p>你也可以用你最喜欢的通知库中实现通知。只需要在自定义javascript文件中重写所有的函数，然后把它添加到页面中而不是abp.toastr.js（你可以检查该文件看它是否实现，这个相当简单）中。</p><h2 id="Message"><a href="#Message" class="headerlink" title="Message##"></a>Message##</h2><p>给用户展示消息对话框。</p><p>消息API用于给用户展示消息或者获得用户的确认。</p><p>消息API默认是使用**<a href="http://tristanedwards.me/sweetalert">sweetalert</a><strong>实现的。要让sweetalert生效，你应该包含它的css和javascript文件，然后再页面中添加 **abp.sweet-alert.js</strong>的引用作为适配器。</p><h4 id="展示消息"><a href="#展示消息" class="headerlink" title="展示消息"></a>展示消息</h4><p>例子如下：</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'some info message'</span><span class="token punctuation">,</span> <span class="token string">'some optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>abp<span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">'some success message'</span><span class="token punctuation">,</span> <span class="token string">'some optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>abp<span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'some warning message'</span><span class="token punctuation">,</span> <span class="token string">'some optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>abp<span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'some error message'</span><span class="token punctuation">,</span> <span class="token string">'some optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>一个成功的消息如下所示：</p><p><img src="http://i.imgur.com/gkHdu4k.png" alt="img"></p><h4 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h4><p>例子如下：</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">confirm</span><span class="token punctuation">(</span>    <span class="token string">'User admin will be deleted.'</span><span class="token punctuation">,</span>    <span class="token string">'Are you sure?'</span><span class="token punctuation">,</span>    <span class="token keyword">function</span> <span class="token punctuation">(</span>isConfirmed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isConfirmed<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//...删除用户</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里的第二个参数（title）是可选的，因此，回调函数也可以是第二个参数。</p><p>一个确认消息的例子如下所示：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160111104142897-1109234390.png" alt="img"></p><p>ABP内部使用了Message API。比如，如果Ajax调用失败了，那么它会调用abp.message.error。</p><h2 id="UI-block和Busy-API"><a href="#UI-block和Busy-API" class="headerlink" title="UI block和Busy API##"></a>UI block和Busy API##</h2><p>使用一个区域（一个div，form，整个页面等）阻塞用户的输入。此外，还使得一个区域处于繁忙状态（具有一个繁忙的指示器，如‘loading…’）。</p><h3 id="UI-Block-API"><a href="#UI-Block-API" class="headerlink" title="UI Block API"></a>UI Block API</h3><p>该API使用一个透明的涂层（transparent overlay）来阻塞整个页面或者该页面上的一个元素。这样，用户的点击就无效了。当保存一个表单或者加载一个区域（一个div或者整个页面）时这是很有用的，比如：</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//阻塞整个页面</span>abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#MyDivElement'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//可以使用jQuery 选择器..</span>abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token string">'#MyDivElement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//..或者直接使用选择器</span>abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">unblock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//解除阻塞整个页面</span>abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">unblock</span><span class="token punctuation">(</span><span class="token string">'#MyDivElement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//解除阻塞特定的元素</span></code></pre><p>UI Block API默认使用jQuery的blockUI插件实现的。要是它生效，你应该包含它的javascript文件，然后在页面中包含<strong>abp.blockUI.js</strong>作为适配器。</p><h3 id="UI-Busy-API"><a href="#UI-Busy-API" class="headerlink" title="UI Busy API"></a>UI Busy API</h3><p>该API用于使得某些页面或者元素处于繁忙状态。比如，你可能想阻塞一个表单，然后当提交表单至服务器时展示一个繁忙的指示器。例子：</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">setBusy</span><span class="token punctuation">(</span><span class="token string">'#MyLoginForm'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">clearBusy</span><span class="token punctuation">(</span><span class="token string">'#MyLoginForm'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>样例截图：</p><p><img src="http://i.imgur.com/ZmAirzt.png" alt="img"></p><p>该参数应该是一个选择器（如‘#MyLoginForm’）或者jQuery选择器（如$(‘#MyLoginForm’)）。要使得整个页面处于繁忙状态，你可以传入null（或者’body’）作为选择器。</p><p>setBusy函数第二个参数接收一个promise（约定），当该约定完成时会自动清除繁忙的状态。例子：</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">setBusy</span><span class="token punctuation">(</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#MyLoginForm'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     abp<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>因为abp.ajax返回promise，我们可以直接将它作为promise传入。要学习惯于promise更多的东西，查看jQuery的**<a href="http://api.jquery.com/category/deferred-object/">Deferred</a>**。</p><p>UI Busy API是使用**<a href="http://fgnass.github.io/spin.js/">spin.js</a><strong>实现的。要让它生效，应该包含它的javascript文件，然后在页面中包含</strong>abp.spin.js**作为适配器。</p><h2 id="事件总线-1"><a href="#事件总线-1" class="headerlink" title="事件总线"></a>事件总线</h2><p>用于注册和触发客户端的全局事件。</p><h3 id="介绍-13"><a href="#介绍-13" class="headerlink" title="介绍"></a>介绍</h3><p><strong>Pub/sub</strong>事件模型广泛用于客户端，ABP包含了一个简单的<strong>全局事件总线</strong>来 <strong>注册</strong>并 <strong>触发事件</strong>。</p><h4 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h4><p>可以使用<strong>abp.event.on</strong>来注册一个全局事件。一个注册的例子：</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>event<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'itemAddedToBasket'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">' is added to basket!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第一个参数是<strong>事件的唯一名称</strong>。第二个是回调函数，当特定事件被触发时，会被调用。</p><p>可以使用<strong>abp.event.off</strong>方法来从一个事件中取消注册。注意：要取消注册，要提供相同的函数。因此，对于上面的例子，你应该将回调函数设置为一个变量，然后在<strong>on和off</strong>方法中使用它。</p><h4 id="触发事件-1"><a href="#触发事件-1" class="headerlink" title="触发事件"></a>触发事件</h4><p><strong>abp.event.trigger</strong>用于触发一个全局事件。触发一个已经注册的事件的代码如下：</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>event<span class="token punctuation">.</span><span class="token function">trigger</span><span class="token punctuation">(</span><span class="token string">'itemAddedToBasket'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    id<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">,</span>    name<span class="token punctuation">:</span> <span class="token string">'Acme Light MousePad'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第一个参数是<strong>该事件的唯一名称</strong>。第二个是（可选的）<strong>事件参数</strong>。你可以添加任何数量的参数，并且在回调方法中获得它们。</p><h2 id="Logging"><a href="#Logging" class="headerlink" title="Logging##"></a>Logging##</h2><p>在客户端记录日志。</p><h3 id="Javascript-Logging-API"><a href="#Javascript-Logging-API" class="headerlink" title="Javascript Logging API"></a>Javascript Logging API</h3><p>当你想要在客户端记录一些简单的日志时，你可以使用console.log(‘…’)API，这你已经知道了。但是这种写法不是所有的浏览器都支持的，而且可能会破坏你的脚本。因此，你应该首先检查console是否可用，此外，你可能想在别的地方记录日志，甚至你想以某种级别记录日志。ABP定义了安全的日志函数：</p><pre><code>abp.log.debug(&#39;...&#39;);abp.log.info(&#39;...&#39;);abp.log.warn(&#39;...&#39;);abp.log.error(&#39;...&#39;);abp.log.fatal(&#39;...&#39;);</code></pre><p>你可以通过设置<strong>abp.log.level</strong>为abp.log.levels之一来更改日志级别（比如，abp.log.levels.INFO没有记录调试日志）。这些函数默认将日志记录到了浏览器的控制台里了。但如果你需要的话，你也可以重写或者扩展这个行为。</p><h2 id="其他工具功能"><a href="#其他工具功能" class="headerlink" title="其他工具功能##"></a>其他工具功能##</h2><p>ABP提供了一些通用的工具功能。</p><h3 id="abp-utils-createNamespace"><a href="#abp-utils-createNamespace" class="headerlink" title="abp.utils.createNamespace"></a>abp.utils.createNamespace</h3><p>用于立即创建更深的命名空间。假设我们有一个基命名空间‘abp’，然后想要创建或者获得‘abp.utils.strings.formatting’命名空间。不需要下面这样写：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//创建或获得namespace</span>abp<span class="token punctuation">.</span>utils <span class="token operator">=</span> abp<span class="token punctuation">.</span>utils <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>strings <span class="token operator">=</span> abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>strings <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>strings<span class="token punctuation">.</span>formatting <span class="token operator">=</span> abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>strings<span class="token punctuation">.</span>formatting <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//给该namespace添加一个function</span>abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>strings<span class="token punctuation">.</span>formatting<span class="token punctuation">.</span>format <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>我们可以这样写：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> formatting <span class="token operator">=</span> abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span><span class="token function">createNamespace</span><span class="token punctuation">(</span>abp<span class="token punctuation">,</span> <span class="token string">'utils.strings.formatting'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//给该namespace添加一个function</span>formatting<span class="token punctuation">.</span>format <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>这样就简化了安全地创建深入的命名空间了。注意，第一个参数是必须存在的根命名空间。</p><h3 id="abp-utils-formatString"><a href="#abp-utils-formatString" class="headerlink" title="abp.utils.formatString"></a>abp.utils.formatString</h3><p>这个和C#中的string.Format()很相似。用法示例：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span><span class="token function">formatString</span><span class="token punctuation">(</span><span class="token string">'Hello {0}!'</span><span class="token punctuation">,</span> <span class="token string">'World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//str = 'Hello World!'</span><span class="token keyword">var</span> str <span class="token operator">=</span> abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span><span class="token function">formatString</span><span class="token punctuation">(</span><span class="token string">'{0} number is {1}.'</span><span class="token punctuation">,</span> <span class="token string">'Secret'</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//str = 'Secret number is 42'</span></code></pre><h1 id="ABP理论学习之本地化-2016第一篇"><a href="#ABP理论学习之本地化-2016第一篇" class="headerlink" title="ABP理论学习之本地化(2016第一篇)"></a><a href="https://www.cnblogs.com/farb/p/ABPLocalization.html">ABP理论学习之本地化(2016第一篇)</a></h1><hr><h2 id="本篇目录-27"><a href="#本篇目录-27" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPLocalization.html#appLang">应用语言</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPLocalization.html#source">本地化资源</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPLocalization.html#text">获取本地化文本</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPLocalization.html#extend">扩展本地化资源</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPLocalization.html#bestPractice">最佳实践</a></strong></li></ul><h3 id="应用语言"><a href="#应用语言" class="headerlink" title="应用语言###"></a>应用语言###</h3><p>一个应用至少有一种UI语言，许多应用不止有一种语言。ABP为应用提供了一个灵活的本地化系统。</p><p>第一件事情就是声明支持哪些语言。这个是在模块的<strong>PreInitialize</strong>方法中完成的，如下所示：</p><pre class=" language-C#"><code class="language-C#">Configuration.Localization.Languages.Add(new LanguageInfo("en", "English", "famfamfam-flag-england", true));Configuration.Localization.Languages.Add(new LanguageInfo("tr", "Türkçe", "famfamfam-flag-tr"));</code></pre><p>在服务端，可以先注入<strong>ILocalizationManager</strong>,然后使用它。在客户端，可以使用 <strong>abp.localization</strong>Javascript API来获得所有可使用的语言和当前的语言。famfamfam-flag-england (和tr)只是一个Css类而已，你可以根据自己的需要改变它。然后在UI上使用它来展示相关的旗帜（比如各种国旗）。</p><p>ABP模板使用了本地化系统给用户呈现的是一个<strong>切换语言</strong>的下拉列表。你可以创建一个模板项目然后学习一下源代码。</p><h3 id="本地化资源"><a href="#本地化资源" class="headerlink" title="本地化资源###"></a>本地化资源###</h3><p>本地化文本可以存储在不同的资源中。甚至你可以在相同的应用中使用不止一种语言（如果你有不止一个模块，每个模块可以定义一个单独的本地化资源）。应该为本地化资源实现<strong>ILocalizationSource</strong>接口，然后将它注册到ABP的本地化配置中。</p><p>每个本地化资源必须有一个<strong>唯一的资源名</strong>。 <strong>XML文件</strong>和 <strong>资源</strong>文件是预定义的本地化资源类型。</p><h4 id="XML文件"><a href="#XML文件" class="headerlink" title="XML文件"></a>XML文件</h4><p>本地化文本可以存储在XML文件中，XML文件的内容就像下面展示的那样：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>localizationDictionary</span> <span class="token attr-name">culture</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>texts</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TaskSystem<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Task System<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TaskList<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Task List<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>NewTask<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>New Task<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Xtasks<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{0} tasks<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CompletedTasks<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Completed tasks<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>EmailWelcomeMessage<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hi,Welcome to Simple Task System! This is a sampleemail content.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>texts</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>localizationDictionary</span><span class="token punctuation">></span></span></code></pre><p>XML文件必须是<strong>utf-8</strong>编码， <strong>culture=”en”**声明该XML文件包含了英语文本。对于文本节点，</strong>name<strong>特性用于标识一个文本。你可以使用 **value</strong>特性或者 <strong>inner text</strong>(如上面的最后一个)给本地化文本赋值。如下所示，我们为<strong>每种语言</strong>创建了一个单独的XML文件：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151231232053042-1808284103.png" alt="img"></p><p>这里，<strong>SimpleTaskSystem</strong>是 <strong>资源名称</strong>，SimpleTaskSystem定义了 <strong>默认的语言</strong>。当请求一个文本时，ABP会从当前语言的XML文件中获取文本（使用Thread.CurrentThread.<strong>CurrentUICulture</strong>找到当前的语言）。如果不存在当前语言的文本，就会从默认语言的XML文件中获得文本。</p><p><strong>注册XML本地化资源</strong></p><p>XML文件可以存储在文件系统中或者可以内嵌在一个程序集中。</p><p>对于<strong>文件系统</strong>存储的XML，我们可以注册一个XML本地化资源，如下所示：</p><pre class=" language-C#"><code class="language-C#">Configuration.Localization.Sources.Add(    new DictionaryBasedLocalizationSource(        "SimpleTaskSystem",        new XmlFileLocalizationDictionaryProvider(            HttpContext.Current.Server.MapPath("~/Localization/SimpleTaskSystem")            )        )    );</code></pre><p>这个是在模块的<strong>PreInitialize</strong>事件中完成的（看**<a href="http://www.cnblogs.com/farb/p/ABPModuleSystem.html">模块系统</a>**获取更多信息）。ABP会找到所有给定目录的XML文件并注册这些本地化资源。</p><p>对于<strong>内嵌的XML文件</strong>，我们应该将所有的本地化XML文件标记为内嵌的资源（选中xml文件，打开属性窗口，将生成操作的值改为‘内嵌的资源’）。然后像下面那样注册该本地化资源：</p><pre class=" language-C#"><code class="language-C#">Configuration.Localization.Sources.Add(    new DictionaryBasedLocalizationSource(        "SimpleTaskSystem",        new XmlEmbeddedFileLocalizationDictionaryProvider(            Assembly.GetExecutingAssembly(),            "MyCompany.MyProject.Localization.Sources"            )        )    );</code></pre><p><strong>XmlEmbeddedFileLocalizationDictionaryProvider</strong>会获得包含XML文件的程序集（GetExecutingAssembly简单地指向当前的程序集）和XML文件的 <strong>命名空间</strong>（程序集名称+xml文件的文件夹层次）。</p><p>注意：当给内嵌的XML文件起名字时，要加上语言后缀，但是不要使用“.”，比如“MySource.ch.xml”，而要使用短号“-”，比如“MySource-en.xml”。因为当寻找资源时，“.”会造成问题。</p><h4 id="JSON文件"><a href="#JSON文件" class="headerlink" title="JSON文件"></a>JSON文件</h4><p>JSON文件可以用于存储本地化资源的文本。JSON本地化文件的一个简单样例如下所示：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"culture"</span><span class="token operator">:</span> <span class="token string">"en"</span><span class="token punctuation">,</span>  <span class="token property">"texts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"TaskSystem"</span><span class="token operator">:</span> <span class="token string">"Task system"</span><span class="token punctuation">,</span>    <span class="token property">"Xtasks"</span><span class="token operator">:</span> <span class="token string">"{0} tasks"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>JSON文件的格式应该是unicode(utf-8)格式。<code>&quot;culture&quot;:&quot;en&quot;</code>表示该Json文件包含了英文文本。如下所示，我们为<strong>每种语言</strong>创建了一个单独的Json文件：</p><p><img src="https://dn-coding-net-production-pp.qbox.me/3a2186cf-3d54-4e0c-b70a-98ead158721c.png" alt="图片"></p><p>这里的<strong>MySourceName</strong>是资源名称， MySourceName.json定义了 <strong>默认的语言</strong>，json文件和XML文件很相似。</p><p><strong>注册JSON本地化资源</strong><br> Json文件可以存储在<strong>文件系统</strong>中，也可以 <strong>内嵌</strong>到一个程序集中。<br> 对于文件系统存储JSON，我们可以注册一个Json本地化资源，如下所示：</p><pre class=" language-C#"><code class="language-C#">Configuration.Localization.Sources.Add(    new DictionaryBasedLocalizationSource(        "MySourceName",        new JsonFileLocalizationDictionaryProvider(            HttpContext.Current.Server.MapPath("~/Localization/MySourceName")            )        )    );</code></pre><p>这是在模块的<strong>PerInitialize</strong>事件中完成的。ABP会在给定的目录中寻找所有的Json文件，并注册到本地化资源。</p><p>对于<strong>内嵌的Json文件</strong>，首先我们应该将所有的本地化Json文件标记为 <strong>内嵌的资源</strong>（选中Json文件，然后打开属性窗口，更改生成操作为内嵌的资源即可）。然后我们就可以像下面那样注册本地化资源了：</p><pre class=" language-C#"><code class="language-C#"> Configuration.Localization.Sources.Add(    new DictionaryBasedLocalizationSource(        "MySourceName",        new JsonEmbeddedFileLocalizationDictionaryProvider(            Assembly.GetExecutingAssembly(),            "MyCompany.MyProject.Localization.Sources"            )        )    );</code></pre><p><strong>JsonEmbeddedFileLocalizationDictionaryProvider</strong>需要一个包含Json文件的程序集（GetExecutingAssembly指向当前的程序集）和Json文件的命名空间（命名空间是通过程序集名称+json文件的文件夹层次计算出来的）。</p><p><strong>注意：</strong>当我们给json文件添加了语言后缀时，不要使用“.”标记符号，如“MySource.tr.json”，而要使用分隔符如“<strong>MySource-tr.json</strong>”，因为“.”标记符号在寻找资源时可能会发生问题。</p><h4 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h4><p>本地化文本也可以存储在.NET的资源文件中。我们可以为每种语言创建一个资源文件，如下所示：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151231234452479-171479678.png" alt="img"></p><p><strong>MyTexts.resx</strong>包含了默认的语言文本， MyTexts.tr.resx包含了土耳其语言的文本。当我们打开MyTexts.resx时，我们可以看到所有文本：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151231234648354-476448936.png" alt="img"></p><p>在这种情况下，ABP使用了.NET中内置的本地化资源管理者。你应该为该资源配置一个本地化资源：</p><pre class=" language-C#"><code class="language-C#">Configuration.Localization.Sources.Add(    new ResourceFileLocalizationSource(        "MySource",        MyTexts.ResourceManager        ));</code></pre><p>这里，<strong>MySource</strong>是资源的 <strong>唯一名字</strong>，而且 <strong>MyTexts.ResourceManager</strong>是获取本地化文本的资源管理者的引用。这个是在模块的 <strong>Initialize</strong>事件中完成的。</p><h4 id="自定义资源"><a href="#自定义资源" class="headerlink" title="自定义资源"></a>自定义资源</h4><p>自定义本地化资源实现了在不同的资源中（比如数据库）存储文本。你可以直接实现<strong>ILocalizationSource</strong>接口或者从<strong>DictionaryBasedLocalizationSource</strong>类中派生可以使得实现更容易。</p><h3 id="获取本地化文本"><a href="#获取本地化文本" class="headerlink" title="获取本地化文本###"></a>获取本地化文本###</h3><p>当创建了资源并把它注册到ABP的本地化系统之后，文本就能轻易地本地化了。</p><h4 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h4><p>在服务端，我们可以注入<strong>ILocalizationManager</strong>，然后使用它的 <strong>GetString</strong>方法。</p><pre class=" language-C#"><code class="language-C#">var s1 = _localizationManager.GetString("SimpleTaskSystem", "NewTask");</code></pre><p>GetString方法会基于<strong>当前线程的UI文化（culture）</strong>获取字符串。如果没有找到，就会返回 <strong>默认语言</strong>对应的字符串。如果任何地方都没有定义该字符串，就会默认返回使用 <strong>“[]”</strong> 包装的 <strong>给定字符串</strong>（而不是抛出异常）。这种行为是可以配置的（你可以在模块的PreInitialize中使用Configuration.Loacalization.ReturnGivenTextIfNotFound属性进行配置）。</p><p>记得不要重复资源的名字(运行时会报错)，你可以首先获得<strong>该资源</strong>，然后从该资源中获得字符串：</p><pre class=" language-C#"><code class="language-C#">var source = _localizationManager.GetSource("SimpleTaskSystem");var s1 = source.GetString("NewTask");</code></pre><p>这会返回当前语言的文本。GetString方法也有重载方法通过参数获取不同语言和格式的文本。</p><p>如果我们不能注入ILocalizationManager（也许在一个不能到达依赖注入系统的静态上下文中），那么可以简单地使用<strong>LocalizationHelper</strong>静态类。但是尽可能地注入并使用ILocalizationManager，因为LocalizationHelper是静态的而且静态不好测试（对于写单元测试的人来说）。</p><p>如果你需要在**<a href="http://www.cnblogs.com/farb/p/ABPApplicationService.html">应用服务</a><strong>、MVC控制器、Razor视图或者其他派生自</strong>AbpServiceBase<strong>的类中本地化，那么可以使用快捷的 **L</strong>方法。</p><p><strong>在MVC控制器中</strong></p><p>一般在MVC控制器和视图中需要本地化文本。这里有一个快捷方式，如下所示：</p><pre class=" language-C#"><code class="language-C#">public class HomeController : SimpleTaskSystemControllerBase{    public ActionResult Index()    {        var helloWorldText = L("HelloWorld");        return View();    }}</code></pre><p><strong>L</strong>方法用于本地化一个字符串。当然，你必须提供一个资源名，这里的HelloWorld就是从资源中找到的。它是在控制器基类SimpleTaskSystemControllerBase(以ControllerBase为后缀的控制器)中完成的，如下所示：</p><pre class=" language-C#"><code class="language-C#">public abstract class SimpleTaskSystemControllerBase : AbpController{    protected SimpleTaskSystemControllerBase()    {        LocalizationSourceName = "SimpleTaskSystem";    }}</code></pre><p>注意L派生自<strong>AbpController</strong>。因此，你可以使用 <strong>L</strong>方法轻松地本地化文本。</p><p><strong>在MVC视图中</strong></p><p>在视图中也可以使用相同的<strong>L</strong>方法：</p><pre class=" language-C#"><code class="language-C#"><div>    <form id="NewTaskForm" role="form">        <div class="form-group">            <label for="TaskDescription">@L("TaskDescription")</label>            <textarea id="TaskDescription" data-bind="value: task.description" class="form-control" rows="3" placeholder="@L("EnterDescriptionHere")" required></textarea>        </div>        <div class="form-group">            <label for="TaskAssignedPerson">@L("AssignTo")</label>            <select id="TaskAssignedPerson" data-bind="options: people, optionsText: 'name', optionsValue: 'id', value: task.assignedPersonId, optionsCaption: '@L("SelectPerson")'" class="form-control"></select>        </div>        <button data-bind="click: saveTask" type="submit" class="btn btn-primary">@L("CreateTheTask")</button>    </form></div></code></pre><p>为了能够这样使用，你应该让你的视图派生自设置了资源名的一个基类：</p><pre class=" language-C#"><code class="language-C#">public abstract class SimpleTaskSystemWebViewPageBase : SimpleTaskSystemWebViewPageBase<dynamic>{}public abstract class SimpleTaskSystemWebViewPageBase<TModel> : AbpWebViewPage<TModel>{    protected SimpleTaskSystemWebViewPageBase()    {        LocalizationSourceName = "SimpleTaskSystem";    }}</code></pre><p>而且要在web.config中设置这个视图基类：</p><pre class=" language-webconfig"><code class="language-webconfig"><pages pageBaseType="SimpleTaskSystem.Web.Views.SimpleTaskSystemWebViewPageBase"></code></pre><p>当你从ABP模板创建解决方案时，对于视图和控制器的所有这些都已经准备好了。</p><h4 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h4><p>ABP也使得在javascript代码中使用相同的本地化文本成为了可能。首先，你应该将动态的ABP脚本添加到页面中：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/AbpScripts/GetScripts<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>ABP在客户端会自动生成需要的javascript代码来获得本地化的文本。然后，你就可以轻松地使用javascript获得一个本地化的文本，如下所示：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> s1 <span class="token operator">=</span> abp<span class="token punctuation">.</span>localization<span class="token punctuation">.</span><span class="token function">localize</span><span class="token punctuation">(</span><span class="token string">'NewTask'</span><span class="token punctuation">,</span> <span class="token string">'SimpleTaskSystem'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里，NewTask是文本名，SimpleTaskSystem是资源名。记住不要重复资源名。你也可以先获得资源名，然后获得文本：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> source <span class="token operator">=</span> abp<span class="token punctuation">.</span>localization<span class="token punctuation">.</span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token string">'SimpleTaskSystem'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token function">source</span><span class="token punctuation">(</span><span class="token string">'NewTask'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>格式化参数</strong></p><p>本地化方法也可以有额外的格式参数，例子：</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>localization<span class="token punctuation">.</span><span class="token function">localize</span><span class="token punctuation">(</span><span class="token string">'RoleDeleteWarningMessage'</span><span class="token punctuation">,</span> <span class="token string">'MySource'</span><span class="token punctuation">,</span> <span class="token string">'Admin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果使用上面的getSource找到了资源，就使用source作为快捷方式</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token string">'RoleDeleteWarningMessage'</span><span class="token punctuation">,</span> <span class="token string">'Admin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果RoleDeleteWarningMessage = ‘Role {0} will be deleted’， 那么本地化后的文本就是’Role Admin will be deleted’。</p><p><strong>默认的本地化资源</strong><br> 可以设置默认的本地化资源，然后就能够不使用资源名称也可以使用<code>abp.localization.localize</code>方法了。</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>localization<span class="token punctuation">.</span>defaultSourceName <span class="token operator">=</span> <span class="token string">'SimpleTaskSystem'</span><span class="token punctuation">;</span><span class="token keyword">var</span> s1 <span class="token operator">=</span> abp<span class="token punctuation">.</span>localization<span class="token punctuation">.</span><span class="token function">localize</span><span class="token punctuation">(</span><span class="token string">'NewTask'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>defaultSourceName是全局的，并且一次只能用于一个资源名称。</p><h3 id="扩展本地化资源"><a href="#扩展本地化资源" class="headerlink" title="扩展本地化资源###"></a>扩展本地化资源###</h3><p>假设我们已经有一个定义了自己本地化资源的模块。我们可能需要更改它的本地化文本，或者添加一些新的文本或者翻译为其他的语言。如何解决这个呢？ABP允许扩展一个本地化资源，当前只对XML文件有效（实际上任何本地化资源都实现了IDictionaryBasedLocalizationSource接口）。</p><p>ABP也定义了一些本地化资源。比如，<strong>Abp.Web</strong>nuget包定义了一个叫做 <strong>AbpWeb</strong>的本地化资源作为内嵌XML文件：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160101131030401-240846594.png" alt="img"></p><p>默认的（英语）XML文件像下面这个样子（这里只展示一部分文本）：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>localizationDictionary</span> <span class="token attr-name">culture</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>texts</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>InternalServerError<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>An internal error occurred during your request!<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ValidationError<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Your request is not valid!<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    ...  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>texts</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>localizationDictionary</span><span class="token punctuation">></span></span></code></pre><p>要扩展AbpWeb资源，我们可以定义XML文件。假设我们只想更改<strong>InternalServerError</strong>文本，我们就可以像下面那样定义一个XML文件：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>localizationDictionary</span> <span class="token attr-name">culture</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>texts</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>InternalServerError<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Sorry :( It seems there is a problem. Let us to solve it and please try again later.<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>texts</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>localizationDictionary</span><span class="token punctuation">></span></span></code></pre><p>然后我们在模块的PreInitialize方法中注册它：</p><pre class=" language-C#"><code class="language-C#">Configuration.Localization.Sources.Extensions.Add(    new LocalizationSourceExtensionInfo("AbpWeb",        new XmlFileLocalizationDictionaryProvider(            HttpContext.Current.Server.MapPath("~/Localization/AbpWebExtensions")            )        )    );</code></pre><p>如果我们想创建内嵌的资源XML文件（上面有讲），那么可以使用XmlEmbeddedFileLocalizationDictionaryProvider。ABP使用XML文件合并了基本的本地化资源。我们也可以添加新的语言文件。</p><p><strong>注意：</strong>我们可以使用Json文件来扩展XMl文件，反过来也一样。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论###"></a>结论###</h3><p>ABP提供了使用不同资源进行本地化的功能，也提供了在服务端和客户端代码中使用相同的本地化文本的基础设施。</p><p>XML文件，Json文件和资源文件都有自己的长处和弱势，我们建议使用XML文件或者Json文件代替资源文件。因为：</p><ul><li>XML/JSON文件更容易编辑，扩展或者移植。</li><li>当获取本地化文本时，XML/JSON文件要求string类型的key，而不是像资源文件需要编译时的属性。这个可以被认为是缺点，但是以后更改资源时相对容易一些。甚至我们将本地化不需要更改就可以移动到数据库或者使用了该本地化资源的代码中了（Module-zero已经实现了创建一个<strong>基于数据库和每个租户的</strong>本地化资源，查看《**<a href="http://www.cnblogs.com/farb/p/ModuleZeroLanguageManagement.html">Module Zero之语言管理</a>**》）。</li></ul><p>此外，如果你使用XML或者Json，建议不要按照name进行排序文本，而要按照创建日期进行排序。这样，当别人要将文本翻译为其他语言时，ta就可以轻松地看到哪一个文本是新添加的。</p><p>通过实现<strong>ILocalizationSource</strong>接口，你也可以创建你自己的本地化资源并集成到ABP中。 <strong>Module-zero</strong>实现了一个 <strong>基于数据库</strong>和 <strong>各租户</strong>的本地化资源。 <strong><a href="http://www.cnblogs.com/farb/p/ModuleZeroLanguageManagement.html">点击查看文档</a></strong></p><h1 id="ABP理论学习之导航-Navigation"><a href="#ABP理论学习之导航-Navigation" class="headerlink" title="ABP理论学习之导航(Navigation)"></a><a href="https://www.cnblogs.com/farb/p/ABPNavigation.html">ABP理论学习之导航(Navigation)</a></h1><hr><h2 id="本篇目录-28"><a href="#本篇目录-28" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><a href="https://www.cnblogs.com/farb/p/ABPNavigation.html#create">创建菜单</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNavigation.html#register">注册导航提供者</a></strong></li></ul></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNavigation.html#show">展示菜单</a></strong></li></ul><p>每一个web应用在页面之间都有一些要导航的菜单。ABP提供了公用的基础设施来创建菜单并将菜单展示给用户。</p><h3 id="创建菜单"><a href="#创建菜单" class="headerlink" title="创建菜单###"></a>创建菜单###</h3><p>一个应用可能由不同的模块组成，每个模块可能有它自己的菜单项。想要定义菜单项，我们需要创建一个派生自<strong>NavigationProvider</strong>的类。</p><p>假设我们有一个如下所示的主菜单：</p><ul><li>Tasks</li><li>Reports</li><li>Administration<ul><li>User Management</li><li>Role Management</li></ul></li></ul><p>这里，Administration菜单项有两个<strong>子菜单项</strong>。创建这么一个菜单的导航提供者类如下所示：</p><pre class=" language-C#"><code class="language-C#">   public class SimpleTaskSystemNavigationProvider : NavigationProvider{    public override void SetNavigation(INavigationProviderContext context)    {        context.Manager.MainMenu            .AddItem(                new MenuItemDefinition(                    "Tasks",                    new LocalizableString("Tasks", "SimpleTaskSystem"),                    url: "/Tasks",                    icon: "fa fa-tasks"                    )            ).AddItem(                new MenuItemDefinition(                    "Reports",                    new LocalizableString("Reports", "SimpleTaskSystem"),                    url: "/Reports",                    icon: "fa fa-bar-chart"                    )            ).AddItem(                new MenuItemDefinition(                    "Administration",                    new LocalizableString("Administration", "SimpleTaskSystem"),                    icon: "fa fa-cogs"                    ).AddItem(                        new MenuItemDefinition(                            "UserManagement",                            new LocalizableString("UserManagement", "SimpleTaskSystem"),                            url: "/Administration/Users",                            icon: "fa fa-users",                            requiredPermissionName: "SimpleTaskSystem.Permissions.UserManagement"                            )                    ).AddItem(                        new MenuItemDefinition(                            "RoleManagement",                            new LocalizableString("RoleManagement", "SimpleTaskSystem"),                            url: "/Administration/Roles",                            icon: "fa fa-star",                            requiredPermissionName: "SimpleTaskSystem.Permissions.RoleManagement"                            )                    )            );    }}</code></pre><p>一个MenuItemDefinition一般有一个唯一的<strong>name</strong>，一个本地化的<strong>displayName</strong>，一个 <strong>url</strong>和一个 <strong>icon</strong>。而且，</p><ul><li>一个菜单项可能要求一个特定的用户具有展示该菜单的权限。此时可以使用<strong>requiredPermissionName</strong>属性。</li><li>一个菜单项可能依赖于一个功能。此时可以使用<strong>featureDependency</strong>。</li><li>一个菜单项可以定义一个<strong>customData</strong>和 <strong>order</strong>。</li></ul><p>**INavigationProviderContext **具有一个获得已存在菜单项、添加菜单以及菜单项的方法。这样，不同的模块就可以将自己的项添加到菜单上。</p><p>在一个应用中也可能有一个或更多的菜单，<strong>context.Manager.MainMenu</strong>引用了默认的主菜单。使用<strong>context.Manager.Menus</strong>可以创建和添加更多的菜单。</p><h4 id="注册导航提供者"><a href="#注册导航提供者" class="headerlink" title="注册导航提供者"></a>注册导航提供者</h4><p>创建导航提供者之后，我们应该在模块的<strong>PreInitialize</strong>事件里将它注册到ABP的配置中：</p><pre class=" language-C#"><code class="language-C#">Configuration.Navigation.Providers.Add<SimpleTaskSystemNavigationProvider>();</code></pre><h3 id="展示菜单"><a href="#展示菜单" class="headerlink" title="展示菜单###"></a>展示菜单###</h3><p>可以注入<strong>IUserNavigationManager</strong>，然后使用它来获得菜单项，再将菜单项展示给用户。这样，我们就可以在服务端创建菜单了。</p><p>ABP在客户端自动生成获得菜单和菜单项的<strong>javascript API</strong>。 <strong>abp.nav</strong>命名空间下的方法和对象就是用于这个目的。比如，可以使用 <strong>abp.nav.menus.Mainmenu</strong>获得应用的主菜单。这样我们就能在客户端创建菜单了。</p><p>ABP模板使用了这个系统来创建菜单并将菜单展示给用户，你可以通过创建一个模板来查看源代码了解更多。</p><h1 id="ABP理论学习之异常处理"><a href="#ABP理论学习之异常处理" class="headerlink" title="ABP理论学习之异常处理"></a><a href="https://www.cnblogs.com/farb/p/ABPException.html">ABP理论学习之异常处理</a></h1><hr><h2 id="本篇目录-29"><a href="#本篇目录-29" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPException.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPException.html#enable">开启错误处理</a></strong></li><li><a href="https://www.cnblogs.com/farb/p/ABPException.html#nonAjax">非Ajax请求</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPException.html#show">展示异常信息</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPException.html#UserFriendlyException">UserFriendlyException</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPException.html#model">Error模型</a></strong></li></ul></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPException.html#Ajax">Ajax请求</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPException.html#event">异常事件</a></strong></li></ul><h3 id="介绍-14"><a href="#介绍-14" class="headerlink" title="介绍###"></a>介绍###</h3><p>在一个web应用中，异常通常是在MVC控制器的action方法和Web API控制器中处理的。当异常发生时，应用程序会通知用户发生的错误，也可能包含该错误产生的原因。</p><p>如果错误发生在一个常规的HTTP请求中，那么就会展示一个错误页面。如果一个错误发生在Ajax请求中，那么服务端会给客户端发送错误信息，然后处理后将错误展示给用户。</p><p>在所有的web应用中处理异常是一个乏味反复的工作。ABP的异常处理是自动化的。你大多数情况下不需要处理任何异常。ABP会处理所有的异常，记录异常信息日志，并返回给客户端合适且格式化的响应，而且也会在客户端处理这些响应并通知用户。</p><h3 id="开启错误处理"><a href="#开启错误处理" class="headerlink" title="开启错误处理###"></a>开启错误处理###</h3><p>要开启错误处理，必须开启<strong>customErrors</strong>模式。</p><pre class=" language-webconfig"><code class="language-webconfig"><customErrors mode="On" /></code></pre><p>如果你不想在本机上处理错误，那么你可以将该值设置成“RemoteOnly”。</p><h3 id="非Ajax请求"><a href="#非Ajax请求" class="headerlink" title="非Ajax请求###"></a>非Ajax请求###</h3><p>如果请求是非Ajax的，那么就会显示一个错误页面。</p><h4 id="展示异常信息"><a href="#展示异常信息" class="headerlink" title="展示异常信息"></a>展示异常信息</h4><p>这里有个抛出任意异常的MVC控制器action。</p><pre class=" language-C#"><code class="language-C#">public ActionResult Index(){    throw new Exception("A sample exception message...");}</code></pre><p>当然，这个异常信息也可能被在该action中调用的其他方法抛出。ABP会处理这个异常，记录到日志，然后显示<strong>“Error.cshtml”</strong>视图。你也可以<strong>自定义</strong>该错误视图。一个错误视图的例子如下（它是ABP模板中默认的错误视图）：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151231212223792-1292368149.png" alt="img"></p><p>ABP会将该异常的细节隐藏给用户，然后展示一个标准的（本地化）错误信息，除非你显示抛出一个<strong>UserFriendlyException</strong>。</p><h4 id="UserFriendlyException"><a href="#UserFriendlyException" class="headerlink" title="UserFriendlyException"></a>UserFriendlyException</h4><p>UserFriendlyException是一个特殊类型的异常，它会直接展示给用户。看下面的例子：</p><pre class=" language-C#"><code class="language-C#">public ActionResult Index(){    throw new UserFriendlyException("Ooppps! There is a problem!", "You are trying to see a product that is deleted...");}</code></pre><p>ABP会记录这个错误日志，但是这次不会隐藏异常信息了，如下所示：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151231212718573-747775861.png" alt="img"></p><p>因此，如果你想要给用户展示一个特殊的错误信息，只要抛出一个UserFriendlyException（或者派生自它的异常）就行了。</p><h4 id="Error模型"><a href="#Error模型" class="headerlink" title="Error模型"></a>Error模型</h4><p>ABP将一个<strong>ErrorViewModel</strong>对象传给了Error视图：</p><pre class=" language-C#"><code class="language-C#">public class ErrorViewModel{    public AbpErrorInfo ErrorInfo { get; set; }    public Exception Exception { get; set; }}</code></pre><p><strong>ErrorInfo</strong>包含了可以展示给用户的详细信息， <strong>Exception</strong>对象是抛出的异常。如果你想，你也可以检查它，然后展示额外的信息。比如，如果它是一个<strong>AbpValidationException</strong>，那么我们可以展示一个验证错误的信息：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151231213304698-1528714449.png" alt="img"></p><h3 id="Ajax请求"><a href="#Ajax请求" class="headerlink" title="Ajax请求###"></a>Ajax请求###</h3><p>如果请求是Ajax请求，那么ABP会返回一个Json对象给客户端。这对于MVC控制器和Web API控制器都是成立的。下面是返回一个错误对象的例子：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"targetUrl"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>  <span class="token property">"result"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"error"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"An internal error occured during your request!"</span><span class="token punctuation">,</span>    <span class="token property">"details"</span><span class="token operator">:</span> <span class="token string">"..."</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"unAuthorizedRequest"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span></code></pre><p><strong>success:false</strong>表明发送了错误。<br> <strong>error</strong>对象提供了错误 <strong>信息</strong>和 <strong>细节</strong>。</p><p>当你使用ABP的基础设施在客户端发起Ajax请求时，客户端会自动地处理这个Json对象，然后使用message API给用户提示错误信息。</p><h3 id="异常事件"><a href="#异常事件" class="headerlink" title="异常事件###"></a>异常事件###</h3><p>ABP处理任何异常时都会触发<strong>AbpHandledExceptionData</strong>事件，注册该事件后就会收到通知（查看**<a href="http://www.cnblogs.com/farb/p/ABPEventBus.html">事件总线（EventBus）</a>**获取更多信息关于事件总线的信息）。例子：</p><pre class=" language-C#"><code class="language-C#">public class MyExceptionHandler : IEventHandler<AbpHandledExceptionData>, ITransientDependency{    public void HandleEvent(AbpHandledExceptionData eventData)    {        //TODO: 检查 eventData.Exception!    }}</code></pre><p>如果你把这个样例类放到你的应用中（一般放到Web项目中），<strong>HandleEvent</strong>方法就会被ABP处理的所有异常调用。这样，你就可以研究Exception对象的细节了。</p><h1 id="ABP理论学习之内嵌资源文件"><a href="#ABP理论学习之内嵌资源文件" class="headerlink" title="ABP理论学习之内嵌资源文件"></a><a href="https://www.cnblogs.com/farb/p/ABPEmbeddedFile.html">ABP理论学习之内嵌资源文件</a></h1><hr><h2 id="本篇目录-30"><a href="#本篇目录-30" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEmbeddedFile.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEmbeddedFile.html#create">创建内嵌文件</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEmbeddedFile.html#expose">暴露内嵌文件</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEmbeddedFile.html#consume">使用内嵌文件</a></strong></li></ul><h3 id="介绍-15"><a href="#介绍-15" class="headerlink" title="介绍###"></a>介绍###</h3><p>在一个web应用中，有供客户端使用的javascript，css，xml等文件。它们一般是作为分离的文件被添加到web项目中并发布。有时，我们需要将这些文件打包到一个程序集（类库项目，一个dll文件）中，作为内嵌资源散布到程序集中。ABP提供了一个基础设施使得这个很容易实现。</p><h3 id="创建内嵌文件"><a href="#创建内嵌文件" class="headerlink" title="创建内嵌文件###"></a>创建内嵌文件###</h3><p>我们首先应该创建一个资源文件并把它标记为<strong>内嵌的资源</strong>。任何程序集都可以包含内嵌的资源文件。假设我们有一个叫做“Abp.Zero.Web.UI.Metronic.dll”程序集，而且它包含了javascript，css，和图片文件：</p><p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151225220358531-512438953.png" alt="img"></p><p>我们想要使这些文件在一个web应用中可用，首先，我们应该将想要暴露的文件标记为<strong>内嵌的资源</strong>。在这里，我选择了 <strong>metronic.js</strong>文件，右键打开属性面板（快捷键是F4）。</p><p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151225222645218-1301105987.png" alt="img"></p><p>选中你想在web应用中使用的所有文件，将<strong>生成操作（build action）</strong>的属性值选为<strong>内嵌的 资源</strong>。</p><h3 id="暴露内嵌文件"><a href="#暴露内嵌文件" class="headerlink" title="暴露内嵌文件###"></a>暴露内嵌文件###</h3><p>ABP使得暴露这些内嵌资源很容易，只需要一行代码：</p><pre><code>WebResourceHelper.ExposeEmbeddedResources(&quot;AbpZero/Metronic&quot;, Assembly.GetExecutingAssembly(), &quot;Abp.Zero.Web.UI.Metronic&quot;);</code></pre><p>这行代码一般放在模块的Initialize方法中，下面解释一下这些参数：</p><ul><li>第一个参数为这些文件定义了<strong>根文件夹</strong>，它匹配了根命名空间。</li><li>第二个参数定义了包含这些文件的<strong>程序集</strong>。本例中，我传入了包含这行代码的程序集。但你也可以传入任何包含内嵌资源的程序集。</li><li>最后一个参数定义了这些文件在程序集的根命名空间。它是“默认的命名空间”加上“文件夹名”。默认的命名空间一般和程序集的名字是相同的，但是在程序集的属性中进行更改。这里 ，默认的命名空间是Abp(已经更改了)，因此Metronic文件夹的命名空间是“Abp.Zero.Web.UI.Metronic”。</li></ul><h3 id="使用内嵌文件"><a href="#使用内嵌文件" class="headerlink" title="使用内嵌文件###"></a>使用内嵌文件###</h3><p>可以直接使用内嵌的资源：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>~/AbpZero/Metronic/assets/global/scripts/metronic.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>ABP知道这是一个内嵌的资源，因而可以从之前暴露的dll中获得文件。此外，还可以在razor视图中使用HtmlHelper的扩展方法<strong>IncludeScript</strong>:</p><pre class=" language-razor"><code class="language-razor">@Html.IncludeScript("~/AbpZero/Metronic/assets/global/scripts/metronic.js")</code></pre><p>这会产生下面的代码：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/AbpZero/Metronic/assets/global/scripts/metronic.js?v<span class="token punctuation">=</span>635438748506909100<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>唯一的不同就是参数<strong>v=635438748506909100</strong>。这样做的好处是阻止了浏览器端脚本的<strong>失败缓存</strong>。该值只有当你的dll重新生成（实际上是文件的最后写入时间）的时候才会改变，而且如果该值改变了，浏览器就不会缓存这个文件了。因此，建议使用IncludeScript方式。这对于非嵌入的物理资源也是有效的。对应于css文件，也存在相应的<strong>IncludeStyle</strong>方法。</p><h1 id="后台服务"><a href="#后台服务" class="headerlink" title="后台服务"></a>后台服务</h1><hr><h2 id="本篇目录-31"><a href="#本篇目录-31" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPBackgroundJobsAndWorkers.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPBackgroundJobsAndWorkers.html#jobs">后台工作</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPBackgroundJobsAndWorkers.html#workers">后台工作者</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPBackgroundJobsAndWorkers.html#running">让你的应用程序一直运行</a></strong></li></ul><h3 id="介绍-16"><a href="#介绍-16" class="headerlink" title="介绍"></a>介绍</h3><p>ABP提供了后台工作和后台工作者，它们会在应用程序的<strong>后台线程</strong>中执行一些任务。</p><h3 id="后台工作"><a href="#后台工作" class="headerlink" title="后台工作"></a>后台工作</h3><p>后台工作以队列和持续的方式在后台给一些即将被执行的任务排队。你可能因为某些原因需要后台工作，比如：</p><ul><li>执行<strong>长时间运行的任务</strong>。比如，一个用户按了“report”按钮来启动一个长时间运行的报告工作，点击了这个按钮你不可能让用户一直处于等待状态，所以你应该将这个工作（job）添加到 <strong>队列（queue）</strong>中，然后，当这项工作完成时，通过邮件将报告结果发送给该用户。</li><li>创建<strong>重复尝试（re-trying）和持续的任务</strong>来保证代码将会 <strong>成功执行</strong>。比如，你可以在后台工作中发送邮件以克服 <strong>临时失败</strong>，并 <strong>保证</strong>邮件最终能够发送出去。因此，当发送邮件的时候用户不需要等待。</li></ul><h4 id="创建一个后台工作"><a href="#创建一个后台工作" class="headerlink" title="创建一个后台工作"></a>创建一个后台工作</h4><p>我们可以通过继承<strong>BackgroundJob</strong>类或者直接实现 <strong>IBackgroundJob</strong>接口来创建一个后台工作类。</p><p>下面是一个最简单的后台工作：</p><pre class=" language-C#"><code class="language-C#">public class TestJob : BackgroundJob<int>, ITransientDependency{    public override void Execute(int number)    {        Logger.Debug(number.ToString());    }}</code></pre><p>该后台工作定义了一个需要输入参数的<strong>Execute</strong>方法。参数类型是泛型参数类型。</p><p>后台工作必须注册到依赖注入系统中，实现<strong>ITransientDependency</strong>是最简单的方式。</p><p>接下来定义一个更现实的工作，它会在后台队列中发送邮件：</p><pre class=" language-C#"><code class="language-C#">public class SimpleSendEmailJob : BackgroundJob<SimpleSendEmailJobArgs>, ITransientDependency{    private readonly IRepository<User, long> _userRepository;    private readonly IEmailSender _emailSender;    public SimpleSendEmailJob(IRepository<User, long> userRepository, IEmailSender emailSender)    {        _userRepository = userRepository;        _emailSender = emailSender;    }    public override void Execute(SimpleSendEmailJobArgs args)    {        var senderUser = _userRepository.Get(args.SenderUserId);        var targetUser = _userRepository.Get(args.TargetUserId);        _emailSender.Send(senderUser.EmailAddress, targetUser.EmailAddress, args.Subject, args.Body);    }}</code></pre><p>我们注入了user仓储（为了获得用户信息）和email发送者（发送邮件的服务），然后简单地发送了该邮件。<strong>SimpleSendEmailJobArgs</strong>是该工作的参数，它定义如下：</p><pre class=" language-C#"><code class="language-C#">[Serializable]public class SimpleSendEmailJobArgs{    public long SenderUserId { get; set; }    public long TargetUserId { get; set; }    public string Subject { get; set; }    public string Body { get; set; }}</code></pre><p>工作参数应该是<strong>serializable(可序列化)**，因为要将它 **序列化并存储</strong>到数据库中。虽然ABP默认的后台工作管理者使用了JSON序列化（它不需要[Serializable]特性），但是最好定义 **[Serializable]**特性，因为我们将来可能会转换到其他使用二进制序列化的工作管理者。</p><p>记住，<strong>要保持你的参数简单</strong>，不要在参数中包含实体或者其他非可序列化的对象。正如上面的例子演示的那样，我们只存储了实体的 <strong>Id</strong>，然后在该工作的内部从仓储中获得该实体。</p><h4 id="添加新工作到队列"><a href="#添加新工作到队列" class="headerlink" title="添加新工作到队列"></a>添加新工作到队列</h4><p>当定义了一个后台工作后，我们就可以注入并使用<strong>IBackgroundJobManager</strong>来添加一个工作到队列中。看上面定义的TestJob的例子：</p><pre class=" language-C#"><code class="language-C#">public class MyService{    private readonly IBackgroundJobManager _backgroundJobManager;    public MyService(IBackgroundJobManager backgroundJobManager)    {        _backgroundJobManager = backgroundJobManager;    }    public void Test()    {        _backgroundJobManager.Enqueue<TestJob, int>(42);    }}</code></pre><p>当入队（Enqueue）时，我们将42作为参数传递。IBackgroundJobManager将会实例化并使用42作为参数执行TestJob。</p><p>让我们看一下如何为上面定义的SimpleSendEmailJob添加一个新的工作：</p><pre class=" language-C#"><code class="language-C#">[AbpAuthorize]public class MyEmailAppService : ApplicationService, IMyEmailAppService{    private readonly IBackgroundJobManager _backgroundJobManager;    public MyEmailAppService(IBackgroundJobManager backgroundJobManager)    {        _backgroundJobManager = backgroundJobManager;    }    public async Task SendEmail(SendEmailInput input)    {            await _backgroundJobManager.EnqueueAsync<SimpleSendEmailJob, SimpleSendEmailJobArgs>(            new SimpleSendEmailJobArgs            {                Subject = input.Subject,                Body = input.Body,                SenderUserId = AbpSession.GetUserId(),                TargetUserId = input.TargetUserId            });    }}</code></pre><p>Enqueu (或 EnqueueAsync)方法还有其他的参数，比如 <strong>priority和 delay（优先级和延迟）</strong>。</p><h4 id="默认的后台工作管理者"><a href="#默认的后台工作管理者" class="headerlink" title="默认的后台工作管理者"></a>默认的后台工作管理者</h4><p>IBackgroundJobManager默认是由<strong>BackgroundJobManager</strong>实现的。它可以被其他的后台工作提供者替代（看后面的Hangfire集成）。关于默认的BackgroundJobManager一些信息如下：</p><ul><li>它是一个在单线程中以<strong>FIFO（First In First Out）</strong>工作的简单工作队列，使用 <strong>IBackgroundJobStore</strong>来持久化工作。</li><li>它会<strong>重复尝试</strong>执行工作，直到工作成功执行（不会抛出任何异常）或者超时。默认的超时是一个工作2天。</li><li>当成功执行后，它会从存储（数据库）中<strong>删除</strong>该工作。如果超时了，就会将该工作设置为 <strong>abandoned（废弃的）</strong>，并保留在数据库中。</li><li>在重复尝试一个工作之间会<strong>增加等待时间</strong>。第一次重试时等待1分钟，第二次等待2分钟，第三次等待4分钟等等。</li><li>在固定的时间间隔轮询工作的存储。查询工作时先按优先级排序，再按尝试次数排序。</li></ul><p><strong>后台工作存储</strong><br> 默认的BackgroundJobManager需要一个数据存储来保存、获得工作。如果你没有实现<strong>IBackgroundJobStore</strong>，那么它会使用 <strong>InMemoryBackgroundJobStore</strong>，它不会将工作持久化到数据库中。你可以简单地实现它来存储工作到数据库或者你可以使用module-zero，它已经实现了IBackgroundJobStore。</p><p>如果你正在使用第三方的工作管理者（像Hangfire），那么不需要实现IBackgroundJobStore。</p><h4 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h4><p>你可以在模块的PreInitialize方法中使用<strong>Configuration.BackgroundJobs</strong>来配置后台工作系统。</p><p><strong>关闭工作执行功能</strong><br> 你可能想关闭应用程序的后台工作执行：</p><pre class=" language-C#"><code class="language-C#">public class MyProjectWebModule : AbpModule{    public override void PreInitialize()    {        Configuration.BackgroundJobs.IsJobExecutionEnabled = false;    }    //...}</code></pre><p>这种情况很罕见，但是想一下，如果你正在对相同的数据库运行多个应用的实例（在web应用中）。在这种情况下，每个应用都会为工作查询相同的数据库并执行它们。这会导致相同工作的多次执行和一些其它问题。要阻止这种情况发生，你有两种选择：</p><ul><li>你可以只为该应用的一个实例开启工作执行。</li><li>你可以为该web应用的所有实例关闭工作执行，然后创建一个会执行后台工作的独立应用（比如一个Windows服务）。</li></ul><h4 id="Hangfire集成"><a href="#Hangfire集成" class="headerlink" title="Hangfire集成"></a>Hangfire集成</h4><p>后台工作管理者设计成了可以被其他的后台工作管理者<strong>取代</strong>。查看**<a href="http://www.cnblogs.com/farb/p/ABPHangfireIntegration.html">Hangfire集成</a>**来替代默认的后台工作管理者。</p><h3 id="后台工作者"><a href="#后台工作者" class="headerlink" title="后台工作者"></a>后台工作者</h3><p>后台工作者不同于后台工作。它们是运行在应用后台的简单<strong>独立线程</strong>。一般来说，它们会定期地执行一些任务。比如：</p><ul><li>后台工作者可以定期运行来<strong>删除旧的日志</strong>。</li><li>后台工作者可以定期运行来<strong>确定不活跃的用户</strong>，并给他们发送邮件以使他们返回你的应用。</li></ul><h4 id="创建后台工作者"><a href="#创建后台工作者" class="headerlink" title="创建后台工作者"></a>创建后台工作者</h4><p>要创建后台工作者，我们应该实现<strong>IBackgroundWorker</strong>接口。除此之外，我们可以基于需求从  <strong>BackgroundWorkerBase</strong>或者 <strong>PeriodicBackgroundWorkerBase</strong>继承。</p><p>假设一个用户在过去30天内没有登录到该应用，那我们想要让Ta的状态为passive。看下面的代码：</p><pre class=" language-C#"><code class="language-C#">public class MakeInactiveUsersPassiveWorker : PeriodicBackgroundWorkerBase, ISingletonDependency{    private readonly IRepository<User, long> _userRepository;    public MakeInactiveUsersPassiveWorker(AbpTimer timer, IRepository<User, long> userRepository)        : base(timer)    {        _userRepository = userRepository;        Timer.Period = 5000; //5 seconds (good for tests, but normally will be more)    }    [UnitOfWork]    protected override void DoWork()    {        using (CurrentUnitOfWork.DisableFilter(AbpDataFilters.MayHaveTenant))        {            var oneMonthAgo = Clock.Now.Subtract(TimeSpan.FromDays(30));            var inactiveUsers = _userRepository.GetAllList(u =>                u.IsActive &&                ((u.LastLoginTime < oneMonthAgo && u.LastLoginTime != null) || (u.CreationTime < oneMonthAgo && u.LastLoginTime == null))                );            foreach (var inactiveUser in inactiveUsers)            {                inactiveUser.IsActive = false;                Logger.Info(inactiveUser + " made passive since he/she did not login in last 30 days.");            }            CurrentUnitOfWork.SaveChanges();        }    }}</code></pre><p>这是现实中的代码，并且在具有module-zero模块的ABP中直接有效。</p><ul><li>如果你从<strong>PeriodicBackgroundWorkerBase</strong> 类继承（如这个例子），那么你应该实现 <strong>DoWork</strong>方法来执行定期运行的代码。</li><li>如果从<strong>BackgroundWorkerBase</strong>继承或直接实现了 <strong>IBackgroundWorker</strong>，那么你要重写或者实现Start, Stop 和 WaitToStop方法。Start和Stop方法应该是 <strong>非阻塞的（non-blocking）</strong>，WaitToStop方法应该等待工作者完成当前重要的工作。</li></ul><h4 id="注册后台工作者"><a href="#注册后台工作者" class="headerlink" title="注册后台工作者"></a>注册后台工作者</h4><p>创建一个后台工作者后，我们应该把它添加到<strong>IBackgroundWorkerManager</strong>，通常放在模块的PostInitialize方法中：</p><pre class=" language-C#"><code class="language-C#">public class MyProjectWebModule : AbpModule{    //...    public override void PostInitialize()    {        var workManager = IocManager.Resolve<IBackgroundWorkerManager>();        workManager.Add(IocManager.Resolve<MakeInactiveUsersPassiveWorker>());    }}</code></pre><p>虽然一般我们将工作者添加到PostInitialize方法中，但是没有强制要求。你可以在任何地方注入IBackgroundWorkerManager，在运行时添加工作者。<br> 当应用要关闭时，IBackgroundWorkerManager会停止并释放所有注册的工作者。</p><h4 id="后台工作者生命周期"><a href="#后台工作者生命周期" class="headerlink" title="后台工作者生命周期"></a>后台工作者生命周期</h4><p>后台工作者一般实现为单例的，但是没有严格限制。如果你需要相同工作者类的多个实例，那么可以使它成为transient（每次使用时创建），然后给IBackgroundWorkerManager添加多个实例。在这种情况下，你的工作者很可能会参数化（比如，你有单个LogCleaner类，但是两个LogCleaner工作者实例会监视并清除不同的log文件夹）。</p><h3 id="让你的应用程序一直运行"><a href="#让你的应用程序一直运行" class="headerlink" title="让你的应用程序一直运行"></a>让你的应用程序一直运行</h3><p>只有当你的应用运行时，后台工作和工作者才会工作。如果一个Asp.Net  应用长时间没有执行请求，那么它默认会关闭（shutdown）。如果你想让后台工作一直在web应用中执行（这是默认行为），那么你要确保web应用配置成了总是运行。否则，后台工作只有在应用使用时才会执行。</p><h1 id="实时服务"><a href="#实时服务" class="headerlink" title="实时服务"></a>实时服务</h1><h1 id="ABP理论学习之通知系统"><a href="#ABP理论学习之通知系统" class="headerlink" title="ABP理论学习之通知系统"></a><a href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html">ABP理论学习之通知系统</a></h1><hr><h2 id="本篇目录-32"><a href="#本篇目录-32" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html#subscribe">订阅通知</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html#publish">发布通知</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html#manager">用户通知管理者</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html#realtime">实时通知</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html#store">通知存储</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html#definition">通知定义</a></strong></li></ul><h3 id="介绍-17"><a href="#介绍-17" class="headerlink" title="介绍"></a>介绍</h3><p>通知（Notification）用于告知用户系统中的特定事件。ABP提供了基于<strong>实时</strong>通知基础设施的发布订阅模型（pub/sub）。</p><h4 id="发送模型"><a href="#发送模型" class="headerlink" title="发送模型"></a>发送模型</h4><p>给用户发送通知有两种方式：</p><ul><li>首先用户订阅特定的通知类型，然后我们发布这种类型的通知，这种类型的通知会传递给所有<strong>已经订阅</strong>的用户。这就是发布订阅（pub/sub）模型。</li><li>直接给目标用户发送通知。</li></ul><h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><p>通知类型也有两种：</p><ul><li><strong>一般通知</strong>：是任意类型的通知。“如果一个用户给我发送了添加好友的请求就通知我”是这种通知类型的一个例子。</li><li><strong>实体通知</strong>：和特定的实体相关联。“如果一个用户在 <strong>这张</strong>图片上评论那么通知我”是基于实体的通知，因为它和特定的实体相关联。用户可能想获得某些图片的通知而不是所有的图片通知。</li></ul><h4 id="通知数据"><a href="#通知数据" class="headerlink" title="通知数据"></a>通知数据</h4><p>一个通知一般都会包括一个<strong>通知数据</strong>。比如，“如果一个用户给我发送了添加好友的请求就通知我”，这个通知可能有两个数据属性：发送者用户名（那哪一个用户发送的这个添加好友的请求）和请求内容（该用户在这个请求中写的东西）。很明显，该通知数据类型紧耦合于通知类型。不同的通知类型有不同的数据类型。</p><ul><li>通知数据是<strong>可选的</strong>。某些通知可能不需要数据。一些预定义的通知数据类型可能对于大多数情况够用了。 <strong>MessageNotificationData</strong>可以用于简单的信息， <strong>LocalizableMessageNotificationData</strong>可以用于本地化的，带参数的通知信息。</li></ul><h4 id="通知安全"><a href="#通知安全" class="headerlink" title="通知安全"></a>通知安全</h4><p>通知的安全性有5个级别，它们定义在NotificationSeverity枚举类中，分别是 Info,Success,Warn,Error和Fatal。默认值是Info。</p><h3 id="订阅通知"><a href="#订阅通知" class="headerlink" title="订阅通知"></a>订阅通知</h3><p><strong>INotificationSubscriptionManager</strong> 提供了订阅通知的API。例如：</p><pre class=" language-C#"><code class="language-C#">public class MyService : ITransientDependency{    private readonly INotificationSubscriptionManager _notificationSubscriptionManager;    public MyService(INotificationSubscriptionManager notificationSubscriptionManager)    {        _notificationSubscriptionManager = notificationSubscriptionManager;    }    //订阅一个一般通知    public async Task Subscribe_SentFrendshipRequest(int? tenantId, long userId)    {        await _notificationSubscriptionManager.SubscribeAsync(tenantId, userId, "SentFrendshipRequest");        }    //订阅一个实体通知    public async Task Subscribe_CommentPhoto(int? tenantId, long userId, Guid photoId)    {        await _notificationSubscriptionManager.SubscribeAsync(tenantId, userId, "CommentPhoto", new EntityIdentifier(typeof(Photo), photoId));       }}</code></pre><p>首先，我们注入了<strong>INotificationSubscriptionManager</strong>。第一个方法订阅了一个一般通知。当某人发送了一个添加好友的请求时，用户想得到通知。第二个方法订阅了一个和特定实体（Photo）相关的通知。如果任何人对这个特定的图片进行了评论，那么用户就会收到通知。</p><p>每一个通知应该有<strong>唯一的名字</strong>（比如例子中的SentFrendshipRequest和 CommentPhoto）。</p><p><strong>INotificationSubscriptionManager</strong>还有很多方法来管理通知，比如<strong>UnsubscribeAsync, IsSubscribedAsync, GetSubscriptionsAsync</strong>等方法。</p><h3 id="发布通知"><a href="#发布通知" class="headerlink" title="发布通知"></a>发布通知</h3><p><strong>INotificationPublisher</strong>用于发布通知，例如：</p><pre class=" language-C#"><code class="language-C#">public class MyService : ITransientDependency{    private readonly INotificationPublisher _notiticationPublisher;    public MyService(INotificationPublisher notiticationPublisher)    {        _notiticationPublisher = notiticationPublisher;    }    //给特定的用户发送一个一般通知    public async Task Publish_SentFrendshipRequest(string senderUserName, string friendshipMessage, long targetUserId)    {        await _notiticationPublisher.PublishAsync("SentFrendshipRequest", new SentFrendshipRequestNotificationData(senderUserName, friendshipMessage), userIds: new[] { targetUserId });    }    //给特定的用户发送一个实体通知    public async Task Publish_CommentPhoto(string commenterUserName, string comment, Guid photoId, long photoOwnerUserId)    {        await _notiticationPublisher.PublishAsync("CommentPhoto", new CommentPhotoNotificationData(commenterUserName, comment), new EntityIdentifier(typeof(Photo), photoId), userIds: new[] { photoOwnerUserId });    }    //给具特定严重级别程度的所有订阅用户发送一个一般通知    public async Task Publish_LowDisk(int remainingDiskInMb)    {        //例如 "LowDiskWarningMessage"的英文内容 -> "Attention! Only {remainingDiskInMb} MBs left on the disk!"        var data = new LocalizableMessageNotificationData(new LocalizableString("LowDiskWarningMessage", "MyLocalizationSourceName"));        data["remainingDiskInMb"] = remainingDiskInMb;        await _notiticationPublisher.PublishAsync("System.LowDisk", data, severity: NotificationSeverity.Warn);        }}</code></pre><p>在第一个例子中，我们向单个用户发布了一个通知。<em>SentFrendshipRequestNotificationData</em>应该从 <strong>NotificationData</strong>继承，比如：</p><pre class=" language-C#"><code class="language-C#">[Serializable]public class SentFrendshipRequestNotificationData : NotificationData{    public string SenderUserName { get; set; }    public string FriendshipMessage { get; set; }    public SentFrendshipRequestNotificationData(string senderUserName, string friendshipMessage)    {        SenderUserName = senderUserName;        FriendshipMessage = friendshipMessage;    }}</code></pre><p>在第二个例子中，我们向特定的用户发送了一个特定实体的通知。通知数据类CommentPhotoNotificationData一般不需要<strong>serializble</strong>(因为默认使用了JSON序列化)。但是建议把它标记为serializable，因为你可能需要在应用之间移动通知，也可能在未来使用二进制的序列。此外，正如之前声明的那样，通知数据是可选的，而且对于所有的通知可能不是必须的。</p><p>注意：如果我们对特定的用户发布了一个通知，那么他们不需要订阅那些通知。</p><p>在第三个例子中，我们没有定义一个专用的通知数据类。相反，我们直接使用了内置的具有基于字典数据的<strong>LocalizableMessageNotificationData</strong>，并且以 <strong>Warn</strong>发布了通知。<strong>LocalizableMessageNotificationData</strong>可以存储基于字典的任意数据（这对于自定义的通知数据类也是成立的，因为它们也从 <strong>NotificationData类继承</strong>）。在本地化时我们使用了“ <strong>remaingDiskInMb</strong>”作为参数。本地化信息可以包含这些参数（比如例子中的”Attention! Only {remainingDiskInMb} MBs left on the disk!”）</p><h3 id="用户通知管理者"><a href="#用户通知管理者" class="headerlink" title="用户通知管理者"></a>用户通知管理者</h3><p><strong>IUserNotificationManager</strong>用于管理用户的通知，它有 <strong>get,update或delete</strong>用户通知的方法。你可以为你的应用程序准备一个通知列表页面。</p><h3 id="实时通知"><a href="#实时通知" class="headerlink" title="实时通知"></a>实时通知</h3><p>当使用IUserNotificationManager来查询通知时，我们一般想实时地将通知推送到客户端。</p><p>通知系统使用了<strong>IRealTimeNotifier</strong>向用户发送实时通知。这可以使用任何类型的实时通讯系统来实现。ABP在一个单独的包中使用了 <strong>SignalR</strong>来实现。ABP官网的起始模板已经安装了SignalR。</p><p>注意：通知系统在一个后台工作中异步调用<strong>IRealTimeNotifier</strong>。因此，通知发送时可能伴有轻微的延迟。</p><h4 id="客户端-4"><a href="#客户端-4" class="headerlink" title="客户端"></a>客户端</h4><p>当接收到一个实时通知时，ABP会在客户端触发一个<strong>全局的事件（global event）</strong>。你可以像下面那样注册来获取通知：</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>event<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'abp.notifications.received'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>userNotification<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>userNotification<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>abp.notifications.received</strong>事件对于每个接收到的实时通知都会触发。你可以像上面那样注册该事件来获取通知。查看**<a href="http://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#eventBus">javascript事件总线</a>**文档获取更多信息。对于上面的“System.LowDisk”例子，下面是接收到的通知消息的JSON数据：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"userId"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token property">"state"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token property">"notification"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"notificationName"</span><span class="token operator">:</span> <span class="token string">"System.LowDisk"</span><span class="token punctuation">,</span>        <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"message"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"sourceName"</span><span class="token operator">:</span> <span class="token string">"MyLocalizationSourceName"</span><span class="token punctuation">,</span>                <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"LowDiskWarningMessage"</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Abp.Notifications.LocalizableMessageNotificationData"</span><span class="token punctuation">,</span>            <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"remainingDiskInMb"</span><span class="token operator">:</span> <span class="token string">"42"</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"entityType"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>        <span class="token property">"entityTypeName"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>        <span class="token property">"entityId"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>        <span class="token property">"severity"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>        <span class="token property">"creationTime"</span><span class="token operator">:</span> <span class="token string">"2016-02-09T17:03:32.13"</span><span class="token punctuation">,</span>        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"0263d581-3d8a-476b-8e16-4f6a6f10a632"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"4a546baf-bf17-4924-b993-32e420a8d468"</span><span class="token punctuation">}</span></code></pre><p>在这个对象中，</p><ul><li><p><strong>userId</strong>:当前的用户Id。一般来说不需要这个，因为你知道当前的用户。</p></li><li><p><strong>state</strong>： <strong>UserNotificationState</strong>枚举的值。0：未读，1：已读。</p></li><li><p>notification</p><p>:通知细节。</p><ul><li><strong>notificationName</strong>:通知的唯一名称。（当发布该通知时使用相同的值）</li><li><strong>data</strong>:通知数据。在本例中，我们使用了**LocalizableMessageNotificationData **（正如之前的例子中发布的）。</li><li><strong>message</strong>:本地的信息通知。我们可以使用 <strong>sourceName</strong>和 <strong>name</strong>来本地化UI上的信息。</li><li><strong>type</strong>:通知数据类型。全类型名称，包括命名空间。当处理该通知数据时我们可以检查该类型。</li><li><strong>properties</strong>：基于字典的自定义属性。</li><li><strong>entityType, entityTypeName和entityId</strong>：和通知相关的实体的信息。</li><li><strong>severity</strong>： <strong>NotificationSeverity</strong>枚举的值。0: Info, 1: Success, 2: Warn, 3: Error, 4: Fatal。</li><li><strong>creationTime</strong>:该通知创建的时间。</li><li><strong>id</strong>:通知的Id。</li></ul></li><li><p><strong>id</strong>:用户的通知id。</p></li></ul><p>当然，你不仅可以记录该通知。你还可以使用通知数据将通知信息展示给该用户。例如：</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>event<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'abp.notifications.received'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>userNotification<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>userNotification<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>data<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'Abp.Notifications.LocalizableMessageNotificationData'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> localizedText <span class="token operator">=</span> abp<span class="token punctuation">.</span>localization<span class="token punctuation">.</span><span class="token function">localize</span><span class="token punctuation">(</span>            userNotification<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>data<span class="token punctuation">.</span>message<span class="token punctuation">.</span>name<span class="token punctuation">,</span>            userNotification<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>data<span class="token punctuation">.</span>message<span class="token punctuation">.</span>sourceName        <span class="token punctuation">)</span><span class="token punctuation">;</span>        $<span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span>userNotification<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>data<span class="token punctuation">.</span>properties<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            localizedText <span class="token operator">=</span> localizedText<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'{'</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">'}'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'New localized notification: '</span> <span class="token operator">+</span> localizedText<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>userNotification<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>data<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'Abp.Notifications.MessageNotificationData'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'New simple notification: '</span> <span class="token operator">+</span> userNotification<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>data<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>要处理通知数据，我们应该检查该数据类型。这个例子简单地从通知数据中获得信息。对于本地化的信息（LocalizableMessageNotificationData），我们要本地化该信息并替换参数。对于简单的信息（MessageNotificationData），我们直接获得该信息。当然，在一个真实项目中，我们不使用alert函数。我们可以使用<code>abp.notify</code>api来展示漂亮的UI通知。</p><p>如果你要实现这么上面的逻辑，那么有一种更简单且可伸缩的方式。当接收到一个push通知时，你可以只使用一句代码来显示UI通知：</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>event<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'abp.notifications.received'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>userNotification<span class="token punctuation">)</span> <span class="token punctuation">{</span>    abp<span class="token punctuation">.</span>notifications<span class="token punctuation">.</span><span class="token function">showUiNotifyForUserNotification</span><span class="token punctuation">(</span>userNotification<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这句代码会展示一个UI通知如下所示（上面System.LowDisk通知的例子）：</p><p><img src="https://dn-coding-net-production-pp.qbox.me/11f2d44b-fa5d-456f-8512-25a714df7c31.png" alt="图片"></p><p>对于内置的通知数据类型（LocalizableMessageNotificationData和 MessageNotificationData）是有效的。如果你有自定义的通知数据类型，那么你应该注册数据格式化器，如下所示：</p><pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>notifications<span class="token punctuation">.</span>messageFormatters<span class="token punctuation">[</span><span class="token string">'MyProject.MyNotificationDataType'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>userNotification<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">...</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//format and return message here</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>这样，<strong>showUiNotifyForUserNotification</strong>就可以对你的数据类型创建要显示的信息了。如果你只需要格式化信息，那么你可以直接使用 **abp.notifications.getFormattedMessageFromUserNotification(userNotification)**，它内部还是使用了showUiNotifyForUserNotification。</p><p>当接收到一个push通知时，启动模板包含了展示UI通知的代码。</p><h3 id="通知存储"><a href="#通知存储" class="headerlink" title="通知存储"></a>通知存储</h3><p>通知系统使用了<strong>INotificationStore</strong>来持久化通知。为了使通知系统合适地工作，应该实现这个接口。你可以自己实现或者使用module-zero（它已经实现了该接口）。</p><h3 id="通知定义"><a href="#通知定义" class="headerlink" title="通知定义"></a>通知定义</h3><p>在使用之前你不必定义一个通知。你无需定义任何类型的<strong>通知名</strong>就可以使用它们。但是，定义通知名可能会给你带来额外的好处。比如，你以后要研究应用程序中所有的通知，在这种情况下，我们可以给我们的模块定义一个<strong>通知提供器</strong>（notification provider ），如下所示：</p><pre class=" language-C#"><code class="language-C#">public class MyAppNotificationProvider : NotificationProvider{    public override void SetNotifications(INotificationDefinitionContext context)    {        context.Manager.Add(            new NotificationDefinition(                "App.NewUserRegistered",                displayName: new LocalizableString("NewUserRegisteredNotificationDefinition", "MyLocalizationSourceName"),                permissionDependency: new SimplePermissionDependency("App.Pages.UserManagement")                )            );    }}</code></pre><p><strong>“App.NewUserRegistered”**是该通知的唯一名称。我们定义了一个本地的 **displayName</strong>（然后当在UI上订阅了该通知时，我们可以显示该通知）。最后，我们声明了只有拥有了**”App.Pages.UserManagement”**权限的用户才可以使用该通知。</p><p>也有一些其他的参数，你可以在代码中研究。对于一个通知定义，只有通知名称是<strong>必须</strong>的。</p><p>当定义了这么一个通知提供器之后，我们应该在模块的PreInitialize事件中进行注册，如下所示：</p><pre class=" language-c#"><code class="language-c#">public class AbpZeroTemplateCoreModule : AbpModule{    public override void PreInitialize()    {        Configuration.Notifications.Providers.Add<MyAppNotificationProvider>();    }    //...}</code></pre><p>最后，要获得通知定义，在应用程序中注入并使用<strong>INotificationDefinitionManager</strong>。</p><h1 id="ABP理论学习之SignalR集成"><a href="#ABP理论学习之SignalR集成" class="headerlink" title="ABP理论学习之SignalR集成"></a><a href="https://www.cnblogs.com/farb/p/ABPSignalRIntegration.html">ABP理论学习之SignalR集成</a></h1><hr><h2 id="本篇目录-33"><a href="#本篇目录-33" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPSignalRIntegration.html#intro">介绍</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPSignalRIntegration.html#install">安装</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPSignalRIntegration.html#connEstablishment">建立连接</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPSignalRIntegration.html#built-in">内置功能</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPSignalRIntegration.html#yourCode">你自己的SignaR代码</a></strong></li></ul><h3 id="介绍-18"><a href="#介绍-18" class="headerlink" title="介绍###"></a>介绍###</h3><p><strong><a href="https://www.nuget.org/packages/Abp.Web.SignalR">Abp.Web.SignalR</a></strong> 使得在基于ABP的应用程序中使用 <strong>SignalR</strong>相当容易。查看**<a href="http://www.asp.net/signalr">SignalR文档</a>**获取更多关于SignalR的详细信息。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装###"></a>安装###</h3><h4 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h4><p>将**<a href="http://www.nuget.org/packages/Abp.Web.SignalR">Abp.Web.SignalR</a>**nuget包安装到你的项目中（一般是web层），然后给你的模块添加一个依赖：</p><pre class=" language-C#"><code class="language-C#">[DependsOn(typeof(AbpWebSignalRModule))]public class YourProjectWebModule : AbpModule{    //...}</code></pre><p>然后在你的OWIN Startup类中使用<strong>MapSignalR</strong>方法：</p><pre class=" language-C#"><code class="language-C#">[assembly: OwinStartup(typeof(Startup))]namespace MyProject.Web{    public class Startup    {        public void Configuration(IAppBuilder app)        {                app.MapSignalR();            //...        }    }}</code></pre><p>注意：Abp.Web.SignalR只依赖于Microsoft.AspNet.SignalR.Core包。因此，如果你之前没有安装，那么你也需要将**<a href="https://www.nuget.org/packages/Microsoft.AspNet.SignalR">Microsoft.AspNet.SignalR</a>**安装到你的web项目中。</p><h4 id="客户端-5"><a href="#客户端-5" class="headerlink" title="客户端"></a>客户端</h4><p>在页面上应该添加<strong>abp.signalr.js</strong>脚本。它位于**<a href="https://www.nuget.org/packages/Abp.Web.Resources">Abp.Web.Resources</a>**包中（在启动模块中已经安装了）。我们应该在signalr总线之后包含它：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"~/signalr/hubs"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"~/Abp/Framework/scripts/libs/abp.signalr.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>就这样，SignalR就配置好了，也就集成到了你的项目中。</p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接###"></a>建立连接###</h3><p>当页面上包含<strong>abp.signalr.js</strong>时，ABP会 <strong>自动连接</strong> 到服务器（从客户端）。一般来说这很好，但是也可能存在你不想这样的情况。那么你可以在包含 <strong>abp.signalr.js</strong>之前添加下面的代码来关闭自动连接。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span>    abp<span class="token punctuation">.</span>signalr <span class="token operator">=</span> abp<span class="token punctuation">.</span>signalr <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    abp<span class="token punctuation">.</span>signalr<span class="token punctuation">.</span>autoConnect <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>这样，当你需要连接到服务器时，你可以手动调用**abp.signalr.connect()**函数。</p><p>当客户端连接到服务器时，会触发全局事件“<strong>abp.signalr.connected</strong>”。当该连接成功建立时，你可以注册到该事件以采取相应行动。</p><h3 id="内置功能"><a href="#内置功能" class="headerlink" title="内置功能###"></a>内置功能###</h3><p>你可以在应用程序中使用SignalR的所有功能，此外，<strong>Abp.Web.SignalR</strong>包实现了一些内置的功能。</p><h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p><strong>Abp.Web.SignalR</strong>包实现了 <strong>IRealTimeNotifier</strong>来向客户端发送实时通知（查看《**<a href="http://www.cnblogs.com/farb/p/ABPNotificationSystem.html">通知系统</a>**》）。因此，你的用户可以获得实时的推送通知。</p><h4 id="在线客户端"><a href="#在线客户端" class="headerlink" title="在线客户端"></a>在线客户端</h4><p>ABP提供了<strong>IOnlineClientManager</strong>来获取关于在线用户的信息（比如，注入IOnlineClientManager然后使用GetByUserIdOrNull, GetAllClients, IsOnline 方法 ）。为了能够正确地工作，IOnlineClientManager需要一个通讯基础设施。<strong>Abp.Web.SignalR</strong>提供了一个这样的基础设施。因此，如果安装了SignalR，那么在应用的任何层都可以注入并使用IOnlineClientManager。</p><h4 id="PascalCase-vs-camelCase"><a href="#PascalCase-vs-camelCase" class="headerlink" title="PascalCase vs. camelCase"></a>PascalCase vs. camelCase</h4><p>Abp.Web.SignalR包在序列化时使用<strong>CamelCasePropertyNamesContractResolver</strong>覆盖了SignalR默认的 <strong>ContractResolver</strong>。因此，我们在服务端的类具有 <strong>PascalCase</strong>属性，而在客户端作为 <strong>camelCase</strong>使用来发送/接收对象（因为在javascript中camelCase是更受人喜欢的命名）。如果你想在某些程序集中忽略这个，那么你可以将那些程序集添加AbpSignalRContractResolver.IgnoredAssemblies 列表中。</p><h3 id="你自己的SignaR代码"><a href="#你自己的SignaR代码" class="headerlink" title="你自己的SignaR代码###"></a>你自己的SignaR代码###</h3><p><strong>Abp.Web.SignalR</strong> 包也简化了你的SignalR代码。假设我们想添加一个集线器（Hub）到应用程序中：</p><pre class=" language-C#"><code class="language-C#">public class MyChatHub : Hub, ITransientDependency{    public IAbpSession AbpSession { get; set; }    public ILogger Logger { get; set; }    public MyChatHub()    {        AbpSession = NullAbpSession.Instance;        Logger = NullLogger.Instance;    }    public void SendMessage(string message)    {        Clients.All.getMessage(string.Format("User {0}: {1}", AbpSession.UserId, message));    }    public async override Task OnConnected()    {        await base.OnConnected();        Logger.Debug("A client connected to MyChatHub: " + Context.ConnectionId);    }    public async override Task OnDisconnected(bool stopCalled)    {        await base.OnDisconnected(stopCalled);        Logger.Debug("A client disconnected from MyChatHub: " + Context.ConnectionId);    }}</code></pre><p>我们实现了<strong>ITransientDependency</strong>来简化将我们的集线器hub注册到依赖注入系统中（你可以基于你的需求使它是单例的【singleton】）。我们也使用属性注入了session和logger。</p><p><strong>SendMessage</strong>是hub的一个方法，它可以被客户端使用。在这个方法中，我们可以调用所有客户端的 <strong>getMessage</strong>函数。正如你看到的那样，我们可以使用AbpSession来获得当前的用户id(如果用户登录了系统)。为了演示，我们也重写了 <strong>OnConnected 和 OnDisconnected</strong>，实际这里是不需要的。</p><p>这里，客户端的javascript代码使用了我们的集线器hub发送/接收信息。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> chatHub <span class="token operator">=</span> $<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>myChatHub<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//获取 hub的引用</span>chatHub<span class="token punctuation">.</span>client<span class="token punctuation">.</span>getMessage <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//为即将到来的信息注册</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'received message: '</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>abp<span class="token punctuation">.</span>event<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'abp.signalr.connected'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//为连接事件注册</span>chatHub<span class="token punctuation">.</span>server<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">"Hi everybody, I'm connected to the chat!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给服务器发送信息</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>然后，无论何时需要向服务器发送信息，我们都可以使用chatHub。这里再提醒一下，想要获取更多关于SignalR的信息，可以点击查看**<a href="http://www.asp.net/signalr">SinalR文档</a>**。</p><h1 id="基础设施层-1"><a href="#基础设施层-1" class="headerlink" title="基础设施层"></a>基础设施层</h1><h1 id="ABP理论学习之NHibernate集成"><a href="#ABP理论学习之NHibernate集成" class="headerlink" title="ABP理论学习之NHibernate集成"></a><a href="https://www.cnblogs.com/farb/p/ABPNHibernate.html">ABP理论学习之NHibernate集成</a></h1><hr><h2 id="本篇目录-34"><a href="#本篇目录-34" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#nuget">Nuget包</a></strong></li><li><a href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#config">配置</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#mapping">实体映射</a></strong></li></ul></li><li><a href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#repository">仓储</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#base">仓储基类</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#implement">实现仓储</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#custom">自定义仓储方法</a></strong></li></ul></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#seeAlso">阅读其他</a></strong></li></ul><p>ABP可以使用任何ORM框架工作，并且已经内置了<strong>NHibernate</strong>集成。这篇文章会解释如何在ABP中使用NHibernate。阅读本文的前提是假设你已经熟悉了EF的基本知识。</p><h3 id="Nuget包"><a href="#Nuget包" class="headerlink" title="Nuget包###"></a>Nuget包###</h3><p>在ABP中使用NH作为ORM的Nuget包是<strong>Abp.NHibernate</strong>。你应该将它添加到应用程序中。最好在应用程序中分离的程序集(dll)中实现NHibernate，并让该程序集依赖Abp.NHibernate包。</p><h3 id="配置-4"><a href="#配置-4" class="headerlink" title="配置###"></a>配置###</h3><p>要开始使用NHibernate,应该首先要配置它。配置代码应该写在模块的PreInitialize方法中。</p><pre class=" language-C#"><code class="language-C#">[DependsOn(typeof(AbpNHibernateModule))]public class SimpleTaskSystemDataModule : AbpModule{    public override void PreInitialize()    {        var connStr = ConfigurationManager.ConnectionStrings["Default"].ConnectionString;        Configuration.Modules.AbpNHibernate().FluentConfiguration            .Database(MsSqlConfiguration.MsSql2008.ConnectionString(connStr))            .Mappings(m => m.FluentMappings.AddFromAssembly(Assembly.GetExecutingAssembly()));    }    public override void Initialize()    {        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());    }}</code></pre><p><strong>AbpNHibernate</strong>模块为了使ABP能够使用NHibernate工作提供了基本的功能和适配器。</p><h4 id="实体映射"><a href="#实体映射" class="headerlink" title="实体映射"></a>实体映射</h4><p>在下面的样例配置中，使用了当前程序集中的所有映射类进行了流畅地映射。一个映射类的例子如下所示：</p><pre class=" language-C#"><code class="language-C#">public class TaskMap : EntityMap<Task>{    public TaskMap()        : base("TeTasks")    {        References(x => x.AssignedUser).Column("AssignedUserId").LazyLoad();        Map(x => x.Title).Not.Nullable();        Map(x => x.Description).Nullable();        Map(x => x.Priority).CustomType<TaskPriority>().Not.Nullable();        Map(x => x.Privacy).CustomType<TaskPrivacy>().Not.Nullable();        Map(x => x.State).CustomType<TaskState>().Not.Nullable();    }}</code></pre><p><strong>EntityMap</strong>是ABP继承了 <strong>ClassMap</strong>的一个类，它会自动映射 <strong>Id</strong>属性并在构造函数中获得<strong>表名</strong>。因此，我们可以从它派生并使用 **<a href="http://www.fluentnhibernate.org/">FluentNHibernate</a>**映射其他的属性。当然，你可以直接从ClassMap派生，可以使用FluentNHibernate的所有API，也可以使用NHinernate其他的映射技术（比如映射XML文件）。</p><h3 id="仓储"><a href="#仓储" class="headerlink" title="仓储###"></a>仓储###</h3><p>你可以使用仓储的默认实现而不用在项目中创建仓储类。或者可以创建派生自NhRepositoryBase的仓储类。</p><h4 id="仓储基类"><a href="#仓储基类" class="headerlink" title="仓储基类"></a>仓储基类</h4><p>虽然可以从ABP的NhRepositoryBase中派生仓储类，但是最佳实践是创建自己的继承了NhRepositoryBase的基类。这样，我们就可以轻松地将一些公用的方法添加到仓储中了。例子如下：</p><pre class=" language-C#"><code class="language-C#">//所有仓储的基类public abstract class MyRepositoryBase<TEntity, TPrimaryKey> : NhRepositoryBase<TEntity, TPrimaryKey>    where TEntity : class, IEntity<TPrimaryKey>{    protected MyRepositoryBase(ISessionProvider sessionProvider)        : base(sessionProvider)    {    }    //为所有的仓储添加一些公共的方法}//Id为整数的实体的快捷方式public abstract class MyRepositoryBase<TEntity> : MyRepositoryBase<TEntity, int>    where TEntity : class, IEntity<int>{    protected MyRepositoryBase(ISessionProvider sessionProvider)        : base(sessionProvider)    {    }    //不要在这里添加任何方法，在上面的方法中添加（因为该方法继承了上面的方法）}public class TaskRepository : MyRepositoryBase<Task>, ITaskRepository{    public TaskRepository(ISessionProvider sessionProvider)        : base(sessionProvider)    {    }    //这里添加一些task仓储特有的方法}</code></pre><h4 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h4><p>你不需要为实体类创建仓储，只需要使用预定义的仓储方法。例子：</p><pre class=" language-C#"><code class="language-C#">public class PersonAppService : IPersonAppService{    private readonly IRepository<Person> _personRepository;    public PersonAppService(IRepository<Person> personRepository)    {        _personRepository = personRepository;    }    public void CreatePerson(CreatePersonInput input)    {                person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };                _personRepository.Insert(person);    }}</code></pre><p>PersonAppService通过构造函数注入了<strong>IRepository</strong>并使用仓储中的<strong>Insert</strong>方法。使用这种方法，你可以轻松地注入 <strong>IRepository</strong>(或者IRepository&lt;TEntity,TPrimaryKey&gt;)，然后使用预定义的方法。所有预定义的方法列表，请查看**<a href="http://www.cnblogs.com/farb/p/ABPRepository.html">仓储文档</a>**。</p><h4 id="自定义仓储方法"><a href="#自定义仓储方法" class="headerlink" title="自定义仓储方法"></a>自定义仓储方法</h4><p>如果你想添加一些自定义的方法，那么首先应该给它添加仓储接口（这是最佳实践），然后在仓储类中实现。ABP提供了一个基类<strong>NhRepositoryBase</strong>来轻松地实现仓储。要实现仓储接口，只需要从仓储基类中派生仓储就可以了。</p><p>假设我们有一个Task（任务）实体，该任务可以派给一个Person（人）实体，而且Task实体有这么几种状态，包括new,assigned,completed等等。我们可能需要写一个自定义方法来根据一些条件和AssignedPerson来获取任务的列表。看下面的代码：</p><pre class=" language-C#"><code class="language-C#">public interface ITaskRepository : IRepository<Task, long>{    List<Task> GetAllWithPeople(int? assignedPersonId, TaskState? state);}public class TaskRepository : NhRepositoryBase<Task, long>, ITaskRepository{    public TaskRepository(ISessionProvider sessionProvider)        : base(sessionProvider)    {    }    public List<Task> GetAllWithPeople(int? assignedPersonId, TaskState? state)    {        var query = GetAll();        if (assignedPersonId.HasValue)        {            query = query.Where(task => task.AssignedPerson.Id == assignedPersonId.Value);        }        if (state.HasValue)        {            query = query.Where(task => task.State == state);        }        return query            .OrderByDescending(task => task.CreationTime)            .Fetch(task => task.AssignedPerson)            .ToList();    }}</code></pre><p>GetAll()方法返回了<strong>IQueryable</strong>，然后使用给定的参数添加了一些 <strong>Where</strong>过滤。最后使用 **ToList()**获得Tasks的列表。</p><p>你也可以在仓储方法中使用<strong>Session</strong>对象来调用NHibernate的全部API。</p><p>仓储应该在它的构造函数中获得一个ISessionProvider。这样的话，我们就可以在单元测试中轻松地注入一个伪造的session提供者了。在运行时，ABP会自动地注入正确的session提供者。</p><h1 id="ABP理论学习之EntityFramework集成"><a href="#ABP理论学习之EntityFramework集成" class="headerlink" title="ABP理论学习之EntityFramework集成"></a><a href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html">ABP理论学习之EntityFramework集成</a></h1><hr><h2 id="本篇目录-35"><a href="#本篇目录-35" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html#nuget">Nuget包</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html#DbContext">创建DbContext</a></strong></li><li><a href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html#repository">仓储</a><ul><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html#base">仓储基类</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html#implement">实现仓储</a></strong></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html#custom">自定义仓储方法</a></strong></li></ul></li><li><strong><a href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html#seeAlso">阅读其他</a></strong></li></ul><p>ABP可以使用任何ORM框架工作，并且已经内置了<strong>EntityFramework</strong>集成。这篇文章会解释如何在ABP中使用EntityFramework。阅读本文的前提是假设你已经熟悉了EF的基本知识。</p><h3 id="Nuget包-1"><a href="#Nuget包-1" class="headerlink" title="Nuget包###"></a>Nuget包###</h3><p>在ABP中使用EF作为ORM的Nuget包是<strong>Abp.EntityFramework</strong>。你应该将它添加到应用程序中。最好在应用程序中分离的程序集(dll)中实现EntityFramework，并让该程序集依赖Abp.EntityFramework包。</p><h3 id="创建DbContext"><a href="#创建DbContext" class="headerlink" title="创建DbContext###"></a>创建DbContext###</h3><p>要使用EF工作，你应该为应用程序定义一个<strong>DbContext</strong>。定义DbContext的一个例子如下所示：</p><pre class=" language-C#"><code class="language-C#">public class SimpleTaskSystemDbContext : AbpDbContext{    public virtual IDbSet<Person> People { get; set; }    public virtual IDbSet<Task> Tasks { get; set; }    public SimpleTaskSystemDbContext()        : base("MyConnectionStringName")    {            }    protected override void OnModelCreating(DbModelBuilder modelBuilder)    {        base.OnModelCreating(modelBuilder);        modelBuilder.Entity<Person>().ToTable("StsPeople");        modelBuilder.Entity<Task>().ToTable("StsTasks").HasOptional(t => t.AssignedPerson);    }}</code></pre><p>除了派生自<strong>AbpDbContext</strong>而不是DbContext之外，它还是一个常规的DbContext。AbpDbContext的构造函数有很多重载。你可以使用你需要的那个。</p><p>EntityFramework可以以一种惯例的方式将类映射到数据库中对应的表。除非你要做一些自定义的东西，否则你不需要做任何配置。在这个例子中，我们将实体映射到不同的表，默认地，Task实体会映射到<strong>Tasks</strong>表。但是我们将它改成了<strong>StsTasks</strong>表，这里没有用数据注解特性配置，我更喜欢使用流畅的配置。你也可以选择你喜欢的方式。</p><h3 id="仓储-1"><a href="#仓储-1" class="headerlink" title="仓储###"></a>仓储###</h3><p>ABP提供了一个基类<strong>EfRepositoryBase</strong>可以轻松地实现仓储。为了实习IRepository接口，只需要从这个类中派生仓储就可以了。但是最好创建你自己的继承了EfRepositoryBase的基类。这样，你就可以给仓储轻松地添加一些共享的方法了。</p><h4 id="仓储基类-1"><a href="#仓储基类-1" class="headerlink" title="仓储基类"></a>仓储基类</h4><p>一个简单任务系统（SimpleTaskSystem）应用的所有仓储的基类例子如下所示：</p><pre class=" language-C#"><code class="language-C#">//所有仓储的基类public class SimpleTaskSystemRepositoryBase<TEntity, TPrimaryKey> : EfRepositoryBase<SimpleTaskSystemDbContext, TEntity, TPrimaryKey>    where TEntity : class, IEntity<TPrimaryKey>{    public SimpleTaskSystemRepositoryBase(IDbContextProvider<SimpleTaskSystemDbContext> dbContextProvider)        : base(dbContextProvider)    {    }    //为所有的仓储添加一些公共的方法}//Id为整数的实体的快捷方式public class SimpleTaskSystemRepositoryBase<TEntity> : SimpleTaskSystemRepositoryBase<TEntity, int>    where TEntity : class, IEntity<int>{    public SimpleTaskSystemRepositoryBase(IDbContextProvider<SimpleTaskSystemDbContext> dbContextProvider)        : base(dbContextProvider)    {    }    //不要在这里添加任何方法，在上面的方法中添加（因为该方法继承了上面的方法）}</code></pre><p>注意我们是从EfRepositoryBase&lt;SimpleTaskSystemDbContext, TEntity, TPrimaryKey&gt;继承的。这就声明了ABP在仓储中使用的数据上下文是SimpleTaskSystemDbContext。</p><h4 id="默认实现仓储"><a href="#默认实现仓储" class="headerlink" title="默认实现仓储"></a>默认实现仓储</h4><p>你不需要为实体类创建仓储，只需要使用预定义的仓储方法。例子：</p><pre class=" language-C#"><code class="language-C#">public class PersonAppService : IPersonAppService{    private readonly IRepository<Person> _personRepository;    public PersonAppService(IRepository<Person> personRepository)    {        _personRepository = personRepository;    }    public void CreatePerson(CreatePersonInput input)    {                person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };                _personRepository.Insert(person);    }}</code></pre><p>PersonAppService通过构造函数注入了<strong>IRepository</strong>并使用仓储中的<strong>Insert</strong>方法。使用这种方法，你可以轻松地注入 <strong>IRepository</strong>(或者IRepository&lt;TEntity,TPrimaryKey&gt;)，然后使用预定义的方法。所有预定义的方法列表，请查看**<a href="http://www.cnblogs.com/farb/p/ABPRepository.html">仓储文档</a>**。</p><h4 id="自定义仓储方法-1"><a href="#自定义仓储方法-1" class="headerlink" title="自定义仓储方法"></a>自定义仓储方法</h4><p>要实现一个自定义的仓储，只需要从上面创建的仓储基类中派生就可以了。</p><p>假设我们有一个Task（任务）实体，该任务可以派给一个Person（人）实体，而且Task实体有这么几种状态，包括new,assigned,completed等等。我们可能需要写一个自定义方法来根据一些条件和AssignedPerson来获取任务的列表。看下面的代码：</p><pre class=" language-C#"><code class="language-C#">public interface ITaskRepository : IRepository<Task, long>{    List<Task> GetAllWithPeople(int? assignedPersonId, TaskState? state);}public class TaskRepository : SimpleTaskSystemRepositoryBase<Task, long>, ITaskRepository{    public TaskRepository(IDbContextProvider<SimpleTaskSystemDbContext> dbContextProvider)        : base(dbContextProvider)    {    }    public List<Task> GetAllWithPeople(int? assignedPersonId, TaskState? state)    {        var query = GetAll();        if (assignedPersonId.HasValue)        {            query = query.Where(task => task.AssignedPerson.Id == assignedPersonId.Value);        }        if (state.HasValue)        {            query = query.Where(task => task.State == state);        }        return query            .OrderByDescending(task => task.CreationTime)            .Include(task => task.AssignedPerson)            .ToList();    }}</code></pre><p>我们首先定义了一个<strong>ITaskRepository</strong>接口，然后实现了它。GetAll()方法返回了<strong>IQueryable</strong>，然后使用给定的参数添加了一些 <strong>Where</strong>过滤。最后使用 **ToList()**获得Tasks的列表。</p><p>你也可以在仓储方法中使用<strong>Context</strong>对象到达DbContext,然后可以直接使用EF基础设施了。</p><p>仓储应该获得一个IDbContextProvider。这样的话，我们就可以在单元测试中轻松地注入一个伪造的DbContext提供者了。在运行时，ABP会自动地注入正确的DbContext提供者。</p><h3 id="阅读其他"><a href="#阅读其他" class="headerlink" title="阅读其他###"></a>阅读其他###</h3><p>你也可以查看**<a href="http://www.cnblogs.com/farb/p/ABPRepository.html">仓储文档</a>**获取更多关于仓储的知识。</p><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1>]]></content>
      
      
      <categories>
          
          <category> abp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> abp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低代码平台——可视化表单</title>
      <link href="2021/03/20/kaikeba/biao-dan-she-ji-qi/"/>
      <url>2021/03/20/kaikeba/biao-dan-she-ji-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="低代码平台——可视化表单（Avue）"><a href="#低代码平台——可视化表单（Avue）" class="headerlink" title="低代码平台——可视化表单（Avue）"></a>低代码平台——可视化表单（Avue）</h1><h2 id="业务组件——表单开发"><a href="#业务组件——表单开发" class="headerlink" title="业务组件——表单开发"></a>业务组件——表单开发</h2><h2 id="提效利器——低代码平台"><a href="#提效利器——低代码平台" class="headerlink" title="提效利器——低代码平台"></a>提效利器——低代码平台</h2><h3 id="创建开源表单"><a href="#创建开源表单" class="headerlink" title="创建开源表单"></a>创建开源表单</h3><p>​    form-generator</p><p>​    Epage</p><p>​    avue-form-design（基于两个成熟框架进行的可视化升级，ui框架和配置都有成熟的体系）</p><p>​    k-form-design</p><p>优点：拖拉拽，轻松创建表单</p><p>缺点：</p><p>​    排班布局比较不够友好</p><p>​    缺乏流程控制</p><p>​    表单间关联</p><p>​    字典数据不能动态</p><h3 id="核心功能介绍"><a href="#核心功能介绍" class="headerlink" title="核心功能介绍"></a>核心功能介绍</h3><p>element-ui -&gt; Avue-&gt; avue-form-design</p><p>UI框架     配置化前端框架   可视化表单</p><p>Avue 是基于现有element进行的二次封装，简化繁琐操作，核心离线是数据驱动视图，主要的组件库针对表格和表单场景，同时衍生更多企业常用组件，达到高复用，容易维护和扩展的框架。</p><p>内置了丰富数据展示组件</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210320205753968.png" alt="image-20210320205753968"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210320205833721.png" alt="image-20210320205833721"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210320210115508.png" alt="image-20210320210115508"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210320212122440.png" alt="image-20210320212122440"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210320212147281.png" alt="image-20210320212147281"></p><h2 id><a href="#" class="headerlink" title></a></h2><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210320212751926.png" alt="image-20210320212751926"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210320212851703.png" alt="image-20210320212851703"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210320214133631.png" alt="image-20210320214133631"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210320214727015.png" alt="image-20210320214727015"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210320215552203.png" alt="image-20210320215552203"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210320215607143.png" alt="image-20210320215607143"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210320215800766.png" alt="image-20210320215800766"></p><p>渲染引擎——简化使用难度</p><h2 id="表单——校验，数据上传"><a href="#表单——校验，数据上传" class="headerlink" title="表单——校验，数据上传"></a>表单——校验，数据上传</h2><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210320220315383.png" alt="image-20210320220315383"></p>]]></content>
      
      
      <categories>
          
          <category> 可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 低代码平台 </tag>
            
            <tag> 可视化表单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的数学课</title>
      <link href="2021/03/18/la-gou/math/cheng-xu-yuan-de-shu-xue-ke/"/>
      <url>2021/03/18/la-gou/math/cheng-xu-yuan-de-shu-xue-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="程序员的数学课-拉勾笔记"><a href="#程序员的数学课-拉勾笔记" class="headerlink" title="程序员的数学课(拉勾笔记)"></a>程序员的数学课(拉勾笔记)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        复杂度如何计算、某个代码优化是否降低了时间复杂度，或者是动态规划的状态转移方程问题，等等。这的确是在学习数据结构中遇到的困难，但剥离了外壳之后，你会发现本质上都是数学问题</p><p>​        此外，数学还可以帮助你降低代码的复杂度。</p><p>​        我们看一个编程问题。一个数组中，只有数字 obj 出现了一次，其他数字都出现了两次。请查找出 obj，约束为 O(n) 的时间复杂度、O(1) 的空间复杂度</p><p>​        例如在数组 a = [2,1,4,3,4,2,3] 中，则输出 1。因为 2、3、4 都出现了两次，唯独 1 只出现一次。</p><p>​        这是个在无序数组中，涉及与其他元素匹配的查找问题。常规解法的复杂度应该是：O(n²) 时间复杂度、O(1) 空间复杂度，或者 O(n) 时间复杂度、O(n) 空间复杂度。显然，这并不符合题目的约束。</p><p>​        要想解决这个问题，需要借助数学的异或运算。异或有这样两个性质：第一，任何数异或自己为零；第二，任何数异或零，是它自己。借助异或运算，你只需要把数组 a 中所有元素计算一下异或就可以得到 obj 了。实现起来，就是如下所示的 O(n) 时间复杂度的 for 循环，且不需要额外开辟复杂变量。</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>result <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> result <span class="token operator">^</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">print</span> result</code></pre><p>​        如果你是数学专业者，需要追求大而全，但如果是程序员用得上的数学，大而全便会失去意义。工作若干年后的你会发现，很多数学知识学得慢、忘得快，而且工作中还用不到。所以，你应该放弃学生时代学习数学的思路，这里我很建议你遵循以下学习理念。</p><p>​        首先，聚焦自己的工作领域，明确哪些是你必备的。例如，位运算、数学归纳法、最优化算法等。对这些知识的精通，可以奠定你知识体系的基础。此外，所有的学习都要落地在实践。你需要不断复习巩固知识、加深对知识点的理解深度，达到灵活运用的状态。在实际工作中，利用数学思想去解决问题。</p><ul><li><strong>模块一，无处不在的数学思维。</strong> 带你在数制中体验编程，用逻辑工具提升沟通能力，并通过数学思维进行业务决策，再从数学角度出发，重新审视万物背后的数学原理，让你对数学思维有全新认知。</li><li><strong>模块二，编程基础，代数与统计。</strong> 数学作为编程基础，我从“线性代数”“概率论与统计”等基础内容中，精挑细选出程序员必备的数学知识，并结合大量案例讲解，以全新视角带你认识“理论数学”在实际工作中的应用。而这些内容也是之后实战、应用部分的理论基础，便于你之后的学习。</li><li><strong>模块三，数学实战，算法与数据结构。</strong> 算法和数据结构中存在大量的数学问题，脱离数学去孤立地看它们，一定是事倍功半的。在这个模块，我会与你一起复习基础算法，并从数学的角度向你诠释基础算法背后的规律。同时对每个知识点，我还会给出实战场景，加强你的理解深度。</li><li><strong>模块四，数学应用，AI 与机器学习。</strong> AI 是近年来很火的技术方向，其实，把 AI 和机器学习技术的外壳剥开，它就是一个最优化的问题，也就是个数学问题。在这个模块，我会围绕 AI  的几个常用技术点，从数学的角度抽象出它的技术核心。即使你对 AI 还不是很熟悉，也可以从数学的角度，把握住 AI 建模的主要脉络。</li></ul><h2 id="模块一，无处不在的数学思维"><a href="#模块一，无处不在的数学思维" class="headerlink" title="模块一，无处不在的数学思维"></a>模块一，无处不在的数学思维</h2><h3 id="01-从计数开始，程序员必知必会的数制转换法"><a href="#01-从计数开始，程序员必知必会的数制转换法" class="headerlink" title="01 | 从计数开始，程序员必知必会的数制转换法"></a>01 | 从计数开始，程序员必知必会的数制转换法</h3><p>数制</p><p><strong>数制是一种计算数量大小的制度</strong>，也是计数法。用大白话来说，<strong>就是数数的方法</strong>。   </p><p>数制中，最重要的因素是<strong>基数</strong>。假设我们设置基数为 10 来数数，那就是在用十进制计数法；如果设置基数为 2，就是在用二进制计数法。</p><p>不同的数制中，使用最广泛的就是十进制，这与人类有 10 个手指头是密不可分的。人类在学习计数和四则运算时，会通过手指头辅助计算。</p><ul><li>在我国的古代，也曾经使用过十六进制。例如，成语半斤八两的含义是彼此不相上下，实力相当。即半斤就是 8 两，1 斤就是 16 两。</li><li>在时间的计数场景时，我们也用过二十四进制和六十进制。例如，1 天等于 24 小时，1 小时等于 60 分钟，1 分钟等于 60 秒</li></ul><h4 id="不同数制的表达"><a href="#不同数制的表达" class="headerlink" title="不同数制的表达"></a>不同数制的表达</h4><p>​        有了不同的数制，就需要对数制下的数字进行区分，否则就会造成混淆。例如，象征考试得了满分的 100，在十进制下依旧是 100；而在二进制下，它就是十进制下的 4；在八进制，则表示十进制下的 64；在十六进制，则表示十进制下的 256。</p><p>​        所以如果对数字不加以说明，你会发现很难判断这到底是哪个数制下的数字，毕竟同一数字在不同数制下其意义是完全不同的。为了避免混淆，我们对不同数制下的数字做了区分。</p><p>​        十进制使用的数字符号是  [0,1,2,3,4,5,6,7,8,9]；对于二进制和八进制，它们仍然沿用十进制的数字符号。在十六进制中，由于数字符号不够用，这就需要额外补充。一般用 [A,B,C,D,E,F]（一般不会特别区分字母的大小写），分别代表十进制下的 [10,11,12,13,14,15]。</p><ul><li>一般而言，没有额外说明的数字都是十进制下的数字；</li><li>表示二进制时，会用 0b 作为数字的前缀；</li><li>表示八进制时，会用 0o 或者 0 作为数字的前缀；</li><li>表示十六进制时，会用 0x 作为数字的前缀。</li></ul><p>这里 b、o、x 三个英文字母的选择均来自数制的英文单词。</p><p>综上，我们对这几个数制的信息整理如下表：</p><p><img src="https://s0.lgstatic.com/i/image/M00/63/74/CgqCHl-WYACATr-VAAC40XoQFZU944.png" alt="1.png"></p><h4 id="数制转换的方法"><a href="#数制转换的方法" class="headerlink" title="数制转换的方法"></a>数制转换的方法</h4><h5 id="1-换基法（换向十进制）"><a href="#1-换基法（换向十进制）" class="headerlink" title="1. 换基法（换向十进制）"></a>1. 换基法（换向十进制）</h5><p>我们给出数制转换的定量方法，也就是对于任意一个基数 N 进制下的数字 X，它转换为十进制的方法。如下图的公式所示：原进制若是 N 进制，转换时的基数便取 N。例如，将二进制的 X 转化为十进制时，运算时的转换基数便取为 2。</p><p><img src="https://s0.lgstatic.com/i/image/M00/63/69/Ciqc1F-WYCCAOCMMAACEX2a1vNU222.png" alt="2.png"></p><ul><li>我们举个例子，十进制下的 2020。</li></ul><p>它是十进制，所以我们基数便取 10；2020有 4 位数，根据上图公式，我们分别取(4-1)次方、(4-2)次方、(4-3)次方、(4-4)次方，再分别与每位数相乘，再相加取和。</p><p><img src="https://s0.lgstatic.com/i/image/M00/63/69/Ciqc1F-WYCiAGzKgAABcMIWYJfA894.png" alt="3.png"></p><ul><li>再举个例子，二进制下的 10110，利用换基法转换为十进制。</li></ul><p>它原是二进制，所以我们基数便取 2；10110 有 5 位数，根据上图公式，我们分别取(5-1)次方、(5-2)次方、(5-3)次方、(5-4)次方、(5-5)次方，再分别与每位数相乘，再相加取和。</p><p><img src="https://s0.lgstatic.com/i/image/M00/63/74/CgqCHl-WYDWAFnchAABhzdyMebE350.png" alt="4.png"></p><h5 id="2-除余法（十进制向其他进制转换）"><a href="#2-除余法（十进制向其他进制转换）" class="headerlink" title="2. 除余法（十进制向其他进制转换）"></a>2. 除余法（十进制向其他进制转换）</h5><p>转向的目标进制为 N 进制，则以 N 为除数不断地做除法，将最后的商和之前的余数<strong>逆序</strong>串联在一起，就是最终的结果。</p><p>例如，十进制的 19 转换为二进制的过程如下图所示：</p><p><img src="https://s0.lgstatic.com/i/image/M00/63/74/CgqCHl-WYEKAWp8MAABzhu_bTgE812.png" alt="5.png"></p><p>用 19 对 2 做除法得到余数 1，再用商对 2 做除法得到余数 1，再用商对 2 做除法得到余数 0…直到商为 1 结束。最终，用最后的商（也就是1），和过程中所有的余数<strong>逆序</strong>串联在一起，就是最终的结果 10011。</p><p>值得一提的是，除余法除了适用于十进制向二进制的转换，也<strong>适用于十进制向任何数制的转换</strong>。例如，用除余法将十进制的 100，转换为八进制和十六进制的计算过程如下，得到结果分别是 0144 和 0x64。</p><p><img src="https://s0.lgstatic.com/i/image/M00/63/69/Ciqc1F-WYEqAI9leAABAGGC65Co725.png" alt="6.png"></p><p>我们可以给出个简单的证明，根据换基法我们知道某个数制 N 下的数字的十进制表示为：</p><p>我们可以给出个简单的证明，根据换基法我们知道某个数制 N 下的数字的十进制表示为：</p><p><img src="https://s0.lgstatic.com/i/image/M00/63/69/Ciqc1F-WYFOAS0s2AABTeUEt0AY493.png" alt="7.png"></p><p>其中，Xm、Xm-1、…、X1 分别为数字 X 在 N 进制下的每一位数字，也是我们要求解的目标。接着，我们可以计算 X 除以 N。</p><p>这样可以得到，当我们第一次对 N 做除法时，就可以得到商为 N 进制下的 XmXm-1Xm-2…X2，余数就是 X1，即：<br> <img src="https://s0.lgstatic.com/i/image/M00/64/CF/CgqCHl-ZLnKAYGn9AACGBxBvaeQ751.png" alt="WechatIMG237.png"><br> 那么第一次除以 N，是如何得到商为 N 进制下的 XmXm-1Xm-2…X2，余数就是 X1 的呢？你可以通过下图这个 16 进制下的 5321 这个例子理解。<br> <img src="https://s0.lgstatic.com/i/image/M00/65/11/Ciqc1F-aLESAM0L2AAITpDWjzuk862.png" alt="WechatIMG259.png"><br> 这里以 16 进制下的 5321 为例，可以更好地理解这一过程。如果不带入具体数制下的数字，你也可以通过公式推导出来，只是不那么容易理解，不过你自己也可以尝试。</p><p>接着同理，我们再用上一步的商 XmXm-1Xm-2…X2 重复对 N 做除法的过程，就会得到新的商为 N 进制下的 XmXm-1Xm-2…X3 ，余数为 X2 。再同理，重复上面的过程，你会发现得到的余数分别是 X1X2X3…Xm。</p><p>最后，我们把所有的余数做个逆序，就得到了 N 进制下的 X 的每一位，最终就能得到 XmXm-1Xm-2…X1 了。</p><h5 id="3-按位拆分法和按位合并法"><a href="#3-按位拆分法和按位合并法" class="headerlink" title="3. 按位拆分法和按位合并法"></a>3. 按位拆分法和按位合并法</h5><p>对于八进制和二进制之间的转换，你可以利用十进制做个跳板。</p><p><strong>除此之外，还有一个简单的按位拆分法，可以将八进制转为二进制。</strong></p><p>你只需要把原来八进制中的每个数字符号，直接拆分为 <strong>3 位的二进制</strong>数字符号（必须保证是 3 位），再按<strong>顺序</strong>串联起来，就是最终结果。</p><p>我们以八进制下的 023 为例进行讲解：</p><ul><li>由于十进制的 2 的二进制表示是 010；</li><li>十进制的 3 的二进制表示是 011；</li><li>最后，别忘加上二进制的符号 0b，并去掉首位 0。</li></ul><p>则八进制的 023 的二进制表示就是 0b10011，如下图：</p><p><img src="https://s0.lgstatic.com/i/image/M00/63/75/CgqCHl-WYbSARzuZAABfRNDl43E120.png" alt="9.png"></p><p><strong>同理，二进制转换为八进制，可以采用每 3 位合并的按位合并法。</strong></p><p>如下图，二进制的 0b10011 转换为八进制，则<strong>从后往前</strong>每 3 位合并：</p><ul><li>最后 3 位是 011，它是十进制的 3，在八进制也用 3 表示；</li><li>从后往前的两位是 10（不够三位时补“0”则为 10），它是十进制的 2，在八进制也用 2 来表示；</li><li>别忘加上八进制的符号 0o。</li></ul><p>则最终八进制的结果就是 0o23 或 023。</p><p><img src="https://s0.lgstatic.com/i/image/M00/63/75/CgqCHl-WYb2AWnlDAABXQI-u4nk588.png" alt="10.png"></p><p>对于<strong>十六进制和二进制之间的转换</strong>，也可以采用按位合并和按位拆分的方法，区别只是在于需要按<strong>4 位</strong>进行合并或拆分。</p><p>例如下图，十六进制的 0x1a 转换为二进制，由于 1 为 0001，a 为 1010，串联在一起之后，二进制的结果就是 0b11010。</p><p><img src="https://s0.lgstatic.com/i/image/M00/63/6A/Ciqc1F-WYcSAbeioAABXFe3nLms882.png" alt="11.png"></p><p>同样地，二进制的 0b1011101 转换为十六进制，从后往前每 4 位合并：</p><ul><li>最后 4 位是 1101，它是十进制的 13，在十六进制表示为 d；</li><li>往前的几位是 101，十进制和十六进制都用 5 来表示；</li><li>别忘加上十六进制的符号 0x。</li></ul><p>则最终十六进制的结果就是 0x5d。</p><p><img src="https://s0.lgstatic.com/i/image/M00/63/ED/CgqCHl-XgvyAPLFvAABXUh2bCnY315.png" alt="WechatIMG133.png"></p><p>为何八进制与二进制的转换是按照 3 位数合并、拆分，而十六进制与二进制之间则是 4  位数呢？本质原因是在于 2³=8 和 2⁴=16。根据这表达式可以看出，二进制中的 3 个 bit（位），恰好可以表示 0～7 这 8  个数字。因此，按照 3 位合并，就可以从二进制转化到八进制了。同理，按照 4 位合并，就可以从二进制转化到十六进制了。</p><p>而八进制与十六进制之间的转换，就不适用按位合并和按位拆分的方法了，你可以以二进制或十进制为跳板，进行两者之间的转换。</p><h5 id="4-数制转换图"><a href="#4-数制转换图" class="headerlink" title="4. 数制转换图"></a>4. 数制转换图</h5><p>我们总结一下，对于一般的数制之间转换，我们喜欢以十进制来作为跳板。</p><p>其他数制向十进制的转换方法是<strong>换基法</strong>，而十进制向其他数制转换的方法是<strong>除余法</strong>。</p><p>特别地，对于程序员经常关注的二进制、八进制和十六进制之间，它们又有一些特殊的转换方法。二进制向八进制或十六进制的转换，可以采用<strong>按位合并法</strong>；八进制或十六进制向二进制的转换，可以采用<strong>按位拆分法</strong>。</p><p><img src="https://s0.lgstatic.com/i/image/M00/63/6B/Ciqc1F-WYpOAE9r4AAHd7gv5pPI247.png" alt="13.png"></p><h5 id="数制转换与编程"><a href="#数制转换与编程" class="headerlink" title="数制转换与编程"></a>数制转换与编程</h5><p>在编程的时候，利用对不同数制及其转换的性质，往往能让很多复杂问题迎刃而解。最常见的就是二进制下的运算，看下下面的例题。</p><h5 id="【例题】判断一个整数-a，是否是-2-的整数次幂。"><a href="#【例题】判断一个整数-a，是否是-2-的整数次幂。" class="headerlink" title="【例题】判断一个整数 a，是否是 2 的整数次幂。"></a>【例题】判断一个整数 a，是否是 2 的整数次幂。</h5><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210318230239420.png" alt="image-20210318230239420"></p><p>因此这个题目的解法就是，把 a 转换为二进制，看看 bin(a) 的形式是否为一个“1”和若干个“0”构成，代码如下：</p><pre><code>a = 8b = str(bin(a))total = 0for i in range(2,len(b)):    total += int(b[i])if total == 1 and b[2] == &#39;1&#39;:    print &#39;yes&#39;else:    print &#39;no&#39;</code></pre><p>我们对代码进行解读。</p><ul><li>第 1～2 行，变量 a 为待判断的整数；变量 b 是 a 的二进制形式，并且被我们强制转化为 string 类型，这样 b 的值就是 0b1000。</li><li>如果形式为一个“1”和若干个“0”，则需要满足以下两个性质：第一，首位为“1”；第二，所有位加和为“1”。</li><li>在代码中，第 4～6 行，我们计算了所有位数的加和，并保存在 total 变量中。</li><li>在第 8～11 行，我们根据两个性质，对结果进行判断，并打印 yes 或者 no。</li></ul><p>我们还可以利用<strong>位运算的“与”</strong>，来判断二进制数字 x 的形式是否为一个“1”和若干个“0”。判断的方法是，计算 x &amp; (x-1)，如果结果为 0 则是，如果结果非 0 则不是。这样我们可以得到更简单的实现代码，代码如下：</p><pre><code>a = 80if a &amp; (a-1) == 0:    print &#39;yes&#39;else:    print &#39;no&#39;</code></pre><p>​            02 | 逻辑与沟通，怎样才能讲出有逻辑的话？        </p><p>​            2020/10/28            公瑾</p><p>​                    35.65M                </p><p>​                    00:21/13:38                </p><p>​                看视频            </p><p>你好，欢迎来到第 02 课时—— “与”“或”“非”：怎样才能讲出有逻辑的话？</p><p>我们都知道，语言沟通的背后是说话人逻辑思维的过程，单句与单句间、事件与事件间，都是靠关联词联系起来的，所以这节课我将从数学逻辑的角度，向你论述语言沟通背后的原理。</p><p>我将先向你介绍这一课时的根本思维原则 —— MECE 原则，再从“与”“或”“非”“异或”，以及“文氏图”这些运算方式出发，带你深入剖析沟通表达中的关联词。</p><h3 id="02-从日常沟通看逻辑"><a href="#02-从日常沟通看逻辑" class="headerlink" title="02 从日常沟通看逻辑"></a>02 从日常沟通看逻辑</h3><p>在日常的沟通中，代表逻辑关系的词汇有很多，例如“而且”“或者”“但是”“如果…那么…”“因为…所以…”等关联词。</p><p>在我们使用这些词汇的时候，其实都是在表达事件之间的逻辑关系，如果你的逻辑是混乱的或者是不清晰的，就会出现关联词乱用的情况，从而造成沟通效率低下，甚至传递错误信息。</p><p>我们先来看一个例子，事情背景是某个系统需要从 A 环境迁移过渡至 B 环境，大家可以注意一下这段话有什么表达不妥之处。</p><blockquote><p>“为了保证系统的稳定过渡，<strong>并且</strong>保证在过渡期，各个使用方的需求正常迭代，<strong>因此</strong>系统拟定共分为三期：过渡期、实验期、切换期。其中，过渡期采用某技术，保证数据系统打通；实验期通过 AB 实验，验证流程正确。”</p></blockquote><p>从字面来看，我们能脑补出说话者要做什么事情，以及做这些事情的目的和方法。但是，从逻辑的视角来看，上面一段话至少包含了以下几个问题：</p><ul><li>“保证系统的稳定过渡”和“在过渡期内，各个使用方的需求正常迭代”，这二者的语意是包含关系，并不是并列关系，用 <strong>“并且”</strong> 进行连接，不合理。</li><li>为了保证系统的稳定过渡，因此需要分为三期。这里构不成因果关系，用 <strong>“因此”</strong> 进行连接，不合理。</li><li>过渡期怎样怎样，实验期怎样怎样，切换期呢？丢了一个重要环节，不知道需要做什么事情。</li></ul><p><strong>这些问题看似是语文问题，实际是背后思考的逻辑问题。</strong></p><p>而逻辑思维对于程序员的代码编程能力非常重要，所以接下来我将向你介绍“MECE 原则”，帮你提升逻辑能力，MECE 原则非常重要，它将贯穿整个课时内容。</p><h4 id="MECE-原则，提升逻辑思维水平"><a href="#MECE-原则，提升逻辑思维水平" class="headerlink" title="MECE 原则，提升逻辑思维水平"></a>MECE 原则，提升逻辑思维水平</h4><p>MECE 原则（Mutually Exclusive Collectively Exhaustive）的中文意思是“相互独立，完全穷尽”，简而言之，能够做到不重叠、不遗漏，兼顾排他性和完整性。</p><blockquote><p>MECE 原则是麦肯锡提出的一种结构化思考方式，无论是报告撰写，提案演讲，业务分析，它是一种很好的思维方式。</p></blockquote><p>它就像是切比萨一样，一个大比萨，用 4 刀切成了 8 份，每一份之间彼此不重叠（排他）；所有的小比萨不遗漏（完整）地合在一起，又还原了大比萨。</p><p><img src="https://s0.lgstatic.com/i/image/M00/64/46/Ciqc1F-X_WCACPQdAAS8XzplCC8498.png" alt="图片1.png"></p><p>我们来看个例子，公园的票价问题。公园的门票价格是 20 元，优惠票包括了老人票和儿童票。价格制度为：</p><ul><li>不到 10 岁的儿童免费；</li><li>10 岁以上的未成年人半价；</li><li>60 岁及以上的老人免费；</li><li>其他成年人无折扣。</li></ul><p>我们用 MECE 原则来看一下这里的定价制度，就会发现这个制度不满足“不遗漏”“不重叠”的要求。比如，这让 10 岁的小琳很尴尬，她到底是算不到 10 岁免费呢？还是 10 岁以上未成年的半价呢？至少，从上面的描述是看不出来的。</p><p>用程序语言来看，上面价格对应的代码就是：</p><p>复制代码</p><pre><code>org_price = 20age = 10if age &lt; 10:    discount = 0.0if age &gt; 10 and age &lt; 18:    discount = 0.5if age &gt; 60:    discount = 0.0if age &gt;= 18 and age &lt; 60:    discount = 1.0final_price = discount * price</code></pre><p>显然，当 age 为 10 的时候，程序不会走任何一个策略分支，于是代码会出现错误。</p><p>在解决类似的逻辑问题时，<strong>一定要注意所有边界值的可能性</strong>。原则上，每个可行值（尤其是边界值）能且只能落在一个策略分支中。</p><p>一个常用的分析方法就是画线法，如下图所示。画一根数轴，代表所有的可行值，再使用 if 语句分解问题，空心点表示开区间，实心点表示闭区间。</p><p><img src="https://s0.lgstatic.com/i/image/M00/64/51/CgqCHl-X_XKAD9IhAAECj1fCMwQ960.png" alt="图片2.png"></p><p>画线法</p><h4 id="逻辑运算：“与”“或”“非”“异或”"><a href="#逻辑运算：“与”“或”“非”“异或”" class="headerlink" title="逻辑运算：“与”“或”“非”“异或”"></a>逻辑运算：“与”“或”“非”“异或”</h4><p>接着我们来深入到逻辑的运算，首先看一下命题的概念。</p><p><strong>命题是一个描述客观事物的陈述，它包含了正确或错误两个可能性。</strong></p><ul><li>如果命题正确，我们一般用 true 或 1 来表示；</li><li>如果命题错误，我们一般用 false 或 0 来表示。</li></ul><p>有了命题，我们就可以对命题和命题进行逻辑计算。这很像有了数字之后，就有了加减法。逻辑运算的对象是命题，它根据命题的真假进行计算，并且最终再输出真或者假，作为结果。</p><p>逻辑的运算，通常有“与”“或”“非”，以及叠加在这之上的“异或”。</p><h5 id="1-最基础的“与”“或”“非”。"><a href="#1-最基础的“与”“或”“非”。" class="headerlink" title="1.最基础的“与”“或”“非”。"></a>1.最基础的“与”“或”“非”。</h5><ul><li>逻辑 <strong>“与”</strong>—— A 并且 B，在 Python 语言中也记作 A and B。只有命题 A 和命题 B 同时为真的时候，A and B才是真，否则都是假；</li><li>逻辑 <strong>“或”</strong>—— A 或者 B，在 Python 语言中也记作 A or B。命题 A 或者命题 B 有一个为真的时候，A or B 就是真，否则为假；</li><li>逻辑 <strong>“非”</strong>——不是 A，在 Python 语言中也记作 notA。命题 A 为假的时候，not A 就是真，否则为假。</li></ul><p>值得一提的是，在不同学科、不同编程语言中，对于逻辑的“与”“或”“非”的符号表示并不相同，可能的符号有：</p><p><img src="https://s0.lgstatic.com/i/image/M00/64/51/CgqCHl-X_ZaAPWjiAACEuBV6W0U200.png" alt="图片3.png"></p><p>虽然符号不一样，但是计算结果都是一样的。</p><h5 id="2-从文氏图看“异或”"><a href="#2-从文氏图看“异或”" class="headerlink" title="2.从文氏图看“异或”"></a>2.从文氏图看“异或”</h5><p><strong>“异或”\</strong>在 Python 语言中也记作**A^B**。命题 A 和命题 B 的真假不同时，则 A^B 为真，否则为假。一个好的记忆方式是，异为 1，即 A 和 B 的真假性相异（不同），则结果为 1（为真）。</p><p>一个形象判断逻辑关系的方法是，便是<strong>文氏图</strong>，如下图所示，假设在文氏图中有两个命题 A 和 B，用椭圆形的区域表示一个命题为真的地方，而椭圆区域外则表示这个命题为假的区域。</p><p><img src="https://s0.lgstatic.com/i/image/M00/64/46/Ciqc1F-X_Y6AWx9PAACybmhz670044.png" alt="图片4.png"></p><p>文氏图</p><p>通过分析两个命题的椭圆形，在图中的位置关系，就能得到每个运算的结果。接下来，我先用文氏图演示“与”“或”“非”的运算过程，最后再向你讲解什么是“异或”。</p><ul><li><strong>“与” A and B</strong></li></ul><p>根据逻辑运算的定义，如下图所示，A and B 为真的区域就是，椭圆 A 和椭圆 B的交集（蓝色区域）。</p><p><img src="https://s0.lgstatic.com/i/image/M00/64/46/Ciqc1F-X_aiAQY8DAAC51MF7nEY060.png" alt="图片5.png"></p><p>A and B 文氏图</p><ul><li><strong>“或” A or B</strong></li></ul><p>如下图所示，A or B 为真的区域，便是椭圆 A 和椭圆 B 的并集（蓝色区域）。</p><p><img src="https://s0.lgstatic.com/i/image/M00/64/51/CgqCHl-X_bSAMk_NAACS8sN1OUQ850.png" alt="图片6.png"></p><p>A or B 文氏图</p><ul><li><strong>“非” not A</strong></li></ul><p>如下图所示，not A 为真的区域，便是椭圆 A 以外的部分（蓝色区域）：</p><p><img src="https://s0.lgstatic.com/i/image/M00/64/46/Ciqc1F-X_bqAPtn0AACQgR3cvsI153.png" alt="图片7.png"></p><p>not A 文氏图</p><ul><li><strong>“异或” A^B</strong></li></ul><p>A^B，表示 命题 A 和命题 B 的真假不同，也就是真假相异，故是下方文氏图的蓝色区域。</p><p><img src="https://s0.lgstatic.com/i/image/M00/64/51/CgqCHl-X_cKACVmDAADBcVHtKCE265.png" alt="图片8.png"></p><p>A^B 文氏图</p><p>你会发现，<strong>“A^B”\</strong>的蓝色区域，就是上面*<em>“A or B”*</em>区域减去*<em>“A and B”*</em>区域，即**A^B = (A or B) - (A and B)**。</p><p>讲完命题的逻辑运算后，我们进入工作实践场景，向你讲解工作中的命题逻辑处理问题。</p><h4 id="逻辑处理：MECE-原则与代码"><a href="#逻辑处理：MECE-原则与代码" class="headerlink" title="逻辑处理：MECE 原则与代码"></a>逻辑处理：MECE 原则与代码</h4><p>在工作中需要处理命题的逻辑关系时，一定要在满足上文提及的<strong>MECE 原则</strong>的基础上进行代码开发。</p><h5 id="1-不遗漏原则"><a href="#1-不遗漏原则" class="headerlink" title="1.不遗漏原则"></a>1.不遗漏原则</h5><p>当你在处理逻辑关系时，不管有多少个可能的 if 语句，哪怕你觉得你已经在 if 中穷举了所有的可能性，也尽可能用<strong>else</strong>进行一个兜底，<strong>这是对代码潜在风险的规避</strong>。</p><p>例如，下面一段代码从结构来看，它虽然没有错误，但不利于解读、维护。</p><p>复制代码</p><pre><code>def fun(x):    if x == 1:    #命题A        return 1    if x == 2:    #命题B        return 2</code></pre><p>不管命题 A 和命题 B 是否包含了全部的可能性，你都需要用个<strong>else</strong>进行兜底，因此更好的方式是：</p><p>复制代码</p><pre><code>def fun(x):    if x == 1:    #命题A        return 1    if x == 2:    #命题B        return 2    else:    #兜底        return 0</code></pre><h5 id="2-不重复原则"><a href="#2-不重复原则" class="headerlink" title="2.不重复原则"></a>2.不重复原则</h5><p>就说明<strong>每个可能的输入，只能进入唯一 一个策略分支</strong>，否则就有可能造成结果不受控制。这就说明，在代码开发中，尽可能少用多个 if 语句，而改用 elif 语句。</p><blockquote><p>elif 是 else if 的合体，功能上他们二者完全可以互相替代，从逻辑的表达来看，elif 更像是对 if 的兜底。</p></blockquote><p>例如下面一段代码，风格就有些不好，容易引起不必要的代码风险。</p><p>复制代码</p><pre><code>def fun(x,y):    a = 0    if x &lt; y:    #命题A        a = 1    if x &gt;= y:    #命题B        a = 2    else:    #兜底        a = 0    return a</code></pre><p>不管你的命题 A 和命题 B 是否有交集，你都需要尽可能少地使用多个并列无关的 if 语句，而改用 elif，例如：</p><p>复制代码</p><pre><code>def fun(x,y):    a = 0    if x &lt; y:    #命题A        a = 1    elif x &gt;= y:    #命题B        a = 2    else:    #兜底        a = 0    return a</code></pre><p>从数学思维和代码角度，深入了解“逻辑”后，我们重新回到日常沟通中。</p><h4 id="从逻辑回归到沟通"><a href="#从逻辑回归到沟通" class="headerlink" title="从逻辑回归到沟通"></a>从逻辑回归到沟通</h4><p>我们最开始提到了很多日常沟通的词语，例如 “而且” “或者” “但是” “如果…那么…” “因为…所以…”等关联词。</p><p>那么，这些关联词跟我们这个课时讲到的 “与” “或” “非” 有什么关系呢？我们结合逻辑运算和文氏图进行分析。</p><h5 id="1-“而且”与“或者”"><a href="#1-“而且”与“或者”" class="headerlink" title="1.“而且”与“或者”"></a>1.“而且”与“或者”</h5><p>“而且”，顾名思义，就是 A and B。例如，小琳很漂亮（A），同时小琳很聪明（B）。经过逻辑运算后，得到小琳漂亮且聪明（A and B）。</p><p>“或者”，顾名思义，就是 A or B。例如，这个暑期，小琳打算去海南，否则小琳就打算去辽宁。经过逻辑运算后，得到这个暑假，小琳打算去海南或者辽宁（A or B）。</p><p>你可以发现“漂亮”和“聪明”，“海南”和“辽宁”都是相互独立的。所以你在使用“而且”和“或者”沟通时，要注意命题 A 和命题 B 也最好是相互独立的，<strong>也就是 A 与 B 应符合上文讲的 MECE 中的不重复原则。</strong></p><p>下面我将通过三个反例说明问题：</p><ul><li>例1，小琳很聪明漂亮（A），<strong>而且</strong>小琳很聪明（B）。</li></ul><blockquote><p>虽然语义上无误，读者也能理解，但从沟通的角度来看，这句话非常不妥帖。</p></blockquote><ul><li>例2，为了保证系统的稳定过渡（A），并且（即而且）保证在过渡期内，各个使用方的需求正常迭代（B）。</li></ul><blockquote><p>此时，命题 A 显然包括了命题 B，与例1 如出一辙。</p></blockquote><ul><li>例3，小琳是东北人（A），<strong>或者</strong>小琳是北方人（B）。</li></ul><blockquote><p>“北方”包含了“东北”，相互重复，在表达上绕了一个大弯，仅表达小琳是北方人。</p></blockquote><p>通过这三个反例我们可看出，缺乏逻辑性的关联词，虽然不会影响语义表达的正误，但却会让沟通变得冗杂，不够直接明了，从而降低了沟通效率。</p><p>所以，沟通表达与逻辑思维有着直接关系。接下来，我将讲解“因为…所以…”和“虽然…但是…”这对更体现逻辑思维的关联词，也请你好好揣摩一下这对关联词之间的相互逻辑关系。</p><h5 id="2-因为……所以……"><a href="#2-因为……所以……" class="headerlink" title="2.因为……所以……"></a>2.因为……所以……</h5><p>“因为…所以…”，是一种逻辑推理，即由 A 推导出 B。</p><p>“因为…所以…”的文氏图表达如下图所示，A 包含于 B，B 包含了 A，在 A 区域内，也一定会在 B 区域内，因为存在于 A，所以存在于 B，这是个<strong>由“小”推导出“大”</strong> 的过程。</p><p><img src="https://s0.lgstatic.com/i/image/M00/64/51/CgqCHl-X_dWAEtdhAACZZBpouKw150.png" alt="9.png"></p><p>“因为…所以…”文氏图</p><p>在使用“因为…所以…”沟通时，一定要注意命题之间是否具备了<strong>充足的因果关系</strong>。否则，就会出现让人反感的逻辑错误。</p><p>先举一个恰当的例子：</p><blockquote><p>因为小琳聪明漂亮（命题 A），所以小琳很漂亮（命题 B）。</p></blockquote><p>可以看出命题 A 和 命题 B 两者有充足的包含和被包含的因果关系。</p><p>下面再举一个反例：</p><blockquote><p><strong>因为</strong>要保证系统的稳定过渡，并且保证在过渡期内，各个使用方的需求正常迭代，所以系统拟定共分为三期：过渡期、实验期、切换期。</p><p>长话短说，即“因为要保证稳定过渡，所以拆分为三期”。</p></blockquote><p>那么要保证稳定过渡，就必须拆分为三期吗？显然并不是，拆分为四期、五期，全凭开发者自己的设计方案，都是可以的，显然这两者不具备强烈的因果关系。</p><h5 id="3-虽然……但是……"><a href="#3-虽然……但是……" class="headerlink" title="3.虽然……但是……"></a>3.虽然……但是……</h5><p>再来看看“但是”，一般也用作“虽然…但是…”，它表示的是一种转折关系，比如：</p><blockquote><p>虽然小琳学习成绩不好，但她一直很努力。</p></blockquote><p>在人们的潜意识中，成绩好的人一定是努力的人，这就是“<strong>因为</strong>她成绩好（A），<strong>所以</strong>她是个努力的人（B）”的默认关系；反之，努力的人（B），学习成绩不一定很好（非 A），这就构成了转折，于是得到“<strong>虽然</strong>小琳成绩不好（非 A），<strong>但是</strong>她很努力（B）”。</p><p>在这一例子的逻辑过程中，你会发现 <strong>“虽然（非A）…但是（B）…”</strong> 这个关联词与 <strong>“因为（A）…所以（B）…”</strong> 刚好相反。</p><p>正如下图所示，“因为A，所以B”，也可以用作描述“虽然非A，但是B”。</p><p><img src="https://s0.lgstatic.com/i/image/M00/64/51/CgqCHl-X_eCAAfmVAAA8ZXM95Kc406.png" alt="10.png"></p><p>“虽然…但是…”文氏图</p><p>所以我们在验证“虽然…但是…”这个关联词是否使用妥帖时，可以先将其转为因果关系，我会通过以下几个例子向你演示这一过程。</p><ul><li>虽然小琳不是单身（非A），但是她是个东北人（B）。</li></ul><blockquote><p>将这句话转为因果关系，则有“因为小琳是单身（A），所以她是东北人（B）”。显然，这里就构不成任何的因果关系了。（✖️）</p></blockquote><ul><li>虽然小琳成绩不太好（非A），但是她并没有自暴自弃（B）。</li></ul><blockquote><p>将这句话转为因果关系，则有“因为小琳成绩好（A），所以她没有自暴自弃（B）”。显然，这里的因果性很强。这里的“但是”使用得非常恰当。（☑️）</p></blockquote><ul><li>虽然小琳不是单身（非A），但是她的成绩依旧很好（B）。</li></ul><blockquote><p>将这句话转为因果关系，则有“因为小琳是单身（A），所以她的成绩好（B）”。这里的因果性就很弱了，也因此“但是”使用得并不完全恰当。（✖️）</p></blockquote><p>在日常生活中，很多时候的“但是”是被误用的，虽然日常沟通中，不必过度关注这些瑕疵，但在书面语的环境下，就会不太妥帖。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>“怎样才能讲出有逻辑的话？”学完这一课时的你，对这个问题肯定有了自己的答案，并对“逻辑”与“沟通”之间的关系有了更深的理解。</p><p>其实，在日常沟通中的很多场景下，逻辑词的使用并没有那么高的要求，人们往往会根据自己的用词偏好去说话，也不必过度吹毛求疵。</p><p><strong>但是，当你掌握了很好的逻辑思维方式后，你与人沟通表达时，便会更有说服力，沟通效率也会大大提升；分析事物问题时，也会更加周密完善，一针见血。</strong></p><p><strong>比如，当你站在逻辑的视角来重看上文的这些例子时，你就会发现很多逻辑并不规范，尤其是使用了文氏图这一工具之后，你便能一针见血地看到本质，清晰地分析出这些逻辑关系背后的漏洞。</strong></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端工程化实战</title>
      <link href="2021/03/18/ziliao/qianduan/qian-duan-gong-cheng-hua-shi-zhan/"/>
      <url>2021/03/18/ziliao/qianduan/qian-duan-gong-cheng-hua-shi-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h1><h2 id="前端工程化概念"><a href="#前端工程化概念" class="headerlink" title="前端工程化概念"></a>前端工程化概念</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p> js模块</p><p>css模块</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>UI层面拆分</p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>调试，编译，部署，测试，文档化</p><h3 id="规范性"><a href="#规范性" class="headerlink" title="规范性"></a>规范性</h3><p>项目结构，语法提示，编码风格规范，联调规范，命名规范，代码样式规范，gitflow</p><h2 id="实战步骤"><a href="#实战步骤" class="headerlink" title="实战步骤"></a>实战步骤</h2><p>搭建 npm init -y</p><h2 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h2><p><strong>vue组件与插件</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"X-UA-Compatible"</span> content<span class="token operator">=</span><span class="token string">"IE=edge"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1.0"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span>Document<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> vue引入 <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://unpkg.com/vue@next"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"/node_modules/vue/dist/vue.global.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span> <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>script<span class="token operator">></span>        <span class="token keyword">const</span> <span class="token punctuation">{</span>            createApp<span class="token punctuation">,</span>            reactive<span class="token punctuation">,</span>            computed<span class="token punctuation">,</span>            watchEffect        <span class="token punctuation">}</span> <span class="token operator">=</span> Vue<span class="token punctuation">;</span>        <span class="token keyword">const</span> MyButton <span class="token operator">=</span> <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'MyButton'</span><span class="token punctuation">,</span>            data<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token punctuation">{</span>                    count<span class="token punctuation">:</span> <span class="token number">0</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            template<span class="token punctuation">:</span> <span class="token string">'&lt;button v-on:click="count++">click me {{count}}&lt;/button>'</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//添加为一个插件  实现插件实现install </span>        MyButton<span class="token punctuation">.</span>install <span class="token operator">=</span> app <span class="token operator">=</span><span class="token operator">></span> app<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'MyButton'</span><span class="token punctuation">,</span> MyButton<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//组件库</span>        <span class="token keyword">const</span> Element <span class="token operator">=</span> <span class="token punctuation">{</span>            MyButton<span class="token punctuation">,</span>            install<span class="token punctuation">:</span> app <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>MyButton<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> MyComponet <span class="token operator">=</span> <span class="token punctuation">{</span>            template<span class="token punctuation">:</span> <span class="token string">'&lt;my-button/>'</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">createApp</span><span class="token punctuation">(</span>MyComponet<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Element<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre><p>扩展插件的实现</p><p><strong>rollup打包</strong>：适用于库应用的构建工具，更适合打包</p><p>数据拆分</p><pre><code>yarn add vue@nextyarn add @vue/compiler-sfc  # vue单文件组件yarn add @balbe/core     # babel核心yarn add @rollup/plugin-babel  yarn add rollup-plugin-terser  # 压缩代码yarn add rollup-pluginutils</code></pre><p>格式声明 AMD CMD UMD区别</p><p>amd 异步模块定义，用于向RequireJS这样的模块加载器</p><p>cjs  适用于node 和browserify/webpack</p><p>es  将软件包保存为ES模块文件</p><p>life 一个自动执行的功能，适合作为<script>标签</p><p>UMD 通用模块定义，以amd.cjs.life为一体</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> babel <span class="token keyword">from</span> <span class="token string">"@rollup/plugin-babel"</span><span class="token keyword">import</span> vuePlugin <span class="token keyword">from</span> <span class="token string">"rollup-plugin-vue"</span><span class="token keyword">import</span> <span class="token punctuation">{</span> terser <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"rollup-plugin-terser"</span><span class="token keyword">const</span> es <span class="token operator">=</span> <span class="token punctuation">{</span>    input<span class="token punctuation">:</span> <span class="token string">"src/entry.js"</span><span class="token punctuation">,</span>    oninput<span class="token punctuation">:</span> <span class="token punctuation">{</span>        file<span class="token punctuation">:</span> <span class="token string">"dist/index.bundle.js"</span><span class="token punctuation">,</span>        name<span class="token punctuation">:</span> <span class="token string">"Element"</span><span class="token punctuation">,</span>        format<span class="token punctuation">:</span> <span class="token string">"es"</span><span class="token punctuation">,</span>        globals<span class="token punctuation">:</span> <span class="token punctuation">{</span>            vue<span class="token punctuation">:</span> <span class="token string">"Vue"</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    external<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"Vue"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token function">babel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">vuePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            css<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> iife <span class="token operator">=</span> <span class="token punctuation">{</span>    input<span class="token punctuation">:</span> <span class="token string">"src/entry.js"</span><span class="token punctuation">,</span>    oninput<span class="token punctuation">:</span> <span class="token punctuation">{</span>        file<span class="token punctuation">:</span> <span class="token string">"dist/index.js"</span><span class="token punctuation">,</span>        name<span class="token punctuation">:</span> <span class="token string">"Element"</span><span class="token punctuation">,</span>        format<span class="token punctuation">:</span> <span class="token string">"iife"</span><span class="token punctuation">,</span>        globals<span class="token punctuation">:</span> <span class="token punctuation">{</span>            vue<span class="token punctuation">:</span> <span class="token string">"Vue"</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    external<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"Vue"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token function">babel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">vuePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            css<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> minEs <span class="token operator">=</span> <span class="token punctuation">{</span>    input<span class="token punctuation">:</span> <span class="token string">"src/entry.js"</span><span class="token punctuation">,</span>    oninput<span class="token punctuation">:</span> <span class="token punctuation">{</span>        file<span class="token punctuation">:</span> <span class="token string">"dist/index.min.js"</span><span class="token punctuation">,</span>        name<span class="token punctuation">:</span> <span class="token string">"Element"</span><span class="token punctuation">,</span>        format<span class="token punctuation">:</span> <span class="token string">"umd"</span><span class="token punctuation">,</span>        globals<span class="token punctuation">:</span> <span class="token punctuation">{</span>            vue<span class="token punctuation">:</span> <span class="token string">"Vue"</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    external<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"Vue"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token function">babel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">vuePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            css<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> cjs <span class="token operator">=</span> <span class="token punctuation">{</span>    input<span class="token punctuation">:</span> <span class="token string">"src/entry.js"</span><span class="token punctuation">,</span>    oninput<span class="token punctuation">:</span> <span class="token punctuation">{</span>        file<span class="token punctuation">:</span> <span class="token string">"dist/index.cjs.js"</span><span class="token punctuation">,</span>        name<span class="token punctuation">:</span> <span class="token string">"Element"</span><span class="token punctuation">,</span>        format<span class="token punctuation">:</span> <span class="token string">"cjs"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    external<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"Vue"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token function">babel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">vuePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            css<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//多个配置集合</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">[</span>es<span class="token punctuation">,</span> iife<span class="token punctuation">,</span> minEs<span class="token punctuation">,</span> cjs<span class="token punctuation">]</span></code></pre><p>项目目录结构</p><pre><code>build #编译脚本coverage # 覆盖率报告examples #代码范例lib #css样式 编译后packages #组件代码scripts #脚本，发布，提交信息src #通用代码test # 测试types #ts类型定义</code></pre><p>文件命名规范</p><h2 id="1模块化和组件化"><a href="#1模块化和组件化" class="headerlink" title="1模块化和组件化"></a>1模块化和组件化</h2><p>编写button组件</p><p>继承babel</p><pre class=" language-javascript"><code class="language-javascript">yarn add babelyarn add babel<span class="token operator">-</span>plugin<span class="token operator">-</span>syntax<span class="token operator">-</span>dynamic<span class="token operator">-</span><span class="token keyword">import</span>yarn add babel<span class="token operator">-</span>plugin<span class="token operator">-</span>syntax<span class="token operator">-</span>jsxyarn add babel<span class="token operator">-</span>preset<span class="token operator">-</span>envyarn add @babel<span class="token operator">/</span>plugin<span class="token operator">-</span>proposal<span class="token operator">-</span>optional<span class="token operator">-</span>chainingyarn add @babel<span class="token operator">/</span>preset<span class="token operator">-</span>envyarn add @vue<span class="token operator">/</span>babel<span class="token operator">-</span>plugin<span class="token operator">-</span>jsx</code></pre><p>.babelrc</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  <span class="token string">"presets"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"@babel/preset-env"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string">"targets"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token string">"node"</span><span class="token punctuation">:</span> <span class="token string">"current"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">"plugins"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token string">"syntax-dynamic-import"</span><span class="token punctuation">,</span>    <span class="token string">"@ant-design-vue/babel-plugin-jsx"</span><span class="token punctuation">,</span>    <span class="token string">"@babel/plugin-proposal-optional-chaining"</span><span class="token punctuation">,</span>    <span class="token string">"@babel/plugin-proposal-nullish-coalescing-operator"</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">"env"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"utils"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token string">"presets"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">[</span>          <span class="token string">"env"</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token string">"loose"</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            <span class="token string">"modules"</span><span class="token punctuation">:</span> <span class="token string">"commonjs"</span><span class="token punctuation">,</span>            <span class="token string">"targets"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>              <span class="token string">"browsers"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"> 1%"</span><span class="token punctuation">,</span> <span class="token string">"last 2 versions"</span><span class="token punctuation">,</span> <span class="token string">"not ie &lt;= 8"</span><span class="token punctuation">]</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">]</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token string">"plugins"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">[</span>          <span class="token string">"module-resolver"</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token string">"root"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"element-ui"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token string">"alias"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>              <span class="token string">"element-ui/src"</span><span class="token punctuation">:</span> <span class="token string">"element-ui/lib"</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">]</span>      <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"test"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token string">"plugins"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"istanbul"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token string">"presets"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"env"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string">"targets"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token string">"node"</span><span class="token punctuation">:</span> <span class="token string">"current"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"esm"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token string">"presets"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"@babel/preset-env"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string">"modules"</span><span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>继承VTU</p><pre><code>yarn add jextyarn add vue-jext@5.0.0~alpha.5yarn add babel-jextyarn add @vue/compiler-sfc@3.0.2yarn add @vue/test-utils@nextyarn add typescript</code></pre><p>jest.config.js</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    testEnvironment<span class="token punctuation">:</span> <span class="token string">'jsdom'</span><span class="token punctuation">,</span>    roots<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token string">'&lt;rootDir>/src'</span><span class="token punctuation">,</span>        <span class="token string">'&lt;rootDir>/packages'</span><span class="token punctuation">,</span>        <span class="token string">'&lt;rootDir>/test'</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    transform<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">'^.+\\.vue$'</span><span class="token punctuation">:</span> <span class="token string">'vue-jest'</span><span class="token punctuation">,</span>        <span class="token string">'^.+\\js$'</span><span class="token punctuation">:</span> <span class="token string">'babel-jest'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    moduleFileExtensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'vue'</span><span class="token punctuation">,</span> <span class="token string">'js'</span><span class="token punctuation">,</span> <span class="token string">'json'</span><span class="token punctuation">,</span> <span class="token string">'jsx'</span><span class="token punctuation">,</span> <span class="token string">'ts'</span><span class="token punctuation">,</span> <span class="token string">'tsx'</span><span class="token punctuation">,</span> <span class="token string">'node'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    testMatch<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'**/tests/**/?(*.)+(test).[jt]s?(x)'</span><span class="token punctuation">,</span> <span class="token string">'**/__tests__/**/*.spec.js'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    moduleNameMapper<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">'^element-ui(.*)$'</span><span class="token punctuation">:</span> <span class="token string">'&lt;rootDir>$1'</span><span class="token punctuation">,</span>        <span class="token string">'^main(.*)$'</span><span class="token punctuation">:</span> <span class="token string">'&lt;rootDir>/src$1'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>样式打包</p><p>Rolup打包</p><p>编写Entry入口</p><p>验证</p><p>文档自动化 storybook</p><p>规范性检查 yarn add <a href="mailto:&#x68;&#117;&#x73;&#x6b;&#x79;&#64;&#x34;&#46;&#x33;&#x2e;&#48;">&#x68;&#117;&#x73;&#x6b;&#x79;&#64;&#x34;&#46;&#x33;&#x2e;&#48;</a></p><p>回归测试 .github/workflows.mian.yml</p><p>持续继承ci   TravicCi网站</p><p>hexo 扩展开发</p></script></p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-filter</title>
      <link href="2021/03/18/ziliao/javascript/javascript-filter/"/>
      <url>2021/03/18/ziliao/javascript/javascript-filter/</url>
      
        <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><h1 id="JavaScript-filter"><a href="#JavaScript-filter" class="headerlink" title="JavaScript-filter"></a>JavaScript-filter</h1><p>for 和 filter 的效率哪个更高？<br>HYeeee 2020-12-03 15:57:18 166 收藏<br>分类专栏： 前端实践 文章标签： for filter<br>版权<br>测试代码</p><p>假使我们现在需要对一个数组进行过滤，过滤掉其中为0的部分，用作比较的for循环和filter的代码如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">var</span> result1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>result<span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'for循环'</span><span class="token punctuation">)</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'for循环'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'filter'</span><span class="token punctuation">)</span><span class="token keyword">var</span> s <span class="token operator">=</span> result1<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> item <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'filter'</span><span class="token punctuation">)</span></code></pre><pre><code>123456789101112131415</code></pre><p>使用chrome浏览器对其进行测试：<br>当测试数据全为1或者全为0时<br>类型    数量    时间<br>for循环    10    0.011962890625 ms<br>filter    10    0.02099609375 ms<br>for循环    100    0.053955078125 ms<br>filter    100    0.031005859375 ms<br>for循环    1000    0.22900390625 ms<br>filter    1000    0.05712890625 ms<br>for循环    10000    2.56396484375 ms<br>filter    10000    0.31396484375 ms<br>for循环    100000    3.81103515625 ms<br>filter    100000    4.214111328125 ms<br>for循环    1000000    20.89599609375 ms<br>filter    1000000    35.605224609375 ms</p><p>当数量级小于10，或者到10^5之后，for会比filter更快。数量级越高，差距越大。<br>当测试数据0,1各半时<br>类型    数量    时间<br>for循环    10    0.010986328125 ms<br>filter    10    0.022216796875 ms<br>for循环    100    0.0390625 ms<br>filter    100    0.029052734375 ms<br>for循环    1000    0.10595703125 ms<br>filter    1000    0.0419921875 ms<br>for循环    10000    0.625244140625 ms<br>filter    10000    0.182373046875 ms<br>for循环    100000    4.83203125 ms<br>filter    100000    2.058837890625 ms<br>for循环    1000000    9.954833984375 ms<br>filter    1000000    20.64892578125 ms</p><p>当数量级小于10或者到10^6之后，for会比filter更快。数量级越高，差距越大，如10^7时，filter 的时间是for的两倍。<br>新数组还是原数组</p><p>当然，这个比较的受限于这个for循环内部如何实现，你可以选择使用splice删除为0的数，也可以像我这样重新开一个数组。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        result<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>        i<span class="token operator">--</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">for</span>循环<span class="token punctuation">:</span> <span class="token number">11.97509765625</span> msfilter<span class="token punctuation">:</span> <span class="token number">174.044921875</span> ms或者新开一个数组：<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">for</span>循环<span class="token punctuation">:</span> <span class="token number">93.5498046875</span> msfilter<span class="token punctuation">:</span> <span class="token number">176.57080078125</span> ms</code></pre><pre><code>123456789101112131415161718</code></pre><p>由于数量级增大，维护新开的数组需要耗时更多，对于这两种写法，如果不是一定要一个新数组的情况下，更推荐第一种，在原数组删除，相同数量级下，for循环的耗时更短，</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端工程化</title>
      <link href="2021/03/16/ziliao/qianduan/qian-duan-gong-cheng-hua/"/>
      <url>2021/03/16/ziliao/qianduan/qian-duan-gong-cheng-hua/</url>
      
        <content type="html"><![CDATA[<p>前端工程化</p><p>前后端</p><p>lowcode</p><p>前端客户端融合</p><p>hybrid</p><p>React Native</p><p>Flutter</p><p>小程序</p><p>从目标出发，分析问题解决问题</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三面谷歌前，熬夜总结了玩转 Leetcode 的办法</title>
      <link href="2021/03/16/ziliao/suanfa/san-mian-gu-ge-qian-ao-ye-zong-jie-wan-zhuan-leetcode-de-ban-fa/"/>
      <url>2021/03/16/ziliao/suanfa/san-mian-gu-ge-qian-ao-ye-zong-jie-wan-zhuan-leetcode-de-ban-fa/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是小齐。</p><p>最近在网上看到了篇关于算法解题套路，作者总结了 14 种算法模式，我看完了觉得太赞了，所以特此分享给大家一起学习。</p><p>后面我也会继续出算法系列的文章，比如搜索算法、DP，大家有什么特别想看的也可以留言告诉我。</p><p>现在也是拿完年终奖跳槽面试的季节，大家在面试之前配合这份解题套路复习，以及我的算法系列文章，定能让你事半功倍。</p><p>点击这里回顾我的算法系列👉：**<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&album_id=1337155274347692033&__biz=MzIzNDQ3MzgxMw==#wechat_redirect">齐姐聊算法</a>系列**</p><p><strong>作者：Fahim ul Haq</strong></p><p>咱们在面试时通常需要通过算法面试的过程，然而这些问题往往与日常工作没有太大的关系，只会额外增添压力。</p><p>曾在 Facebook 和微软工作过的 Educative.io 创始人 Fahim ul Haq 近日发文总结了编程<strong>面试所遇到的问题的 14 种最常见的模式</strong>，也许能帮你看清各种编程面试问题「背后的真相」。</p><p>这种现状导致了一个后果：现在的开发者往往需要花费数周时间在 LeetCode 等网站上了解综合数百个问题。与我谈过的开发者在面试前的一个常见焦虑问题是：我是否已经解决过足够多的实际问题？我本可以做到更多吗？</p><p>这就是我想要帮助开发者了解每个问题背后的底层模式的原因——这样他们就<strong>不必担忧解决数百个问题以及被 LeetCode 整得疲惫不堪了</strong>。如果你理解面试的通用模式，你就可以将其用作模板，从而解决各种层级的稍有不同的问题。</p><p>这里我将列出最常见的 14 种模式，它们可被用于解决任何编程面试问题。另外我还会说明如何识别每种模式，并会为每种模式提供一些问题示例。</p><p>我们今天将说明以下 14 种模式：</p><p>1．滑动窗口<br>2．二指针或迭代器<br>3．快速和慢速指针或迭代器<br>4．合并区间<br>5．循环排序<br>6．原地反转链表<br>7．树的宽度优先搜索（Tree BFS）<br>8．树的深度优先搜索（Tree DFS）<br>9．Two Heaps<br>10．子集<br>11．经过修改的二叉搜索<br>12． 前 K 个元素<br>13． K 路合并<br>14．拓扑排序</p><p>开始吧！</p><p><strong>1．滑动窗口</strong></p><p>滑动窗口模式是用于在给定数组或链表的特定窗口大小上执行所需的操作，比如寻找包含所有 1 的最长子数组。从第一个元素开始滑动窗口并逐个元素地向右滑，并根据你所求解的问题调整窗口的长度。在某些情况下窗口大小会保持恒定，在其它情况下窗口大小会增大或减小。</p><p><img src="../../../../../../images/image-20210316081228540.png" alt="image-20210316081228540"></p><p>下面是一些你可以用来确定给定问题可能需要滑动窗口的方法：</p><ul><li>问题的输入是一种线性数据结构，比如链表、数组或字符串</li><li>你被要求查找最长/最短的子字符串、子数组或所需的值</li></ul><p>你可以使用滑动窗口模式处理的常见问题：</p><ul><li>大小为 K 的子数组的最大和（简单）</li><li>带有 K 个不同字符的最长子字符串（中等）</li><li>寻找字符相同但排序不一样的字符串（困难）</li></ul><p><strong>2．二指针或迭代器</strong></p><p>二指针（Two Pointers）是这样一种模式：两个指针以一前一后的模式在数据结构中迭代，直到一个或两个指针达到某种特定条件。二指针通常在排序数组或链表中搜索配对时很有用；比如当你必须将一个数组的每个元素与其它元素做比较时。</p><p>二指针是很有用的，因为如果只有一个指针，你必须继续在数组中循环回来才能找到答案。这种使用单个迭代器进行来回在时间和空间复杂度上都很低效——这个概念被称为「渐进分析（asymptotic analysis）」。尽管使用 1 个指针进行暴力搜索或简单普通的解决方案也有效果，但这会沿 O(n²) 线得到一些东西。在很多情况中，二指针有助于你寻找有更好空间或运行时间复杂度的解决方案。</p><p><img src="../../../../../../images/image-20210316081249265.png" alt="image-20210316081249265"></p><p>用于识别使用二指针的时机的方法：</p><ul><li>可用于你要处理排序数组（或链接列表）并需要查找满足某些约束的一组元素的问题</li><li>数组中的元素集是配对、三元组甚至子数组</li></ul><p>下面是一些满足二指针模式的问题：</p><ul><li>求一个排序数组的平方（简单）</li><li>求总和为零的三元组（中等）</li><li>比较包含回退（backspace）的字符串（中等）</li></ul><p><strong>3．快速和慢速指针</strong></p><p>快速和慢速指针方法也被称为 Hare &amp; Tortoise 算法，该算法会使用两个在数组（或序列/链表）中以不同速度移动的指针。该方法在处理循环链表或数组时非常有用。</p><p>通过以不同的速度进行移动（比如在一个循环链表中），该算法证明这两个指针注定会相遇。只要这两个指针在同一个循环中，快速指针就会追赶上慢速指针。</p><p><img src="../../../../../../images/image-20210316081306812.png" alt="image-20210316081306812"></p><p>如何判别使用快速和慢速模式的时机？</p><ul><li>处理链表或数组中的循环的问题</li><li>当你需要知道特定元素的位置或链表的总长度时</li></ul><p>何时应该优先选择这种方法，而不是上面提到的二指针方法？</p><ul><li>有些情况不适合使用二指针方法，比如在不能反向移动的单链接链表中。使用快速和慢速模式的一个案例是当你想要确定一个链表是否为回文（palindrome）时。</li></ul><p>下面是一些满足快速和慢速指针模式的问题：</p><ul><li>链表循环（简单）</li><li>回文链表（中等）</li><li>环形数组中的循环（困难）</li></ul><p><strong>4．合并区间</strong></p><p>合并区间模式是一种处理重叠区间的有效技术。在很多涉及区间的问题中，你既需要找到重叠的区间，也需要在这些区间重叠时合并它们。该模式的工作方式为：</p><p>给定两个区间（a 和 b），这两个区间有 6 种不同的互相关联的方式：</p><p><img src="../../../../../../images/image-20210316081321397.png" alt="image-20210316081321397"></p><p>理解并识别这六种情况有助于你求解范围广泛的问题，从插入区间到优化区间合并等。</p><p>那么如何确定何时该使用合并区间模式呢？</p><ul><li>如果你被要求得到一个仅含互斥区间的列表</li><li>如果你听到了术语「重叠区间（overlapping intervals）」</li></ul><p>合并区间模式的问题：</p><ul><li>区间交叉（中等）</li><li>最大 CPU 负载（困难）</li></ul><p><strong>5. 循环排序</strong></p><p>这一模式描述了一种有趣的方法，处理的是涉及包含给定范围内数值的数组的问题。循环排序模式一次会在数组上迭代一个数值，如果所迭代的当前数值不在正确的索引处，就将其与其正确索引处的数值交换。你可以尝试替换其正确索引处的数值，但这会带来 O(n^2) 的复杂度，这不是最优的，因此要用循环排序模式。</p><p><img src="../../../../../../images/image-20210316081344715.png" alt="image-20210316081344715"></p><p>如何识别这种模式？</p><ul><li>涉及数值在给定范围内的排序数组的问题</li><li>如果问题要求你在一个排序/旋转的数组中找到缺失值/重复值/最小值</li></ul><p>循环排序模式的问题：</p><ul><li>找到缺失值（简单）</li><li>找到最小的缺失的正数值（中等）</li></ul><p><strong>6．原地反转链表</strong></p><p>在很多问题中，你可能会被要求反转一个链表中一组节点之间的链接。通常而言，你需要原地完成这一任务，即使用已有的节点对象且不占用额外的内存。这就是这个模式的用武之地。该模式会从一个指向链表头的变量（current）开始一次反转一个节点，然后一个变量（previous）将指向已经处理过的前一个节点。以锁步的方式，在移动到下一个节点之前将其指向前一个节点，可实现对当前节点的反转。另外，也将更新变量「previous」，使其总是指向已经处理过的前一个节点。</p><p><img src="../../../../../../images/image-20210316081359530.png" alt="image-20210316081359530"></p><p>如何识别使用该模式的时机：</p><ul><li>如果你被要求在不使用额外内存的前提下反转一个链表</li></ul><p>原地反转链表模式的问题：</p><ul><li>反转一个子列表（中等）</li><li>反转每个 K 个元素的子列表（中等）</li></ul><p><strong>7．树的宽度优先搜索（Tree BFS）</strong></p><p>该模式基于宽度优先搜索（BFS）技术，可遍历一个树并使用一个队列来跟踪一个层级的所有节点，之后再跳转到下一个层级。任何涉及到以逐层级方式遍历树的问题都可以使用这种方法有效解决。</p><p>Tree BFS 模式的工作方式是：将根节点推至队列，然后连续迭代知道队列为空。在每次迭代中，我们移除队列头部的节点并「访问」该节点。在移除了队列中的每个节点之后，我们还将其所有子节点插入到队列中。</p><p>如何识别 Tree BFS 模式：</p><ul><li>如果你被要求以逐层级方式遍历（或按层级顺序遍历）一个树</li></ul><p>Tree BFS 模式的问题：</p><ul><li>二叉树层级顺序遍历（简单）</li><li>之字型遍历（Zigzag Traversal）（中等）</li></ul><p><strong>8．树的深度优先搜索（Tree DFS）</strong></p><p>Tree DFS 是基于深度优先搜索（DFS）技术来遍历树。</p><p>你可以使用递归（或该迭代方法的技术栈）来在遍历期间保持对所有之前的（父）节点的跟踪。</p><p>Tree DFS 模式的工作方式是从树的根部开始，如果这个节点不是一个叶节点，则需要做三件事：</p><p>1．决定现在是处理当前的节点（pre-order），或是在处理两个子节点之间（in-order），还是在处理两个子节点之后（post-order）</p><ol><li>为当前节点的两个子节点执行两次递归调用以处理它们</li></ol><p>如何识别 Tree DFS 模式：</p><ul><li>如果你被要求用 in-order、pre-order 或 post-order DFS 来遍历一个树</li><li>如果问题需要搜索其中节点更接近叶节点的东西</li></ul><p>Tree DFS 模式的问题：</p><ul><li>路径数量之和（中等）</li><li>一个和的所有路径（中等）</li></ul><p><strong>9. Two Heaps</strong></p><p>在很多问题中，我们要将给定的一组元素分为两部分。为了求解这个问题，我们感兴趣的是了解一部分的最小元素以及另一部分的最大元素。这一模式是求解这类问题的一种有效方法。该模式要使用两个堆（heap）：一个用于寻找最小元素的 Min Heap 和一个用于寻找最大元素的 Max Heap。该模式的工作方式是：先将前一半的数值存储到 Max Heap，这是由于你要寻找前一半中的最大数值。然后再将另一半存储到 Min Heap，因为你要寻找第二半的最小数值。在任何时候，当前数值列表的中间值都可以根据这两个 heap 的顶部元素计算得到。</p><p>识别 Two Heaps 模式的方法：</p><ul><li>在优先级队列、调度等场景中有用</li><li>如果问题说你需要找到一个集合的最小/最大/中间元素</li><li>有时候可用于具有二叉树数据结构的问题</li></ul><p>Two Heaps 模式的问题：</p><ul><li>查找一个数值流的中间值（中等）</li></ul><p><strong>10. 子集</strong></p><p>很多编程面试问题都涉及到处理给定元素集合的排列和组合。子集（Subsets）模式描述了一种用于有效处理所有这些问题的宽度优先搜索（BFS）方法。</p><p>该模式看起来是这样：</p><p>给定一个集合 [1, 5, 3]</p><p>1． 从一个空集开始：[[]]<br>2．向所有已有子集添加第一个数 (1)，从而创造新的子集：[[], [1]]<br>3．向所有已有子集添加第二个数 (5)：[[], [1], [5], [1,5]]<br>4．向所有已有子集添加第三个数 (3)：[[], [1], [5], [1,5], [3], [1,3], [5,3], [1,5,3]]</p><p>下面是这种子集模式的一种视觉表示：</p><p><img src="../../../../../../images/image-20210316081414056.png" alt="image-20210316081414056"></p><p>如何识别子集模式：</p><ul><li>你需要找到给定集合的组合或排列的问题</li></ul><p>子集模式的问题：</p><ul><li>带有重复项的子集（简单）</li><li>通过改变大小写的字符串排列（中等）</li></ul><p><strong>11. 经过修改的二叉搜索</strong></p><p>只要给定了排序数组、链表或矩阵，并要求寻找一个特定元素，你可以使用的最佳算法就是二叉搜索。这一模式描述了一种用于处理所有涉及二叉搜索的问题的有效方法。</p><p>对于一个升序的集合，该模式看起来是这样的：</p><p>1．首先，找到起点和终点的中间位置。寻找中间位置的一种简单方法是：middle = (start + end) / 2。但这很有可能造成整数溢出，所以推荐你这样表示中间位置：middle = start + (end — start) / 2。<br>2．如果键值（key）等于中间索引处的值，那么返回这个中间位置。<br>3．如果键值不等于中间索引处的值：<br>4．检查 key &lt; arr[middle] 是否成立。如果成立，将搜索约简到 end = middle — 15．检查 key &gt; arr[middle] 是否成立。如果成立，将搜索约简到 end = middle + 1</p><p>下面给出了这种经过修改的二叉搜索模式的视觉表示：</p><p><img src="../../../../../../images/image-20210316081428005.png" alt="image-20210316081428005"></p><p>经过修改的二叉搜索模式的问题：</p><ul><li>与顺序无关的二叉搜索（简单）</li><li>在经过排序的无限数组中搜索（中等）</li></ul><p><strong>12. 前 K 个元素</strong></p><p>任何要求我们找到一个给定集合中前面的/最小的/最常出现的 K 的元素的问题都在这一模式的范围内。</p><p>跟踪 K 个元素的最佳的数据结构是 Heap。这一模式会使用 Heap 来求解多个一次性处理一个给定元素集中 K 个元素的问题。该模式是这样工作的：</p><p>1． 根据问题的不同，将 K 个元素插入到 min-heap 或 max-heap 中<br>2．迭代处理剩余的数，如果你找到一个比 heap 中数更大的数，那么就移除那个数并插入这个更大的数</p><p><img src="../../../../../../images/image-20210316081642101.png" alt="image-20210316081642101"></p><p>这里无需排序算法，因为 heap 将为你跟踪这些元素。</p><p>如何识别前 K 个元素模式：</p><ul><li>如果你被要求寻找一个给定集合中前面的/最小的/最常出现的 K 的元素</li><li>如果你被要求对一个数值进行排序以找到一个确定元素</li></ul><p>前 K 个元素模式的问题：</p><ul><li>前面的 K 个数（简单）</li><li>最常出现的 K 个数（中等）</li></ul><p><strong>13. K 路合并</strong></p><p>K 路合并能帮助你求解涉及一组经过排序的数组的问题。</p><p>当你被给出了 K 个经过排序的数组时，你可以使用 Heap 来有效地执行所有数组的所有元素的排序遍历。你可以将每个数组的最小元素推送至 Min Heap 以获得整体最小值。在获得了整体最小值后，将来自同一个数组的下一个元素推送至 heap。然后，重复这一过程以得到所有元素的排序遍历结果。</p><p><img src="../../../../../../images/image-20210316081541080.png"></p><p>该模式看起来像这样：</p><p>1．将每个数组的第一个元素插入 Min Heap<br>2．之后，从该 Heap 取出最小（顶部的）元素，将其加入到合并的列表。<br>3．在从 Heap 移除了最小的元素之后，将同一列表的下一个元素插入该 Heap<br>4．重复步骤 2 和 3，以排序的顺序填充合并的列表</p><p>如何识别 K 路合并模式：</p><ul><li>具有排序数组、列表或矩阵的问题</li><li>如果问题要求你合并排序的列表，找到一个排序列表中的最小元素</li></ul><p>K 路合并模式的问题：</p><ul><li>合并 K 个排序的列表（中等）</li><li>找到和最大的 K 个配对（困难）</li></ul><p><strong>14. 拓扑排序</strong></p><p>拓扑排序可用于寻找互相依赖的元素的线性顺序。比如，如果事件 B 依赖于事件 A，那么 A 在拓扑排序时位于 B 之前。</p><p>这个模式定义了一种简单方法来理解执行一组元素的拓扑排序的技术。</p><p>该模式看起来是这样的：</p><p>1．初始化。a）使用 HashMap 将图（graph）存储到邻接的列表中；b）为了查找所有源，使用 HashMap 记录 in-degree 的数量<br>2．构建图并找到所有顶点的 in-degree。a）根据输入构建图并填充 in-degree HashMap<br>3．寻找所有的源。a）所有 in-degree 为 0 的顶点都是源，并会被存入一个队列<br>4．排序。a）对于每个源，执行以下操作：i）将其加入到排序的列表；ii）根据图获取其所有子节点；iii）将每个子节点的 in-degree 减少 1；iv）如果一个子节点的 in-degree 变为 0，将其加入到源队列。b）重复 (a)，直到源队列为空。</p><p><img src="../../../../../../images/image-20210316081709288.png" alt="image-20210316081709288"></p><p>如何识别拓扑排序模式：</p><ul><li>处理无向有环图的问题</li><li>如果你被要求以排序顺序更新所有对象</li><li>如果你有一类遵循特定顺序的对象</li></ul><p>拓扑排序模式的问题：</p><ul><li>任务调度（中等）</li><li>一个树的最小高度</li></ul><p>转载：<a href="https://mp.weixin.qq.com/s/CoIRjOITAHZI9jmEYiGPtQ">https://mp.weixin.qq.com/s/CoIRjOITAHZI9jmEYiGPtQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法分析与设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网机试在线训练JavaScript(V8)版04</title>
      <link href="2021/03/15/niuke/suanfa/huaweijs-03/"/>
      <url>2021/03/15/niuke/suanfa/huaweijs-03/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客网机试在线训练JavaScript-V8-版04"><a href="#牛客网机试在线训练JavaScript-V8-版04" class="headerlink" title="牛客网机试在线训练JavaScript(V8)版04"></a>牛客网机试在线训练JavaScript(V8)版04</h1><h2 id="1：-编程题-数串"><a href="#1：-编程题-数串" class="headerlink" title="1：[编程题]数串"></a>1：[编程题]数串</h2><p>设有n个正整数，将他们连接成一排，组成一个最大的多位整数。<br> 如:n=3时，3个整数13,312,343,连成的最大整数为34331213。<br> 如:n=4时,4个整数7,13,4,246连接成的最大整数为7424613。</p><p><strong>输入描述:</strong></p><pre><code>有多组测试样例，每组测试样例包含两行，第一行为一个整数N（N&lt;=100），第二行包含N个数(每个数不超过1000，空格分开)。</code></pre><p><strong>输出描述:</strong></p><pre><code>每组数据输出一个表示最大的整数。</code></pre><p><strong>输入</strong></p><pre><code>212 12347 13 4 246</code></pre><p><strong>输出</strong></p><pre><code>123127424613</code></pre><p>解析</p><p>第一次的想法是，对比排序，按照相同位数，大者居前</p><p>不同的，比较相同的位数，大者居前</p><p>相同的。。。 </p><p>最后反复比了好几次，只过了70% </p><p>哎，然后找到网站百度了下，看到一个比较巧妙的比较方法</p><p>然后自己排序写了下</p><p>参考答案（自己写得）  ：两数比较，就比较两者拼接后的结果大小</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span><span class="token punctuation">(</span>line <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> lines <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> j<span class="token operator">=</span>n<span class="token number">-1</span><span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span>lines<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>lines<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">let</span> temp <span class="token operator">=</span> lines<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                lines<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span>lines<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                lines<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span>temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">print</span><span class="token punctuation">(</span>lines<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//重点在这。。。。</span><span class="token keyword">function</span> <span class="token function">compare</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>b<span class="token operator">+</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我用了两个月的时间才理解 let</title>
      <link href="2021/03/15/ziliao/javascript/liu-lan-qi-cha-jian/"/>
      <url>2021/03/15/ziliao/javascript/liu-lan-qi-cha-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="我用了两个月的时间才理解-let"><a href="#我用了两个月的时间才理解-let" class="headerlink" title="我用了两个月的时间才理解 let"></a>我用了两个月的时间才理解 let</h1><p>当然不是说用完整的两个月时间来理解 let，而是零零碎碎地理解，同时我还要想着怎么写出一篇文章把这个事情说清楚。</p><p>在 let 刚出来的时候，我就「以为」我理解了 let。<strong>然鹅在过去的两个月里，我对 let 的理解发生了一波三折的变化。</strong></p><p><strong>我写这篇文章，是希望我的学习过程，能对你自学有帮助。</strong></p><h2 id="初识-let"><a href="#初识-let" class="headerlink" title="初识 let"></a>初识 let</h2><p>跟很多人一样，我第一次了解 let 的特性是从 MDN 的文档：</p><p><img src="https://pic3.zhimg.com/80/v2-673251397cd659ac021e8d55ad2bdb7e_720w.png" alt="img"></p><p>我得到的信息有这么几条：</p><ul><li>let 声明的变量的作用域是块级的；</li><li>let 不能重复声明已存在的变量；</li><li>let 有暂时死区，不会被提升。</li></ul><p>大部分人应该都是这么认为的，我也是这么理解的。</p><p>这个理解「没有问题」，但是不够「全面和深刻」。</p><h2 id="第一次质疑"><a href="#第一次质疑" class="headerlink" title="第一次质疑"></a>第一次质疑</h2><p>我第一次质疑我的理解是在遇到 for 循环的时候，代码如下。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 代码段1</span><span class="token keyword">var</span> liList <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 共5个li</span><span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>liList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  liList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>大家都知道依次点击 li <a href="https://link.zhihu.com/?target=http://js.jirengu.com/vesat/3/edit?html,js,console,output">会打印出 5 个 5</a>。如果把 var i 改成 let i，就会分别<a href="https://link.zhihu.com/?target=http://js.jirengu.com/vesat/4/edit?html,js,console,output">打印出 0、1、2、3、4</a>：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 代码段2</span><span class="token keyword">var</span> liList <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 共5个li</span><span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>liList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  liList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>然而，用我之前的知识来理解这个代码是不能自圆其说的</strong>。因为代码中依然只声明了一个 i，在 for 循环结束后，i 的值还是会变成 5 才对。</p><p><strong>这说明我的理解有误。</strong></p><p>于是我去看 MDN 的例子，发现鸡贼的 MDN 巧妙地避开了这个问题，它的例子是这样的：</p><p><img src="https://pic4.zhimg.com/80/v2-e2db72f8ad3358e0b89bad2f2e86ef6f_720w.png" alt="img"></p><p>你看 MDN 的例子，在每次循环的时候用 let j 保留的 i 的值，所以在 i 变化的时候，j 并不会变化。而console.log 的是 j，所以不会出现 5 个 5。</p><p><strong>为什么 MDN 要故意声明一个 j 呢，为什么不直接用 i 呢？</strong></p><p><strong>我猜测 MDN 为了简化知识，隐瞒了什么。</strong></p><p>于是我去看了看 ES 文档，其中的 <a href="https://link.zhihu.com/?target=http://www.ecma-international.org/ecma-262/6.0/%23sec-for-statement-runtime-semantics-labelledevaluation">13.7.4.7 章节</a> 清楚地说明了个中缘由，但是由于说得太清楚了，很多人都看不下去，不信你可以试试。</p><p>我说一下我的理解：</p><ol><li><strong>for( let i = 0; i&lt; 5; i++) 这句话的圆括号之间，有一个隐藏的作用域</strong></li><li><strong>for( let i = 0; i&lt; 5; i++) { 循环体 } 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。</strong></li><li>其他细节就不说了，太细碎了</li></ol><p>也就是说上面的代码段2可以<strong>近似近似近似地</strong>理解为</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 代码段3</span><span class="token keyword">var</span> liList <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 共5个li</span><span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>liList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> i <span class="token operator">=</span> 隐藏作用域中的i <span class="token comment" spellcheck="true">// 看这里看这里看这里</span>  liList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>那样的话，5 次循环，就会有 5 个不同的 i，console.log 出来的 i 当然也是不同的值。</p><p>再加上隐藏作用域里的 i，一共有 6 个 i。</p><p>这就是 MDN 加那句 let j = i 的原因：方便新人理解。</p><p>总得来说就是 let/const 在与 for 一起用时，会有一个 perIterationBindings 的概念（一种语法糖）。</p><p>从此之后，我就开始怀疑我对 let 的所有理解了。</p><h2 id="第二次质疑"><a href="#第二次质疑" class="headerlink" title="第二次质疑"></a>第二次质疑</h2><p>我在 StackOverflow 上闲逛的时候，无意中发现了一个是关于「let 到底有没有提升」的问题：</p><p><a href="https://link.zhihu.com/?target=https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6">Are variables declared with let or const not hoisted in ES6?</a></p><p>其中一个高票回答认为 <a href="https://link.zhihu.com/?target=https://stackoverflow.com/a/31222689/1262580">JS 中所有的声明（var/let/const/function/class），都存在提升</a>，理由是如下代码：</p><pre class=" language-js"><code class="language-js">x <span class="token operator">=</span> <span class="token string">"global"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// function scope:</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// not "global"</span>    <span class="token keyword">var</span><span class="token operator">/</span><span class="token keyword">let</span><span class="token operator">/</span>… x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// block scope (not for `var`s):</span><span class="token punctuation">{</span>    x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// not "global"</span>    <span class="token keyword">let</span><span class="token operator">/</span><span class="token keyword">const</span><span class="token operator">/</span>… x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我觉得他说得挺有道理的。于是我又去 MDN 和 ECMAScript 翻了翻，发现两处疑点：</p><ol><li>MDN 关于 let 是否存在提升的章节，被编辑了两次，第一次说存在提升，第二次说不存在提升（参考 <a href="https://link.zhihu.com/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let$compare?locale=en-US&to=1242757&from=1242229">2017 年 3 月 10 号的变更记录</a>）。也就是说 MDN 的维护者都在这个问题上产生过分歧，更何况我们了。</li><li>ES 文档里出现了「var/let hoisting」字样。</li></ol><p>鉴于此，我认为应该尊重 ES 文档，认为 let 确实存在提升。只不过由于暂时死区的限制，你不能在 let x 之前使用 let（详见我的那篇 <a href="https://zhuanlan.zhihu.com/p/27558914">let 声明会提升（hoist）吗？</a>）。</p><h2 id="故事并没有结束"><a href="#故事并没有结束" class="headerlink" title="故事并没有结束"></a>故事并没有结束</h2><p>当一个疑问一直存在你脑中时，你会在潜意识中不停地对它进行消化和思考。</p><p>上面说到我认为 let 存在提升的主要原因是 ES 文档中出现了「var/let hoisting」字样。</p><p>但是我在咨询 TC39 的成员 <strong><a href="https://link.zhihu.com/?target=https://twitter.com/rwaldron">Rick Waldron</a></strong> 时，他是这么说的：</p><blockquote><p>You’re misunderstanding the intention of that (non-normative) Note. let and const do not hoist as var and function decls do.</p></blockquote><p>而且还细心地专门写了一个 <a href="https://link.zhihu.com/?target=https://gist.github.com/rwaldron/ca35924d59ddc60a6aa165e1e4a3acda">gist</a> 来详细解释（twitter 有 140 字限制）。</p><p>既然 TC39 的 representative 都说了 let hoisting 不是一个正式词汇，那我就应该重新思考一下什么是「提升」了。</p><p>于是就有了这篇文章，我想要说一下我对「提升」的理解。你看完之后，就知道 let 到底有没有「提升」。</p><p>首先明确一点：提升不是一个技术名词。</p><p>要搞清楚提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」</p><p>有的地方把创建说成是声明（declare），为了将这个概念与变量声明区别开，我故意不使用声明这个字眼。</p><p>有的地方把初始化叫做绑定（binding），但我感觉这个词不如初始化形象。</p><p><strong>我们来看看 var 声明的「创建、初始化和赋值」过程</strong></p><p>假设有如下代码：</p><pre class=" language-text"><code class="language-text">function fn(){  var x = 1  var y = 2}fn()</code></pre><p>在执行 fn 时，会有以下过程（不完全）：</p><ol><li>进入 fn，为 fn 创建一个环境。</li><li>找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。</li><li>将这些变量「初始化」为 undefined。</li><li>开始执行代码</li><li>x = 1 将 x 变量「赋值」为 1</li><li>y = 2 将 y 变量「赋值」为 2</li></ol><p>也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。</p><p>这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined。</p><p><strong>接下来来看 function 声明的「创建、初始化和赋值」过程</strong></p><p>假设代码如下：</p><pre class=" language-js"><code class="language-js"><span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>JS 引擎会有一下过程：</p><ol><li>找到所有用 function 声明的变量，在环境中「创建」这些变量。</li><li>将这些变量「初始化」并「赋值」为 function(){ console.log(2) }。</li><li>开始执行代码 fn2()</li></ol><p>也就是说 function 声明会在代码执行之前就「创建、初始化并赋值」。 </p><p><strong>接下来看 let 声明的「创建、初始化和赋值」过程</strong></p><p>假设代码如下：</p><pre class=" language-text"><code class="language-text">{  let x = 1  x = 2}</code></pre><p>我们只看 {} 里面的过程：</p><ol><li>找到所有用 let 声明的变量，在环境中「创建」这些变量</li><li>开始执行代码（注意现在还没有初始化）</li><li>执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined）</li><li>执行 x = 2，对 x 进行「赋值」</li></ol><p>这就解释了为什么在 let x 之前使用 x 会报错：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token string">'global'</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Uncaught ReferenceError: x is not defined</span>  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span></code></pre><p>原因有两个</p><ol><li>console.log(x) 中的 x 指的是下面的 x，而不是全局的 x</li><li>执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）</li></ol><p>看到这里，你应该明白了 let 到底有没有提升：</p><ol><li>let 的「创建」过程被提升了，但是初始化没有提升。</li><li>var 的「创建」和「初始化」都被提升了。</li><li>function 的「创建」「初始化」和「赋值」都被提升了。</li></ol><p>接下来我考考你：</p><blockquote><p>var foo 和 function foo 同时存在会怎样</p></blockquote><p>代码1：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> foo<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span></code></pre><p><em>代码2：</em></p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> fooconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span></code></pre><p>请问代码1 和 代码2 的输出分别是什么？</p><p>答案：由于 function 比 var 多一个「赋值」过程，所以两个代码的输出都是函数。你也可以记住结论：function 比 var 牛逼。</p><p>那如果 function foo 和 let foo 同时出现呢？不会有这种情况的，因为 let 发现重名就会报错，叫你滚去改代码。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>最后看 const，其实 const 和 let 只有一个区别，那就是 const 只有「创建」和「初始化」，没有「赋值」过程。</p><p>这四种声明，用下图就可以快速理解：</p><p><img src="https://pic1.zhimg.com/80/v2-9c8c4a0a3ce5402b1a74f488d79c74d0_720w.png" alt="img"></p><p>所谓暂时死区，就是不能在初始化之前，使用变量。</p><h2 id="完了吗？"><a href="#完了吗？" class="headerlink" title="完了吗？"></a>完了吗？</h2><p>故事依然没有结束，这周我在知乎上问了一个问题：<a href="https://www.zhihu.com/question/62966713">如何理解 let x = x 报错之后，再次 let x 依然会报错？</a>（这个问题是饥人谷的学生问我的）</p><p><img src="https://pic1.zhimg.com/80/v2-a0d8881872aabf1fd086b630ff17d0f4_720w.png" alt="img"></p><p>这个问题说明：如果 let x 的初始化过程失败了，那么 </p><ol><li>x 变量就将永远处于 created 状态。</li><li>你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）。</li><li>由于 x 无法被初始化，所以 x 永远处在暂时死区（也就是盗梦空间里的 limbo）！</li><li>有人会觉得 JS 坑，怎么能出现这种情况；其实问题不大，因为此时代码已经报错了，后面的代码想执行也没机会。</li></ol><p>细节参见我的另一篇文章：<a href="https://zhuanlan.zhihu.com/p/28117094">JS变量封禁大法：薛定谔的X</a></p><p>以上，就是一个 let 引发的思考。</p><p>重要参考：<a href="https://link.zhihu.com/?target=https://rainsoft.io/variables-lifecycle-and-why-let-is-not-hoisted/">JavaScript variables lifecycle: why let is not hoisted</a></p><p>转载于<a href="https://zhuanlan.zhihu.com/p/28140450">https://zhuanlan.zhihu.com/p/28140450</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetCode初级教程</title>
      <link href="2021/03/14/leetcode/leetcode-chu-ji-jiao-cheng/"/>
      <url>2021/03/14/leetcode/leetcode-chu-ji-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="leetCode初级教程"><a href="#leetCode初级教程" class="headerlink" title="leetCode初级教程"></a>leetCode初级教程</h1><p>前言</p><p>先说说我的经历，刚刚下载 LeetCode 没多久，也没看什么刷题方法，就按顺序，刷就完事，遍工作边刷。因为有一定的基础，评分也还算高，但是慢慢觉得好像这样太缺乏系统性了，感觉会的基本看一眼就知道思路，不会的想一天也没头绪，特别是困难的，想到的方法也很 low，所以这两天就开始总结下，怎么系统地、性价比最高地来使用 LeetCode 提高自我。<br>下面是我总结的方法，大家参考下（后面会持续更新，由于用到了别人的文章，这里说明下，如有侵权，立刻删除）<br>如何开始？从何开始？数据结构？什么是数据结构？</p><p><img src="https://pic.leetcode-cn.com/320577d801cf78437caa47174e88f1bc59407194981db453fbdb65771a5cc414-image.png" alt="image.png"></p><p><img src="https://pic.leetcode-cn.com/a1b1c5393301f3dbf4bce469829597cb04b80879ad77b669d053f3c64659d97c-image.png" alt="image.png"></p><p><img src="https://pic.leetcode-cn.com/cf9f214590da807cc1a8bcf9b06601fa3e3acd8891a6a5909a6a6dea091e6fc1-image.png" alt="image.png"></p><p><img src="https://pic.leetcode-cn.com/c1daf71b200638823314347d65feeee7084dc576306f7dda3ec8e121213c7592-image.png" alt="image.png"></p><p>了解了数据结构的重要性，那我们就结合下LeetCode，通过实践吃透数据结构吧！！！<br>力扣零基础从入门到面试这篇文章已经有很详细的做法了，和我的思路基本吻合，我这里说下有差异的个人见解：</p><p>个人觉得，不管有没有数据结构基础，都应该把数据结构过一遍，不需要完全理解，死磕细节，只需要知道有这么一个东西，它的作用是什么，如果太复杂了，你完全可以先忽略它是怎么实现的。因为我看困难题解的时候，就发现题解上说的算法非常陌生，你都不知道是别人题解讲的是什么，那还怎么理解别人的思路，从而变成自己的东西呢？同理，如果你刚刚接触编程，那更应该这样，不然只会知其然而不知其所以然。<br>总结：过一遍数据结构，分类刷，难度高跳过，遇到有思路的题，但又记不清具体，就回去巩固数据结构，对比着做题，再举一反三。</p><h1 id="LeetCode-经典题目分类"><a href="#LeetCode-经典题目分类" class="headerlink" title="LeetCode 经典题目分类"></a>LeetCode 经典题目分类</h1><pre><code>Hash相关1_两数之和链表操作2_两数相加19_删除链表的倒数第N个节点61_旋转链表138_复制带随机指针的链表206_反转链表双指针遍历/滑动窗口3_无重复字符的最长子串11_盛最多水的容器15_三数之和16_最接近的三数之和26_删除排序数组中的重复项42_接雨水121_买卖股票的最佳时机209_长度最小的子数组快慢指针遍历141_环形链表202_快乐数876_链表的中间结点区间合并56_合并区间字符串操作6_Z字形变换14_最长公共前缀736_划分字母区间数字操作7_整数反转8_字符串转换整数9_回文数43_字符串相乘172_阶乘后的零258_各位相加数组操作54_螺旋矩阵73_矩阵置零945_使数组唯一的最小增量栈相关20_有效的括号32_最长有效括号155_最小栈224_基本计算器316_去除重复字母堆相关215_数组中的第K个最大元素347_前K个高频元素递归21_合并两个有序链表101_对称二叉树104_二叉树的最大深度226_翻转二叉树236_二叉树的最近公共祖先分治法/二分法23_合并K个排序链表33_搜索旋转排序数组34_在排序数组中查找元素的第一个和最后一个位置动态规划5_最长回文子串53_最大子序和62_不同路径64_最小路径和70_爬楼梯118_杨辉三角300_最长上升子序列746_使用最小花费爬楼梯1277_统计全为1的正方形子矩阵回溯法10_正则表达式匹配22_括号生成46_全排列树的遍历94_二叉树的中序遍历102_二叉树的层次遍历110_平衡二叉树144_二叉树的前序遍历145_二叉树的后序遍历二叉搜索树相关98_验证二叉搜索树450_删除二叉搜索树中的节点701_二叉搜索树中的插入操作</code></pre><p>过了基础的阶段，基本上看到题自然而然会有解决方案，但总觉得不是最优解，但最优解一时又想不出，这个时候你的知识面还不够，先了解一下这篇干货：秒杀算法面试必须掌握的14种模式</p><p>然后进阶练习动态规划，先了解思路，再系统做题<br>细谈动态规划<br>动态规划解题技巧<br>DP 问题分类汇总</p><p>作者：吕善柯-三七互娱<br>链接：<a href="https://leetcode-cn.com/circle/article/qDaN1Y/">https://leetcode-cn.com/circle/article/qDaN1Y/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h1 id="leetCode动态规划"><a href="#leetCode动态规划" class="headerlink" title="leetCode动态规划"></a>leetCode动态规划</h1><p>动态规划告别动态规划，连刷 40 道题，我总结了这些套路，看不懂你打我（万字长文）</p><p>公众号「帅地玩编程」，回复「程序员内功修炼」获取原创电子书</p><p>动态规划难吗？说实话，我觉得很难，特别是对于<strong>初学者</strong>来说，我当时入门动态规划的时候，是看 0-1 背包问题，当时真的是一脸懵逼。后来，我遇到动态规划的题，<strong>看的懂答案，但就是自己不会做，不知道怎么下手</strong>。就像做递归的题，看的懂答案，但下不了手，关于递归的，我之前也写过一篇<strong>套路</strong>的文章，如果对递归不大懂的，强烈建议看一看：<a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s/mJ_jZZoak7uhItNgnfmZvQ">为什么你学不会递归，告别递归，谈谈我的经验</a></p><p>对于动态规划，春招秋招时好多题都会用到动态规划，一气之下，再 leetcode 连续刷了几十道题</p><p><img src="https://pic1.zhimg.com/80/v2-3ed41ca65e1f521ca8223e8f3c079400_720w.jpg" alt="img"></p><p>之后，豁然开朗 ，感觉动态规划也不是很难，今天，我就来跟大家讲一讲，我是怎么做动态规划的题的，以及从中学到的一些<strong>套路</strong>。相信你看完一定有所收获</p><p>如果你对动态规划感兴趣，或者你看的懂动态规划，但却不知道怎么下手，那么我建议你好好看以下，这篇文章的写法，和之前那篇讲递归的写法，是差不多一样的，将会举大量的例子。如果一次性看不完，建议收藏，同时别忘了<strong>素质三连</strong>。</p><blockquote><p> 为了兼顾初学者，我会从最简单的题讲起，后面会越来越难，最后面还会讲解，该如何优化。因为 80% 的动规都是可以进行优化的。不过我得说，如果你连动态规划是什么都没听过，可能这篇文章你也会压力山大。</p></blockquote><h3 id="一、动态规划的三大步骤"><a href="#一、动态规划的三大步骤" class="headerlink" title="一、动态规划的三大步骤"></a>一、动态规划的三大步骤</h3><p>动态规划，无非就是利用<strong>历史记录</strong>，来避免我们的重复计算。而这些<strong>历史记录</strong>，我们得需要一些<strong>变量</strong>来保存，一般是用<strong>一维数组</strong>或者<strong>二维数组</strong>来保存。下面我们先来讲下做动态规划题很重要的三个步骤，</p><blockquote><p> 如果你听不懂，也没关系，下面会有很多例题讲解，估计你就懂了。之所以不配合例题来讲这些步骤，也是为了怕你们脑袋乱了</p></blockquote><p><strong>第一步骤</strong>：定义<strong>数组元素的含义</strong>，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？</p><p><strong>第二步骤</strong>：找出<strong>数组元素之间的关系式</strong>，我觉得动态规划，还是有一点类似于我们高中学习时的<strong>归纳法</strong>的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是可以利用<strong>历史数据</strong>来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面我会讲几种类型的题来说。</p><blockquote><p> 学过动态规划的可能都经常听到<strong>最优子结构</strong>，把大的问题拆分成小的问题，说时候，最开始的时候，我是对<strong>最优子结构</strong>一梦懵逼的。估计你们也听多了，所以这一次，我将<strong>换一种形式来讲，不再是各种子问题，各种最优子结构</strong>。所以大佬可别喷我再乱讲，因为我说了，这是我自己平时做题的套路。</p></blockquote><p><strong>第三步骤</strong>：找出<strong>初始值</strong>。学过<strong>数学归纳法</strong>的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算  dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1]  是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这，就是<strong>所谓的初始值</strong>。</p><p>由了<strong>初始值</strong>，并且有了<strong>数组元素之间的关系式</strong>，那么我们就可以得到 dp[n] 的值了，而 dp[n] 的含义是由你来定义的，你想<strong>求什么，就定义它是什么</strong>，这样，这道题也就解出来了。</p><p><strong>不懂？没事，我们来看三四道例题</strong>，我讲严格按这个步骤来给大家讲解。</p><h3 id="二、案例详解"><a href="#二、案例详解" class="headerlink" title="二、案例详解"></a>二、案例详解</h3><h3 id="案例一、简单的一维-DP"><a href="#案例一、简单的一维-DP" class="headerlink" title="案例一、简单的一维 DP"></a>案例一、简单的一维 DP</h3><blockquote><p> 问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>(1)、定义数组元素的含义</p><p>按我上面的步骤说的，首先我们来定义 dp[i] 的含义，我们的问题是要求青蛙跳上 n 级的台阶总共由多少种跳法，那我们就定义 dp[i] 的含义为：<strong>跳上一个 i 级的台阶总共有 dp[i] 种跳法</strong>。这样，如果我们能够算出 dp[n]，不就是我们要求的答案吗？所以第一步定义完成。</p><p>（2）、找出数组元素间的关系式</p><p>我们的目的是要求 dp[n]，动态规划的题，如你们经常听说的那样，就是把一个<strong>规模</strong>比较大的问题分成几个<strong>规模</strong>比较小的问题，然后由小的问题推导出大的问题。也就是说，dp[n] 的规模为 n，比它规模小的是 n-1, n-2, n-3…. 也就是说，dp[n] 一定会和 dp[n-1], dp[n-2]….存在某种关系的。我们要找出他们的关系。</p><p><strong>那么问题来了，怎么找？</strong></p><p>这个怎么找，<strong>是最核心最难的一个</strong>，我们必须回到问题本身来了，来寻找他们的关系式，dp[n] 究竟会等于什么呢？</p><p>对于这道题，由于情况可以选择跳一级，也可以选择跳两级，所以青蛙到达第 n 级的台阶有两种方式</p><p>一种是从第 n-1 级跳上来</p><p>一种是从第 n-2 级跳上来</p><p>由于我们是要算<strong>所有可能的跳法的</strong>，所以有 dp[n] = dp[n-1] + dp[n-2]。</p><p>（3）、找出初始条件</p><p>当 n = 1 时，dp[1] = dp[0] + dp[-1]，而我们是数组是不允许下标为负数的，所以对于 dp[1]，我们必须要<strong>直接给出它的数值</strong>，相当于初始值，显然，dp[1] = 1。一样，dp[0] = 0.（因为 0 个台阶，那肯定是 0 种跳法了）。于是得出初始值：</p><p>dp[0] = 0. dp[1] = 1. 即 n &lt;= 1 时，dp[n] = n.</p><p>三个步骤都做出来了，那么我们就来写代码吧，代码会详细注释滴。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span> <span class="token keyword">int</span> n <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 先创建一个数组来保存历史数据</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 给出初始值</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 通过关系式来计算出 dp[n]</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 把最终结果返回</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>（4）、再说初始化</p><p>大家先想以下，你觉得，上面的代码有没有问题？</p><p>答是有问题的，还是错的，错在<strong>对初始值的寻找不够严谨</strong>，这也是我故意这样弄的，意在告诉你们，关于<strong>初始值的严谨性</strong>。例如对于上面的题，当 n = 2 时，dp[2] = dp[1] + dp[0] = 1。这显然是错误的，你可以模拟一下，应该是 dp[2] = 2。</p><p>也就是说，在寻找初始值的时候，一定要注意不要找漏了，dp[2] 也算是一个初始值，不能通过公式计算得出。有人可能会说，我想不到怎么办？这个很好办，多做几道题就可以了。</p><blockquote><p> 下面我再列举三道不同的例题，并且，再在未来的文章中，我也会持续按照这个步骤，给大家找几道有难度且类型不同的题。下面这几道例题，不会讲的特性详细哈。实际上 ，上面的一维数组是可以把空间优化成更小的，不过我们现在先不讲优化的事，下面的题也是，不讲优化版本。</p></blockquote><h3 id="案例二：二维数组的-DP"><a href="#案例二：二维数组的-DP" class="headerlink" title="案例二：二维数组的 DP"></a>案例二：二维数组的 DP</h3><p>我做了几十道 DP 的算法题，可以说，80% 的题，都是要用二维数组的，所以下面的题主要以二维数组为主，当然有人可能会说，要用一维还是二维，我怎么知道？这个问题不大，接着往下看。</p><p>问题描述</p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img src="https://pic1.zhimg.com/80/v2-bbbe99e44d3a46fae8a6529a25452f98_720w.jpg" alt="img"></p><blockquote><p> 这是 leetcode 的 62 号题：<a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/unique-paths/">https://leetcode-cn.com/problems/unique-paths/</a></p></blockquote><p>还是老样子，三个步骤来解决。</p><p>步骤一、定义数组元素的含义</p><p>由于我们的目的是从左上角到右下角一共有多少种路径，那我们就定义 dp[i] [j]的含义为：<strong>当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i] [j] 种路径</strong>。那么，dp[m-1] [n-1] 就是我们要的答案了。</p><blockquote><p> 注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 右下角的位置是 (m-1, n - 1)，所以 dp[m-1] [n-1] 就是我们要找的答案。</p></blockquote><p>步骤二：找出关系数组元素间的关系式</p><p>想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达</p><p>一种是从 (i-1, j) 这个位置走一步到达</p><p>一种是从(i, j - 1) 这个位置走一步到达</p><p>因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]。</p><p>步骤三、找出初始值</p><p>显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j -  1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n-1] 和所有的 dp[0….m-1]  [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：</p><p>dp[0] [0….n-1] = 1; // 相当于最上面一行，机器人只能一直往右走</p><p>dp[0…m-1] [0] = 1; // 相当于最左面一列，机器人只能一直往下走</p><p>撸代码</p><p>三个步骤都写出来了，直接看代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// </span>    <span class="token comment" spellcheck="true">// 初始化</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 推导出 dp[m-1][n-1]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p> O(n*m) 的空间复杂度可以优化成 O(min(n, m)) 的空间复杂度的，不过这里先不讲</p></blockquote><h3 id="案例三、二维数组-DP"><a href="#案例三、二维数组-DP" class="headerlink" title="案例三、二维数组 DP"></a>案例三、二维数组 DP</h3><p>写到这里，有点累了，，但还是得写下去，所以看的小伙伴，你们可得继续看呀。下面这道题也不难，比上面的难一丢丢，不过也是非常类似</p><p>问题描述</p><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><pre class=" language-java"><code class="language-java">举例：输入<span class="token operator">:</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>输出<span class="token operator">:</span> <span class="token number">7</span>解释<span class="token operator">:</span> 因为路径 <span class="token number">1</span>→<span class="token number">3</span>→<span class="token number">1</span>→<span class="token number">1</span>→<span class="token number">1</span> 的总和最小。</code></pre><p>和上面的差不多，不过是算最优路径和，这是 leetcode 的第64题：<a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/minimum-path-sum/">https://leetcode-cn.com/problems/minimum-path-sum/</a></p><blockquote><p> 还是老样子，可能有些人都看烦了，哈哈，但我还是要按照步骤来写，让那些不大懂的加深理解。有人可能觉得，这些题太简单了吧，别慌，小白先入门，这些属于 medium 级别的，后面在给几道 hard 级别的。</p></blockquote><p>步骤一、定义数组元素的含义</p><p>由于我们的目的是从左上角到右下角，最小路径和是多少，那我们就定义 dp[i] [j]的含义为：**当机器人从左上角走到(i, j) 这个位置时，最下的路径和是 dp[i] [j]**。那么，dp[m-1] [n-1] 就是我们要的答案了。</p><blockquote><p> 注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 由下角的位置是 (m-1, n - 1)，所以 dp[m-1] [n-1] 就是我们要走的答案。</p></blockquote><p>步骤二：找出关系数组元素间的关系式</p><p>想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达</p><p>一种是从 (i-1, j) 这个位置走一步到达</p><p>一种是从(i, j - 1) 这个位置走一步到达</p><p>不过这次不是计算所有可能路径，而是<strong>计算哪一个路径和是最小的</strong>，那么我们要从这两种方式中，选择一种，使得dp[i] [j] 的值是最小的，显然有 </p><pre class=" language-java"><code class="language-java">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>，dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// arr[i][j] 表示网格种的值</span></code></pre><p>步骤三、找出初始值</p><p>显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j -  1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n-1] 和所有的 dp[0….m-1]  [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：</p><p>dp[0] [j] = arr[0] [j] + dp[0] [j-1]; // 相当于最上面一行，机器人只能一直往左走</p><p>dp[i] [0] = arr[i] [0] + dp[i] [0];  // 相当于最左面一列，机器人只能一直往下走</p><p>代码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// </span>    <span class="token comment" spellcheck="true">// 初始化</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化最左边的列</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化最上边的行</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 推导出 dp[m-1][n-1]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p> O(n*m) 的空间复杂度可以优化成 O(min(n, m)) 的空间复杂度的，不过这里先不讲</p></blockquote><h3 id="案例-4：编辑距离"><a href="#案例-4：编辑距离" class="headerlink" title="案例 4：编辑距离"></a>案例 4：编辑距离</h3><p>这次给的这道题比上面的难一些，在 leetcdoe 的定位是 hard 级别。好像是 leetcode 的第 72 号题。</p><p><strong>问题描述</strong></p><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符 删除一个字符 替换一个字符</p><pre class=" language-java"><code class="language-java">示例：输入<span class="token operator">:</span> word1 <span class="token operator">=</span> <span class="token string">"horse"</span><span class="token punctuation">,</span> word2 <span class="token operator">=</span> <span class="token string">"ros"</span>输出<span class="token operator">:</span> <span class="token number">3</span>解释<span class="token operator">:</span> horse <span class="token operator">-</span><span class="token operator">></span> <span class="token function">rorse</span> <span class="token punctuation">(</span>将 <span class="token string">'h'</span> 替换为 <span class="token string">'r'</span><span class="token punctuation">)</span>rorse <span class="token operator">-</span><span class="token operator">></span> <span class="token function">rose</span> <span class="token punctuation">(</span>删除 <span class="token string">'r'</span><span class="token punctuation">)</span>rose <span class="token operator">-</span><span class="token operator">></span> <span class="token function">ros</span> <span class="token punctuation">(</span>删除 <span class="token string">'e'</span><span class="token punctuation">)</span></code></pre><p><strong>解答</strong></p><p>还是老样子，按照上面三个步骤来，并且我这里可以告诉你，90% 的字符串问题都可以用动态规划解决，并且90%是采用二维数组。</p><p>步骤一、定义数组元素的含义</p><p>由于我们的目的求将 word1 转换成 word2 所使用的最少操作数 。那我们就定义 dp[i] [j]的含义为：**当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i] [j]**。</p><blockquote><p> 有时候，数组的含义并不容易找，所以还是那句话，我给你们一个套路，剩下的还得看你们去领悟。</p></blockquote><p>步骤二：找出关系数组元素间的关系式</p><p>接下来我们就要找 dp[i] [j] 元素之间的关系了，比起其他题，这道题相对比较难找一点，但是，不管多难找，大部分情况下，dp[i] [j] 和  dp[i-1] [j]、dp[i] [j-1]、dp[i-1] [j-1]  肯定存在某种关系。因为我们的目标就是，**从规模小的，通过一些操作，推导出规模大的。对于这道题，我们可以对 word1 进行三种操作</p><p>插入一个字符 删除一个字符 替换一个字符</p><p>由于我们是要让操作的次数最小，所以我们要寻找最佳操作。那么有如下关系式：</p><p>一、如果我们 word1[i] 与 word2 [j] 相等，这个时候不需要进行任何操作，显然有 dp[i] [j] = dp[i-1] [j-1]。（别忘了 dp[i] [j] 的含义哈）。</p><p>二、如果我们 word1[i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。三种操作对应的关系试如下（注意字符串与字符的区别）：</p><p>（1）、如果把字符 word1[i] 替换成与 word2[j] 相等，则有 dp[i] [j] = dp[i-1] [j-1] + 1;</p><p>（2）、如果在字符串 word1末尾插入一个与 word2[j] 相等的字符，则有 dp[i] [j] = dp[i] [j-1] + 1;</p><p>（3）、如果把字符 word1[i] 删除，则有 dp[i] [j] = dp[i-1] [j] + 1;</p><p>那么我们应该选择一种操作，使得 dp[i] [j] 的值最小，显然有 </p><p><strong>dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1;</strong></p><p>于是，我们的关系式就推出来了，</p><p>步骤三、找出初始值</p><p>显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j -  1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n] 和所有的 dp[0….m]  [0]。这个还是非常容易计算的，因为当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了。</p><p>代码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>String word1<span class="token punctuation">,</span> String word2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n1 <span class="token operator">=</span> word1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n2 <span class="token operator">=</span> word2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// dp[0][0...n2]的初始值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>         dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// dp[0...n1][0] 的初始值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过公式推出 dp[n1][n2]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>word1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> word2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>               dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                 <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>最后说下，如果你要练习，可以去 leetcode，选择动态规划专题，然后连续刷几十道，保证你以后再也不怕动态规划了。当然，遇到很难的，咱还是得挂。</p><p>Leetcode 动态规划直达：<a href="https://link.zhihu.com/?target=https://leetcode-cn.com/tag/dynamic-programming/">https://leetcode-cn.com/tag/dynamic-programming/</a></p><h3 id="三、如何优化？"><a href="#三、如何优化？" class="headerlink" title="三、如何优化？"></a>三、如何优化？</h3><p>前两天写一篇长达 8000 子的关于<strong>动态规划</strong>的文章<a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s/pg-IJ8rA1duIzt5hW1Cycw">告别动态规划，连刷40道动规算法题，我总结了动规的套路</a></p><p>这篇文章更多讲解我平时做题的套路，不过由于篇幅过长，举了 4 个案例之后，没有讲解优化，今天这篇文章就来讲解下，对动态规划的优化如何下手，并且以前几天那篇文章的题作为例子直接讲优化，如果没看过的建议看一下（不看也行，我会直接给出题目以及没有优化前的代码）：<a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s/pg-IJ8rA1duIzt5hW1Cycw">告别动态规划，连刷40道动规算法题，我总结了动规的套路</a></p><h3 id="四、优化核心：画图！画图！画图"><a href="#四、优化核心：画图！画图！画图" class="headerlink" title="四、优化核心：画图！画图！画图"></a>四、优化核心：画图！画图！画图</h3><p>没错，80% 的动态规划题都可以画图，其中 80% 的题都可以通过画图一下子知道怎么优化，当然，DP 也有一些很难的题，想优化可没那么容易，不过，今天我要讲的，是属于不怎么难，且最常见，面试笔试最经常考的难度的题。</p><p>下面我们直接通过三道题目来讲解优化，你会发现，这些题，优化过后，代码只有细微的改变，你只要会一两道，可以说是会了 80% 的题。</p><p>O(n*m) 空间复杂度优化成 O(n)</p><p>上次那个青蛙跳台阶的 dp 题是可以把空间复杂度 O( n) 优化成 O(1)，本来打算从这道题讲起的，但想了下，想要学习 dp 优化的感觉至少都是 <strong>小小大佬</strong>了，所以就不讲了，就从二维数组的 dp 讲起。</p><h3 id="案例1：最多路径数"><a href="#案例1：最多路径数" class="headerlink" title="案例1：最多路径数"></a>案例1：最多路径数</h3><p>问题描述</p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img src="https://pic1.zhimg.com/80/v2-bbbe99e44d3a46fae8a6529a25452f98_720w.jpg" alt="img"></p><blockquote><p> 这是 leetcode 的 62 号题：<a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/unique-paths/">https://leetcode-cn.com/problems/unique-paths/</a></p></blockquote><p>这道题的 dp 转移公式是 dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]，代码如下</p><blockquote><p> 不懂的看我之前文章：<a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s/pg-IJ8rA1duIzt5hW1Cycw">告别动态规划，连刷40道动规算法题，我总结了动规的套路</a></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// </span>    <span class="token comment" spellcheck="true">// 初始化</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 推导出 dp[m-1][n-1]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这种做法的空间复杂度是 O(n * m)，下面我们来讲解如何优化成 O(n)。</p><p>dp[i] [j] 是一个二维矩阵，我们来画个二维矩阵的图，对矩阵进行初始化</p><p><img src="https://pic1.zhimg.com/80/v2-2db5e52b8f014e3d1eda3da90f53595c_720w.jpg" alt="img"></p><p> 然后根据公式   dp[i][j] = dp[i-1][j] + dp[i][j-1] 来填充矩阵的其他值。下面我们先填充第二行的值。 </p><p><img src="https://pic4.zhimg.com/80/v2-8127598df4d0eca6f9df8440b786746f_720w.jpg" alt="img"></p><p> 大家想一个问题，<strong>当我们要填充第三行的值的时候，我们需要用到第一行的值吗？</strong>答是不需要的，不行你试试，当你要填充第三，第四….第 n 行的时候，第一行的值永远不会用到，只要填充第二行的值时会用到。</p><p>根据公式  dp[i][j] = dp[i-1][j] + dp[i][j-1]，我们可以知道，当我们要计算第 i 行的值时，<strong>除了会用到第 i - 1 行外，其他第 1 至 第 i-2 行的值我们都是不需要用到的</strong>，也就是说，对于那部分用不到的值我们还有必要保存他们吗？</p><p>答是没必要，我们只需要用一个一维的 dp[] 来保存<strong>一行</strong>的历史记录就可以了。然后在计算机的过程中，不断着更新 dp[] 的值。单说估计你可能不好理解，下面我就手把手来演示下这个过程。</p><p>1、刚开始初始化第一行，此时 dp[0..n-1] 的值就是第一行的值。 </p><p><img src="https://pic1.zhimg.com/80/v2-2db5e52b8f014e3d1eda3da90f53595c_720w.jpg" alt="img"></p><p>2、接着我们来一边填充第二行的值一边更新 dp[i] 的值，一边把第一行的值抛弃掉。</p><blockquote><p> 为了方便描述，下面我们用arr (i，j）表示矩阵中第 i 行 第 j 列的值。从 0 开始哈，就是说有第 0 行。</p></blockquote><p>（1）、显然，矩阵(1, 0) 的值相当于以往的初始化值，为 1。然后这个时候矩阵 (0，0）的值不在需要保存了，因为再也用不到了。 </p><p><img src="https://pic4.zhimg.com/80/v2-123a712506a46e548c3b70ab99c71cff_720w.jpg" alt="img"></p><p> 这个时候，我们也要跟着更新 dp[0] 的值了，刚开始 dp[0] = (0, 0)，现在更新为 dp[0] = (1, 0)。</p><p>（2）、接着继续更新 (1, 1) 的值，根据之前的公式 （i, j) = (i-1, j) + (i, j- 1)。即 （1，1）=（0，1）+（1，0）=2。 </p><p><img src="https://pic2.zhimg.com/80/v2-e4971bbe0332b40650b72b740c433fc5_720w.jpg" alt="img"></p><p> 大家看图，以往的二维的时候， dp[i][j] = dp[i-1] [j]+ dp[i][j-1]。现在转化成一维，不就是 <strong>dp[i] = dp[i] + dp[i-1]</strong> 吗？</p><p>即 dp[1] = dp[1] + dp[0]，而且还动态帮我们更新了 dp[1] 的值。因为刚开始 dp[i] 的保存第一行的值的，现在更新为保存第二行的值。 </p><p><img src="https://pic4.zhimg.com/80/v2-2ef2a10dfe2dbb6179b838abbed8d03f_720w.jpg" alt="img"></p><p> (3)、同样的道理，按照这样的模式一直来计算第二行的值，顺便把第一行的值抛弃掉，结果如下 </p><p><img src="https://pic1.zhimg.com/80/v2-1518e4a039024bf85960ed7d28f8b844_720w.jpg" alt="img"></p><p> 此时，dp[i] 将完全保存着第二行的值，并且我们可以推导出公式</p><p>dp[i] = dp[i-1] + dp[i]</p><blockquote><p> dp[i-1] 相当于之前的 dp[i-1][j]，dp[i] 相当于之前的 dp[i][j-1]。</p></blockquote><p>于是按照这个公式不停着填充到最后一行，结果如下： </p><p><img src="https://pic4.zhimg.com/80/v2-2a2ff79b38f56dc4dd6a323fc1b5c60b_720w.jpg" alt="img"></p><p> 最后 dp[n-1] 就是我们要求的结果了。所以优化之后，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// </span>    <span class="token comment" spellcheck="true">// 初始化</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 公式：dp[i] = dp[i-1] + dp[i]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 第 i 行第 0 列的初始值</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="案例2：编辑距离"><a href="#案例2：编辑距离" class="headerlink" title="案例2：编辑距离"></a>案例2：编辑距离</h3><p>接着我们来看昨天的另外一道题，就是<strong>编辑矩阵</strong>，这道题的优化和这一道有一点点的不同，上面这道 dp[i][j] 依赖于 dp[i-1][j] 和 dp[i][j-1]。而还有一种情况就是 dp[i][j] 依赖于 dp[i-1][j]，dp[i-1][j-1] 和 dp[i][j-1]。</p><p><strong>问题描述</strong></p><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符 删除一个字符 替换一个字符</p><pre class=" language-java"><code class="language-java">示例：输入<span class="token operator">:</span> word1 <span class="token operator">=</span> <span class="token string">"horse"</span><span class="token punctuation">,</span> word2 <span class="token operator">=</span> <span class="token string">"ros"</span>输出<span class="token operator">:</span> <span class="token number">3</span>解释<span class="token operator">:</span> horse <span class="token operator">-</span><span class="token operator">></span> <span class="token function">rorse</span> <span class="token punctuation">(</span>将 <span class="token string">'h'</span> 替换为 <span class="token string">'r'</span><span class="token punctuation">)</span>rorse <span class="token operator">-</span><span class="token operator">></span> <span class="token function">rose</span> <span class="token punctuation">(</span>删除 <span class="token string">'r'</span><span class="token punctuation">)</span>rose <span class="token operator">-</span><span class="token operator">></span> <span class="token function">ros</span> <span class="token punctuation">(</span>删除 <span class="token string">'e'</span><span class="token punctuation">)</span></code></pre><p><strong>解答</strong></p><p>昨天的代码如下所示，不懂的记得看之前的文章哈：<a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s/pg-IJ8rA1duIzt5hW1Cycw">告别动态规划，连刷40道动规算法题，我总结了动规的套路</a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>String word1<span class="token punctuation">,</span> String word2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n1 <span class="token operator">=</span> word1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n2 <span class="token operator">=</span> word2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// dp[0][0...n2]的初始值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>         dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// dp[0...n1][0] 的初始值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过公式推出 dp[n1][n2]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>word1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> word2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>               dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                 <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><blockquote><p> 没有优化之间的空间复杂度为 O(n*m)</p></blockquote><p>大家可以自己动手做下，按照上面的那个模式，你会优化吗？ </p><p><img src="https://pic3.zhimg.com/80/v2-91e72102719b41b33ae341de6976b6aa_720w.jpg" alt="img"></p><p> 对于这道题其实也是一样的，如果要计算 第 i 行的值，我们最多只依赖第 i-1 行的值，不需要用到第 i-2 行及其以前的值，所以一样可以采用一维 dp 来处理的。</p><p>不过这个时候要注意，在上面的例子中，我们每次更新完 (i, j) 的值之后，就会把 (i, j-1) 的值抛弃，也就是说之前是一边更新 dp[i] 的值，一边把 dp[i] 的旧值抛弃的，不过在这道题中则不可以，因为我们还需要用到它。</p><p>哎呀，直接举例子看图吧，文字绕来绕去估计会绕晕你们。当我们要计算图中 (i,j) 的值的时候，在案例1 中，我们值需要用到 (i-1, j) 和 (i, j-1)。（看图中方格的颜色） </p><p><img src="https://pic2.zhimg.com/80/v2-2398bcd562e8781962effd9e1fac2c8d_720w.jpg" alt="img"></p><p> 不过这道题中，我们还需要用到 （i-1, j-1) 这个值（但是这个值在以往的案例1 中，它会被抛弃掉） </p><p><img src="https://pic1.zhimg.com/80/v2-57910e99714602d67c1ebbdd3809cafc_720w.jpg" alt="img"></p><p><strong>所以呢，对于这道题，我们还需要一个额外的变量 pre 来时刻保存 (i-1,j-1) 的值</strong>。推导公式就可以从二维的</p><pre class=" language-text"><code class="language-text">dp[i][j] = min(dp[i-1][j] , dp[i-1][j-1] , dp[i][j-1]) + 1</code></pre><p>转化为一维的</p><pre class=" language-text"><code class="language-text">dp[i] = min(dp[i-1], pre, dp[i]) + 1。</code></pre><p>所以呢，案例2 其实和案例1 差别不大，就是多了个变量来临时保存。最终代码如下（但是初学者话，代码也没那么好写）</p><p>代码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>String word1<span class="token punctuation">,</span> String word2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n1 <span class="token operator">=</span> word1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n2 <span class="token operator">=</span> word2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// dp[0...n2]的初始值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>         dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// dp[j] = min(dp[j-1], pre, dp[j]) + 1</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 相当于初始化</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// pre 相当于之前的 dp[i-1][j-1]</span>            <span class="token keyword">int</span> pre <span class="token operator">=</span> temp<span class="token punctuation">;</span>            temp <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>word1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> word2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>               dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>             <span class="token comment" spellcheck="true">// 保存要被抛弃的值       </span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的这些题，基本都是不怎么难的入门题，除了最后一道相对难一点。并且基本 80% 的二维矩阵 dp 都可以像上面的方法一样优化成 一维矩阵的 dp，核心就是要画图，看他们的<strong>值依赖</strong>，当然，还有很多其他比较难的优化，但是，我遇到的题中，大部分都是我上面这种类型的优化。后面如何遇到其他的，我会作为案例来讲，今天就先讲<strong>最普遍最通用的优化方案</strong>。记住，画二维 dp 的矩阵图，然后看元素之间的值依赖，然后就可以很清晰着知道该如何优化了。</p><p>在之后的文章中，我也会按照这个步骤，在给大家讲四五道动态规划 <strong>hard</strong> 级别的题，会放在每天推文的第二条给大家学习。如果觉得有收获，不放<strong>三连</strong>走起来（点赞、感谢、分享），嘻嘻。 </p>]]></content>
      
      
      <categories>
          
          <category> leetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetCode指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法02</title>
      <link href="2021/03/12/kaikeba/suan-fa-dui-lie/"/>
      <url>2021/03/12/kaikeba/suan-fa-dui-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构和算法–队列"><a href="#数据结构和算法–队列" class="headerlink" title="数据结构和算法–队列"></a>数据结构和算法–队列</h1><h1 id><a href="#" class="headerlink" title></a></h1><p>leetcode </p><p>86分割链表</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> partition <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建两个链表，一个保存小于x的元素，一个存储大的元素</span>    <span class="token keyword">let</span> big <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        small <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//为两个链表，定义两个指针</span>    <span class="token keyword">let</span> bigNode <span class="token operator">=</span> big<span class="token punctuation">,</span>        smallNode <span class="token operator">=</span> small<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义原链表的头指针，然后进行比较，连接到对应的链表，然后进行移动</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">,</span> next<span class="token punctuation">;</span> cur<span class="token punctuation">;</span> cur <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//链接的操作</span>            smallNode<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//指针移动</span>            smallNode <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            bigNode<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>            bigNode <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    smallNode<span class="token punctuation">.</span>next <span class="token operator">=</span> big<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">return</span> small<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>138<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer">复制带随机指针的链表</a> </p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> copyRandomList <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//复制一遍链表挨个插入原节点之后</span>    <span class="token keyword">let</span> p <span class="token operator">=</span> head<span class="token punctuation">,</span>        q<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        q<span class="token punctuation">.</span>random <span class="token operator">=</span> p<span class="token punctuation">.</span>random<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        p <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//找到克隆节点，然后修正random，将克隆节点random指向克隆节点</span>    p <span class="token operator">=</span> head<span class="token punctuation">.</span>hext<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token punctuation">.</span>random <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>random <span class="token operator">=</span> p<span class="token punctuation">.</span>random<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span>p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//拆分链表，原节点链表和克隆节点链表</span>    p <span class="token operator">=</span> q <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        q<span class="token punctuation">.</span>next <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        q <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//返回克隆节点链表</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>其他参考</p><pre><code>var copyRandomList = function (head) &#123;  if (!head) return head;  let cur = head;  const map = new Map();  // 第一次遍历，生成一个具有val属性的链表；  while (cur) &#123;    map.set(cur, new Node(cur.val))    cur = cur.next  &#125;  //第二次遍历，根据map映射关系，将random和next指针指向对应的节点或者null;  cur = head  while (cur) &#123;    map.get(cur).next = map.get(cur.next) || null    map.get(cur).random = map.get(cur.random) || null    cur = cur.next  &#125;  return map.get(head);&#125;;</code></pre><pre class=" language-javascript"><code class="language-javascript">递归解题思路    Map作哈希表（对象的key不能为对象，Map可以），以节点为键存节点的副本    先跟随next指针递归，哈希表中存入全部节点的副本    next递归回溯阶段，当前节点作键查哈希表，将random指针当前节点的副本代码<span class="token keyword">var</span> copyRandomList <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> head <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token punctuation">:</span> h<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token operator">?</span> h<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">:</span>     <span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token punctuation">{</span>val<span class="token punctuation">:</span> head<span class="token punctuation">.</span>val<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>next<span class="token punctuation">:</span> <span class="token function">copyRandomList</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">,</span> random<span class="token punctuation">:</span> <span class="token function">copyRandomList</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>random<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>迭代解题思路    第一次迭代，复制链表每个节点到被复制节点右侧，连起来。        原来 A → B → C，复制后 A → 副本A → B → 副本B → C → 副本C    第二次迭代，把副本的random指向左侧本尊<span class="token punctuation">.</span>random<span class="token punctuation">.</span>next，即本尊<span class="token punctuation">.</span>random的副本    第三次迭代，恢复A → B → C<span class="token operator">...</span>，副本A → 副本B → 副本C<span class="token operator">...</span>，返回 副本A<span class="token comment" spellcheck="true">//代码</span><span class="token keyword">var</span> copyRandomList <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> p <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">{</span>val<span class="token punctuation">:</span> head<span class="token punctuation">.</span>val<span class="token punctuation">,</span> next<span class="token punctuation">:</span> head<span class="token punctuation">.</span>next<span class="token punctuation">}</span>        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next    <span class="token punctuation">}</span>    head <span class="token operator">=</span> p    <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>random <span class="token operator">=</span> head<span class="token punctuation">.</span>random <span class="token operator">?</span> head<span class="token punctuation">.</span>random<span class="token punctuation">.</span>next <span class="token punctuation">:</span> <span class="token keyword">null</span>        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next    <span class="token punctuation">}</span>    head <span class="token operator">=</span> p<span class="token punctuation">,</span> head <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">)</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">&amp;&amp;</span> head<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> t <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> t <span class="token operator">?</span> t<span class="token punctuation">.</span>next <span class="token punctuation">:</span> <span class="token keyword">null</span>        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next <span class="token operator">=</span> t    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网华为机试03</title>
      <link href="2021/03/11/niuke/suanfa/huaweijs-02/"/>
      <url>2021/03/11/niuke/suanfa/huaweijs-02/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客网华为机试在线训练JavaScript-V8-版03"><a href="#牛客网华为机试在线训练JavaScript-V8-版03" class="headerlink" title="牛客网华为机试在线训练JavaScript(V8)版03"></a>牛客网华为机试在线训练JavaScript(V8)版03</h1><h2 id="1-简单错误记录"><a href="#1-简单错误记录" class="headerlink" title="1.简单错误记录"></a>1.简单错误记录</h2><p>题目描述</p><p>  开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。 </p><p>  处理： </p><p>  1、 记录最多8条错误记录，循环记录，最后只用输出最后出现的八条错误记录。对相同的错误记录只记录一条，但是<strong>错误计数增加。最后一个斜杠后面的带后缀名的部分（保留最后16位）和行号完全匹配的记录才做算是”相同“的错误记录。</strong></p><p>  2、 超过16个字符的文件名称，只记录文件的最后有效16个字符；</p><p>  3、 输入的文件可能带路径，记录文件名称不能带路径。 </p><p>  4、循环记录时，只以第一次出现的顺序为准，后面重复的不会更新它的出现时间，仍以第一次为准</p><p><strong>输入描述:</strong></p><pre><code>每组只包含一个测试用例。一个测试用例包含一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。</code></pre><p><strong>输出描述:</strong></p><pre><code>将所有的记录统计并将结果输出，格式：文件名 代码行数 数目，一个空格隔开，如：</code></pre><p><strong>输入</strong></p><pre class=" language-javascript"><code class="language-javascript">D<span class="token punctuation">:</span>\zwtymj\xccb\ljj\cqzlyaszjvlsjmkwoqijggmybr <span class="token number">645</span>E<span class="token punctuation">:</span>\je\rzuwnjvnuz <span class="token number">633</span>C<span class="token punctuation">:</span>\km\tgjwpb\gy\atl <span class="token number">637</span>F<span class="token punctuation">:</span>\weioj\hadd\connsh\rwyfvzsopsuiqjnr <span class="token number">647</span>E<span class="token punctuation">:</span>\ns\mfwj\wqkoki\eez <span class="token number">648</span>D<span class="token punctuation">:</span>\cfmwafhhgeyawnool <span class="token number">649</span>E<span class="token punctuation">:</span>\czt\opwip\osnll\c <span class="token number">637</span>G<span class="token punctuation">:</span>\nt\f <span class="token number">633</span>F<span class="token punctuation">:</span>\fop\ywzqaop <span class="token number">631</span>F<span class="token punctuation">:</span>\yay\jc\ywzqaop <span class="token number">631</span></code></pre><p><strong>输出</strong></p><pre class=" language-javascript"><code class="language-javascript">rzuwnjvnuz <span class="token number">633</span> <span class="token number">1</span>atl <span class="token number">637</span> <span class="token number">1</span>rwyfvzsopsuiqjnr <span class="token number">647</span> <span class="token number">1</span>eez <span class="token number">648</span> <span class="token number">1</span>fmwafhhgeyawnool <span class="token number">649</span> <span class="token number">1</span>c <span class="token number">637</span> <span class="token number">1</span>f <span class="token number">633</span> <span class="token number">1</span>ywzqaop <span class="token number">631</span> <span class="token number">2</span></code></pre><p><strong>解析：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> errLists <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">errList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>line <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> lines <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token regex">/\s{1,}/g</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> codeFiles <span class="token operator">=</span> lines<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'\\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> codeFile <span class="token operator">=</span>codeFiles<span class="token punctuation">[</span>codeFiles<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> codeLine <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>lines<span class="token punctuation">[</span>lines<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>codeFile<span class="token punctuation">.</span>length<span class="token operator">></span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        codeFile <span class="token operator">=</span> codeFile<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>codeFile<span class="token punctuation">.</span>length<span class="token number">-16</span><span class="token punctuation">,</span>codeFile<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> errItem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">createErr</span><span class="token punctuation">(</span>codeFile<span class="token operator">+</span><span class="token string">' '</span><span class="token operator">+</span>codeLine<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    errLists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>errItem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>errLists<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">createErr</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">errList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>lists <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>add <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> errItem <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> isNew <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lists<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>name <span class="token operator">==</span> errItem<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>                item<span class="token punctuation">.</span>num <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                isNew <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>isNew<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>lists<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>errItem<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>lists<span class="token punctuation">.</span>length<span class="token number">-8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token keyword">this</span><span class="token punctuation">.</span>lists<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name <span class="token operator">+</span><span class="token string">' '</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="2-汽水瓶"><a href="#2-汽水瓶" class="headerlink" title="2.汽水瓶"></a>2.汽水瓶</h2><p><strong>题目描述</strong></p><p>  有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？  </p><p><strong>输入描述:</strong></p><pre><code>输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1&lt;=n&lt;=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。</code></pre><p><strong>输出描述:</strong></p><pre><code>对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。</code></pre><p><strong>输入</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">3</span><span class="token number">10</span><span class="token number">81</span><span class="token number">0</span></code></pre><p><strong>输出</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">1</span><span class="token number">5</span><span class="token number">40</span></code></pre><h2 id="3-密码验证程序"><a href="#3-密码验证程序" class="headerlink" title="3.密码验证程序"></a>3.密码验证程序</h2><p>题目描述</p><p>  密码要求: </p><p>  1.长度超过8位 </p><p>  2.包括大小写字母.数字.其它符号,以上四种至少三种 </p><p>  3.不能有相同长度大于2的子串重复 </p><p>输入描述:</p><pre><code>一组或多组长度超过2的字符串。每组占一行</code></pre><p>输出描述:</p><pre><code>如果符合要求输出：OK，否则输出NG</code></pre><p>  密码要求: </p><p>  1.长度超过8位 </p><p>  2.包括大小写字母.数字.其它符号,以上四种至少三种 </p><p>  3.不能有相同长度大于2的子串重复 </p><p>输入描述:</p><pre><code>一组或多组长度超过2的字符串。每组占一行</code></pre><p>输出描述:</p><pre><code>如果符合要求输出：OK，否则输出NG</code></pre><p>输入</p><pre class=" language-javascript"><code class="language-javascript">021Abc9000021Abc9Abc1021ABC9000<span class="token number">021</span>$bc9000</code></pre><p>输出</p><pre class=" language-javascript"><code class="language-javascript">OKNGNGOK</code></pre><p>解析</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span> <span class="token punctuation">(</span>line <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> NG <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断类型</span><span class="token keyword">let</span> lnum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex">/^(?=.*[a-z]).{9,}$/</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span> lnum<span class="token operator">++</span><span class="token punctuation">;</span>reg <span class="token operator">=</span> <span class="token regex">/^(?=.*[A-Z]).{9,}$/</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span> lnum<span class="token operator">++</span><span class="token punctuation">;</span>reg <span class="token operator">=</span> <span class="token regex">/^(?=.*[1-9]).{9,}$/</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span> lnum<span class="token operator">++</span><span class="token punctuation">;</span>reg <span class="token operator">=</span> <span class="token regex">/^(?=.*[\W]).{9,}$/</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span> lnum<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>lnum <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'NG'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NG <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>NG<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//判断子串</span>    <span class="token keyword">let</span> numSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> line<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            item <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>numSet<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'NG'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                NG <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                numSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>NG<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'OK'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>参考答案</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span><span class="token punctuation">(</span>line <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token function">handleData</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">function</span> <span class="token function">handleData</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>length<span class="token operator">&lt;=</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'NG'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> point <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token regex">/[A-Z]/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        point<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token regex">/[a-z]/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        point<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token regex">/\d/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        point<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token regex">/[^A-Za-z\d]/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        point<span class="token operator">++</span>    <span class="token punctuation">}</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>point<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'NG'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>str<span class="token punctuation">.</span>length<span class="token number">-3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> tempStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span>tempStr<span class="token punctuation">)</span><span class="token operator">></span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"NG"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"OK"</span><span class="token punctuation">)</span>          <span class="token punctuation">}</span></code></pre><p>4.简单密码</p><p>题目描述</p><p>  密码是我们生活中非常重要的东东，我们的那么一点不能说的秘密就全靠它了。哇哈哈. 接下来渊子要在密码之上再加一套密码，虽然简单但也安全。 </p><p>  假设渊子原来一个BBS上的密码为zvbo9441987,为了方便记忆，他通过一种算法把这个密码变换成YUANzhi1987，这个密码是他的名字和出生年份，怎么忘都忘不了，而且可以明目张胆地放在显眼的地方而不被别人知道真正的密码。 </p><p>   他是这么变换的，大家都知道手机上的字母： 1–1， abc–2, def–3, ghi–4, jkl–5, mno–6, pqrs–7, tuv–8 wxyz–9, 0–0,就这么简单，渊子把密码中出现的小写字母都变成对应的数字，数字和其他的符号都不做变换， </p><p>  声明：密码中没有空格，而密码中出现的大写字母则变成小写之后往后移一位，如：X，先变成小写，再往后移一位，不就是y了嘛，简单吧。记住，z往后移是a哦。 </p><p>输入描述:</p><pre><code>输入包括多个测试数据。输入是一个明文，密码长度不超过100个字符，输入直到文件结尾</code></pre><p>输出描述:</p><pre><code>输出渊子真正的密文</code></pre><p>输入</p><pre><code>YUANzhi1987</code></pre><p>输出</p><pre><code>zvbo9441987</code></pre>]]></content>
      
      
      <categories>
          
          <category> 牛客网华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="2021/03/09/niuke/suanfa/suan-fa/"/>
      <url>2021/03/09/niuke/suanfa/suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构：图的存储结构之邻接表"><a href="#数据结构：图的存储结构之邻接表" class="headerlink" title="数据结构：图的存储结构之邻接表"></a>数据结构：图的存储结构之邻接表</h1><p><a href="https://blog.csdn.net/jnu_simba/article/details/8866844">https://blog.csdn.net/jnu_simba/article/details/8866844</a></p><h1 id="判断有向图是否存在环"><a href="#判断有向图是否存在环" class="headerlink" title="判断有向图是否存在环"></a>判断有向图是否存在环</h1><p><a href="https://blog.csdn.net/KID_LWC/article/details/82391702">https://blog.csdn.net/KID_LWC/article/details/82391702</a></p><h1 id="哈夫曼树原理，及构造方法"><a href="#哈夫曼树原理，及构造方法" class="headerlink" title="哈夫曼树原理，及构造方法"></a>哈夫曼树原理，及构造方法</h1><p><a href="https://blog.csdn.net/qq_29519041/article/details/81428934">https://blog.csdn.net/qq_29519041/article/details/81428934</a></p><h1 id="操作系统之进程调度——优先权法和轮转法（附上样例讲解）"><a href="#操作系统之进程调度——优先权法和轮转法（附上样例讲解）" class="headerlink" title="操作系统之进程调度——优先权法和轮转法（附上样例讲解）"></a>操作系统之进程调度——优先权法和轮转法（附上样例讲解）</h1><p><a href="https://blog.csdn.net/qq_40693171/article/details/84755887">https://blog.csdn.net/qq_40693171/article/details/84755887</a></p><p>动态规划</p><p><a href="https://www.cnblogs.com/hithongming/p/9229871.html">https://www.cnblogs.com/hithongming/p/9229871.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析与设计</title>
      <link href="2021/03/09/ziliao/suanfa/suan-fa-fen-xi-yu-she-ji/"/>
      <url>2021/03/09/ziliao/suanfa/suan-fa-fen-xi-yu-she-ji/</url>
      
        <content type="html"><![CDATA[<p>笔记总结</p><h1 id="第一章-算法引论"><a href="#第一章-算法引论" class="headerlink" title="第一章 算法引论"></a>第一章 算法引论</h1><h2 id="1-1-算法与程序"><a href="#1-1-算法与程序" class="headerlink" title="1.1 算法与程序"></a>1.1 算法与程序</h2><pre><code>算法定义：解决问题的方法或过程算法的性质：    （1）输入：有零个或多个外部量作为算法的输入    （2）输出：算法产生至少一个量作为输出    （3）确定性：组成算法的每条指令是清晰的，无歧义的    （4）有限性：算法中每条指令的执行次数有限，执行每条指令的时间也有限    有时还会加入通用性或可行性程序的定义：是算法用某种程序设计语言的具体实现。程序与算法的区别：程序可以不满足算法的第四点性质即有限性。例如操作系统，是在无限循环中执行的程序。</code></pre><h2 id="1-2-表达算法的抽象机制"><a href="#1-2-表达算法的抽象机制" class="headerlink" title="1.2 表达算法的抽象机制"></a>1.2 表达算法的抽象机制</h2><pre><code>为了将顶层算法与底层算法隔开，使二者在设计时不互相牵制，互相影响，必须对二者的接口进行抽象。让底层只通过接口为顶层服务，顶层也只通过接口调用底层运算。这个接口就是抽象数据类型(ADT)。</code></pre><h2 id="1-3-描述算法"><a href="#1-3-描述算法" class="headerlink" title="1.3 描述算法"></a>1.3 描述算法</h2><pre><code>有多种方式，如：自然语言方式，表格方式，高级程序语言方式等…</code></pre><h2 id="1-4-算法复杂性分析"><a href="#1-4-算法复杂性分析" class="headerlink" title="1.4 算法复杂性分析"></a>1.4 算法复杂性分析</h2><pre><code>算法分析的目的：分析算法占用计算机资源的情况，对算法做出比较和评价，设计出更好的算法算法的复杂性是算法运行时所需的计算机资源的量，需要时间资源的量称为时间复杂性，需要空间资源的量称为空间复杂性。C=F(N,I,A)，用N，I，A分别表示算法要解的问题的规模，算法的输入和算法本身，F表示是上诉N，I，A的确定的三元函数，C表示复杂性一般只考虑3种情况下的时间复杂性，即最坏情况，最好情况，平均情况实践表明，可操作性最好且最有实际价值的是最坏情况下的时间复杂性。复杂性渐进性态：对于T(N)，如果存在~T(N)，使得当N→∞时有(T(N)-~T(N))/T(N)→0，那么就说~T(N)是T(N)当N→∞时的渐进性态。如果存在正的常数C和自然数N0，使得当N≥N0时有f(N)≤Cg(N)，则称函数f(N)当N充分大时上有界，且g(N)是它的一个上界，记为f(N)=O(g(N))。这时还说f(N)的阶不高于g(N)的阶。对于符号O，有如下运算规则：    O(f)+O(g)=O(max(f,g))    O(f)+O(g)=O(f+g)    O(f)O(g)=O(fg)    如果g(N)=O(f(N)),则O(f)+O(g)=O(f)    O(Cf(N))=O(f(N)),其中C是一个正的常数    f=O(f)</code></pre><h1 id="第二章-递归与分治策略"><a href="#第二章-递归与分治策略" class="headerlink" title="第二章 递归与分治策略"></a>第二章 递归与分治策略</h1><h2 id="2-1-递归的概念"><a href="#2-1-递归的概念" class="headerlink" title="2.1 递归的概念"></a>2.1 递归的概念</h2><pre><code>直接或间接地调用自身的算法称为递归算法。用函数自身给出定义的函数称为递归函数递归函数的两个要素：边界条件和递归方程阶乘函数：</code></pre><p>#include<iostream><br>using namespace std;</iostream></p><p>int factorial(int n){<br>    if(n==0) return 1;<br>    else{<br>        return n*factorial(n-1);<br>    }<br>}</p><p>Fibonacci数列：</p><p>#include<iostream><br>using namespace std;</iostream></p><p>int fibonacci(int n){<br>    if(n&lt;=1) return 1;<br>    else return fibonacci(n-1)+fibonacci(n-2);<br>} </p><p>hanoi塔：</p><pre><code>def hanoi(n,a,b,c):    #将a上的n个圆盘经过c移动到b    if(n&gt;0):        hanoi(n-1,a,c,b)        move(a,b)        hanoi(n-1,c,b,a)递归算法的优点：结构清晰，可读性强，容易用数学归纳法来证明算法的正确性递归算法的缺点：运行效率低，无论是耗费的计算时间还是占用的存储空间都比非递归算法多。消除递归的方法：①采用一个用户定义的栈来模拟系统的递归调用工作栈，从而达到将递归算法改为非递归算法的目的②用递推来实现递归函数</code></pre><h2 id="2-2-分治法的基本思想"><a href="#2-2-分治法的基本思想" class="headerlink" title="2.2 分治法的基本思想"></a>2.2 分治法的基本思想</h2><pre><code>分治法的基本思想：将一个规模为n的问题分解为k个规模较小的子问题，这些子问题相互独立且与原问题相同。递归地解这些子问题，然后将各子问题的解合并得到原问题的解。分治法的适用条件：    ①该问题的规模缩小到一定程度容易解决。    ②该问题可以分解为若干个规模较小的相同问题。即该问题具有最优子结构性质。    ③该问题分解出的子问题的解可以合并为该问题的解。    ④子问题间不包含公共的子问题（各子问题相互独立）分治法的步骤：    划分    解决    合并</code></pre><h2 id="2-3-二分搜索技术"><a href="#2-3-二分搜索技术" class="headerlink" title="2.3 二分搜索技术"></a>2.3 二分搜索技术</h2><p>def binarySearch(a,x):<br>    #a是数组,x是要搜索的数<br>    a=sorted(a)<br>    #a要求有序（从小到大）<br>    n=len(a)<br>    left,right=0,n-1<br>    while(left&lt;=right):<br>        middle=(left+right)//2<br>        if(x==a[middle]):<br>            return middle<br>        elif(x&gt;a[middle]):<br>            left=middle+1<br>        else:<br>            right=middle-1<br>    #未找到<br>    return -1</p><pre><code>最坏情况下，时间复杂度是O(logn)</code></pre><h2 id="2-4-大整数乘法"><a href="#2-4-大整数乘法" class="headerlink" title="2.4 大整数乘法"></a>2.4 大整数乘法</h2><pre><code>设x和y都是n位的二进制整数，现在要计算他们的乘积xy。如果直接相乘，需要O(n^2)步，而其分治法是：将n位二进制整数X和Y都分为2段，每段的长为n/2位：X=[A][B],Y=[C][D],其中X，Y有n位；A，B，C，D均有n/2位由此可以得到：X=A*2^(n/2)+B , Y=C*2^(n/2)+DXY=(A*2^(n/2)+B)(C*2^(n/2)+D)  =A*C*2^n+(A*D+C*B)*2^(n/2)+B*D  =A*C*2^n+((A-B)(D-C)+A*C+B*D)*2^(n/2)+B*D最后一个式子看起来似乎复杂了，但是它仅需做3次n/2位整数的乘法，6次加减法和2次移位2.5 Strassen矩阵乘法对于方阵（n*n）A,B,C，有C=A*B,将它们都分块成4个大小相等的子矩阵，每个子矩阵都是(n/2)*(n/2)的方阵MhaKxS.png</code></pre><h2 id="2-7-合并排序"><a href="#2-7-合并排序" class="headerlink" title="2.7 合并排序"></a>2.7 合并排序</h2><p>def merge(arr,left,mid,right):<br>    #left，right为需要合并的数组范围<br>    #mid为中间下标，左边比中值小，右边比中值大<br>    i=left<br>    j=mid+1<br>    #复制一个临时数组<br>    aux=arr[:]<br>    for k in range(left,right+1):<br>        #如果左指针超过mid，即右边还有剩余<br>        if(i&gt;mid):<br>            arr[k]=aux[j]<br>            j=j+1<br>        #如果右指针超过right，即左边还有剩余<br>        elif(j&gt;right):<br>            arr[k]=aux[i]<br>            i=i+1<br>        #如果左边小，则左边合并<br>        elif(aux[i]&lt;aux[j]):<br>            arr[k]=aux[i]<br>            i=i+1<br>        #如果右边小<br>        else:<br>            arr[k]=aux[j]<br>            j=j+1</p><p>def mergeSort(arr,left,right):<br>    #如果已经遍历完<br>    if(left&gt;=right):<br>        return ;<br>    #取中值，拆成左右两边<br>    mid=(left+right)//2<br>    #对左半边进行归并排序<br>    mergeSort(arr,left,mid)<br>    #对右半边进行归并排序<br>    mergeSort(arr,mid+1,right)<br>    #合并算法<br>    merge(arr,left,mid,right)</p><pre><code>最坏情况下的时间复杂度为O(nlogn)</code></pre><h2 id="2-8-快速排序"><a href="#2-8-快速排序" class="headerlink" title="2.8 快速排序"></a>2.8 快速排序</h2><pre><code>步骤：分解，递归求解，合并def quicksort(arr,low,high):    if low&lt;high :        index=getindex(arr,low,high)        quicksort(arr,low,index-1)        quicksort(arr,index+1,high)#快速排序算法核心#作用：将小于基准值的数放在其左边，大于在右边def getindex(arr,low,high):    #默认第一个数字为标准值    temp=arr[low]    #当未遍历完，即左右指针未相遇    while(low&lt;high):        #如果右边大于标准值，右指针左移        while((low&lt;high)and(arr[high]&gt;=temp)):            high=high-1        #此时右指针对应值小于标准值，将其复制给左指针位置        arr[low]=arr[high]        #当左边小于标准值，左指针右移        while((low&lt;high)and(arr[low]&lt;=temp)):            low=low+1        #此时左指针对应值大于标准值，将其复制给右指针位置        arr[high]=arr[low]    #将标准值赋值给左右指针相遇的位置    arr[low]=temp    #此时low左边全部小于等于arr[low],low右边全部大于等于arr[low]    return low快排平均情况下的时间复杂度是O(nlogn)，最坏情况下的时间复杂度是O(n^2)</code></pre><h2 id="2-9-线性时间选择"><a href="#2-9-线性时间选择" class="headerlink" title="2.9 线性时间选择"></a>2.9 线性时间选择</h2><pre><code>找出一组数中，第X大（小）的数采用了随机划分算法</code></pre><h2 id="2-10-最近点对问题"><a href="#2-10-最近点对问题" class="headerlink" title="2.10 最近点对问题"></a>2.10 最近点对问题</h2><pre><code>时间复杂度分析O(nlogn)</code></pre><p>“””<br>Copyright: Copyright (c) 2019<br>Author: Justlovesmile<br>Title: 最近点对问题<br>“””</p><p>#按x坐标排序的点<br>class Point1:<br>    #x,y为坐标，id为序号<br>    def <strong>init</strong>(self,xx,yy,index):<br>        self.x=xx<br>        self.y=yy<br>        self.id=index</p><p>#按y坐标排序的点<br>class Point2(Point1):<br>    #x，y为坐标，id为该点按x排序时的序号<br>    def <strong>init</strong>(self,xx,yy,index):<br>        self.x=xx<br>        self.y=yy<br>        self.id=index</p><p>#表示输出的平面点对<br>class Pair:<br>    #a，b为点，dist为距离<br>    def <strong>init</strong>(self, aa, bb,dd):<br>        self.a=aa<br>        self.b=bb<br>        self.dist=dd</p><p>#求平面上任意两点u,v的距离<br>def dist(u,v):<br>    dx=u.x-v.x<br>    dy=u.y-v.y<br>    return dx<em>dx+dy</em>dy</p><p>#归并排序<br>def merge(S,order,left,mid,right):<br>    i=left<br>    j=mid+1<br>    aux=S[:]<br>    #按x排序<br>    if(order==’x’):<br>        for k in range(left,right+1):<br>            if(i&gt;mid):<br>                S[k]=aux[j]<br>                j=j+1<br>            elif(j&gt;right):<br>                S[k]=aux[i]<br>                i=i+1<br>            elif(S[i].x&lt;aux[j].x):<br>                S[k]=aux[i]<br>                i=i+1<br>            else:<br>                S[k]=aux[j]<br>                j=j+1<br>    #按y排序<br>    elif(order==’y’):<br>        for k in range(left,right+1):<br>            if(i&gt;mid):<br>                S[k]=aux[j]<br>                j=j+1<br>            elif(j&gt;right):<br>                S[k]=aux[i]<br>                i=i+1<br>            elif(S[i].y&lt;aux[j].y):<br>                S[k]=aux[i]<br>                i=i+1<br>            else:<br>                S[k]=aux[j]<br>                j=j+1</p><p>#归并排序<br>def mergeSort(S,x,left,right):<br>    if(left&gt;=right):<br>        return ;<br>    mid=(left+right)//2<br>    mergeSort(S,x,left,mid)<br>    mergeSort(S,x,mid+1,right)<br>    merge(S,x,left,mid,right)</p><p>#计算最接近点对<br>def closePair(S,Y,Z,l,r):<br>    #两个点<br>    if(r-l==1):<br>        return Pair(S[l],S[r],dist(S[l],S[r]))<br>    #三个点<br>    if(r-l==2):<br>        d1=dist(S[l],S[l+1])<br>        d2=dist(S[l+1],S[r])<br>        d3=dist(S[l],S[r])<br>        if((d1&lt;=d2)and(d1&lt;=d3)):<br>            return Pair(S[l],S[l+1],d1)<br>        if(d2&lt;=d3):<br>            return Pair(S[l+1],S[r],d2)<br>        else:<br>            return Pair(S[l],S[r],d3)<br>    #多于三个点<br>    m=(l+r)//2<br>    f=l<br>    g=m+1<br>    for i in range(l,r+1):<br>        if(Y[i].id&gt;m):<br>            Z[g]=Y[i]<br>            g=g+1<br>        else:<br>            Z[f]=Y[i]<br>            f=f+1<br>    #递归求解<br>    best = closePair(S,Z,Y,l,m)<br>    right = closePair(S,Z,Y,m+1,r)<br>    #选最近的点对<br>    if(right.dist&lt;best.dist):<br>        best=right<br>    merge(Y,”y”,l,m,r)</p><pre><code>k=l#距离中线最近的for i in range(l,r+1):    if(abs(S[m].x-Y[i].x)&lt;best.dist):        Z[k]=Y[i]        k=k+1for i in range(l,k):    for j in range(i+1,k):        if(Z[j].y-Z[i].y&lt;best.dist):            dp=dist(Z[i],Z[j])            if(dp&lt;best.dist):                best=Pair(S[Z[i].id],S[Z[j].id],dp)#返回最近点对return best</code></pre><p>#一维点集<br>def cpair1(S):<br>    #先设为正无穷<br>    min_d=float(“inf”)<br>    S=sorted(S)<br>    for i in range(1,len(S)):<br>        dist=abs(S[i]-S[i-1])<br>        if(dist&lt;min_d):<br>            pair=[]<br>            min_d=dist<br>            pair.append([S[i-1],S[i]])<br>        elif(dist==min_d):<br>            pair.append([S[i-1],S[i]])<br>    print(“Closest point:”)<br>    for i in pair:<br>        print(i,end=” “)<br>    print(“\nMin_dist:”,min_d)</p><p>#二维点集<br>def cpair2(S):<br>    Y=[]<br>    n=len(S)<br>    if(n&lt;2):<br>        return ;<br>    #按X坐标排序<br>    mergeSort(S,”x”,0,n-1)<br>    #以Point2类型赋值<br>    for i in range(n):<br>        p=Point2(S[i].x,S[i].y,i)<br>        Y.append(p)<br>    #按y坐标排序<br>    mergeSort(Y,”y”,0,n-1)<br>    Z=Y[:]<br>    return closePair(S,Y,Z,0,n-1)</p><p>def main():<br>    #输入一维还是二维点平面<br>    model=input(“Please choose model of ‘1’ or ‘2’:”).split()[0]<br>    S=[]<br>    #一维点对<br>    if(model == ‘1’):<br>        point=input(“Please input a group of number in order:\n”).split()<br>        #如果输入空点对<br>        if(len(point)==0):<br>            raise ValueError(“您输入了空点对！”)<br>        #转换类型<br>        for i in range(len(point)):<br>            S.append(int(point[i]))<br>        #输出最近点对<br>        cpair1(S)<br>    #二维点对<br>    elif(model == ‘2’):<br>        #输入点数<br>        n=int(input(“Please input how many points:\n”))<br>        if(n==0):<br>            raise ValueError(“您输入了0个点！”)<br>        for i in range(n):<br>            words=f”please input the No.{i+1} point (like: x y) in x order:”<br>            point=input(words).split()<br>            p=Point1(int(point[0]),int(point[1]),i)<br>            S.append(p)<br>        #找到最近的一对点对<br>        best=cpair2(S)<br>        print(f”The closest points are ({best.a.x},{best.a.y}) and ({best.b.x},{best.b.y}).”)<br>        print(f”And the distance is {best.dist**0.5}.”)<br>    else:<br>        raise ValueError(“没有这个选项！”)</p><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    #异常处理<br>    try:<br>        main()<br>    except Exception as e:<br>        print(“您的输入不合法！出错信息如下：”)<br>        print(e)</p><h1 id="第三章-动态规划"><a href="#第三章-动态规划" class="headerlink" title="第三章 动态规划"></a>第三章 动态规划</h1><pre><code>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解，但与分治法不同的是，适用于动态规划法求解的问题，经分解得到的子问题往往不是相互独立的。动态规划算法的步骤：    ①找出最优解的性质，并刻画其结构特征    ②递归地定义最优值    ③以自底向上的方式计算出最优值    ④根据计算最优值时得到的信息，构造最优解动态规划算法的两个基本要素：最优子结构与重叠子问题    最优子结构性质：问题的最优解包含子问题的最优解    重叠子问题：在用递归算法自顶向下求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次    无后效性：一个问题被划分阶段后，阶段I中的状态只能由I+1中的状态通过状态转移方程得来，与其他状态没有关系，特别是与未发生的状态没有关系动态规划算法有一个变形方法——备忘录方法，这种方法不同于动态规划算法“自底向上”的填充方向，而是“自顶向下”的递归方向，为每一个解过的子问题建立一个记录项（备忘录）以备需要时查看，也可以避免相同子问题的重复求解</code></pre><h2 id="3-1-矩阵连乘问题"><a href="#3-1-矩阵连乘问题" class="headerlink" title="3.1 矩阵连乘问题"></a>3.1 矩阵连乘问题</h2><pre><code>MIK2dK.pngm(i,j)是指从A[i]到A[j]（1≤i≤j≤n）的最少数乘次数矩阵可乘条件：A的列数等于B的行数，若A是一个p×q矩阵，B是一个q×r矩阵，则AB总共需要pqr次数乘。</code></pre><p>“””<br>Copyright: Copyright (c) 2019<br>Author: Justlovesmile<br>Title: 矩阵连乘问题<br>“””</p><p>#计算最优值<br>def matrixChain(p,m,s):<br>    #m[i][j]表示A[i]到A[j]所需的最少数乘次数<br>    #s[i][j]表示A[i]到A[j]所需的最少数乘法对应的分隔位置<br>    n=len(p)-1<br>    for r in range(2,n+1):<br>        for i in range(1,n-r+2):<br>            #沿斜线方向递进<br>            j=r+i-1<br>            m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j]<br>            s[i][j]=i<br>            k=i+1<br>            #寻找i到j间最优分隔k<br>            while(k&lt;j):<br>                t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]<br>                if(t&lt;m[i][j]):<br>                    m[i][j]=t<br>                    s[i][j]=k<br>                k=k+1</p><p>#根据S递归输出<br>def traceback(s,i,j):<br>    if(i==j):<br>        print(f”A[{i}]”,end=””)<br>        return ;<br>    print(“(“,end=””)<br>    traceback(s,i,s[i][j])<br>    traceback(s,s[i][j]+1,j)<br>    print(“)”,end=””)</p><p>def main():<br>    p=[]<br>    y=0<br>    #输入矩阵个数<br>    n=input(“Please iuput the number of matrix:”).split()<br>    #异常处理<br>    if(len(n)==0):<br>        raise ValueError(“您输入了空矩阵！”)<br>    n=int(n[0])<br>    #输入每个矩阵的信息<br>    for i in range(n):<br>        s=input(f”Input No.{i+1} Matrix size,eg:5 5\n”).split()<br>        #判断是否能与前一项相乘<br>        if(len(p)&gt;=1):<br>            if(y!=int(s[0])):<br>                raise ValueError(“您输入的矩阵不能相乘！”)<br>        x,y=int(s[0]),int(s[1])<br>        p.append(x)<br>    p.append(y)<br>    m=[]<br>    s=[]<br>    for i in range(n+1):<br>        m.append([0]<em>(n+1))<br>        s.append([0]</em>(n+1))<br>    matrixChain(p,m,s)<br>    traceback(s,1,n)<br>    print(“\nCount times:”,m[1][n])</p><p>​    </p><p>if <strong>name</strong> ==”<strong>main</strong>“:<br>    #异常处理<br>    try:<br>        main()<br>    except Exception as e:<br>        print(“您的输入不合法！出错信息如下：”)<br>        print(e)</p><h2 id="3-3-最长公共子序列"><a href="#3-3-最长公共子序列" class="headerlink" title="3.3 最长公共子序列"></a>3.3 最长公共子序列</h2><pre><code>MI179S.png建立递归关系：MI399U.png</code></pre><p>“””<br>Copyright: Copyright (c) 2019<br>Author: Justlovesmile<br>Title: 最长公共子序列问题<br>“””</p><p>def IcsLength(x,y,b):<br>    m=len(x)<br>    n=len(y)<br>    #初始化<br>    c=[]<br>    for j in range(m+1):<br>        c.append([0]*(n+1))<br>    #逐个比较<br>    for i in range(1,m+1):<br>        for j in range(1,n+1):<br>            #如果相等那么此时的最长公共长度为去除该位置的最长公共长度+1<br>            if(x[i-1]==y[j-1]):<br>                c[i][j]=c[i-1][j-1]+1<br>                #记录c[i][j]的值是第一类子问题的解得到的<br>                b[i][j]=1<br>            #如果对应位置不相等，则比较两个序列去掉这个不等值后哪边的最长子序列会更长<br>            elif(c[i-1][j]&gt;=c[i][j-1]):<br>                c[i][j]=c[i-1][j]<br>                b[i][j]=2<br>            else:<br>                c[i][j]=c[i][j-1]<br>                b[i][j]=3<br>    return c[m][n]</p><p>#根据b[i][j]输出最长子序列<br>def Ics(i,j,x,b):<br>    if(i==0 or j==0):<br>        return ;<br>    #如果是第一类子问题的解，则说明该位置是公共部分<br>    if(b[i][j]==1):<br>        Ics(i-1,j-1,x,b)<br>        print(x[i-1],end=””)<br>    #如果是第二类子问题的解，则说明此时Zk≠Xm<br>    elif(b[i][j]==2):<br>        Ics(i-1,j,x,b)<br>    #Zk≠Yn<br>    else:<br>        Ics(i,j-1,x,b)</p><p>def main():<br>    #输入字符串<br>    A=input(“Please input No.1 Ics:”).split()<br>    B=input(“Please input No.2 Ics:”).split()<br>    b=[]<br>    for i in range(len(A)+1):<br>        b.append([0]*(len(B)+1))<br>    print(“The longest length:”,IcsLength(A,B,b))<br>    Ics(len(A),len(B),A,b)</p><p>if <strong>name</strong>==”<strong>main</strong>“:<br>    #异常处理<br>    try:<br>        main()<br>    except Exception as e:<br>        print(“您的输入不会合法！出错信息如下：”)<br>        print(e)</p><h2 id="3-4-凸多边形最优三角剖分"><a href="#3-4-凸多边形最优三角剖分" class="headerlink" title="3.4 凸多边形最优三角剖分"></a>3.4 凸多边形最优三角剖分</h2><pre><code>和矩阵连乘相似</code></pre><p>“””<br>Copyright: Copyright (c) 2019<br>Author: Justlovesmile<br>Title: 凸多边形最优三角剖分问题<br>“””<br>from isConvex import isConvex</p><p>#计算最优值<br>def minWeightTriangulation(n,t,s,v):<br>    #t[i][j]是凸子多边形vi-1,vi,…,vj的最优三角剖分对应的权函数值<br>    for r in range(2,n+1):<br>        for i in range(1,n-r+2):<br>            j=r+i-1<br>            t[i][j]=t[i+1][j]+weight(i-1,i,j,v)<br>            s[i][j]=i<br>            k=i+1<br>            #遍历i到j的所有边<br>            while(k&lt;j):<br>                u=t[i][k]+t[k+1][j]+weight(i-1,k,j,v)<br>                if(u&lt;t[i][j]):<br>                    t[i][j]=u<br>                    s[i][j]=k<br>                k=k+1</p><p>#根据s输出划分结果<br>def traceback(s,i,j):<br>    if(i==j):<br>        print(f”B[{i}]”,end=””)<br>        return ;<br>    print(“(“,end=””)<br>    traceback(s,i,s[i][j])<br>    traceback(s,s[i][j]+1,j)<br>    print(“)”,end=””)</p><p>#根据距离计算权重<br>def weight(i,j,k,v):<br>    return dist(i,j,v)+dist(i,k,v)+dist(k,j,v)</p><p>#计算距离<br>def dist(i,j,v):<br>    return (v[i][0]-v[j][0])**2+(v[i][1]-v[j][1])**2</p><p>def main():<br>    v=[]<br>    #可选择手动输入和使用默认值<br>    ans=input(“Do you want to use default v[]:(y / n )”)<br>    if(ans==”y” or ans==”Y”):<br>        v=[[6,1],[13,1],[16,4],[13,7],[6,7],[3,4]]<br>        graph=”””—–@######@——-\n—-#——–#——\n—#———-#—–\n–@————@—-\n—#———-#—–\n—-#——–#——\n—–@######@——-\n”””<br>        print(graph)<br>        for i in v:<br>            print(f”({i[0]},{i[1]})”,end=” “)</p><pre><code>elif(ans==&quot;n&quot; or ans==&quot;N&quot;):    n=int(input(&quot;Please input the number of points:\n&quot;))    if(n==0):        raise ValueError(&quot;您输入了0！&quot;)    for i in range(n):        a=input(f&quot;Input X and Y of No.&#123;i+1&#125; point:(eg:X Y)\n&quot;).split()        v.append([int(a[0]),int(a[1])])    else:    raise ValueError(&quot;对不起没有这个选项！&quot;)#判断是不是图多边形if(not isConvex(v)):    raise ValueError(&quot;您输入的不是凸多边形！请确认是否按顺序输入！&quot;)t=[]s=[]n=len(v)#初始化for i in range(n):    t.append([0]*(n))    s.append([0]*(n))minWeightTriangulation(n-1,t,s,v)traceback(s,0,n-1)</code></pre><p>if <strong>name</strong>==”<strong>main</strong>“:<br>    #异常处理<br>    try:<br>        main()<br>    except Exception as e:<br>        print(“您的输入不合法！出错信息如下：”)<br>        print(e)</p><p>判断是否为凸多边形</p><p>#判断是否为凸多边形<br>‘’’<br>计算直线表达式<br>param vertex1: 前一个顶点<br>param vertex2: 后一个顶点<br>return (type, param): 返回直线的类别及其描述参数<br>‘’’<br>def kb(vertex1, vertex2):<br>    x1 = vertex1[0]<br>    y1 = vertex1[1]<br>    x2 = vertex2[0]<br>    y2 = vertex2[1]</p><pre><code>if x1==x2:    return (0, x1)      # 0-垂直直线if y1==y2:                  return (1, y1)      # 1-水平直线else:    k = (y1-y2)/(x1-x2)    b = y1 - k*x1    return (2, k, b)    # 2-倾斜直线</code></pre><p>‘’’<br>判断是否为凸多边形<br>param vertexes: 构成多边形的所有顶点坐标列表，如[[0，0], [50, 0], [0, 50]]<br>return convex: 布尔类型，为True说明该多边形为凸多边形，否则为凹多边形<br>‘’’<br>def isConvex(vertexes):<br>    # 默认为凸多边形<br>    convex = True   </p><pre><code># 多边形至少包含三个顶点l = len(vertexes)if l&lt;3:    raise ValueError(&quot;多边形至少包含三个顶点！&quot;)# 对每两个点组成的直线做判断for i in range(l):    pre = i    nex = (i+1)%l        # 得到直线    line = kb(vertexes[pre], vertexes[nex])        # 计算所有点和直线的距离（可能为正也可能为负）    if line[0]==0:        offset = [vertex[0]-vertexes[pre][0] for vertex in vertexes]    elif line[0]==1:        offset = [vertex[1]-vertexes[pre][1] for vertex in vertexes]    else:        k, b = line[1], line[2]        offset = [k*vertex[0]+b-vertex[1] for vertex in vertexes]        # 计算两两距离的乘积，如果出现负数则存在两个点位于直线两侧，因此为凹多边形    for o in offset:        for s in offset:            if o*s&lt;0:                convex = False                break        if convex==False:            break                    if convex==False:        break        # 打印判断结果if convex==True:    print(&quot;该多边形为凸多边形！&quot;)else:    print(&quot;该多边形为凹多边形！&quot;)return convex</code></pre><h2 id="3-9-0-1背包问题"><a href="#3-9-0-1背包问题" class="headerlink" title="3.9 0-1背包问题"></a>3.9 0-1背包问题</h2><pre><code>MIGH1O.png其中m(i,j)是指背包容量为j，可选择物品为i，i+1，···，n时0-1背包问题的最优值</code></pre><p>“””<br>Copyright: Copyright (c) 2019<br>Author: Justlovesmile<br>Title: 0-1背包问题–动态规划<br>“””</p><p>#跳跃点法<br>def knapsack_Pro(n,v,w,C,p,x):<br>    #head指向每一阶段跳跃点集合的开始<br>    head=[0 for i in range(n+1)]<br>    p[0][0],p[0][1]=0,0<br>    left,right,pnext,head[1]=0,0,1,1<br>    for i in range(n):<br>        k=left<br>        for j in range(left,right+1):<br>            if(p[j][0]+w[i]&gt;C):<br>                break<br>            y=p[j][0]+w[i]<br>            m=p[j][1]+v[i]<br>            #重量小于此数的跳跃点直接加进来，不会被支配<br>            while(k&lt;=right and p[k][0]&lt;y):<br>                p[pnext][0]=p[k][0]<br>                p[pnext][1]=p[k][1]<br>                pnext+=1<br>                k+=1<br>            #两个if判断新产生的点能否加入p<br>            if(k&lt;=right and p[k][0]==y):<br>                if(m&lt;p[k][1]):<br>                    m=p[k][1]<br>                k+=1<br>            if(m&gt;p[pnext-1][1]):<br>                p[pnext][0]=y<br>                p[pnext][1]=m<br>                pnext+=1<br>            #取出可以支配的点<br>            while(k&lt;=right and p[k][1]&lt;=p[pnext-1][1]):<br>                k+=1</p><pre><code>    #上面break后    while(k&lt;=right):        p[pnext][0]=p[k][0]        p[pnext][1]=p[k][1]        pnext+=1        k+=1        left=right+1    right=pnext-1    head[i+1]=pnexttraceback_Pro(n,w,v,p,head,x)</code></pre><p>def traceback_Pro(n,w,v,p,head,x):<br>    j=p[head[n]-1][0]<br>    m=p[head[n]-1][1]<br>    print(“max value:”,m,”max weight:”,j)<br>    for i in range(n)[::-1]:<br>        for k in range(head[i],head[i+1]-1):<br>            if(p[k][0]+w[i]==j and p[k][1]+v[i]==m):<br>                x[i]=1<br>                j=p[k][0]<br>                m=p[k][1]<br>                break</p><p>def knapsack(v,w,C,m):<br>    #m[i][j]指背包容量为j，可选择物品为i，i+1，…，n时的0-1背包问题的最优值<br>    n=len(v)-1<br>    #只剩一个物品的情况<br>    for j in range(C):<br>        m[n][j] = v[n] if j&gt;=min(w[n]-1,C) else 0<br>    #普通情况<br>    for i in range(1,n)[::-1]:<br>        for j in range(C):<br>            m[i][j] = max(m[i+1][j],m[i+1][j-w[i]]+v[i]) if j&gt;w[i]-1 else m[i+1][j]<br>    #第一件物品<br>    if(n&gt;0):<br>        m[0][C-1]=m[1][C-1]<br>        if C-1&gt;=w[0]:<br>            m[0][C-1]=max(m[0][C-1],m[1][C-1-w[0]]+v[0])</p><p>def traceback(m,w,C,x):<br>    c=C-1<br>    for i in range(len(w)-1):<br>        #没选物品i则x[i]=0<br>        if (m[i][c]==m[i+1][c]):<br>            x[i]=0<br>        else:<br>            x[i]=1<br>            c -= w[i]<br>    #对于最后一个物品<br>    x[len(w)-1]=1 if m[len(w)-1][c]&gt;0 else 0</p><p>#输出格式<br>def cout(x,v,w):<br>    total_v=0<br>    total_w=0<br>    print(“Choose:”)<br>    for i in range(len(v)):<br>        if x[i]==1:<br>            print(f”No.{i+1} item: value is {v[i]} , weight is {w[i]}”)<br>            total_v +=v[i]<br>            total_w +=w[i]<br>    print(f”total value: {total_v}”)<br>    print(f”total weight: {total_w}”)</p><p>def main():<br>    v=[]    #物品的价值列表<br>    w=[]    #物品的重量列表<br>    #输入物品数量<br>    n=input(“Please input the number of items:\n”)<br>    if(n==”” or n==”0”):<br>        raise ValueError(“您输入了空值或0！”)<br>    else:<br>        n=int(n)<br>    x=[0 for i in range(n+1)]<br>    #选择两种算法（课本上的）<br>    ans=input(“Choose Knapsack or Knapsack_Pro?(1 or 2)\n”).split()[0]<br>    if ans==’1’:<br>        m=[]    #m(i,j)指背包容量为j，可选择物品为i，i+1，…，n时的0-1背包问题的最优值<br>        for i in range(n):<br>            item=input(f”please input No.{i+1} item’s value(v) and weight(w):(eg:v w)\n”).split()<br>            v.append(int(item[0]))<br>            w.append(int(item[1]))<br>        C=int(input(“Please input the max weight of bag:\n”))<br>        if(C&lt;=0):<br>            raise ValueError(“背包容量不能≤0”)<br>        for i in range(n):<br>            m.append([0]<em>C)<br>        knapsack(v,w,C,m)<br>        traceback(m,w,C,x)<br>        cout(x,v,w)<br>    elif ans==’2’:<br>        for i in range(n):<br>            item=input(f”please input No.{i+1} item’s value(v) and weight(w):(eg:v w)\n”).split()<br>            v.append(float(item[0]))<br>            w.append(float(item[1]))<br>        #初始化<br>        p=[[0 for i in range(2)]for j in range(n</em>n)]<br>        C=float(input(“Please input the max weight of bag:\n”))<br>        if(C&lt;=0):<br>            raise ValueError(“背包容量不能小于等于0”)<br>        if(n==1):<br>            if(w[0]&lt;=C):<br>                x[0]=1<br>            else:<br>                x[0]=0<br>        else:<br>            knapsack_Pro(n,v,w,C,p,x)<br>        for i in range(n):<br>            if(x[i]==1):<br>                print(“choose: value:”,v[i],”weight:”,w[i])<br>    else:<br>        raise ValueError(f”您输入了{ans}没有该选项！”)</p><p>if <strong>name</strong>==”<strong>main</strong>“:<br>    #异常处理<br>    try:<br>        main()<br>    except Exception as e:<br>        print(“您的输入不合法！出错信息如下：”)<br>        print(e)</p><h2 id="3-10-最优二叉搜索树"><a href="#3-10-最优二叉搜索树" class="headerlink" title="3.10 最优二叉搜索树"></a>3.10 最优二叉搜索树</h2><pre><code>二叉搜索树：存储于每个结点中的元素x大于其左子树中任一结点所存储的元素，小于其右子树中任一结点所存储的元素</code></pre><h1 id="第四章-贪心算法"><a href="#第四章-贪心算法" class="headerlink" title="第四章 贪心算法"></a>第四章 贪心算法</h1><pre><code>贪心算法：总是做出在当前看来最好的选择，也就是说贪心算法并不从整体最优考虑它所作出的选择只是在某种意义上的局部最优选择。使用贪心算法需满足：    贪心选择性：指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到    最优子结构性质：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质贪心算法适合的问题：有n个输入，其解就由这n个输入满足某些事先给定的约束条件的某个子集组成，而把满足约束条件的子集称为该问题的可行解。显然可行解一般来说是不唯一的。那些使目标函数取极值的可行解，成为最优解。贪心算法是一种分级处理方法，它首先根据题意，选取一种度量标准，然后按这种度量标准对这n个的输入排序，并按序依次输入，如果不满足条件，则不把此输入加到解当中。贪心算法设计求解的核心问题：选择能产生问题最优解的最优量度标准。贪心算法正确性的证明：    ①证明算法所求的问题具有优化子结构    ②证明算法所求解的问题具有贪心选择性    ③算法按照②种的贪心选择性进行局部最优选择</code></pre><h2 id="4-2-活动安排问题"><a href="#4-2-活动安排问题" class="headerlink" title="4.2 活动安排问题"></a>4.2 活动安排问题</h2><pre><code>为了选择最多的相容活动，每次选择fi最小的活动，使能够选择更多的活动度量标准：按照结束时间的非减序排列如果有序，则O(n)，如果无序，O(nlogn)</code></pre><p>“””<br>Copyright: Copyright (c) 2019<br>Author: Justlovesmile<br>Title: 活动安排问题<br>“””</p><p>#活动类，每个活动包括开始时间和结束时间<br>class activity():<br>    def <strong>init</strong>(self,ss,ff):<br>        self.s=ss<br>        self.f=ff</p><p>def greedySelector(arr,a):<br>    n=len(arr)-1<br>    a[0]=True<br>    j=0<br>    count=1<br>    #满足开始时间大于上一个活动的结束时间的加入（设为True）<br>    #O(n)<br>    for i in range(1,n+1):<br>        if(arr[i].s&gt;=arr[j].f):<br>            a[i]=True<br>            j=i<br>            count+=1<br>        else:<br>            a[i]=False<br>    return count</p><p>def main():<br>    activities=[]<br>    #输入数据<br>    n=int(input(“please input the number of activities:\n”))<br>    #异常处理<br>    if(n==0):<br>        raise ValueError(“您输入了0！”)<br>    print(“Use greedy selector , activities should be ordered by the end_time.”)<br>    for i in range(n):<br>        item=input(“please input the begin-time and end-time:(eg: 3 6)\n”).split()<br>        if(len(item)!=2):<br>            raise ValueError(“您输入的数据个数不合法！”)<br>        s=activity(float(item[0]),float(item[1]))<br>        activities.append(s)<br>    #以结束时间非减序排序<br>    activities=sorted(activities,key=lambda x:x.f)<br>    #初始化选择集合a<br>    a=[False for i in range(n)]<br>    count=greedySelector(activities,a)<br>    print(“Maximum number of activities:”,count)<br>    print(“Choose:”,a)</p><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    try:<br>        main()<br>    except Exception as e:<br>        print(“您的输入不合法！出错信息如下：”)<br>        print(e)</p><h2 id="4-3-最优装载问题"><a href="#4-3-最优装载问题" class="headerlink" title="4.3 最优装载问题"></a>4.3 最优装载问题</h2><pre><code>O(nlogn)</code></pre><h2 id="4-4-哈夫曼编码"><a href="#4-4-哈夫曼编码" class="headerlink" title="4.4 哈夫曼编码"></a>4.4 哈夫曼编码</h2><pre><code>循环地选择具有最低频率的两个结点，生成一棵子树，直至形成树</code></pre><p>#构建二叉树类型<br>class BinaryTree:<br>    def <strong>init</strong>(self,data,left,right,code):<br>        self.data=data<br>        self.left=left<br>        self.right=right<br>        self.code=code</p><pre><code>def getdata(self):    return self.data</code></pre><p>#哈夫曼树<br>class Huffman:<br>    def <strong>init</strong>(self,tree,ww):<br>        self.tree=tree<br>        self.w=ww</p><pre><code>def getweight(self):    return self.w</code></pre><p>def huffmanTree(f):<br>    #f是出现频率权值字典<br>    H=[]<br>    n=len(f)<br>    #根据value对键进行从大到小排序<br>    for i in sorted(f,key=f.<strong>getitem</strong>,reverse=True):<br>        tree = BinaryTree(i,0,0,””)<br>        w = Huffman(tree,f[i])<br>        H.append(w)</p><pre><code>for i in range(1,n):    #取出最后两位    x=H.pop()    y=H.pop()    #取权重小的做左孩子，大的是右孩子    t=BinaryTree(i,x.tree if x.w&lt;y.w else y.tree,y.tree if y.w&gt;x.w else x.tree,&quot;&quot;)    h=Huffman(t,x.w+y.w)    H.append(h)    #根据权重从大到小排序    H=sorted(H,key=lambda x:x.w,reverse=True)return H.pop()</code></pre><p>“””<br>Copyright: Copyright (c) 2019<br>Author: Justlovesmile<br>Title: 哈夫曼编码<br>“””</p><p>#构建二叉树类型<br>class BinaryTree:<br>    def <strong>init</strong>(self,data,left,right,code):<br>        self.data=data<br>        self.left=left<br>        self.right=right<br>        self.code=code</p><pre><code>def getdata(self):    return self.data</code></pre><p>#哈夫曼树<br>class Huffman:<br>    def <strong>init</strong>(self,tree,ww):<br>        self.tree=tree<br>        self.w=ww</p><pre><code>def getweight(self):    return self.w</code></pre><p>#计算权重<br>def makedict(s):<br>    dic={}<br>    for i in s:<br>        if i not in dic.keys():<br>            dic[i]=1<br>        else:<br>            dic[i]+=1<br>    return dic</p><p>def huffmanTree(f):<br>    #f是出现频率权值字典<br>    H=[]<br>    n=len(f)<br>    #根据value对键进行从大到小排序<br>    for i in sorted(f,key=f.<strong>getitem</strong>,reverse=True):<br>        tree = BinaryTree(i,0,0,””)<br>        w = Huffman(tree,f[i])<br>        H.append(w)</p><pre><code>for i in range(1,n):    #取出最后两位    x=H.pop()    y=H.pop()    #取权重小的做左孩子，大的是右孩子    t=BinaryTree(i,x.tree if x.w&lt;y.w else y.tree,y.tree if y.w&gt;x.w else x.tree,&quot;&quot;)    h=Huffman(t,x.w+y.w)    H.append(h)    #根据权重从大到小排序    H=sorted(H,key=lambda x:x.w,reverse=True)return H.pop()</code></pre><p>def listall(h):<br>    m=[]<br>    k=[]<br>    left,right=h.tree.left,h.tree.right<br>    rcode=”1”<br>    lcode=”0”<br>    m.append(right)<br>    right.code+=rcode<br>    m.append(left)<br>    left.code+=lcode<br>    while(len(m)&gt;0):<br>        #如果存在左孩子（左右必同时存在）<br>        if(m[-1].left):<br>            a=m.pop()<br>            c=a.code<br>            m.append(a.right)<br>            a.right.code=c+rcode<br>            m.append(a.left)<br>            a.left.code=c+lcode<br>        else:<br>            b=m.pop()<br>            k.append(b)<br>    return k</p><p>def back(hfmcode,filename):<br>    ans=input(f”Do you want to decode ‘{filename}’?（y/n）\n”)<br>    if(ans!=”y” and ans!=’Y’):<br>        return;<br>    #读取要解压缩的文件<br>    with open(filename,’r’) as f:<br>        s=f.read()<br>    st=””<br>    #键和值交换形成新字典<br>    new_dict = {v:k for k,v in hfmcode.items()}<br>    #写入新文件<br>    with open(‘解压缩.txt’,’w’) as f:<br>        for i in s:<br>            st+=i<br>            if(st in hfmcode.values()):<br>                f.write(new_dict[st])<br>                st=””<br>    print(“==”*10)<br>    print(“ok!Please check the file: ‘解压缩.txt’”)<br>    print(“==”*10)</p><p>def main():<br>    filename1=”测试用例.txt”<br>    filename2=’编码后.txt’<br>    #可以选择读文件和输入字符串<br>    s=input(f”Do you want to search {filename1}！（y/n）\n”)<br>    if(s==”y” or s==”Y”):<br>        #读文件<br>        with open(filename1,’r’) as f:<br>            s=f.read()<br>        #权值字典<br>        dic=makedict(s)<br>        print(“权值：”,dic)<br>        #构建哈夫曼树<br>        hTree=huffmanTree(dic)<br>        #编码<br>        k=listall(hTree)<br>        print(“哈夫曼编码：”)<br>        for i in k:<br>            print(i.data,i.code)<br>        #存储值对应的编码<br>        hfmcode={}<br>        for i in k:<br>            hfmcode[i.data]=i.code<br>        #写入哈夫曼编码<br>        with open(filename2,’w’) as f:<br>            for i in s:<br>                string=hfmcode[i]<br>                f.write(string)<br>        print(“==”*10)<br>        print(f”ok!Please check the file: ‘{filename2}’”)<br>        print(“==”*10)<br>        back(hfmcode,filename2)</p><pre><code>else:    s=input(&quot;Please input the string:&quot;)    dic=makedict(s)    print(dic)    hTree=huffmanTree(dic)    k=listall(hTree)    for i in k:        print(i.data,i.code)</code></pre><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    try:<br>        main()<br>    except Exception as e:<br>        print(“您的输入不合法！出错信息如下：”)<br>        print(e)</p><h2 id="4-5-单源最短路径"><a href="#4-5-单源最短路径" class="headerlink" title="4.5 单源最短路径"></a>4.5 单源最短路径</h2><pre><code>设置顶点集合S并不断地作贪心选择来扩充这个集合，一个顶点属于集合S当且仅当从源到该顶点的最短路径长度已知，初始时，S中仅含有源。设u是G的某一个顶点，把从源到u且中间只经过S中顶点的路称为从源到u的特殊路径，并用数组dist记录当前每个顶点所对应的最短特殊路径长度。Dijkstra算法每次从V-S中取出具有最短特殊路径长度的顶点u，将u添加到S中，同时对数组dist作必要的修改。一旦S包含了所有V中顶点，dist就记录了从源到所有其他顶点之间的最短路径长度</code></pre><h2 id="4-6-最小生成树"><a href="#4-6-最小生成树" class="headerlink" title="4.6 最小生成树"></a>4.6 最小生成树</h2><pre><code>设G =(V,E)是无向连通带权图，即一个网络。E中每条边(v,w)的权为c[v][w]。如果G的子图G’是一棵包含G的所有顶点的树，则称G’为G的生成树。生成树上各边权的总和称为该生成树的耗费。在G的所有生成树中，耗费最小的生成树称为G的最小生成树最小生成树性质（MST性质）：设G=(V,E)是连通带权图，U是V的真子集。如果(u,v)∈E，且u∈U，v∈V-U，且在所有这样的边中，(u,v)的权为c[u][v]最小，那么一定存在G的一颗最小生成树，它以(u,v)为其中一条边Prim算法：    首先置S=&#123;1&#125;，然后，只要S是V的真子集，就作如下的贪心选择：    选取满足条件i∈S，j∈V-S，且c[i][j]最小的边，将顶点j添加到S中。这个过程一直进行到S=V时为止。    在这个过程中选取到的所有边恰好构成G的一棵最小生成树。    MIjycj.png</code></pre><p>“””<br>Copyright: Copyright (c) 2019<br>Author: Justlovesmile<br>Title: 最小生成树-Prim算法<br>“””</p><p>def prim(n,c):<br>    #初始化Prim算法的数组<br>    s=[1]<br>    p=[1]<br>    lowcost=[float(‘inf’) for i in range(n)]<br>    m=1<br>    #遍历S中的点<br>    for r in range(1,n):<br>        ns=len(s)<br>        for t in range(ns):<br>            i=s[t]<br>            for j in range(1,n+1):<br>                #如果不在S中，且最短则记录<br>                if(j not in s) and (c[i][j]&lt;lowcost[m]):<br>                    lowcost[m]=c[i][j]<br>                    k=j<br>                    u=i<br>        m+=1<br>        s.append(k)<br>        p.append(u)</p><pre><code>for i in range(1,len(s)):    print(s[i],p[i],c[s[i]][p[i]])</code></pre><p>def main():<br>    #输入点数<br>    n=int(input(“Please input the number of points:\n”))<br>    #初始化边长<br>    c=[[float(‘inf’) for i in range(n+1)] for j in range(n+1)]<br>    for i in range(1,n+1):<br>        c[i][i]=0<br>    if(n&lt;=1):<br>        raise ValueError(f”You input {n} point.”)<br>    #输入边长<br>    g=input(“Please input the p1,p2 and weight,like: 1 2 4\nInput end to end.\n”)<br>    while(g!=’end’):<br>        a=g.split()<br>        i=int(a[0])<br>        j=int(a[1])<br>        w=float(a[2])<br>        c[i][j]=w<br>        c[j][i]=w<br>        g=input(“Please input the p1,p2 and weight,like: 1 2 4\nInput end to end.\n”)</p><pre><code>prim(n,c)</code></pre><p>if <strong>name</strong>==”<strong>main</strong>“:<br>    try:<br>        main()<br>    except Exception as e:<br>        print(“您的输入不合法！出错信息如下：”)<br>        print(e)</p><pre><code>Kruskal算法：    首先，将G的n个顶点看成n个孤立的连通分支。将所有的边按权从小到大排序。    然后，从第一条边开始，依边权递增的顺序查看每一条边，并按下述方法连接2个不同的连通分支：        当查看到第k条边(v,w)时，如果端点v和w分别是当前2个不同的连通分支T1和T2中的顶点时，就用边(v,w)将T1和T2连接成一个连通分支，然后继续查看第k+1条边；        如果端点v和w在当前的同一个连通分支中，就直接再查看第k+1条边。        这个过程一直进行到只剩下一个连通分支时为止。        MIvIdP.png</code></pre><p>“””<br>Copyright: Copyright (c) 2019<br>Author: Justlovesmile<br>Title: 最小生成树-Kruskal算法<br>“””</p><p>class Edge:<br>    def <strong>init</strong>(self,u,v,w):<br>        self.u=u<br>        self.v=v<br>        self.w=w</p><p>class EdgeNode:<br>    def <strong>init</strong>(self,p,g):<br>        self.id=p<br>        self.g=g</p><p>def kruskal(n,e):<br>    e=sorted(e,key=lambda x: x.w)<br>    en=len(e)<br>    s=[0]<br>    e[0].u.g,e[0].v.g=0,0<br>    for j in range(en):<br>        if(j not in s) and (e[j].u.g!=e[j].v.g):<br>            m=e[j].u.g if e[j].u.g&lt;e[j].v.g else e[j].v.g<br>            for eachedge in e:<br>                if (eachedge.u==e[j].u or eachedge.v==e[j].v or eachedge.u==e[j].v or eachedge.v==e[j].u) and (eachedge.u.g==eachedge.v.g):<br>                    m=min(eachedge.u.g,eachedge.v.g,m)<br>                    eachedge.u.g=eachedge.v.g=m<br>            e[j].u.g=e[j].v.g=m<br>            s.append(j)</p><pre><code>for i in range(len(s)):    print(e[s[i]].u.id,e[s[i]].v.id,e[s[i]].w)</code></pre><p>def main():<br>    #输入点数<br>    n=int(input(“Please input the number of points:\n”))<br>    if(n&lt;=1):<br>        raise ValueError(f”You input {n} point.”)<br>    #输入边长<br>    e=[]<br>    p={}<br>    g=input(“Please input the p1,p2 and weight,like: 1 2 4\nInput end to end.\n”)<br>    aa,bb=n,n+1<br>    while(g!=’end’):<br>        a=g.split()<br>        i,j,w=int(a[0]),int(a[1]),float(a[2])<br>        if(i not in p.keys()):<br>            p[i]=EdgeNode(i,aa)<br>        if(j not in p.keys()):<br>            p[j]=EdgeNode(j,bb)<br>        e.append(Edge(p[i],p[j],w))<br>        g=input(“Please input the p1,p2 and weight,like: 1 2 4\nInput end to end.\n”)<br>        aa+=1<br>        bb+=1</p><pre><code>kruskal(n,e)</code></pre><p>if <strong>name</strong>==”<strong>main</strong>“:<br>    try:<br>        main()<br>    except Exception as e:<br>        print(“您的输入不合法！出错信息如下：”)<br>        print(e)</p><h1 id="第五章-回溯法"><a href="#第五章-回溯法" class="headerlink" title="第五章 回溯法"></a>第五章 回溯法</h1><pre><code>回溯法是一个既带有系统性又带有跳跃性的搜索算法。它在问题的解空间树中，按深度优先策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，先判断该结点是否包含问题的解。如果肯定不包含，则跳过对该节点为根的子树的搜索，逐层向其祖先结点回溯，否则，进入该子树，继续按深度优先策略搜索具有剪枝函数的深度优先生成法扩展结点：正在产生儿子的结点称为扩展结点活结点：自身已生成但其儿子还没有全部生成的结点回溯法的步骤：    (1)针对所给问题，定义问题的解空间；    (2)确定易于搜索的解空间结构；    (3)以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索子集树：当所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间树称为子集树。通常有2n个叶子节点，其节点总个数为2n+1-1。如：0-1背包问题排列树：当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有n！个叶子节点。如：旅行售货员问题。回溯算法的效率在很大程度上依赖于以下因素：    (1)产生x[k]的时间；    (2)满足显约束的x[k]值的个数；    (3)计算约束函数constraint的时间；    (4)计算上界函数bound的时间；    (5)满足约束函数和上界函数约束的所有x[k]的个数。好的约束函数能显著地减少所生成的结点数。但这样的约束函数往往计算量较大。因此，在选择约束函数时通常存在生成结点数与约束函数计算量之间的折衷。</code></pre><h2 id="5-2-装载问题"><a href="#5-2-装载问题" class="headerlink" title="5.2 装载问题"></a>5.2 装载问题</h2><pre><code>如果一个给定装载问题有解，则采用下面的策略可得到最优装载方案。    (1)首先将第一艘轮船尽可能装满；    (2)将剩余的集装箱装上第二艘轮船。解空间：子集树可行性约束函数(选择当前元素)：上界函数(不选择当前元素)：当前载重量cw+剩余集装箱的重量r≤当前最优载重量bestw</code></pre><p>“””<br>Copyright: Copyright (c) 2019<br>Author: Justlovesmile<br>Title: 装载问题（回溯法）<br>“””</p><p>def backtrack(i,c):<br>    global w,bestx,x,bestw,r,cw<br>    if(i&gt;len(w)-1):<br>        if(cw&gt;bestw):<br>            for j in range(1,len(w)):<br>                bestx[j]=x[j]<br>            bestw=cw<br>        return ;</p><pre><code>#逐层搜索子树r-=w[i]if(cw+w[i]&lt;=c):    x[i]=1    cw+=w[i]    backtrack(i+1,c)    cw-=w[i]if(cw+r&gt;bestw):    x[i]=0    backtrack(i+1,c)r+=w[i]</code></pre><p>def main():<br>    global w,bestx,x,bestw,r,cw<br>    w=[0]<br>    m=input(“Please input the weight of each items:(eg:1 2 3 4 5)\n”).split()<br>    n=len(m)    #物品数量<br>    if(n==0):<br>        raise ValueError(“物品数量不能为空！”)<br>    r=0         #剩余的物品容量<br>    #转换w类型并初始化r<br>    for i in range(n):<br>        w.append(int(m[i]))<br>        r+=w[i+1]<br>    c1=int(input(“Please input the size of No.1 ship:\n”))      #第一艘船载重量<br>    c2=int(input(“Please input the size of No.2 ship:\n”))      #第二艘船载重量</p><pre><code>x=[0 for i in range(n+1)]         #记录路径bestx=x[:]                      #最优路径bestw,cw=0,0                    #最优载重量，当前载重量#尽可能的装满第一个backtrack(1,c1)#print(bestx)cw2=0for i in range(1,len(bestx)):    if(bestx[i]==0):        cw2+=w[i]if(cw2&gt;c2):    print(&quot;不能由两艘船装完！&quot;)    return ;else:    for i in range(1,len(bestx)):        if(bestx[i]==1):            print(f&quot;第&#123;i&#125;个物品，重量&#123;w[i]&#125;,装入第1艘船&quot;)        else:            print(f&quot;第&#123;i&#125;个物品，重量&#123;w[i]&#125;,装入第2艘船&quot;)</code></pre><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    try:<br>        main()<br>    except Exception as e:<br>        print(“您的输入不合法！出错信息如下：”)<br>        print(e)</p><p>5.6 0-1背包问题</p><pre><code>n=3, C=30, w=&#123;16, 15, 15&#125;, v=&#123;45, 25, 25&#125;Mo9ygU.png</code></pre><p>“””<br>Copyright: Copyright (c) 2019<br>Author: Justlovesmile<br>Title: 0-1背包问题（回溯法）<br>“””</p><p>class Q:<br>    def <strong>init</strong>(self,_id,qq):<br>        self.id=_id<br>        self.d=qq</p><p>def bound(i):<br>    global bestp,cw,cp,n,p,c,w,x,bestx<br>    cleft=c-cw<br>    bound=cp<br>    while(i&lt;=n and w[i]&lt;=cleft):<br>        cleft-=w[i]<br>        bound+=p[i]<br>        i+=1<br>    #贪心<br>    if(i&lt;=n):<br>        bound+=p[i]*cleft/w[i]<br>    return bound </p><p>def backtrack(i):<br>    global bestp,cw,cp,n,p,c,w,x,bestx<br>    #到达叶结点<br>    if(i&gt;n):<br>        if(cp&gt;bestp):<br>            for j in range(1,n+1):<br>                bestx[j]=x[j]<br>        bestp=cp<br>        return ;<br>    if(cw+w[i]&lt;c):<br>        x[i]=1<br>        cw+=w[i]<br>        cp+=p[i]<br>        backtrack(i+1)<br>        cp-=p[i]<br>        cw-=w[i]<br>    if(bound(i+1)&gt;bestp):<br>        x[i]=0<br>        backtrack(i+1)</p><p>def main():<br>    global bestp,cw,cp,n,p,c,w,x,bestx<br>    pp=input(“Please input the price of each items.(eg:1 2 3 4 5)\n”).split()<br>    ww=input(“Please input the weight of each items.(eg:1 2 3 4 5)\n”).split()<br>    if(len(pp)!=len(ww)):<br>        raise ValueError(“您的输入长度不一致！”)<br>    n=len(pp)<br>    c=float(input(“Please input the size of bag:\n”))<br>    cw=0        #当前重量<br>    cp=0        #当前价值<br>    bestp=0     #当前最优价值<br>    x=[0 for i in range(n+1)]       #初始化临时选择方案<br>    bestx=x[:]                      #初始化最优选择方案<br>    p=[0]       #价值列表<br>    w=[0]       #重量列表<br>    #单位重量价值<br>    #初始化<br>    q=[Q(0,0) for i in range(n)]<br>    for i in range(n):<br>        pp[i]=float(pp[i])<br>        ww[i]=float(ww[i])<br>        q[i].d=pp[i]/ww[i]<br>        q[i].id=i<br>    q=sorted(q,key=lambda x:x.d)[::-1]                 #从大到小排序<br>    for i in range(n):<br>        p.append(pp[q[i].id])<br>        w.append(ww[q[i].id])<br>    #回溯<br>    backtrack(1)<br>    #打印输出<br>    print(“Max price:”,bestp,”包括：”)<br>    for i in range(len(bestx)):<br>        if(bestx[i]==1):<br>            print(f”第{q[i-1].id+1}个,价值：{pp[q[i-1].id]},重量：{ww[q[i-1].id]}”)</p><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    try:<br>        main()<br>    except Exception as e:<br>        print(“您的输入不合法！出错信息如下：”)<br>        print(e)</p><h1 id="第六章-分支限界法"><a href="#第六章-分支限界法" class="headerlink" title="第六章 分支限界法"></a>第六章 分支限界法</h1><pre><code>分支限界法以广度优先或以最小耗费(最大效益)优先的方式搜索解空间树。其搜索策略是：在扩展结点处，先生成其所有儿子结点，然后再从当前的活结点表中选择下一个扩展结点。为了有效地选择下一扩展结点，加速搜索的进程，在每一格活结点处，计算一个函数值（限界），并根据函数值，从当前活结点表中，选择一个最有利的结点作为扩展结点，使搜索朝着解空间上最优解的分支推进，以便尽快找出一个最优解。常见两种分支限界法：①队列式（FIFO/LIFO）分支限界法②优先队列式分支限界法与回溯法对比：    （1）求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。    （2）搜索方式的不同：回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。    MoPuFI.png</code></pre><h2 id="6-5-0-1背包问题"><a href="#6-5-0-1背包问题" class="headerlink" title="6.5 0-1背包问题"></a>6.5 0-1背包问题</h2><p>class Q:<br>    def <strong>init</strong>(self,_id,qq):<br>        self.id=_id<br>        self.d=qq</p><p>class BBnode:<br>    def <strong>init</strong>(self,par,ch):<br>        self.par=par<br>        self.ch=ch</p><p>class HeapNode:<br>    def <strong>init</strong>(self,bNode,up,pp,ww,lev):<br>        self.liveNode=bNode<br>        self.up=up<br>        self.p=pp<br>        self.w=ww<br>        self.lev=lev</p><p>#插入队列<br>def addlivenode(heap,up,pp,ww,lev,par,ch):<br>    b=BBnode(par,ch)<br>    node=HeapNode(b,up,pp,ww,lev)<br>    heap.append(node)</p><p>#上界函数，贪心<br>def bound(i):<br>    global cw,cp,n,p,c,w<br>    cleft=c-cw<br>    bound=cp<br>    while(i&lt;=n and w[i]&lt;=cleft):<br>        cleft-=w[i]<br>        bound+=p[i]<br>        i+=1</p><pre><code>if(i&lt;=n):    bound+=p[i]*cleft/w[i]return bound</code></pre><p>def knapsack():<br>    global bestp,cw,cp,n,p,c,w,bestx<br>    i=1<br>    up=bound(i)<br>    heap=[]<br>    cnode=BBnode(None,None)<br>    while(i!=n+1):<br>        #左孩子<br>        cleft=cw+w[i]<br>        if(cleft&lt;c):<br>            if(cp+p[i]&gt;bestp):<br>                bestp=cp+p[i]<br>            addlivenode(heap,up,cp+p[i],cw+w[i],i+1,cnode,True)<br>        #右孩子<br>        up=bound(i+1)<br>        if(up&gt;=bestp):<br>            addlivenode(heap,up,cp+p[i],cw+w[i],i+1,cnode,False)<br>        #取下一扩展结点<br>        node=heap.pop(0)<br>        #更新数据<br>        cnode=node.liveNode<br>        cw=node.w<br>        cp=node.p<br>        up=node.up<br>        i=node.lev</p><pre><code>#最优解for j in range(1,n+1)[::-1]:    bestx[j]=1 if cnode.ch==True else 0    cnode=cnode.par</code></pre><p>实现</p><p>“””<br>Copyright: Copyright (c) 2019<br>Author: Justlovesmile<br>Title: 0-1背包问题（分支限界法）<br>“””</p><p>class Q:<br>    def <strong>init</strong>(self,_id,qq):<br>        self.id=_id<br>        self.d=qq</p><p>class BBnode:<br>    def <strong>init</strong>(self,par,ch):<br>        self.par=par<br>        self.ch=ch</p><p>class HeapNode:<br>    def <strong>init</strong>(self,bNode,up,pp,ww,lev):<br>        self.liveNode=bNode<br>        self.up=up<br>        self.p=pp<br>        self.w=ww<br>        self.lev=lev</p><p>#插入队列<br>def addlivenode(heap,up,pp,ww,lev,par,ch):<br>    b=BBnode(par,ch)<br>    node=HeapNode(b,up,pp,ww,lev)<br>    heap.append(node)</p><p>#上界函数，贪心<br>def bound(i):<br>    global cw,cp,n,p,c,w<br>    cleft=c-cw<br>    bound=cp<br>    while(i&lt;=n and w[i]&lt;=cleft):<br>        cleft-=w[i]<br>        bound+=p[i]<br>        i+=1</p><pre><code>if(i&lt;=n):    bound+=p[i]*cleft/w[i]return bound</code></pre><p>def knapsack():<br>    global bestp,cw,cp,n,p,c,w,bestx<br>    i=1<br>    up=bound(i)<br>    heap=[]<br>    cnode=BBnode(None,None)<br>    while(i!=n+1):<br>        #左孩子<br>        cleft=cw+w[i]<br>        if(cleft&lt;c):<br>            if(cp+p[i]&gt;bestp):<br>                bestp=cp+p[i]<br>            addlivenode(heap,up,cp+p[i],cw+w[i],i+1,cnode,True)<br>        #右孩子<br>        up=bound(i+1)<br>        if(up&gt;=bestp):<br>            addlivenode(heap,up,cp+p[i],cw+w[i],i+1,cnode,False)<br>        #取下一扩展结点<br>        node=heap.pop(0)<br>        #更新数据<br>        cnode=node.liveNode<br>        cw=node.w<br>        cp=node.p<br>        up=node.up<br>        i=node.lev</p><pre><code>#最优解for j in range(1,n+1)[::-1]:    bestx[j]=1 if cnode.ch==True else 0    cnode=cnode.par</code></pre><p>def main():<br>    global bestp,cw,cp,n,p,c,w,bestx<br>    #输入<br>    pp=input(“Please input the price of each items.(eg:1 2 3 4 5)\n”).split()<br>    ww=input(“Please input the weight of each items.(eg:1 2 3 4 5)\n”).split()<br>    if(len(pp)!=len(ww)):<br>        raise ValueError(“您的输入长度不一致！”)<br>    n=len(pp)<br>    c=float(input(“Please input the size of bag:\n”))<br>    cw=0        #当前重量<br>    cp=0        #当前价值<br>    bestp=0     #当前最优价值<br>    bestx=[0 for i in range(n+1)]   #最优解初始化<br>    p=[0]<br>    w=[0]<br>    q=[Q(0,0) for i in range(n)]     #单位重量价值<br>    allp=0    #总价值<br>    allw=0    #总重量<br>    #单位重量价值列表<br>    for i in range(n):<br>        pp[i]=float(pp[i])<br>        ww[i]=float(ww[i])<br>        allp+=pp[i]<br>        allw+=ww[i]<br>        q[i].d=pp[i]/ww[i]<br>        q[i].id=i<br>    q=sorted(q,key=lambda x:x.d)[::-1]                 #从大到小排序<br>    for i in range(n):<br>        p.append(pp[q[i].id])<br>        w.append(ww[q[i].id])<br>    #如果能直接全装<br>    if(allw&lt;c):<br>        print(f”All in! Total price is {allp}!”)<br>        return ;</p><pre><code>knapsack()print(&quot;Max price:&quot;,bestp,&quot;包括：&quot;)for i in range(len(bestx)):    if(bestx[i]==1):        print(f&quot;第&#123;q[i-1].id+1&#125;个,价值：&#123;pp[q[i-1].id]&#125;,重量：&#123;ww[q[i-1].id]&#125;&quot;)</code></pre><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    try:<br>        main()<br>    except Exception as e:<br>        print(“您的输入不合法!出错信息如下：”)<br>        print(e)</p><h2 id="6-6-装载问题"><a href="#6-6-装载问题" class="headerlink" title="6.6 装载问题"></a>6.6 装载问题</h2><p>“””<br>Copyright: Copyright (c) 2019<br>Author: Justlovesmile<br>Title: 装载问题（分支限界法）<br>“””</p><p>class Node:<br>    def <strong>init</strong>(self,parent,isleftchild,weight):<br>        self.parent=parent<br>        self.islchild=isleftchild<br>        self.weight=weight</p><p>def maxloading(c):<br>    global w,bestx,bestw,r,cw,n<br>    i=1<br>    r-=w[i]<br>    cnode=Node(None,None,-1)    #当前结点<br>    q=[cnode]<br>    while(True):<br>        #左结点<br>        cleft=cw+w[i]<br>        if(cleft&lt;=c):<br>            enode=Node(cnode,True,cleft)<br>            if(cleft&gt;bestw):<br>                bestw=cleft<br>                bestx=enode<br>            if(i&lt;n):<br>                q.append(enode)<br>            if(i==n):<br>                return;<br>        #右结点<br>        if(cw+r&gt;bestw and i&lt;n):<br>            enode=Node(cnode,False,cw)<br>            q.append(enode)<br>        #出队列<br>        cnode=q.pop(0)<br>        cw=cnode.weight<br>        if(cw==-1):<br>            if(len(q)==0):<br>                return ;<br>            q.append(Node(None,None,-1))<br>            cnode=q.pop(0)<br>            cw=cnode.weight<br>            i+=1<br>            r-=w[i]</p><p>def main():<br>    global w,bestx,bestw,r,cw,n<br>    w=[0]<br>    m=input(“Please input the weight of each items:(eg:1 2 3 4 5)\n”).split()<br>    n=len(m)    #物品数量<br>    if(n==0):<br>        raise ValueError(“物品数量不能为空！”)<br>    r=0         #剩余的物品容量<br>    bestw,cw=0,0<br>    #转换w类型并初始化r<br>    for i in range(n):<br>        w.append(int(m[i]))<br>        r+=w[i+1]<br>    allweight=r    #总重量<br>    x=[0 for i in range(n+1)]<br>    tx=[]<br>    c1=int(input(“Please input the size of No.1 ship:\n”))      #第一艘船载重量<br>    c2=int(input(“Please input the size of No.2 ship:\n”))      #第二艘船载重量</p><pre><code>maxloading(c1)if(bestw+c2&lt;allweight):    print(&quot;不能由两艘船装完！&quot;)    return;for i in range(1,n+1)[::-1]:    if(bestx.islchild==True):        tx.append(1)    elif(bestx.islchild==False):        tx.append(0)    bestx=bestx.parentfor i in range(len(tx)):    x[i+1]=tx[::-1][i]print(f&quot;第一艘船载重量&#123;bestw&#125;，包括：&quot;)for i in range(1,n+1):    if(x[i]==1):        print(f&quot;第&#123;i&#125;个集装箱&quot;)print(f&quot;第二艘船载重量&#123;allweight-bestw&#125;,包括：&quot;)for i in range(1,n+1):    if(x[i]==0):        print(f&quot;第&#123;i&#125;个集装箱&quot;)    </code></pre><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    try:<br>        main()<br>    except Exception as e:<br>        print(“您的输入不合法！出错信息如下：”)<br>        print(e)</p><p>知识点整理</p><pre><code>算法的特征：输入，输出，确定性，有限性θ记号在算法复杂性的表示法中表示紧致界由分治法产生的子问题往往是原问题的较小模式，这就为使用递归提供了方便建立计算模型的目的：为了使问题的计算复杂性分析有一个共同的客观尺度基本计算模型：RAM,RASP,TM拉斯维加斯算法找到的解一定是正确的贪心算法常采用自顶向下的方式求解最优解采用高级语言的主要好处：    ①更接近算法语言，易学，易掌握②提供了结构化程序设计的环境和工具，使得设计出的程序可读性高，可维护性强，可靠性高③不依赖于机器语言，因此写出的程序可移植性好，重用率高③自动化程度高，开发周期短，程序员可以集中精力从事更重要的创造性劳动，提高程序质量贪心算法的特点：    ①不能保证最后求得的解是最优的②策略易发现，运用简单，被广泛运用③策略多样，结果也多样④常用到辅助算法：排序平衡子问题思想：通常分治法在分割原问题，形成若干子问题时，这些子问题的规模都大致相同Prim算法采用贪心策略求解最小生成树问题，其时间复杂度是O(n^2)。动态规划算法适用于解具有某种最优性质的问题。贪心算法做出的选择只是适用于在某种意义上的局部最优选择在动态规划算法中，通常不同子问题的个数随问题规模呈多项式级增长动态规划是解决多阶段决策过程的最优化问题选择能产生最优解的贪心准则是设计贪心算法的核心问题分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树为什么用分治法设计的算法一般有递归调用？因为子问题的规模还很大时，必须继续使用分治法，反复分治，必然要用到递归请简述分支限界法找最优解比回溯法高的原因：在分支限界法中，每一个点只有一次机会称为扩展结点。回溯法的算法框架按照问题的解空间一般分为子集树算法框架（如解0-1背包问题）和排列树算法框架（如解批处理作业调度问题）MIEmhn.png常见的多项式阶：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)回溯和分支限界：    相同点：都是以构造一颗状态空间树为基础的，树的结点反映了对一部分解所作的特定选择    不同点：①他们处理的问题类型不同，回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。②生成状态空间树的顺序不同③对节点存储的常用数据结构以及节点存储特性也各不相同，除由搜索方式决定的不同的存储结构外，分支限界法通常需要存储一些额外的信息以利于进一步地展开搜索MoFWQK.pngMoFHJI.pngNP问题是指还未被证明是否存在多项式算法能够解决的问题，而其中NP完全问题又是最有可能不是P问题的问题类型。所有的NP问题都可以用多项式时间划归到他们中的一个。所以显然NP完全的问题具有如下性质：它可以在多项式时间内求解，当且仅当所有的其他的NP－完全问题也可以在多项式时间内求解</code></pre><p>作者: Justlovesmile<br>来源: Justlovesmile’s BLOG</p><p><a href="https://blog.justlovesmile.top/posts/16050.html#3-9-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">https://blog.justlovesmile.top/posts/16050.html#3-9-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法分析与设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法-链表</title>
      <link href="2021/03/08/kaikeba/suan-fa-dui-zhan/"/>
      <url>2021/03/08/kaikeba/suan-fa-dui-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构和算法–链表"><a href="#数据结构和算法–链表" class="headerlink" title="数据结构和算法–链表"></a>数据结构和算法–链表</h1><h1 id="（1）链表的基础知识"><a href="#（1）链表的基础知识" class="headerlink" title="**（1）链表的基础知识**"></a><strong>**（</strong>1<strong>）</strong>链表的基础知识**</h1><h2 id="链表的结构"><a href="#链表的结构" class="headerlink" title="链表的结构"></a><strong>链表的结构</strong></h2><p>节点</p><p>​        数据域</p><p>​        指针域：实现方式包括地址、下标（相对地址）、引用</p><p>链状结构</p><p>​        通过指针域的值形成了一个线性结构</p><h2 id="访问链表的时间复杂度"><a href="#访问链表的时间复杂度" class="headerlink" title="访问链表的时间复杂度"></a><strong>访问链表的时间复杂度</strong></h2><p>​    链表不适合快速的定位数据，适合动态的插入和删除的应用场景。</p><p>​    查找节点O(n)</p><p>​    插入节点O(1)</p><p>​    删除节点O(1) </p><h2 id="几种经典的链表实现方法"><a href="#几种经典的链表实现方法" class="headerlink" title="几种经典的链表实现方法"></a><strong>几种经典的链表实现方法</strong></h2><p>​    传统方法（节点+指针）</p><p>​    使用数组模拟</p><p>​        指针域和数据域分离</p><p>​        利用数组存放下标进行索引</p><h1 id="（2）-链表的典型应用场景"><a href="#（2）-链表的典型应用场景" class="headerlink" title="（2） 链表的典型应用场景"></a><strong>（</strong>2<strong>） 链表的典型应用场景</strong></h1><h2 id="操作系统内的动态内存分配"><a href="#操作系统内的动态内存分配" class="headerlink" title="操作系统内的动态内存分配"></a>操作系统内的动态内存分配</h2><p>​    LRU缓存淘汰算法</p><p>​    LRU = Least Recently Used（近期最少使用）</p><h2 id="缓存是一种高速的数据结构。"><a href="#缓存是一种高速的数据结构。" class="headerlink" title="缓存是一种高速的数据结构。"></a>缓存是一种高速的数据结构。</h2><p>​    设备间存在速度差异，可以通过将使用较多的数据存放在高速区域，而将使用较少的内容存放</p><h2 id="在相对低速的区域的方式，来对系统进行优化。"><a href="#在相对低速的区域的方式，来对系统进行优化。" class="headerlink" title="在相对低速的区域的方式，来对系统进行优化。"></a>在相对低速的区域的方式，来对系统进行优化。</h2><h1 id="（3）-经典面试题"><a href="#（3）-经典面试题" class="headerlink" title="（3） 经典面试题"></a><strong>（</strong>3<strong>） 经典面试题</strong></h1><h2 id="141环形链表"><a href="#141环形链表" class="headerlink" title="141环形链表"></a>141环形链表</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> hasCycle <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">let</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="141环形链表2-判断环的起点"><a href="#141环形链表2-判断环的起点" class="headerlink" title="141环形链表2 (判断环的起点)"></a>141环形链表2 (判断环的起点)</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> detectCycle <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> pre <span class="token operator">=</span> head<span class="token punctuation">,</span>        cur <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">===</span> cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> temp <span class="token operator">=</span> head<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>pre <span class="token operator">!==</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> pre<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210314213959308.png" alt="image-20210314213959308"></p><h2 id="202快乐数"><a href="#202快乐数" class="headerlink" title="202快乐数"></a>202快乐数</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> isHappy <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> pre <span class="token operator">=</span> n<span class="token punctuation">,</span>        cur <span class="token operator">=</span> <span class="token function">getNext</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> pre <span class="token operator">&amp;&amp;</span> cur <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pre <span class="token operator">=</span> <span class="token function">getNext</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span>        cur <span class="token operator">=</span> <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token function">getNext</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cur <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> getNext <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        t <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>n <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="剑指-Offer-24-反转链表-反转链表"><a href="#剑指-Offer-24-反转链表-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表  反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a>  反转链表</h2><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210314215038875.png" alt="image-20210314215038875"></p><pre><code>var reverseList = function(head) &#123;    if(!head) return null;    let pre = null,cur =head;    while(cur)&#123;        let next = cur.next;        cur.next = pre;        pre =cur;        cur =next;        //[cur.next,pre,cur] =[pre,cur,cur.next];    &#125;    return pre;&#125;;</code></pre><h2 id="92-反转链表-II-翻转部分链表"><a href="#92-反转链表-II-翻转部分链表" class="headerlink" title="92. 反转链表 II  翻转部分链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II </a> 翻转部分链表</h2><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210314215646571.png" alt="image-20210314215646571"></p><pre><code></code></pre><h2 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25.K个一组翻转链表"></a>25.K个一组翻转链表</h2><p>61 旋转链表</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> rotateRight <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//先判断首节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">,</span>        size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//找到尾节点，穿成环</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        size <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取到链表的长度，找到第size-k个节点，然后断开</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size <span class="token operator">-</span> <span class="token punctuation">(</span>k <span class="token operator">%</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cur <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> cur<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24 两两交换链表中的节点"></a>24 <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs">两两交换链表中的节点</a></h2><pre><code>var swapPairs = function(head) &#123;    //判断首节点是否为空    if (!head) return null;    //将相邻的两个链表进行反转    let ret = new ListNode(-1, head),        temp = ret;    while (temp.next &amp;&amp; temp.next.next) &#123;        let pre = temp.next,            cur = temp.next.next;        pre.next = cur.next;        cur.next = pre;        temp.next = cur;        temp = pre;    &#125;    return ret.next;&#125;;</code></pre><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19.[删除链表的倒数第 N 个结点]"></a>19.[删除链表的倒数第 N 个结点]</h2><p>自己第一次解析</p><pre><code>var removeNthFromEnd = function(head, n) &#123;    if(!head) return null;    //考虑正常情况    var p = q = r = s = head;    for(let i=1;i&lt;n;i++)&#123;        if(p.next)&#123;            p = p.next;        &#125;else&#123;            return q;        &#125;    &#125;    while(p.next)&#123;        if(q==r)&#123;            p = p.next;            q = q.next;        &#125;else&#123;            p=p.next;            q=q.next;            r=r.next;        &#125;    &#125;    if(r==q )&#123;        return s.next;    &#125;    if(p==q)&#123;        r.next =null;        return s;    &#125;    r.next =q.next;    return s;&#125;;</code></pre><p>参考解析</p><pre><code>var removeNthFromEnd = function(head, n) &#123;    if (!head) return null;    //创建一个虚头，两个指针    //一个指向虚头，一个指向真是的头节点cur    let ret = new ListNode(-1, head),        pre = ret,        cur = head;    //cur移动k步    for (let i = 0; i &lt; n; i++) &#123;        cur = cur.next;    &#125;    if (!cur) return head.next;    //然后两个指针仪器移动，知道cur指向空    while (cur) cur = cur.next, pre = pre.next;    //然后进行删除操作    pre.next = pre.next.next;    return ret.next;&#125;;</code></pre><h2 id="83-删除排序链表中的重复节点"><a href="#83-删除排序链表中的重复节点" class="headerlink" title="83 删除排序链表中的重复节点"></a>83 删除排序链表中的重复节点</h2><h2 id="82删除排序链表中的重复节点ii"><a href="#82删除排序链表中的重复节点ii" class="headerlink" title="82删除排序链表中的重复节点ii"></a>82删除排序链表中的重复节点ii</h2><h2 id="202快乐数-1"><a href="#202快乐数-1" class="headerlink" title="202快乐数"></a>202快乐数</h2><h2 id="242"><a href="#242" class="headerlink" title="242"></a>242</h2><h2 id="241"><a href="#241" class="headerlink" title="241"></a>241</h2><h2 id="202"><a href="#202" class="headerlink" title="202"></a>202</h2><h2 id="206"><a href="#206" class="headerlink" title="206"></a>206</h2><p>2] 两数相加</p><pre><code>var addTwoNumbers = function(l1, l2) &#123;    let p = l1,        q = l2;    let result, re, r;    var s = 0;    while (p || q) &#123;        let a = p != null ? p.val : 0,            b = q != null ? q.val : 0;        //余数        let d = (a + b + s) % 10;        r = new ListNode(d);        if (!result) &#123;            result = r;            re = r;        &#125; else &#123;            re.next = r;            re = re.next;        &#125;        //整数        s = Math.floor((a + b + s) / 10);        p = p != null ? p.next : null;        q = q != null ? q.next : null;    &#125;    if (s &gt; 0) &#123;        r = new ListNode(s);        r.next = null;        re.next = r;    &#125;    return result;&#125;;</code></pre><h4 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622. 设计循环队列"></a><a href="https://leetcode-cn.com/problems/design-circular-queue/">622. 设计循环队列</a></h4><pre><code>var MyCircularQueue = function(k) &#123;    this.queue = Array(k + 1);    this.front = 0;    this.rear = 0;    this.max = k;&#125;;/**  * @param &#123;number&#125; value * @return &#123;boolean&#125; */MyCircularQueue.prototype.enQueue = function(value) &#123;    if (this.isFull()) return false;    this.queue[this.rear] = value;    this.rear = (this.rear + 1) % (this.max + 1);    return true;&#125;;/** * @return &#123;boolean&#125; */MyCircularQueue.prototype.deQueue = function() &#123;    if (this.isEmpty()) return false;    this.front = (this.front + 1) % (this.max + 1);    return true;&#125;;/** * @return &#123;number&#125; */MyCircularQueue.prototype.Front = function() &#123;    if (this.isEmpty()) return -1;    return this.queue[this.front];&#125;;/** * @return &#123;number&#125; */MyCircularQueue.prototype.Rear = function() &#123;    if (this.isEmpty()) return -1;    return this.queue[(this.rear + this.max) % (this.max + 1)];&#125;;/** * @return &#123;boolean&#125; */MyCircularQueue.prototype.isEmpty = function() &#123;    return ((this.rear - this.front + this.max + 1) % (this.max + 1)) == 0;&#125;;/** * @return &#123;boolean&#125; */MyCircularQueue.prototype.isFull = function() &#123;    return (this.rear - this.front + this.max + 1) % (this.max + 1) == this.max;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>戏说面向对象程序设计Ｃ＃版</title>
      <link href="2021/03/06/ziliao/c/xi-shuo-mian-xiang-dui-xiang-cheng-xu-she-ji-c-ban/"/>
      <url>2021/03/06/ziliao/c/xi-shuo-mian-xiang-dui-xiang-cheng-xu-she-ji-c-ban/</url>
      
        <content type="html"><![CDATA[<h1 id="戏说面向对象程序设计C＃版"><a href="#戏说面向对象程序设计C＃版" class="headerlink" title="戏说面向对象程序设计Ｃ＃版"></a>戏说面向对象程序设计Ｃ＃版</h1><div class="row">    <embed src="./2021/03/06/ziliao/c/xi-shuo-mian-xiang-dui-xiang-cheng-xu-she-ji-c-ban/C#.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 戏说面向对象程序设计Ｃ＃版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于复杂人员排班系统的设计</title>
      <link href="2021/03/04/vue/fu-za-pai-ban-xi-tong-she-ji/"/>
      <url>2021/03/04/vue/fu-za-pai-ban-xi-tong-she-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="关于复杂人员排班系统的设计（前端实战）"><a href="#关于复杂人员排班系统的设计（前端实战）" class="headerlink" title="关于复杂人员排班系统的设计（前端实战）"></a>关于复杂人员排班系统的设计（前端实战）</h1><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p>1.实现工作日期，班次，机组的合理安排表格（班次可配置，日期根据每周日期安排）</p><p>2.实现人员排班调整的拖拉拽操作（借助框架）</p><p>3.适应平板和web端</p><p>4.模板</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210304171109789.png" alt="image-20210304171109789"></p><h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><p>界面布局：</p><p>​        班次多选shiftsTemp，病区单选（包含全部病区）wardName，选择后会渲染表格布局initTable</p><p>​        周次信息选择后会调整响应日期范围，changeWeek  库 date-fns参考说明 <a href="https://blog.csdn.net/weixin_39987434/article/details/104635987">https://blog.csdn.net/weixin_39987434/article/details/104635987</a></p><p>​       周次-&gt;对比星期几-&gt;计算日期范围</p><p>​        人数信息统计：根据查询条件显示返回的信息weekPatientCount，todayPatientCount</p><p>​        左侧患者列表，模糊查询，可拖拉至右侧表格</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>每个床位 一行数据；单元格有数据，可以拖动</p>]]></content>
      
      
      <categories>
          
          <category> 前端项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VUE项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化【进阶篇】</title>
      <link href="2021/03/03/ziliao/javascript/qian-duan-xing-neng-you-hua-jin-jie/"/>
      <url>2021/03/03/ziliao/javascript/qian-duan-xing-neng-you-hua-jin-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前端性能优化【进阶篇】"><a href="#前端性能优化【进阶篇】" class="headerlink" title="前端性能优化【进阶篇】"></a>前端性能优化【进阶篇】</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/pfCCZhlbMQSwnCkt8UaYpqrbzCiaNQ2CEH685vW53ibX4xia2IsNRuJ61khpkI2xDooaNyO2lNT9OoU4VUa3iazwLA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><blockquote><p>作者：前端学苑 公号 / 前端小贾 （本文来自作者投稿）</p></blockquote><blockquote><p>衡量网页的性能是一个比较琐碎的事情，因为没有某一个指标或数字可以直接告诉我们网页的性能怎样。优化的目的在于让页面加载的更快，对用户操作响应更及时，为用户带来更好的用户体验，对于开发者来说优化能够减少页面请求数，能够节省资源。</p></blockquote><p>简短的概括：</p><p>1､前端性能优化</p><p>2､前端性能监控</p><p>3､框架性能优化</p><p>正文从这里开始~~~</p><p>一、前端性能优化</p><p>1、从输入url到页面展现发生了什么？（万能面试题）</p><p>2、网络优化</p><p>3、浏览器优化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MXzNlnO3ib9Pxeun9OEYicdJiclWq5Tn0dD4YSLR3ic3bPoSuIUfoksbYibxWuC2VB7VuDNtkicpk5ibnrYnQ6oT6rooA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>详细如下：<img src="https://mmbiz.qpic.cn/mmbiz_png/OtuoacnwftRCRlcwbibSAicuNdvVcA9LmfpFZ6lrUMoBxW8826mJGRERSIuHiaJIbib3CqibatJiccRqMCXADTIoT0uQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></strong></p><hr><p><strong><em>\</em>从输入url到页面展现发生了什么？**</strong></p><p><strong><em>\</em>（万能面试题）**</strong></p><hr><p>1）浏览器的地址栏输入URL并按下回车；</p><p>2）DNS 解析：将域名解析成 IP 地址；</p><p>3）TCP 连接：TCP 三次握手；</p><p>4）发送 HTTP 请求；</p><p>5）服务器处理请求并返回 HTTP 报文；</p><p>6）浏览器解析渲染页面；</p><p>7）断开连接：TCP 四次挥手</p><p><strong>说完整个过程的几个关键点后我们再来展开的说一下。</strong></p><p>1、URL</p><p>我们常见的URL是这样的:<a href="http://www.baidu.com,这个域名由三部分组成：协议名、域名、端口号，这里端口是默认所以隐藏。最常见的的协议是HTTP协议，除此之外还有加密的HTTPS协议、FTP协议、FILe协议等等。如HTTP默认端口80，HTTPS默认端口443。说到这里可能有的面试官会问你同源策略，以及更深层次的跨域的问题。">http://www.baidu.com,这个域名由三部分组成：协议名、域名、端口号，这里端口是默认所以隐藏。最常见的的协议是HTTP协议，除此之外还有加密的HTTPS协议、FTP协议、FILe协议等等。如HTTP默认端口80，HTTPS默认端口443。说到这里可能有的面试官会问你同源策略，以及更深层次的跨域的问题。</a></p><p>2、DNS 解析 （ * 网络优化 ）</p><p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。</p><p><strong>1) IP 地址</strong></p><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式。</p><p><strong>2) 域名解析定义</strong></p><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。</p><p><strong>3) 浏览器如何通过域名去查询 URL 对应的 IP 呢？</strong></p><p>DNS域名解析分为递归查询和迭代查询两种方式，现一般为迭代查询。</p><p><strong>DNS 应用</strong></p><ol><li>CDN (Content Delivery Network) 就是利用DNS的重定向技术，DNS服务器会返回一个跟 用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</li></ol><ol start="2"><li>dns-prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。</li></ol><p><strong>OSI参考模型与TCP/IP四层模型</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/OtuoacnwftRCRlcwbibSAicuNdvVcA9Lmf7fJ23UTO25LfhvkONBS1KM7FzJBOm1EaRmWibsFEpeZIiaqwBDJkhTQw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>3、TCP 连接</p><p>客户端和服务端建立TCP连接需要三次握手。过程如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/OtuoacnwftRCRlcwbibSAicuNdvVcA9LmfB4FYBVZQAw5kI4PYVnrd88IMMxjQrU6Nhgr1Rcab6ChvcPl6lSu6UA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ol><li>客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</li></ol><ol start="2"><li>服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</li></ol><ol start="3"><li>客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</li></ol><p><strong>说明：</strong></p><p>ACK：确认标识，用于表示对数据包的成功接收。</p><p>SYN：同步标识，表示TCP连接已初始化。</p><p><strong>三次握手的目的：为了防止已经失效的连接请求报文段突然又传送到了服务器端，从而产生错误。</strong></p><p>4、发送HTTP请求 （ * 网络优化 ）</p><p>请求报文由请求行、请求头和请求体三部分组成。</p><p>1）请求行包含请求方法、url和协议版本。</p><p>2）请求头包含请求的附加信息，由键值对组成。如Host:github.com、User-Agent：””、Connection:keep-alive以及Cookie。</p><p>3）请求体主要是请求参数（Query String Parameters）。</p><p>注意：在发送HTTP请求的过程中，要先考虑浏览器缓存情况。缓存又分为强制缓存和协商缓存。</p><p>详细资料：<a href="http://mp.weixin.qq.com/s?__biz=MzI5MTUyMjk0Mw==&mid=2247485026&idx=1&sn=f9b76f0e03c8f74e43c16d6deb4354b2&chksm=ec0e1672db799f64cee594e50eb4b6be2f0e6a3271e95f0763864d6c9a2d340cdf9c182f8c0b&scene=21#wechat_redirect">一文读懂，关于 “ HTTP ” 那些事</a></p><p>5、服务器处理请求并返回 HTTP 报文</p><p>每台服务器上都会安装处理请求的应用——Web server。常见的web server产品有apache、nginx、IIS、Lighttpd等。</p><p>6、浏览器解析渲染页面 （ * 浏览器优化 ）</p><p><strong>浏览器渲染过程</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/OtuoacnwftRCRlcwbibSAicuNdvVcA9LmfEia9GK21bqdSZ9IP5GnYwTXVlUwA8gxOMmR4PPmpE7zftUKibtF4yPSw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>1）HTML解析，处理HTML标记并构建DOM树。</p><p>2）CSS解析，处理CSS标记并构建CSSOM树。</p><p>3）将DOM树和CSSOM合并称render tree(渲染树)。将每条css规则按照【从右至左】的方式在dom树上进行逆向匹配，然后生成具有样式规则描述的渲染树。</p><p>4）渲染树布局，计算每个节点的集合信息。包括repaint和reflow。</p><p>5）渲染树绘制，将每个节点绘制到屏幕上。</p><p><strong>重绘与重排（</strong>重排 又叫 回流<strong>）</strong></p><p>1）重排 (html改变) 一般是位置，大小，节点变化引起文档空间变化时发生的。</p><p>引起重排：</p><ul><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>页面一开始渲染的时候（这肯定避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ul><p>2）重绘（css改变）一般是颜色等不引起文档结构变化时发生的。</p><p>注：重绘不一定导致重排，但重排一定会导致重绘。</p><p>7、断开连接：TCP 四次挥手</p><p>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。</p><ol><li>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li></ol><ol start="2"><li>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li></ol><ol start="3"><li>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li></ol><ol start="4"><li>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li></ol><p><strong>TCP与UDP区别总结：</strong></p><p><strong>相同点：</strong>TCP和UDP都是网络层之上的，传输层协议，都能都能保护网络层的传输，双方的通信都需要开放端口，TCP和UDP中都存在复用和分用技术。</p><p><strong>不同点：</strong>TCP是可靠传输的，UDP是不可靠传输的。</p><p><strong>TCP VS UDP 对比：</strong></p><table><thead><tr><th>选项</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>可靠性</td><td>全双工可靠传输无差错，不丢失，不重复，且按序到达</td><td>尽最大努力交付</td></tr><tr><td>建立连接</td><td>需要建立连接</td><td>无需建立连接</td></tr><tr><td>数据发送模式</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>传输方式</td><td>点对点（不支持广播和多播）</td><td>一对一，一对多，多对一，多对多</td></tr><tr><td>首部开销</td><td>20字节</td><td>8字节</td></tr><tr><td>拥塞机制</td><td>有</td><td>无</td></tr><tr><td>流量控制</td><td>有</td><td>无</td></tr><tr><td>系统资源占用</td><td>对系统资源要求较多</td><td>对系统资源要求较少</td></tr><tr><td>实时性</td><td>相对UDP较低</td><td>较高，适用于对高速传输和实时性要求较高的通信或广播通信</td></tr><tr><td>确认重传机制</td><td>TCP提供超时重发，丢弃重复数据，检验数据，</td><td>无重传，只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地</td></tr></tbody></table><hr><p><strong><em>\</em>简单粗暴的优化策略**</strong></p><hr><p>1、⽂件加载的更少</p><ol><li><p>缓存，CDN  （详细资料：<a href="http://mp.weixin.qq.com/s?__biz=MzI5MTUyMjk0Mw==&mid=2247484933&idx=1&sn=19d6185b7ac2fda8f52a3b60e84a0607&chksm=ec0e1615db799f03db12947af64b8b7671d09d14dacc6b662ac25d92be0d4e7bf19ac140c550&scene=21#wechat_redirect">解析Web缓存及其最佳实践</a>）</p></li><li><p>图⽚优化</p></li><li><p>静态⽂件优化</p></li><li><p>浏览器优化</p></li><li><p>⽂件合并压缩等雅⻁军规常规操作</p></li></ol><p>2、代码执⾏的更少</p><p>1）节流防抖 （详细资料：<a href="http://mp.weixin.qq.com/s?__biz=MzI5MTUyMjk0Mw==&mid=2247485093&idx=1&sn=70864537b39b6c926ababf41f816e8d0&chksm=ec0e16b5db799fa341f333218598ef8f14197adad3f2e95decbbd46036e0da89e13bce0665f3&scene=21#wechat_redirect">彻底弄懂 “ 防抖 和 节流 ”</a>）</p><p>2）按需执⾏</p><p>3）回流重绘</p><p>4）框架优化（⽐如vue3的静态标记）</p><p>5）html、css、javascript</p><hr><p><strong>二、前端性能监控</strong></p><p>1、前端性能指标分析</p><p>2、关键性能指标统计</p><p>3、性能分析工具</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MXzNlnO3ib9Pxeun9OEYicdJiclWq5Tn0dD4YSLR3ic3bPoSuIUfoksbYibxWuC2VB7VuDNtkicpk5ibnrYnQ6oT6rooA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>详细如下：<img src="https://mmbiz.qpic.cn/mmbiz_png/OtuoacnwftRCRlcwbibSAicuNdvVcA9LmfpFZ6lrUMoBxW8826mJGRERSIuHiaJIbib3CqibatJiccRqMCXADTIoT0uQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></strong></p><hr><p><strong><em>\</em>前端性能指标分析**</strong></p><hr><p>以 <a href="https://www.google.com.hk/">https://www.google.com.hk</a> 为例，下图是使用Lighthouse（一个性能测评工具）捕获出的测评结果报告。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MpGQUHiaib4ib7IGiboflmhpibLq6UD9r8Y1FkrckDFlOayDdXd5lSkls1XrT04e5c6DTW2ExANczlIk1uAnr4F3hVw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>下图是使用Chrome浏览器的DevTools捕获出的加载性能结果报告。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MpGQUHiaib4ib7IGiboflmhpibLq6UD9r8Y1FV5rTNhQRCgdtCM8hhvtQHduZW6B2iao0EI8xTswicibOblgBVlXHEQF5g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>从上面这两张性能测评报告中，我们会发现报告通常会给出很多个 “关键时间点” 来表示性能数据，单独的某个“时间点”无法体现出网页的性能，只有将它们与自身的产品类型相结合，综合评估，才能判断出网页的性能到底怎样。而我们要做的，就是读懂报告中的各种专业术语，并分辨出哪些因素影响了网页的加载性能。</p><hr><p><strong><em>\</em>关键性能指标统计**</strong></p><hr><p><strong>FP、FCP、FMP与TTI</strong></p><p>从前面的评测报告中，我们会看到FP、FCP、FMP与TTI这几个字母很接近的术语，实际上他们的意思也非常接近，都表示浏览器在屏幕上渲染像素的时间点。</p><p>1）FP（全称“First Paint”，翻译为“首次绘制”） 是时间线上的第一个“时间点”，它代表浏览器第一次向屏幕传输像素的时间，也就是页面在屏幕上首次发生视觉变化的时间。</p><blockquote><p>注意：FP不包含默认背景绘制，但包含非默认的背景绘制。</p></blockquote><p>2）FCP（全称“First Contentful Paint”，翻译为“首次内容绘制”），顾名思义，它代表浏览器第一次向屏幕绘制 “内容”。</p><blockquote><p>注意：只有首次绘制文本、图片（包含背景图）、非白色的canvas或SVG时才被算作FCP。</p></blockquote><p>FP与FCP这两个指标之间的主要区别是：</p><p><strong>FP</strong>是当浏览器开始绘制内容到屏幕上的时候，只要在视觉上开始发生变化，无论是什么内容触发的视觉变化，在这一刻，这个时间点，叫做FP。</p><p><strong>FCP</strong>指的是浏览器首次绘制来自DOM的内容。例如：文本，图片，SVG，canvas元素等，这个时间点叫FCP。</p><p>3）FMP（全称“First Meaningful Paint”，翻译为“首次有效绘制”） 表示页面的“主要内容”开始出现在屏幕上的时间点。它是我们测量用户加载体验的主要指标。</p><blockquote><p>注意：FMP本质上是通过一个算法来猜测某个时间点可能是FMP，所以有时候不准。</p></blockquote><p><strong>说明：</strong></p><p>FMP 实现的三种方式：（需要扩展）</p><p>1､固定好dom的id，统计高度变化时间。</p><p>2､统计首屏dom的面积，计算占比 总结FMP。</p><p>3､dom变化趋势，来统计FMP。</p><p>计算占比 的思路 （需要扩展）</p><ul><li>元素权重：宽<em>⾼</em>权重(img,video要⽐普通dom⾼）；</li><li>进⼊⻚⾯开始记录，启⽤mutationobserver；</li><li>遍历domtree，根据可视区域⾯积，计算得分；</li><li>遍历⽗元素修正得分（⽗元素和⼦元素之和的最⼤值）；</li><li>平均值，过滤出⽬标元素；</li><li>是否img(video,canvas等；</li><li>合集求出FMP</li></ul><p>4）TTI（全称“Time to Interactive”，翻译为“可交互时间”） 表示网页第一次 完全达到可交互状态 的时间点。可交互状态指的是页面上的UI组件是可以交互的（可以响应按钮的点击或在文本框输入文字等），不仅如此，此时主线程已经达到“流畅”的程度，主线程的任务均不超过50毫秒。TTI很重要，因为TTI可以让我们了解我们的产品需要多久可以真正达到“可用”的状态。</p><p>图3给出了<strong>FP、FCP、FMP、TTI</strong>之间的比较。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MpGQUHiaib4ib7IGiboflmhpibLq6UD9r8Y1Fhp8Yhicldb66HPwJibC0Rsj0cFzTRaSxuyKfMecbjWZLiatDWePLh4wWQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><blockquote><p>W3C发布导航计时（Navigation Timing 2）的标准工作草案，该规范定义了一个统一的接口，存储和获取与网页导航和页面加载相关的高解析度的性能度量数据。</p><p>地址：<a href="https://www.w3.org/TR/navigation-timing-2/">https://www.w3.org/TR/navigation-timing-2/</a> </p></blockquote><p>如图：</p><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><hr><p><strong><em>\</em>性能分析工具**</strong></p><hr><p>1）谷歌开发者工具的“性能”选项进行分析：performance</p><p>详细资料：<a href="http://mp.weixin.qq.com/s?__biz=MzI5MTUyMjk0Mw==&mid=2247485181&idx=1&sn=9894db29fa89f155264a1de98d45b247&chksm=ec0e16eddb799ffbe13c480f244b5a8085a485390e3a5c6d042e982ee25c33ba2131c2474417&scene=21#wechat_redirect">性能优化篇 - Performance（工具 &amp; api）</a></p><p>2）谷歌的Lighthouse工具（国内网络环境）：基于 node（版本≥6）</p><p>安装：npm install -g lighthouse</p><p>运行使用：lighthouse <url> –view</url></p><p>例如：lighthouse <a href="https://www.baidu.com/">https://www.baidu.com/</a> –view</p><p>3）如果可以翻墙的话：可以在 Chorome 网上应用商店中安装 - 网页性能优化的扩展程序：Lighthouse、PageSpeed Insights ；</p><p>4）在线网页性能分析工具（推荐）</p><p><a href="https://tools.pingdom.com/">https://tools.pingdom.com/</a></p><p>Pingdom是一个免费的网站速度测试工作，不仅是看起来非常棒，而且尽可能多的呈现出你的网站的各方面信息。</p><p>5）使用 Chrome 原生 lazyload 属性进行图片懒加载</p><blockquote><p>chrome://flags/#enable-lazy-image-loading</p></blockquote><p>复制它到 Chrome 浏览器的地址栏，然后找到如下选项，将其设置为「Enabled」。</p><p><strong>例如：</strong><img src="/jiayueshe/jiayueshe.github/具体图片" alt lazyload="on"></p><p><strong>说明：</strong></p><p>auto 浏览器自行判断</p><p>on 开启懒加载</p><p>off 关闭懒加载</p><hr><p><strong>三、框架性能优化</strong></p><p>1、Vue性能优化</p><p>2、长列表优化 </p><p>3、用户体验优化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MXzNlnO3ib9Pxeun9OEYicdJiclWq5Tn0dD4YSLR3ic3bPoSuIUfoksbYibxWuC2VB7VuDNtkicpk5ibnrYnQ6oT6rooA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>详细如下：<img src="https://mmbiz.qpic.cn/mmbiz_png/OtuoacnwftRCRlcwbibSAicuNdvVcA9LmfpFZ6lrUMoBxW8826mJGRERSIuHiaJIbib3CqibatJiccRqMCXADTIoT0uQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></strong></p><hr><p><strong><em>\</em>Vue性能优化**</strong></p><hr><p>1、你都做过哪些Vue的性能优化？（ 统计后的结果 ）</p><p><strong>1）编码阶段</strong></p><ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher；</li><li>如果需要使用v-for给每项元素绑定事件时使用事件代理；</li><li>SPA 页面采用keep-alive缓存组件；</li><li>在更多的情况下，使用v-if替代v-show；</li><li>key保证唯一；</li><li>使用路由懒加载、异步组件；</li><li>防抖、节流；</li><li>第三方模块按需导入；</li><li>长列表滚动到可视区域动态加载；</li><li>图片懒加载；</li></ul><p><strong>2）用户体验：</strong></p><ul><li>骨架屏；</li><li>PWA；</li><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li></ul><p><strong>3）SEO优化</strong></p><ul><li>预渲染；</li><li>服务端渲染SSR；</li></ul><p><strong>4）打包优化</strong></p><ul><li>压缩代码；</li><li>Tree Shaking/Scope Hoisting；</li><li>使用cdn加载第三方模块；</li><li>多线程打包happypack；</li><li>splitChunks抽离公共文件；</li><li>sourceMap优化；</li></ul><p><strong>说明：</strong>优化是个大工程，会涉及很多方面，这里申请另开一个专栏<img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>2、vue1.X，vue2.X，vue3 框架分析性能 （ 还需要进一步学习 ）</p><p><strong>Vue1.x</strong> （特点：响应式）</p><p>没有vdom，完全的响应式，每个数据变化，都通过响应式通知机制来新建Watcher干活，项目规模变大后，过多的Watcher，会导致性能的瓶颈。</p><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p><strong>Vue2.x</strong> （特点：组件级响应式，组件内部vdom diff） </p><p>引入vdom，控制了颗粒度，组件层面走watcher通知， 组件内部走vdom做diff，既不会有太多watcher，也不会让vdom的规模过大，diff超过16ms，真是优秀。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/OtuoacnwftRdPL4VqJYTeMlGpI0Z2V9d2YU8ajygq0nnlWAZaXtejWob00DW9tsbh8kqRmoTZ3JnKMt9wfjA8g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>Vue3</strong> （特点：proxy做响应式：静态标记、按需更新） </p><p>先说结论，静态标记，<code>upadte</code>性能提升1.3<del>2倍，<code>ssr</code>提升2</del>3倍。</p><p>Vue3通过Proxy响应式+组件内部vdom+静态标记，把任务颗粒度控制的足够细致，所以也不太需要time-slice了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/OtuoacnwftRdPL4VqJYTeMlGpI0Z2V9dgria76w3ILrEFChaUmHPRXcibIXn8UA5fYSgudtfibl4uicxsibtEsBeQSw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><hr><p><strong><em>\</em>长列表优化**</strong></p><hr><p>1、vue-virtual-scroll-list优化长列表</p><p>虚拟列表的实现原理：只渲染可视区的 dom 节点，其余不可见的数据卷起来，只会渲染可视区域的 dom 节点，提高渲染性能及流畅性，优点是支持海量数据的渲染；</p><p>github地址：<a href="https://github.com/tangbc/vue-virtual-scroll-list">https://github.com/tangbc/vue-virtual-scroll-list</a></p><h2 id="2、Object-freeze优化长列表"><a href="#2、Object-freeze优化长列表" class="headerlink" title="2、Object.freeze优化长列表"></a>2、Object.freeze优化长列表</h2><p>Object.freeze()方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。</p><p>对于data()或vuex中冻结的对象，vue不会做getter和setter的转换。因此对于一个不变的、大数据量的数组或Object数据来说，使用Object.freeze()可以有效地提升性能。</p><hr><p><strong><em>\</em>用户体验优化**</strong></p><hr><p><strong>使用骨架屏</strong></p><p>骨架屏可以理解为是当数据还未加载进来前，页面的一个空白版本，一个简单的关键渲染路径。</p><p>一些项目，可能大部分数据都是从后端获取，网络请求是需要占用一定的时间的，所以用户一进来发现是空页面，所以这个时候可以使用骨架屏先加载一个轮廓，而不是让用户觉得这个页面挂了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/OtuoacnwftRmpicO7aMYibNKM1tQLB2A7yRFt5T6GZ4bkN72oRVsNRuNjombzowzwoYeeOCWF4KCmHRCFwVGsLJA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p><p>可以看一下上面的示例图，第一个为骨架屏，第二个为菊花图，第三个为无优化，可以看到相比于传统的菊花图会在感官上觉得内容出现的流畅而不突兀，体验更加优良。</p><p>来源：<a href="https://mp.weixin.qq.com/s/PCmCS46GPc6tt1yb9goNFA">https://mp.weixin.qq.com/s/PCmCS46GPc6tt1yb9goNFA</a></p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>速度与激情之 Vite 初体验（最佳入门）</title>
      <link href="2021/03/03/ziliao/javascript/vite-ti-yan/"/>
      <url>2021/03/03/ziliao/javascript/vite-ti-yan/</url>
      
        <content type="html"><![CDATA[<p>大家最近学习 Vue3 学废了吗？尤雨溪尤大大马不停蹄地又给大家送来了专门为 Vue3 打造的开发利器 — Vite。你是否在开发过程中使用 Webpack 觉得不那么丝滑，是否等待启动编译可以喝好几口热水？本文将带领大家简单了解 Vite 的基本知识和作用，让我们更好的开启 Vue3 开发之旅~ 首先，学习 Vite 之前得至少有 2 部分的知识储备：1）掌握 ES Modules 特性 2）了解 Http2 标准，限于篇幅，这里就不过多赘述啦~</p><h2 id="一、问题来源"><a href="#一、问题来源" class="headerlink" title="一、问题来源"></a>一、问题来源</h2><h3 id="1-1-Webpack-槽点"><a href="#1-1-Webpack-槽点" class="headerlink" title="1.1 Webpack 槽点"></a>1.1 Webpack 槽点</h3><p>如果应用比较复杂，那么使用 Webpack 的开发过程就相对没有那么舒适。</p><pre><code>  - Webpack Dev Server 冷启动时间会比较长  - Webpack HMR 热更新的反应速度比较慢</code></pre><p><strong><img src="https://mmbiz.qpic.cn/mmbiz_jpg/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjxO68MtsrFIplBh3GtpG8Vk9iczYsN4iaJbNZdamHXibF1rUFdqvj6U1b9w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></strong></p><h3 id="1-2-回顾-Webpack-初衷"><a href="#1-2-回顾-Webpack-初衷" class="headerlink" title="1.2 回顾 Webpack 初衷"></a>1.2 回顾 Webpack 初衷</h3><p>【之前技术环境】我们使用 Webpack 打包应用代码，最后生成一个 bundle.js，主要有两个原因：</p><pre><code>  - 浏览器环境并不很好的来支持模块化  - 零散的模块文件会产生大量的 HTTP 请求</code></pre><h3 id="1-3-思考现在"><a href="#1-3-思考现在" class="headerlink" title="1.3 思考现在"></a>1.3 思考现在</h3><p>bundle 太大，要采用各种 Code Splitting，压缩代码，去除的插件，提取的第三方库，so tired~ 【当前技术环境】是否能解决 Webpack 当时的难点？thinking~~</p><h2 id="二、解决思路"><a href="#二、解决思路" class="headerlink" title="二、解决思路"></a>二、解决思路</h2><h3 id="2-1-ES-Module"><a href="#2-1-ES-Module" class="headerlink" title="2.1 ES Module"></a>2.1 ES Module</h3><ul><li>随着浏览器的对 ES 标准支持的逐渐完善，第一个问题已经慢慢不存在了。现阶段绝大多数浏览器都是支持 ES Modules 的。</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjxiaQ2jdztBW5sh45tU9wAJsAkNA15Zk8ia3eAXA46qFRFOqNFWspgSjIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>其最大的特点是在浏览器端使用 export import 的方式导入和导出模块，在 script 标签里写 <code>type=&quot;module&quot;</code> ，然后使用 ES Module。</p><pre><code>// 当 html 里嵌入 ES module 的 script 标签时候，浏览器会发起 http 请求，请求 http server 托管的 main.js ;// index.html&lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;// 使用 export 导出模块, import 导入模块：// main.js import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;./App.vue&#39;import &#39;./index.css&#39;createApp(App).mount(&#39;#app&#39;)</code></pre><p>直接访问 index.html，报错：<img src="https://mmbiz.qpic.cn/mmbiz_png/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjxXRe2963J6wwH63xgPEZ1EsokmSiaGBDLR754C6ySFjCPupxJJvnogqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">在浏览器里使用 ES module 是使用 http 请求拿到模块的，所以 file 协议的请求不允许。</p><h3 id="2-2-模块解析"><a href="#2-2-模块解析" class="headerlink" title="2.2 模块解析"></a>2.2 模块解析</h3><p>那我们就在本地起一个静态服务，再来打开一下 index.html 来看下<img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">报错：找不到模块 vue；原因：”/“, “./“, or “../“开头的 import 相对/绝对路径，才是合法的。</p><pre><code>import vue from &#39;vue&#39;</code></pre><p>也就是说浏览器中的 ESM 是获取不到导入的模块内容的。平时我们写代码，如果不是引用相对路径的模块，而是引用 <code>node_modules</code> 的模块，都是直接 <code>import xxx from &#39;xxx&#39;</code>，由 <code>Webpack</code> 等工具来帮我们处理 js 间的相互依赖关系，找这个模块的具体路径进行打包，但是浏览器不知道你项目里有 <code>node_modules</code>，它只能通过相对路径或者绝对路径去寻找模块。</p><p>那咋办？？？所以 <strong>Vite 的一个任务就是启动一个 web server 去代理这些模块，Vite 这里是借用了 koa 来启动了一个服务</strong></p><pre><code>export function createServer(config: ServerConfig): Server &#123;  // ...  const app = new Koa&lt;State, Context&gt;()  const server = resolveServer(config, app.callback())    // ...  const listen = server.listen.bind(server)  server.listen = (async (port: number, ...args: any[]) =&gt; &#123;    if (optimizeDeps.auto !== false) &#123;      await require(&#39;../optimizer&#39;).optimizeDeps(config)    &#125;    return listen(port, ...args)  &#125;) as any    server.once(&#39;listening&#39;, () =&gt; &#123;    context.port = (server.address() as AddressInfo).port  &#125;)    return server&#125;</code></pre><p>那这就引出了 <strong>Vite 的一个实现核心 - 拦截浏览器对模块的请求并返回处理后的结果</strong>我们来看下 Vite 是怎么处理的？</p><h3 id="2-3-module-前缀"><a href="#2-3-module-前缀" class="headerlink" title="2.3 /@module/前缀"></a>2.3 <code>/@module/</code>前缀</h3><p>通过工程下的 main.js 和开发环境下的实际加载的 main.js 对比，发现 main.js 内容发生了改变，由</p><pre><code>import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;./App.vue&#39;import &#39;./index.css&#39;createApp(App).mount(&#39;#app&#39;)</code></pre><p>变成了</p><pre><code>import &#123; createApp &#125; from &#39;/@modules/vue.js&#39;import App from &#39;/src/App.vue&#39;import &#39;/src/index.css?import&#39;createApp(App).mount(&#39;#app&#39;)</code></pre><p>为了解决 <code>import xxx from &#39;xxx&#39;</code> 报错的问题，Vite 对这种资源路径做了一个统一的处理，加一个<code>/@module/</code>前缀。我们在 <code>src/node/server/serverPluginModuleRewrite.ts</code> 源码这个 koa 中间件里可以看到 Vite 对 import 都做了一层处理，其过程如下：</p><ul><li>在 koa 中间件里获取请求 ctx.body</li><li>通过 <strong>es-module-lexer</strong> 解析资源 ast 拿到 import 的内容</li><li>判断 import 的资源是否是绝对路径，绝对视为 npm 模块</li><li><strong>rewriteImports</strong> 返回处理后的资源路径：”vue” =&gt; “/@modules/vue”</li></ul><p>**如何支持 <code>/@module/？</code>**在 <code>/src/node/server/serverPluginModuleResolve.ts</code> 里可以看到大概的处理逻辑是</p><ul><li>在 koa 中间件里获取请求 ctx.body</li><li>判断路径是否以 /@module/ 开头，如果是取出包名</li><li>去 node_module 里找到这个库，基于 package.json 返回对应的内容</li></ul><h3 id="2-4-文件编译"><a href="#2-4-文件编译" class="headerlink" title="2.4 文件编译"></a>2.4 文件编译</h3><p>上面我们提到的是对普通 js module 的处理，那对于其他文件，比如 <code>vue</code>、<code>css</code>、<code>ts</code>等是如何处理的呢？我们以 vue 文件为例来看一下，在 Webpack 里我们是使用的 vue-loader 对单文件组件进行编译，实际上 Vite 同样的是<strong>拦截了对模块的请求并执行了一个实时编译</strong>。通过工程下的 App.vue 和开发环境下的实际加载的 App.vue 对比，发现内容发生了改变 原本的 App.vue</p><pre><code>&lt;template&gt;  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;  &lt;HelloWorld msg=&quot;Hello Vue 3.0 + Vite&quot; /&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from &#39;./components/HelloWorld.vue&#39;export default &#123;  name: &#39;App&#39;,  components: &#123;    HelloWorld  &#125;&#125;&lt;/script&gt;&lt;style&gt;  body &#123;    background: #fff;  &#125;&lt;/style&gt;</code></pre><p>变成了</p><pre><code>import HelloWorld from &#39;/src/components/HelloWorld.vue&#39;const __script = &#123;    name: &#39;App&#39;,    components: &#123;        HelloWorld    &#125;&#125;import &quot;/src/App.vue?type=style&amp;index=0&quot;import &#123;render as __render&#125; from &quot;/src/App.vue?type=template&quot;__script.render = __render__script.__hmrId = &quot;/src/App.vue&quot;typeof __VUE_HMR_RUNTIME__ !== &#39;undefined&#39; &amp;&amp; __VUE_HMR_RUNTIME__.createRecord(__script.__hmrId, __script)__script.__file = &quot;/Users/liangxiaoying/myfile/wy-project/vite-demo/src/App.vue&quot;export default __script</code></pre><p>这样就把原本一个 <code>.vue</code> 的文件拆成了三个请求（分别对应 script、style 和 template） ，浏览器会先收到包含 script 逻辑的 App.vue 的响应，然后解析到 template 和 style 的路径后，会再次发起 HTTP 请求来请求对应的资源，此时 Vite 对其拦截并再次处理后返回相应的内容。</p><p>实际上在看到这个思路之后，对于其他的类型文件的处理几乎都是类似的逻辑，根据请求的不同文件类型，做出不同的编译处理。<strong>实际上 Vite 就是在按需加载的基础上通过拦截请求实现了实时按需编译</strong></p><h3 id="2-5-HTTP-2"><a href="#2-5-HTTP-2" class="headerlink" title="2.5 HTTP 2"></a>2.5 HTTP 2</h3><ul><li>零散模块文件在<strong>HTTP 1.x \</strong>确实会产生大量的 HTTP 请求，而大量的 HTTP 请求在浏览器端就会并发请求资源的问题；但是这些问题随着**HTTP 2**的出现，也就不复存在了。</li><li>why?</li></ul><p>HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8 个的 TCP 链接请求限制；HTTP 2 则可以使用<strong>多路复用</strong>，代替原来的序列和阻塞机制。所有请求都是通过一个 TCP 连接并发完成。<img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><h2 id="三、三大作用"><a href="#三、三大作用" class="headerlink" title="三、三大作用"></a>三、三大作用</h2><p>即 Vite 的 3 大核心功能：Static Server  + HMR + Compile</p><h3 id="3-1-快速的冷启动"><a href="#3-1-快速的冷启动" class="headerlink" title="3.1 快速的冷启动"></a>3.1 快速的冷启动</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjxU87KR9JVnFl9g26xmuroHsCsZUrECBLDgrhPMWZYusw1mSqjcArlEA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">社区：比如可以借助各种 cli ：vue-cli、create-react-app 等等</p><p>当我们对比使用 vue-cli-service serve 的时候，会有明显感觉。<strong>因为 Webpack Dev Server 在启动时，需要先 build—遍，而 build 的过程是需要耗费很多时间的。**</strong><img src="https://mmbiz.qpic.cn/mmbiz_png/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjx491micWSphF36pgeicUo6WUXpiaiajpYLia2dicibRxqdfqalWTaIZxnJF1GQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><strong>**而 Vite 则完全不同，当我们执行 Vite serve 时（\</strong>npm run dev**），内部直接启动了 Web Server，并不会先编译所有的代码文件。<strong>那仅仅是启动 Web Server，速度上自然就蹭蹭蹭的 up↑。那么及时请求的编译呢？关于支持 JSX， TSX，Typescript 编译到原生 JS —— Vite 引入了</strong>EsBuild**，是使用 Go 写的，直接编译为 Native 代码，性能要比 TSC 好二三十倍,所以就不用担心啦~ 当然也会用上缓存，具体这里暂时不扩展。<img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><h3 id="3-2-即时的热模块更新"><a href="#3-2-即时的热模块更新" class="headerlink" title="3.2 即时的热模块更新"></a>3.2 即时的热模块更新</h3><p>社区：Webpack HMR 等</p><p>热更新的时候，Vite 只需要立即编译当前所修改的文件即可，所以 响应速度非常快。<img src="https://mmbiz.qpic.cn/mmbiz_png/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjxQYDdeabfibbYbvMv9ofluF3UFfbdvSw7ccLtNHuh98yEict844tlohWQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">而 Webpack 修改某个文件过后，会自动以这个文件为入口重写 build—次，所有的涉及到的依赖也都会被加载一遍，所以反应速度会慢很多。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjxt1hEjAceHTNSF6nYUBT3pwCnSEhyZjuhIr6VaLuzmL7XZ1A4z1gM0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz_png/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjxwc7elX8zqScUZKyICSdgJyOAEv6OFkj8jEeCvK79nrcz11m7nvuIfw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="3-3-真正的按需编译"><a href="#3-3-真正的按需编译" class="headerlink" title="3.3 真正的按需编译"></a>3.3 真正的按需编译</h3><p>社区：需要开发者自行在代码中引入其他插件 <code>impor(&#39;xx.js&#39;)</code> 实现 dynamic-import；如@babel/plugin-syntax-dynamic-import</p><p>但是像 Webpack 这类工具的做法是将所有模块提前编译、打包进 bundle 里，换句话说，不管模块是否会被执行，都要被编译和打包到 bundle 里。随着项目越来越大打包后的 bundle 也越来越大，打包的速度自然也就越来越慢。</p><p>Vite 利用现代浏览器原生支持 ESM 特性，省略了对模块的打包。</p><p>对于需要编译的文件，Vite 采用的是另外一种模式：即时编译。也就是说，只有具体去请求某个文件时才会编译这个文件。所以，这种「即时编译」的好处主要体现在：按需编译。</p><h2 id="四、核心思路"><a href="#四、核心思路" class="headerlink" title="四、核心思路"></a>四、核心思路</h2><h3 id="4-1-初始启动静态服务"><a href="#4-1-初始启动静态服务" class="headerlink" title="4.1 初始启动静态服务"></a>4.1 初始启动静态服务</h3><p>初始执行命令  npm run dev –&gt; 实际就是启动了 /src/node/server/index.ts 如上文提到启动了一个 koa server, 该文件还使用了 chokidar 库创建一个 watcher，来监听文件变动：</p><pre><code>export function createServer(config: ServerConfig): Server &#123;  // 启动静态 server：  const app = new Koa&lt;State, Context&gt;()  const server = resolveServer(config, app.callback())    ......    const listen = server.listen.bind(server)  server.listen = (async (port: number, ...args: any[]) =&gt; &#123;    ...  &#125;) as any      // 其中关键 1：使用 chokidar 对文件进行递归监听：监听到文件变动可对不同模块进行相应处理  const watcher = chokidar.watch(root, &#123;    ignored: [&#39;**/node_modules/**&#39;, &#39;**/.git/**&#39;],    ...  &#125;) as HMRWatcher    // 其中关键 2：执行各类插件  const resolvedPlugins = [    // rewrite and source map plugins take highest priority and should be run    // after all other middlewares have finished    sourceMapPlugin,    moduleRewritePlugin,    htmlRewritePlugin, // 处理 html 文件    // user plugins    ...toArray(configureServer),    envPlugin,    moduleResolvePlugin,    proxyPlugin,    clientPlugin, // 输出客户端执行代码    hmrPlugin, // 处理热模块更新    ...(transforms.length || Object.keys(vueCustomBlockTransforms).length      ? [          createServerTransformPlugin(            transforms,            vueCustomBlockTransforms,            resolver          )        ]      : []),    vuePlugin, // 处理单文件组件    cssPlugin, // 处理样式文件    enableEsbuild ? esbuildPlugin : null,    jsonPlugin,    assetPathPlugin,    webWorkerPlugin,    wasmPlugin,    serveStaticPlugin  ]  resolvedPlugins.forEach((m) =&gt; m &amp;&amp; m(context))&#125;</code></pre><h3 id="4-2-监听消息，拦截部分请求"><a href="#4-2-监听消息，拦截部分请求" class="headerlink" title="4.2 监听消息，拦截部分请求"></a>4.2 监听消息，拦截部分请求</h3><p>我们可以看到初始第一个请求如下：<img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">那么这个文件哪里来的？这就是经过 clientPlugin 【/src/node/server/serverPluginClient.ts】处理输出的：</p><pre><code>export const clientPublicPath = `/vite/client` // 当前的文件名称const legacyPublicPath = &#39;/vite/hmr&#39; // 历史版本的名称...export const clientPlugin: ServerPlugin = (&#123; app, config &#125;) =&gt; &#123; // clientCode 替换配置的信息，用于最后 body 输出： const clientCode = fs    .readFileSync(clientFilePath, &#39;utf-8&#39;)    .replace(`__MODE__`, JSON.stringify(config.mode || &#39;development&#39;))    ...app.use(async (ctx, next) =&gt; &#123;   // 请求路径是/vite/client,返回响应：200，响应文本是处理好的 clientCode    if (ctx.path === clientPublicPath) &#123;      // 设置 socket 配置信息      let socketPort: number | string = ctx.port      ...      if (config.hmr &amp;&amp; typeof config.hmr === &#39;object&#39;) &#123;        // hmr option 有最高优先级        ...      &#125;      ctx.type = &#39;js&#39;      ctx.status = 200      // 返回整合好的 body      ctx.body = clientCode.replace(`__HMR_PORT__`, JSON.stringify(socketPort))    &#125; else &#123;      if (ctx.path === legacyPublicPath) &#123; // 历史版本 /vite/hmr        console.error(&#39;xxxx&#39;)      &#125;      return next()    &#125;  &#125;) &#125;</code></pre><p>请求/vite/client 实际就是 /src/client/client.ts 文件，即返回 body = clientCode = client.ts 文件内容；那么它做啥了呢？？？使用 websoket 处理消息，快速编译，达到实时热更新：</p><pre><code>const socketProtocol =  __HMR_PROTOCOL__ || (location.protocol === &#39;https:&#39; ? &#39;wss&#39; : &#39;ws&#39;)const socketHost = `$&#123;__HMR_HOSTNAME__ || location.hostname&#125;:$&#123;__HMR_PORT__&#125;`// 启动 websocket 通信，可实时处理消息，实现 HMRconst socket = new WebSocket(`$&#123;socketProtocol&#125;://$&#123;socketHost&#125;`, &#39;vite-hmr&#39;)...</code></pre><p>监听消息：</p><pre><code>socket.addEventListener(&#39;message&#39;, async (&#123; data &#125;) =&gt; &#123;  const payload = JSON.parse(data) as HMRPayload | MultiUpdatePayload  handleMessage(payload)&#125;)</code></pre><p>处理消息：</p><pre><code>async function handleMessage(payload) &#123;    const &#123; path, changeSrcPath, timestamp &#125; = payload;    switch (payload.type) &#123;        case &#39;connected&#39;: // socket 连接成功            console.log(`[vite] connected.`);            break;        case &#39;vue-reload&#39;: // 组件重新加载            queueUpdate(import(`$&#123;path&#125;?t=$&#123;timestamp&#125;`)                .catch((err) =&gt; warnFailedFetch(err, path))                .then((m) =&gt; () =&gt; &#123;                __VUE_HMR_RUNTIME__.reload(path, m.default);                console.log(`[vite] $&#123;path&#125; reloaded.`);            &#125;));            break;        case &#39;vue-rerender&#39;: // 组件重新渲染            const templatePath = `$&#123;path&#125;?type=template`;            import(`$&#123;templatePath&#125;&amp;t=$&#123;timestamp&#125;`).then((m) =&gt; &#123;                __VUE_HMR_RUNTIME__.rerender(path, m.render);                console.log(`[vite] $&#123;path&#125; template updated.`);            &#125;);            break;        case &#39;style-update&#39;: // 样式更新            // check if this is referenced in html via &lt;link&gt;            const el = document.querySelector(`link[href*=&#39;$&#123;path&#125;&#39;]`);            if (el) &#123;                el.setAttribute(&#39;href&#39;, `$&#123;path&#125;$&#123;path.includes(&#39;?&#39;) ? &#39;&amp;&#39; : &#39;?&#39;&#125;t=$&#123;timestamp&#125;`);                break;            &#125;            // imported CSS            const importQuery = path.includes(&#39;?&#39;) ? &#39;&amp;import&#39; : &#39;?import&#39;;            await import(`$&#123;path&#125;$&#123;importQuery&#125;&amp;t=$&#123;timestamp&#125;`);            console.log(`[vite] $&#123;path&#125; updated.`);            break;        case &#39;style-remove&#39;: // 样式移除            removeStyle(payload.id);            break;        case &#39;js-update&#39;: // js 更新            queueUpdate(updateModule(path, changeSrcPath, timestamp));            break;        case &#39;custom&#39;: // 自定义更新            const cbs = customUpdateMap.get(payload.id);            if (cbs) &#123;                cbs.forEach((cb) =&gt; cb(payload.customData));            &#125;            break;        case &#39;full-reload&#39;: // 网页重刷新            if (path.endsWith(&#39;.html&#39;)) &#123;                ...            &#125; else &#123;                location.reload();            &#125;    &#125;&#125;</code></pre><p>咦？那设立了 message 监听，那 message 又是谁发出来的呢？</p><h3 id="4-3-不同插件，监听文件变化，返回消息"><a href="#4-3-不同插件，监听文件变化，返回消息" class="headerlink" title="4.3 不同插件，监听文件变化，返回消息"></a>4.3 不同插件，监听文件变化，返回消息</h3><p>例如：cssPlugin 【/src/node/server/serverPluginCss.ts】</p><pre><code>// 处理 css 文件，监听 css 文件变动export const cssPlugin: ServerPlugin = (&#123; root, app, watcher, resolver &#125;) =&gt; &#123;  // 输出 css 请求的响应模板  export function codegenCss(    id: string,    css: string,    modules?: Record&lt;string, string&gt;  ): string &#123;    let code =      `import &#123; updateStyle &#125; from &quot;$&#123;clientPublicPath&#125;&quot;\n` +      `const css = $&#123;JSON.stringify(css)&#125;\n` +      `updateStyle($&#123;JSON.stringify(id)&#125;, css)\n`    if (modules) &#123;      code += dataToEsm(modules, &#123; namedExports: true &#125;)    &#125; else &#123;      code += `export default css`    &#125;    return code  &#125;    app.use(async (ctx, next) =&gt; &#123;    await next()    // 处理 .css 的 imports    ...    const id = JSON.stringify(hash_sum(ctx.path))    if (isImportRequest(ctx)) &#123;      const &#123; css, modules &#125; = await processCss(root, ctx)      ctx.type = &#39;js&#39;      // 用`?import`去重写 css 文件为一个 js 模块,插入 style 标记，链接到实际原始 url      ctx.body = codegenCss(id, css, modules)    &#125;  &#125;)  watcher.on(&#39;change&#39;, (filePath) =&gt; &#123;    // 筛出 css 文件，更新 css 请求文件    if (文件更新) &#123;      watcher.send(&#123; // 发送消息        type: &#39;style-update&#39;,        path: publicPath,        changeSrcPath: publicPath,        timestamp: Date.now()      &#125;)    &#125;  &#125;)  &#125;</code></pre><h3 id="4-4-逻辑小结"><a href="#4-4-逻辑小结" class="headerlink" title="4.4 逻辑小结"></a>4.4 逻辑小结</h3><ul><li>将当前项目目录作为静态文件服务器的根目录</li><li>拦截部分文件请求</li><li>处理代码中 import node_modules 中的模块 b</li><li>处理 Vue 单文件组件（SFC)的编译</li><li>通过 WebSocket 实现 HMR</li></ul><h2 id="五、Snowpack-VS-Vite"><a href="#五、Snowpack-VS-Vite" class="headerlink" title="五、Snowpack VS Vite"></a>五、Snowpack VS Vite</h2><p><strong>同：</strong></p><ol><li>底层原理：Snowpack v2 和 Vite 均提供基于浏览器原生 ES 模块导入的开发服务器；</li><li>冷启动快速：在开发反馈速度方面，两个项目都具有相似的性能特征；</li><li>开箱即用：避免各种 Loader 和 Plugin 的配置。</li></ol><p>Vite 默认情况下支持更多的选择加入功能-例如 TypeScript transpilation、CSS import、CSS Modules 和 postcss 支持（需要单独安装所对应的编译器) 都是现成的，无需配置；snowpack 也是支持 JSX、TypeScript、React、Preact、CSS Modules 等构建，非默认；</p><ol><li>插件：支持很多自定义插件；Vite 关于这部分的官方文档还没有。</li></ol><p><strong>异：</strong></p><ol><li>演变：Snowpack 最初不提供 HMR 支持，但在 v2 添加了它，从而使两个项目的范围更加接近。Vite 最初就是参考了 snowpack v1; 双方在基于 ESM 的 HMR 上合作过，尝试建立统一的 api ESM-HMR API 规范， 但因为底层不同还是会略微不同；</li><li>使用：Vite 当前暂时只能给 Vue 3.x.使用+react 等部分模板, 对 vue 支持更棒👍；snowpack 没限制；</li><li>生产打包：Vite 用 rollup，打包体积更小（<strong>rollupInputOptions：定义 rollup 的插件功能</strong>）；snowpack 用 parcel/webpack；- 决定了开发者生产个性化配置的方案不一样；</li><li>偏向：Vue 支持是 Vite 中的一级功能。例如，Vite 提供了一个更细粒度的 HMR 与 Vue 的集成，并且对构建配置进行了微调，以生成最高效的 bundle；</li><li>文档完善性：</li></ol><ul><li>Vitejs 优点是尤雨溪出品，可能和 Vue3 生态更好的融合。缺点是文档不完善。目前 star 13.7k；</li><li>Snowpack 优点是更加成熟，有成熟的 v1 和已经发布正式版的 v2, 支持 react， Vue， preact， svelte 等各类应用，文档也更加完善。目前 star 14.4k。</li></ul><p><strong>so。。。如何选择？：</strong>=&gt; 选 Vite:</p><ol><li>喜欢用 Vue，那么 Vite 提供更好支持；</li><li>诉求是打包 bundle 体积小 ，那么 Vue 使用 rollup👌。</li></ol><p>=&gt; 选 Snowpack：</p><ol><li>不喜欢用 Vue,不用 vue-cli,喜欢 react 等；</li><li>大的 team 想要使用各类插件 plugin，想要清晰的文档📚等；</li><li>对 Webpack 比较用的惯，想要开发模式不要 bundle 打包，更快速👀。</li></ol><p>来源：<a href="https://mp.weixin.qq.com/s/nI9o0NyoAI7jjreoflk79A">https://mp.weixin.qq.com/s/nI9o0NyoAI7jjreoflk79A</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/03/ziliao/javascript/wo-yong-liao-liang-ge-yue-li-jie-let/"/>
      <url>2021/03/03/ziliao/javascript/wo-yong-liao-liang-ge-yue-li-jie-let/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是浏览器插件？"><a href="#什么是浏览器插件？" class="headerlink" title="什么是浏览器插件？"></a>什么是浏览器插件？</h2><p>简单来说浏览器插件，是浏览器上的一种工具，可以提供一些浏览器没有的功能，帮你做一些有趣的事情。开发者可以根据自己的喜欢，去实现一些功能。插件基于Web技术（html、css、js）构建。</p><h2 id="举个栗子🌰"><a href="#举个栗子🌰" class="headerlink" title="举个栗子🌰"></a>举个栗子🌰</h2><h3 id="FeHelper-JSON插件"><a href="#FeHelper-JSON插件" class="headerlink" title="FeHelper.JSON插件"></a>FeHelper.JSON插件</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZM2nTDaNBJXLcTLWtnTlBFMpaSicMge4GL1LfPNNqIGCoz30XMVTEgPag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>功能：格式化JSON、编码转化、markdown、代码压缩等功能。</p><h3 id="二维码生成器"><a href="#二维码生成器" class="headerlink" title="二维码生成器"></a>二维码生成器</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMuGVqnszYxGr4wnLib08SqLsrZP6PgtYict4brzEAhl1u6lMmRALrkTnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>功能：可以根据当前浏览的网页地址，生成一个二维码。</p><h3 id="SwitchyOmega-Proxy"><a href="#SwitchyOmega-Proxy" class="headerlink" title="SwitchyOmega Proxy"></a>SwitchyOmega Proxy</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMG6Xia2PKgfNIaGTN4OibB6ZKsSZZia81RIul9QUu8aLmvibSOjPIHVs4xA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>功能：你懂的。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h3><p>Chrome 浏览器插件没有严格的文件结构约束，只需要保证文件夹根目录有 <strong>manifest.json</strong> 文件<strong>，</strong>该文件的内容会概括插件所需的资源、权限等等。</p><p>一个段简单的示例：</p><pre><code>&#123;    &quot;manifest_version&quot;: 2, // 必填    &quot;name&quot;: &quot;my-plugin&quot;, // 必填    &quot;version&quot;: &quot;0.1.0&quot; // 必填&#125;</code></pre><p>manifest_version：代表了manifest文件的版本，浏览器会根据这个值去指定该版本拥有的功能。</p><p>name：插件的名称。</p><p>version：插件版本。</p><p>将manifest.json文件放到一个文件夹内。</p><h3 id="chrome-extensions"><a href="#chrome-extensions" class="headerlink" title="chrome://extensions/"></a>chrome://extensions/</h3><p>在浏览器地址栏输入chrome://extensions/打开“拓展程序”页面。</p><p>注意：需要启用右上角的 “开发者模式” 才能加载已解压的插件文件：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMsD8eWf0NliaEuTHoBYF1icbMrRhyR4icIsV3olpxsBrpEqtUpicpBr7V8w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="加载已解压的插件"><a href="#加载已解压的插件" class="headerlink" title="加载已解压的插件"></a>加载已解压的插件</h3><p>启用之后点击加载已解压的拓展程序，选择刚刚我们放入了manifest.json的文件夹，之后你会看到：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMFlDibS50coOOYMdQDF3YBwJAiahbb8icfbIAHlAicc6pRvucusoxuCvVpg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>新增了一个我们刚刚添加的插件，而且浏览器右上角也会有我们的一个图标：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMvoVN3ia30vx92He9j8KMF9PMCjY0Y4kIn8k9VmpkiaicgluqsRrUAKqicQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>此时已经加载了一个插件了，但是这个插件除了占用浏览器的一个位置除外，没有任何作用。</p><p>如果没有设置插件图标，那么插件的第一个字符会成为插件的默认icon。</p><h3 id="让插件看起来更“插件”一点"><a href="#让插件看起来更“插件”一点" class="headerlink" title="让插件看起来更“插件”一点"></a>让插件看起来更“插件”一点</h3><p>为了让这个插件更“完善”一点，我们给它加一个icon和描述，并且点击出现一个popup页面，popup 页面一般用来承载临时性的交互，且生命周期很短：单击图标打开popup，焦点离开又立即关闭，可以通过default_popup字段来定义。</p><pre><code>&#123;  .....  &quot;description&quot;: &quot;这是一段描述&quot;,  // 插件管理页面的icon  &quot;icons&quot;: &#123;    &quot;84&quot;: &quot;./icon/ball.png&quot;  &#125;,  // 浏览器右上角的图标和内容  &quot;browser_action&quot;: &#123;    &quot;default_icon&quot;: &quot;./icon/ball.png&quot;,    &quot;default_title&quot;: &quot;我的插件&quot;,    &quot;default_popup&quot;: &quot;./html/popup.html&quot;  &#125;&#125;</code></pre><p>此时我们的目录结构也变成了这样：</p><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>给popup.html加上内容：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;my-plugin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p style=&quot;width: 200px;text-align:center;&quot;&gt;hello world!!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>之后，我们点击插件右下角的“刷新”按钮：</p><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>你会发现插件有了icon和描述：</p><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>并且右上角的icon也变了，点击一下，会弹出我们刚刚编写的popup.html页面：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZM2ybjHtPpicFjoEU8M75faAdzDS3zT0meA0zgMdu3zDicNe9GUTORv85A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>现在，我们一个“完整”的插件就已经做好了。</p><h2 id="manifest-json-配置介绍"><a href="#manifest-json-配置介绍" class="headerlink" title="manifest.json 配置介绍"></a>manifest.json 配置介绍</h2><h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><pre><code>&#123;    ...    &quot;background&quot;: &#123;        // 提供一个页面给background        &quot;page&quot;: &quot;./html/background.html&quot;        // 或者若干个js文件，后台会默认生成一个空白的html        &quot;scripts&quot;: [&quot;./js/background.js&quot;]    &#125;&#125;</code></pre><p>background配置项，为插件的后台常驻页面，生命周期随着浏览器的生命周期一样，浏览器一启动，后台页面就会开始运行，直到浏览器被关闭；或者在插件管理页面，将该插件禁用了，后台页面也会停止运行。</p><p>另外，background拥有的权限比较高，几乎可以调用所有的Chrome扩展API（除了devtools），同时拥有直接跨域的能力。</p><p>page:指定一个网页为后台页面。</p><p>scripts:指定若干个js文件，后台会自动生成一个html，并按顺序调用这些js文件。</p><p>注意：<strong>page</strong> 和 <strong>scripts</strong> 选项只能<strong>二选一</strong>，不然会报错。</p><p>配置好之后，属性插件，会出现一个背景页选项：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMWicHDJKtia4MjSA08GyJPKCYbGlMJsyRKZeqHbK9U2bShJ7NVGBeUqpg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>我使用的是一个background.js文件：</p><pre><code>function _back() &#123;  console.log(&#39;background.js&#39;)&#125;console.log(&#39;running...&#39;)</code></pre><p>点进去看看里面装的什么玩意：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMcgde1yRv2uhwEE8hClMtxzib9NhSPtOfyxJJ9ibmLuZSEXSeRVJlic5iaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>没错，是一个普通的后台页面，如果background.js和其他页面有通信，则可以在这里进行查看请求或者调试代码。</p><p>如果使用page选项，打开也是这个样子。</p><p>另外：由于background是一直在后台运行的，为了优化性能，可以增加一个配置:</p><pre><code>&#123;    ...    &quot;background&quot;: &#123;        ...        &quot;persistent&quot;: false    &#125;&#125;</code></pre><p>这样，插件就会在被需要时加载，在空闲时被关闭。比如安装、更新插件的时候，或者有其他页面与background通信的时候才会被加载。</p><h3 id="content-scripts"><a href="#content-scripts" class="headerlink" title="content-scripts"></a><strong>content-scripts</strong></h3><p>content-scripts能够在合适的时机（页面载入前、载入后、空闲时）注入脚本，允许内容脚本更改其JavaScript环境，而不与页面或其他内容脚本发生冲突。</p><p>例如，原页面有个按钮，并且给按钮添加了一个点击事件：</p><pre><code>&lt;html&gt;    &lt;button id=&quot;mybutton&quot;&gt;click me&lt;/button&gt;    &lt;script&gt;      var greeting = &quot;hello, &quot;;      var button = document.getElementById(&quot;mybutton&quot;);      button.person_name = &quot;Bob&quot;;      button.addEventListener(&quot;click&quot;, function() &#123;        alert(greeting + button.person_name + &quot;.&quot;);      &#125;, false);    &lt;/script&gt;  &lt;/html&gt;</code></pre><p>在content-scripts中，加入以下代码：</p><pre><code>var greeting = &quot;hola, &quot;;var button = document.getElementById(&quot;mybutton&quot;);button.person_name = &quot;Roberto&quot;;button.addEventListener(&quot;click&quot;, function() &#123;alert(greeting + button.person_name + &quot;.&quot;);&#125;, false);</code></pre><p>当页面运行之后，脚本内容也会在插件定义的时间运行，当页面点击按钮时，会出现两次弹窗。</p><p>content-scripts配置：</p><pre><code>&#123;    ...    &quot;content_scripts&quot;: [        &#123;          // 在匹配的URL中运行，&lt;all_urls&gt;表示所有的URL都会运行。          &quot;matches&quot;: [&quot;&lt;all_urls&gt;&quot;],          // 注入的js,会按顺序运行。          &quot;js&quot;: [&quot;./js/content.js&quot;],          // css引入需谨慎，因为可能会影响全局的样式,同样也能接收多个css文件，会按顺序插入到页面中          &quot;css&quot;: [&quot;./css/style.css&quot;],          // 代码注入的时机，可选值： &quot;document_start&quot;, &quot;document_end&quot;, or &quot;document_idle&quot;，最后一个表示页面空闲时，默认document_idle          &quot;run_at&quot;: &quot;document_start&quot;        &#125;,        &#123;          &quot;matches&quot;: [&quot;https://www.baidu.com/&quot;],          &quot;js&quot;: [&quot;./js/other.js&quot;],          &quot;run_at&quot;: &quot;document_start&quot;        &#125;      ],    ...&#125;</code></pre><p>content.js代码如下：</p><pre><code>console.log(&#39;hello, from content.js&#39;);</code></pre><p>other.js代码如下：</p><pre><code>console.log(&#39;hello, from other.js...&#39;)</code></pre><p>更新插件，当在 <a href="https://bytedance.feishu.cn/drive/home/%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%9A">https://bytedance.feishu.cn/drive/home/运行时：</a></p><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>因为【 <a href="https://bytedance.feishu.cn/drive/home/%E3%80%91%E5%8F%AA%E5%8C%B9%E9%85%8D%E5%88%B0%E4%BA%86">https://bytedance.feishu.cn/drive/home/】只匹配到了</a><all_urls>的规则，所以之后运行content.js</all_urls></p><p>当在<a href="https://www.baidu.com/%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%9A">https://www.baidu.com/运行时：</a></p><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>同时命中了2个规则，所以content.js和other.js都会运行，顺序也是正确的。</p><p>content-scripts 和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过inject-scripts来实现。content-scripts能够访问的Chrome API的权限也比较低，只能访问以下四个API：</p><ul><li>chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest)</li><li>chrome.i18n</li><li>chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage)</li><li>chrome.storage</li></ul><h3 id="Inject-scripts"><a href="#Inject-scripts" class="headerlink" title="Inject-scripts"></a>Inject-scripts</h3><p>inject-scripts 是通过DOM操作插入的JS代码，通常在content-scripts只能操作DOM，但是却无法访问页面的JS，借助content-scripts可以操作DOM的能力，往页面中插入JS文件，给页面提供调用插件API的能力，以及和background通信的能力。</p><p>在插入之前，需配置一下web可访问的资源，同时content-scripts的调用时机换成”document_end”或者”document_idle”，不然会无法获取DOM,导致插入失败。在manifest.json中添加以下内容：</p><pre><code>&#123;    ...    &quot;content_scripts&quot;: [        &#123;          &quot;matches&quot;: [&quot;&lt;all_urls&gt;&quot;],          &quot;js&quot;: [&quot;./js/content.js&quot;],          &quot;run_at&quot;: &quot;document_end&quot;        &#125;,        ...     ],    &quot;web_accessible_resources&quot;: [&quot;js/inject.js&quot;],    ...&#125;</code></pre><p>inject.js的内容如下：</p><pre><code>function mockApi () &#123;  console.log(&#39;this is from inject.js&#39;)&#125;</code></pre><p>content.js增加以下代码:</p><pre><code>(function () &#123;  let path = &#39;js/inject.js&#39;;  let script = document.createElement(&#39;script&#39;);  script.setAttribute(&#39;type&#39;, &#39;text/javascript&#39;);  // 注意，路径需用Chrome API 生成，这个方法可以获得插件的资源的真实路径。  // 类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js  script.src = chrome.extension.getURL(path);  script.onload = function () &#123;    // 在执行完代码之后移除script标签    this.parentNode.removeChild(this);  &#125;  document.body.appendChild(script);&#125;)();</code></pre><p>更新插件后，页面就可以访问inject.js的方法：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMUdtVGGetGOGTicuxaFUJ8fkr8NdVlcvias6qqHbzYgFQLbK9y7F7X6zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="permissions"><a href="#permissions" class="headerlink" title="permissions"></a>permissions</h3><p>插件后台有的操作需要配置相应的权限，例如本地存储、网络请求、通知等等，示例：</p><pre><code>&#123;    ...    &quot;permissions&quot;: [        &quot;contextMenus&quot;, // 右键菜单        &quot;tabs&quot;, // 标签        &quot;notifications&quot;, // 通知        &quot;webRequest&quot;, // web请求        &quot;webRequestBlocking&quot;,        &quot;storage&quot; // 插件本地存储    ],    ...&#125;</code></pre><h3 id="完整的manifest配置"><a href="#完整的manifest配置" class="headerlink" title="完整的manifest配置"></a>完整的manifest配置</h3><p>官方文档：<a href="https://developer.chrome.com/extensions/manifest">https://developer.chrome.com/extensions/manifest</a></p><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><h3 id="popup和background通信"><a href="#popup和background通信" class="headerlink" title="popup和background通信"></a>popup和background通信</h3><p>popup可以通过 chrome.extension.getBackgroundPage() API 直接获取到background的上下文，从而调用background的方法来通信：</p><pre><code>// popup.jsvar backend = chrome.extension.getBackgroundPage();backend.test(); // 访问bbackground的函数</code></pre><p>background可以通过chrome.extension.getViews({type:’popup’}) 获取到popup的上下文，前提是popup页面是打开的状态下。</p><pre><code>let views = chrome.extension.getViews(&#123;type:&#39;popup&#39;&#125;);let popup = nullif(views.length &gt; 0) &#123;    popup = views[0];    // 直接访问popup的函数    popup.test();&#125;</code></pre><p>这里需要注意一点：</p><p>在popup页面，你如果想编写js，请将js编写在一个文件里面，然后引入进来，不然会报错，这是因为Chrome的安全政策规定的：<a href="https://developer.chrome.com/extensions/contentSecurityPolicy">https://developer.chrome.com/extensions/contentSecurityPolicy</a></p><p>popup错误示范：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;   ...&lt;/head&gt;&lt;body&gt;    &lt;p style=&quot;width: 200px;text-align:center;&quot;&gt;hello world!!&lt;/p&gt;    &lt;script&gt;        // 不能直接在里面写    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>正确姿势：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    ...&lt;/head&gt;&lt;body&gt;    &lt;p style=&quot;width: 200px;text-align:center;&quot;&gt;hello world!!&lt;/p&gt;    &lt;script src=&quot;../js/popup.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="content-scripts和background通信"><a href="#content-scripts和background通信" class="headerlink" title="content-scripts和background通信"></a>content-scripts和background通信</h3><p>content-scripts可以通过 chrome.runtime.sendMessage(message) 给background发送消息：</p><pre><code>chrome.runtime.sendMessage(&#39;message content&#39;, (res) =&gt; &#123;    console.log(&#39;from background:&#39;, res)&#125;);</code></pre><p>background通过chrome.runtime.onMessage.addListener()监听content-scripts发送的消息：</p><pre><code>chrome.runtime.onMessage.addListener(function(message, sender, callback) &#123;   console.log(mesasge); // meesage content   callback &amp;&amp; callback(&#39;yes this from background&#39;)&#125;);</code></pre><p>background主动给content-scripts发消息，首先得查找要给哪个tab发消息，使用chrome.tabs.query 这个方法查找到tab，再使用chrome.tabs.sendMessage 方法给tab发消息：</p><pre><code>// &#123;active: true, currentWindow: true&#125; 表示查找当前屏幕下的active状态的tab;chrome.tabs.query(&#123;active: true, currentWindow: true&#125;, function (tabs) &#123;    chrome.tabs.sendMessage(tabs[0].id, &#39;message content&#39;, (res) =&gt; &#123;        console.log(&#39;from content:&#39;, res)    &#125;);&#125;);</code></pre><p>content-scripts通过chrome.runtime.onMessage.addListener 去监听事件：</p><pre><code>chrome.runtime.onMessage.addListener(function (message, sender, callback) &#123;    console.log(message, sender)    callback &amp;&amp; callback(&#39;yes this from content&#39;)&#125;);</code></pre><p>注意：</p><p>1.消息内容可以直接发送JSON格式的对象。</p><p>2.popup和content的通信方式与上面一样。</p><p>3.如果popup和background都监听了从content发来的消息，两者都能收到监听消息，但是callback只会触发一次，被谁触发取决与谁先发送。</p><h3 id="inject-scripts和content-scripts"><a href="#inject-scripts和content-scripts" class="headerlink" title="inject-scripts和content-scripts"></a>inject-scripts和content-scripts</h3><p>inject-scripts和content-scripts通信有两种方法：</p><p>1.window.postMessage发送，window.addEventListener接收</p><p>2.还有一种是自定义的DOM事件；</p><p>但是很少情况会是content-scripts去调inject-scripts，因为，可以，但是没必要….content-scripts完全可以自己处理一些API的事件监听，况且inject-scripts也只是content-scripts生成并插入到DOM里面的，所以在content-scripts眼里，inject-scripts就是个弟弟…</p><p>但是，很多用户触发的事件，需要通过inject-scripts告诉content-scripts，content-scripts再给background通信并且去做一些事情，然后再发消息告诉inject-scripts，从这个角度看：content-scripts就是一个inject-scripts的工具人！</p><p>（扯平了，完美。）</p><p>inject-scripts给content-scripts发消息：</p><pre><code>window.postMessage(&#123;&quot;test&quot;: &#39;你好！工具人！&#39;&#125;, &#39;*&#39;);</code></pre><p>content-scripts接收消息:</p><pre><code>window.addEventListener(&quot;message&quot;, function(message) &#123;    console.log(&#39;来了老弟！&#39;, message.data);&#125;, false);</code></pre><p>同样的，content-scripts给inject-scripts发消息是一样的。</p><h2 id="练练手：HTTP-Header-插件"><a href="#练练手：HTTP-Header-插件" class="headerlink" title="练练手：HTTP Header 插件"></a>练练手：HTTP Header 插件</h2><p>实现一个HTTP Header 插件，可以实现动态添加header，并且给网络请求自动加上header，header参数可以配置。</p><p>示例图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMUwzQm5LYOcPkML3jDXAFtMz1kMiaMBo1FVY59VribDA7XQS4QviczXqKQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="Background-功能设计"><a href="#Background-功能设计" class="headerlink" title="Background 功能设计"></a>Background 功能设计</h3><p>background复制存储、操作headers，对所有浏览器请求做一层拦截，并加上启用的headers。</p><p>注意：因为涉及到网络请求，所以需在manifest.json中添加权限：</p><pre><code>&#123;    ...    &quot;permissions&quot;: [        &quot;storage&quot;, // 本地存储        &quot;webRequest&quot;, // 网络请求        &quot;webRequestBlocking&quot;, // 网络请求 阻塞式        &quot;&lt;all_urls&gt;&quot; // 匹配的URL    ]    ...&#125;</code></pre><p>Background 功能伪代码:</p><pre><code>// headers数据结构, 附带默认值;(可以改为本地存储)。const headers = [    &#123;    key: &#39;Content-Type&#39;,    value: &#39;application/x-www-form-urlencoded&#39;,    enable: false,  &#125;,  &#123;    key: &#39;Test-Header&#39;,    value: &#39;按F进入坦克&#39;,    enable: true,  &#125;,];// 获取、新增、删除、启用禁用function getHeaders () &#123;    return headers;&#125;function addHeader (header) &#123;    headers.push(header);&#125;function deleteHeader (index) &#123;    headers.splice(index, 1);&#125;function toggleHeader(index) &#123;  headers[index].enable = !headers[index].enable;&#125;...// 请求拦截器// On install 在被安装的时候去初始化chrome.runtime.onInstalled.addListener(function()&#123;    // 添加事件      chrome.webRequest.onBeforeSendHeaders.addListener(requestHandle, &#123;        urls: [&quot;&lt;all_urls&gt;&quot;],// 拦截所有URL的请求    &#125;,[&quot;blocking&quot;, &quot;requestHeaders&quot;]); // 阻塞式    console.log(&#39;load&#39;);&#125;);// 添加headerfunction requestHandle(request) &#123;    let requestHeaders = request.requestHeaders;    // 添加headers    headers.forEach(item =&gt; &#123;        if (item.enable) &#123;            requestHeaders.push(&#123;                name: item.key,                value: item.value,            &#125;);        &#125;    &#125;);    return &#123;requestHeaders&#125;;&#125;</code></pre><h3 id="chrome-webRequest的生命周期："><a href="#chrome-webRequest的生命周期：" class="headerlink" title="chrome.webRequest的生命周期："></a>chrome.webRequest的生命周期：</h3><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>详细参考：<a href="https://developer.chrome.com/extensions/webRequest">https://developer.chrome.com/extensions/webRequest</a></p><h3 id="popup-页面设计"><a href="#popup-页面设计" class="headerlink" title="popup 页面设计"></a>popup 页面设计</h3><p>popup页面提供增加、删除、启用禁用功能接口，并且在每次打开popup页面的时候去background获取最新的header数据，展示在前台。</p><p>popup.js 功能伪代码：</p><pre><code>// popup页面被打开时，去后台获取最新headerwindow.onload = function () &#123;    let backend = chrome.extension.getBackgroundPage();    // 调用background方法，获得headers    let headers = backend.getHeaders();    // 渲染header    createElement(headers);&#125;// 增加按钮function addHeader() &#123;    let backend = chrome.extension.getBackgroundPage();    let key = document.querySelector(&#39;.key&#39;);    let value =  document.querySelector(&#39;.value&#39;);    let header = &#123;        key: key.value,        value: value.value,        enable: true      &#125;    // 调用background方法，新增headers    backend.addHeader(header);    createElement(header);&#125;// 启用禁用、删除功能function toggleHeader(index) &#123;  let backend = chrome.extension.getBackgroundPage();  backend.toggleHeader(index);&#125;function delHeader(index) &#123;  let backend = chrome.extension.getBackgroundPage();  backend.deleteHeader(index);&#125;</code></pre><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>打开popup,添加一个header:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMKMaeNzVubDDletfVm8LoJ3Vz9xN4T8AqVNJsLibS5LrOmZLEbCtNNbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>随便打开一个网页，打开控制台查看RequestHeaders:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMiawEIbcIZ7icYfdHh2Bzx81siaqVZPfWfZbellc22NHmwUnKfHf74dx5A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>很多权限、功能需要在manifest.json配置。</li><li>content-scripts、popup、background、inject-scripts拥有的权限不一样，通信方式也不一样，理解各个脚本的特点，组合使用。</li><li>开发调试可在后台背景页查看信息，popup、inject-scripts、content-scripts可直接审查元素调试。</li></ul><p>Chrome 插件还有很多功能这里没有详细介绍，例如devtools。感兴趣的同学可以查阅下面的参考文档。</p><p><a href="https://mp.weixin.qq.com/s/5jl8wshMNBbNopuWqUx_7Q">https://mp.weixin.qq.com/s/5jl8wshMNBbNopuWqUx_7Q</a></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/03/niuke/sql/sql-server-cha-xun-you-hua-fang-fa/"/>
      <url>2021/03/03/niuke/sql/sql-server-cha-xun-you-hua-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>SQL Server查询优化方法</p><p>查询速度慢的原因很多，常见如下几种</p><p>　　1、没有索引或者没有用到索引(这是查询慢最常见的问题，是程序设计的缺陷)<br>　　2、I/O吞吐量小，形成了瓶颈效应<br>　　3、没有创建计算列导致查询不优化<br>　　4、内存不足<br>　　5、网络速度慢<br>　　6、查询出的数据量过大（可以采用多次查询，其他的方法降低数据量）<br>　　7、锁或者死锁(这也是查询慢最常见的问题，是程序设计的缺陷)<br>　　8、sp_lock,sp_who,活动的用户查看,原因是读写竞争资源。<br>　　9、返回了不必要的行和列<br>　　10、查询语句不好，没有优化</p><p>可以通过如下方法来优化查询</p><p>　　1、把数据、日志、索引放到不同的I/O设备上，增加读取速度，以前可以将Tempdb应放在RAID0上，SQL2000不在支持。数据量（尺寸）越大，提高I/O越重要.<br>　　2、纵向、横向分割表，减少表的尺寸(sp_spaceuse)<br>　　3、升级硬件<br>　　4、根据查询条件,建立索引,优化索引、优化访问方式，限制结果集的数据量。注意填充因子要适当（最好是使用默认值0）。索引应该尽量小，使用字节数小的列建索引好（参照索引的创建）,不要对有限的几个值的字段建单一索引如性别字段<br>　　5、提高网速;<br>　　6、扩大服务器的内存。配置虚拟内存：虚拟内存大小应基于计算机上并发运行的服务进行配置。可考虑将虚拟内存大小设置为计算机中安装的物理内存的1.5倍。如果另外安装了全文检索功能，并打算运行Microsoft搜索服务以便执行全文索引和查询，可考虑：将虚拟内存大小配置为至少是计算机中安装的物理内存的3倍。将SQL Server max server memory服务器配置选项配置为物理内存的1.5倍（虚拟内存大小设置的一半）。<br>　　7、增加服务器CPU个数;但是必须明白并行处理串行处理更需要资源例如内存。使用并行还是串行程是MsSQL自动评估选择的。单个任务分解成多个任务，就可以在处理器上运行。例如耽搁查询的排序、连接、扫描和GROUPBY字句同时执行，SQLSERVER根据系统的负载情况决定最优的并行等级，复杂的需要消耗大量的CPU的查询最适合并行处理。但是更新操作UPDATE,INSERT，DELETE还不能并行处理。<br>　　8、如果是使用like进行查询的话，简单的使用index是不行的，但是全文索引耗空间。like’a%’使用索引like’%a’不使用索引用like’%a%’查询时，查询耗时和字段值总长度成正比,所以不能用CHAR类型，而是VARCHAR。对于字段的值很长的建全文索引。<br>　　9、DBServer和ApplicationServer分离，OLTP和OLAP分离<br>　　10、分布式分区视图可用于实现数据库服务器联合体。联合体是一组分开管理的服务器，但它们相互协作分担系统的处理负荷。这种通过分区数据形成数据库服务器联合体的机制能够扩大一组服务器，以支持大型的多层Web站点的处理需要。有关更多信息，参见设计联合数据库服务器。（参照SQL帮助文件’分区视图’）</p><p>　　　　a、在实现分区视图之前，必须先水平分区表<br>　　　　b、在创建成员表后，在每个成员服务器上定义一个分布式分区视图，并且每个视图具有相同的名称。这样，引用分布式分区视图名的查询可以在任何一个成员服务器上运行。系统操作如同每个成员服务器上都有一个原始表的复本一样，但其实每个服务器上只有一个成员表和一个分布式分区视图。数据的位置对应用程序是透明的。</p><p>　　11、重建索引DBCCREINDEX,DBCCINDEXDEFRAG,收缩数据和日志DBCCSHRINKDB,DBCCSHRINKFILE.设置自动收缩日志.对于大的数据库不要设置数据库自动增长，它会降低服务器的性能。在T-sql的写法上有很大的讲究，下面列出常见的要点：首先，DBMS处理查询计划的过程是这样的：<br>　　　　1、查询语句的词法、语法检查<br>　　　　2、将语句提交给DBMS的查询优化器<br>　　　　3、优化器做代数优化和存取路径的优化<br>　　　　4、由预编译模块生成查询规划<br>　　　　5、然后在合适的时间提交给系统处理执行<br>　　　　6、最后将执行结果返回给用户其次，看一下SQLSERVER的数据存放的结构：一个页面的大小为8K(8060)字节，8个页面为一个盘区，按照B树存放。<br>　　12、Commit和rollback的区别Rollback:回滚所有的事物。Commit:提交当前的事物.没有必要在动态SQL里写事物，如果要写请写在外面如：begintranexec(@s)committrans或者将动态SQL写成函数或者存储过程。<br>　　13、在查询Select语句中用Where字句限制返回的行数,避免表扫描,如果返回不必要的数据，浪费了服务器的I/O资源，加重了网络的负担降低性能。如果表很大，在表扫描的期间将表锁住，禁止其他的联接访问表,后果严重。<br>　　14、SQL的注释申明对执行没有任何影响<br>　　15、尽可能不使用光标，它占用大量的资源。如果需要row-by-row地执行，尽量采用非光标技术,如：在客户端循环，用临时表，Table变量，用子查询，用Case语句等等。游标可以按照它所支持的提取选项进行分类：只进必须按照从第一行到最后一行的顺序提取行。FETCHNEXT是唯一允许的提取操作,也是默认方式。可滚动性可以在游标中任何地方随机提取任意行。游标的技术在SQL2000下变得功能很强大，他的目的是支持循环。<br>　　有四个并发选项：<br>　　　　READ_ONLY：不允许通过游标定位更新(Update)，且在组成结果集的行中没有锁。<br>　　　　OPTIMISTICWITHvalueS:乐观并发控制是事务控制理论的一个标准部分。乐观并发控制用于这样的情形，即在打开游标及更新行的间隔中，只有很小的机会让第二个用户更新某一行。当某个游标以此选项打开时，没有锁控制其中的行，这将有助于最大化其处理能力。如果用户试图修改某一行，则此行的当前值会与最后一次提取此行时获取的值进行比较。如果任何值发生改变，则服务器就会知道其他人已更新了此行，并会返回一个错误。如果值是一样的，服务器就执行修改。选择这个并发选项OPTIMISTICWITHROWVERSIONING:此乐观并发控制选项基于行版本控制。使用行版本控制，其中的表必须具有某种版本标识符，服务器可用它来确定该行在读入游标后是否有所更改。<br>　　　　在SQLServer中，这个性能由timestamp数据类型提供，它是一个二进制数字，表示数据库中更改的相对顺序。每个数据库都有一个全局当前时间戳值：@@DBTS。每次以任何方式更改带有timestamp列的行时，SQLServer先在时间戳列中存储当前的@@DBTS值，然后增加@@DBTS的值。如果某个表具有timestamp列，则时间戳会被记到行级。服务器就可以比较某行的当前时间戳值和上次提取时所存储的时间戳值，从而确定该行是否已更新。服务器不必比较所有列的值，只需比较timestamp列即可。如果应用程序对没有timestamp列的表要求基于行版本控制的乐观并发，则游标默认为基于数值的乐观并发控制。<br>　　　　SCROLLLOCKS这个选项实现悲观并发控制。在悲观并发控制中，在把数据库的行读入游标结果集时，应用程序将试图锁定数据库行。在使用服务器游标时，将行读入游标时会在其上放置一个更新锁。如果在事务内打开游标，则该事务更新锁将一直保持到事务被提交或回滚；当提取下一行时，将除去游标锁。如果在事务外打开游标，则提取下一行时，锁就被丢弃。因此，每当用户需要完全的悲观并发控制时，游标都应在事务内打开。更新锁将阻止任何其它任务获取更新锁或排它锁，从而阻止其它任务更新该行。<br>　　　　然而，更新锁并不阻止共享锁，所以它不会阻止其它任务读取行，除非第二个任务也在要求带更新锁的读取。滚动锁根据在游标定义的SELECT语句中指定的锁提示，这些游标并发选项可以生成滚动锁。滚动锁在提取时在每行上获取，并保持到下次提取或者游标关闭，以先发生者为准。下次提取时，服务器为新提取中的行获取滚动锁，并释放上次提取中行的滚动锁。滚动锁独立于事务锁，并可以保持到一个提交或回滚操作之后。如果提交时关闭游标的选项为关，则COMMIT语句并不关闭任何打开的游标，而且滚动锁被保留到提交之后，以维护对所提取数据的隔离。所获取滚动锁的类型取决于游标并发选项和游标SELECT语句中的锁提示。<br>　　　　锁提示只读乐观数值乐观行版本控制锁定无提示未锁定未锁定未锁定更新NOLOCK未锁定未锁定未锁定未锁定HOLDLOCK共享共享共享更新UPDLOCK错误更新更新更新TABLOCKX错误未锁定未锁定更新其它未锁定未锁定未锁定更新<em>指定NOLOCK提示将使指定了该提示的表在游标内是只读的。<br>　　16、用Profiler来跟踪查询，得到查询所需的时间，找出SQL的问题所在;用索引优化器优化索引<br>　　17、注意UNion和UNionall的区别。UNIONall好<br>　　18、注意使用DISTINCT，在没有必要时不要用，它同UNION一样会使查询变慢。重复的记录在查询里是没有问题的<br>　　19、查询时不要返回不需要的行、列<br>　　20、用sp_configure’querygovernorcostlimit’或者SETQUERY_GOVERNOR_COST_LIMIT来限制查询消耗的资源。当评估查询消耗的资源超出限制时，服务器自动取消查询,在查询之前就扼杀掉。SETLOCKTIME设置锁的时间<br>　　21、用selecttop100/10Percent来限制用户返回的行数或者SETROWCOUNT来限制操作的行<br>　　22、在SQL2000以前，一般不要用如下的字句:”ISNULL”,”&lt;&gt;”,”!=”,”!&gt;”,”!&lt;”,”NOT”,”NOTEXISTS”,”NOTIN”,”NOTLIKE”,and”LIKE’%500’”，因为他们不走索引全是表扫描。也不要在WHere字句中的列名加函数，如Convert，substring等,如果必须用函数的时候，创建计算列再创建索引来替代.还可以变通写法：WHERESUBSTRING(firstname,1,1)=’m’改为WHEREfirstnamelike’m%’（索引扫描），一定要将函数和列名分开。并且索引不能建得太多和太大。NOTIN会多次扫描表，使用EXISTS、NOTEXISTS，IN,LEFTOUTERJOIN来替代，特别是左连接,而Exists比IN更快，最慢的是NOT操作.如果列的值含有空，以前它的索引不起作用，现在2000的优化器能够处理了。相同的是ISNULL，“NOT”,”NOTEXISTS”,”NOTIN”能优化她，而”&lt;&gt;”等还是不能优化，用不到索引。<br>　　23、使用QueryAnalyzer，查看SQL语句的查询计划和评估分析是否是优化的SQL。一般的20%的代码占据了80%的资源，我们优化的重点是这些慢的地方。<br>　　24、如果使用了IN或者OR等时发现查询没有走索引，使用显示申明指定索引：SELECT</em>FROMPersonMember(INDEX=IX_Title)WHEREprocessidIN(‘男’，‘女’)<br>　　25、将需要查询的结果预先计算好放在表中，查询的时候再SELECT。这在SQL7.0以前是最重要的手段。例如医院的住院费计算。<br>　　26、MIN()和MAX()能使用到合适的索引<br>　　27、数据库有一个原则是代码离数据越近越好，所以优先选择Default,依次为Rules,Triggers,Constraint（约束如外健主健CheckUNIQUE……,数据类型的最大长度等等都是约束）,Procedure.这样不仅维护工作小，编写程序质量高，并且执行的速度快。<br>　　28、如果要插入大的二进制值到Image列，使用存储过程，千万不要用内嵌INsert来插入(不知JAVA是否)。因为这样应用程序首先将二进制值转换成字符串（尺寸是它的两倍），服务器受到字符后又将他转换成二进制值.存储过程就没有这些动作:方法：Createprocedurep_insertasinsertintotable(Fimage)values(@image),在前台调用这个存储过程传入二进制参数，这样处理速度明显改善。<br>　　29、Between在某些时候比IN速度更快,Between能够更快地根据索引找到范围。用查询优化器可见到差别。select<em>fromchineseresumewheretitlein(‘男’,’女’)Select</em>fromchineseresumewherebetween’男’and’女’是一样的。由于in会在比较多次，所以有时会慢些。<br>　　30、在必要是对全局或者局部临时表创建索引，有时能够提高速度，但不是一定会这样，因为索引也耗费大量的资源。他的创建同是实际表一样。<br>　　31、不要建没有作用的事物例如产生报表时，浪费资源。只有在必要使用事物时使用它。<br>　　32、用OR的字句可以分解成多个查询，并且通过UNION连接多个查询。他们的速度只同是否使用索引有关,如果查询需要用到联合索引，用UNIONall执行的效率更高.多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。<br>　　33、尽量少用视图，它的效率低。对视图操作比直接对表操作慢,可以用storedprocedure来代替她。特别的是不要用视图嵌套,嵌套视图增加了寻找原始资料的难度。我们看视图的本质：它是存放在服务器上的被优化好了的已经产生了查询规划的SQL。对单个表检索数据时，不要使用指向多个表的视图，直接从表检索或者仅仅包含这个表的视图上读，否则增加了不必要的开销,查询受到干扰.为了加快视图的查询，MsSQL增加了视图索引的功能。<br>　　34、没有必要时不要用DISTINCT和ORDERBY，这些动作可以改在客户端执行。它们增加了额外的开销。这同UNION和UNIONALL一样的道理。SELECTtop20ad.companyname,comid,position,ad.referenceid,worklocation,convert(varchar(10),ad.postDate,120)aspostDate1,workyear,degreedescriptionFROMjobcn_query.dbo.COMPANYAD_queryadwherereferenceIDin(‘JCNAD00329667’,’JCNAD132168’,’JCNAD00337748’,’JCNAD00338345’,’JCNAD00333138’,’JCNAD00303570’,’JCNAD00303569’,’JCNAD00303568’,’JCNAD00306698’,’JCNAD00231935’,’JCNAD00231933’,’JCNAD00254567’,’JCNAD00254585’,’JCNAD00254608’,’JCNAD00254607’,’JCNAD00258524’,’JCNAD00332133’,’JCNAD00268618’,’JCNAD00279196’,’JCNAD00268613’)orderbypostdatedesc<br>　　35、在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数<br>　　36、当用SELECTINTO时，它会锁住系统表(sysobjects，sysindexes等等)，阻塞其他的连接的存取。创建临时表时用显示申明语句，而不是selectINTO.droptablet_lxhbegintranselect<em>intot_lxhfromchineseresumewherename=’XYZ’–commit在另一个连接中SELECT</em>fromsysobjects可以看到SELECTINTO会锁住系统表，Createtable也会锁系统表(不管是临时表还是系统表)。所以千万不要在事物内使用它！！！这样的话如果是经常要用的临时表请使用实表，或者临时表变量。<br>　　37、一般在GROUPBY个HAVING字句之前就能剔除多余的行，所以尽量不要用它们来做剔除行的工作。他们的执行顺序应该如下最优：select的Where字句选择所有合适的行，GroupBy用来分组个统计行，Having字句用来剔除多余的分组。这样GroupBy个Having的开销小，查询快.对于大的数据行进行分组和Having十分消耗资源。如果GroupBY的目的不包括计算，只是分组，那么用Distinct更快<br>　　38、一次更新多条记录比分多次更新每次一条快,就是说批处理好<br>　　39、少用临时表，尽量用结果集和Table类性的变量来代替它,Table类型的变量比临时表好<br>　　40、在SQL2000下，计算字段是可以索引的，需要满足的条件如下：<br>　　　　a、计算字段的表达是确定的<br>　　　　b、不能用在TEXT,Ntext，Image数据类型<br>　　　　c、必须配制如下选项ANSI_NULLS=ON,ANSI_PADDINGS=ON,…….<br>　　41、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL,可以使用临时存储过程，该过程（临时表）被放在Tempdb中。以前由于SQLSERVER对复杂的数学计算不支持，所以不得不将这个工作放在其他的层上而增加网络的开销。SQL2000支持UDFs,现在支持复杂的数学计算，函数的返回值不要太大，这样的开销很大。用户自定义函数象光标一样执行的消耗大量的资源，如果返回大的结果采用存储过程<br>　　42、不要在一句话里再三的使用相同的函数，浪费资源,将结果放在变量里再调用更快<br>　　43、SELECTCOUNT(*)的效率教低，尽量变通他的写法，而EXISTS快.同时请注意区别：selectcount(Fieldofnull)fromTable和selectcount(FieldofNOTnull)fromTable的返回值是不同的。<br>　　44、当服务器的内存够多时，配制线程数量=最大连接数+5，这样能发挥最大的效率；否则使用配制线程数量&lt;最大连接数启用SQLSERVER的线程池来解决,如果还是数量=最大连接数+5，严重的损害服务器的性能。<br>　　45、按照一定的次序来访问你的表。如果你先锁住表A，再锁住表B，那么在所有的存储过程中都要按照这个顺序来锁定它们。如果你（不经意的）某个存储过程中先锁定表B，再锁定表A，这可能就会导致一个死锁。如果锁定顺序没有被预先详细的设计好，死锁很难被发现<br>　　46、通过SQLServerPerformanceMonitor监视相应硬件的负载Memory:PageFaults/sec计数器如果该值偶尔走高，表明当时有线程竞争内存。如果持续很高，则内存可能是瓶颈。Process:<br>　　　　1、%DPCTime指在范例间隔期间处理器用在缓延程序调用(DPC)接收和提供服务的百分比。(DPC正在运行的为比标准间隔优先权低的间隔)。由于DPC是以特权模式执行的，DPC时间的百分比为特权时间百分比的一部分。这些时间单独计算并且不属于间隔计算总数的一部分。这个总数显示了作为实例时间百分比的平均忙时。<br>　　　　2、%ProcessorTime计数器　如果该参数值持续超过95%，表明瓶颈是CPU。可以考虑增加一个处理器或换一个更快的处理器。<br>　　　　3、%PrivilegedTime指非闲置处理器时间用于特权模式的百分比。(特权模式是为操作系统组件和操纵硬件驱动程序而设计的一种处理模式。它允许直接访问硬件和所有内存。另一种模式为用户模式，它是一种为应用程序、环境分系统和整数分系统设计的一种有限处理模式。操作系统将应用程序线程转换成特权模式以访问操作系统服务)。特权时间的%包括为间断和DPC提供服务的时间。特权时间比率高可能是由于失败设备产生的大数量的间隔而引起的。这个计数器将平均忙时作为样本时间的一部分显示。<br>　　　　4、%UserTime表示耗费CPU的数据库操作，如排序，执行aggregatefunctions等。如果该值很高，可考虑增加索引，尽量使用简单的表联接，水平分割大表格等方法来降低该值。PhysicalDisk:CurretnDiskQueueLength计数器该值应不超过磁盘数的1.5~2倍。要提高性能，可增加磁盘。SQLServer:CacheHitRatio计数器该值越高越好。如果持续低于80%，应考虑增加内存。注意该参数值是从SQLServer启动后，就一直累加记数，所以运行经过一段时间后，该值将不能反映系统当前值。<br>　　47、分析selectemp_nameformemployeewheresalary&gt;3000在此语句中若salary是Float类型的，则优化器对其进行优化为Convert(float,3000)，因为3000是个整数，我们应在编程时使用3000.0而不要等运行时让DBMS进行转化。同样字符和整型数据的转换</p><p>转载于</p><p><a href="https://www.cnblogs.com/gaoxh/p/5230739.html">https://www.cnblogs.com/gaoxh/p/5230739.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript面向对象</title>
      <link href="2021/03/03/ziliao/javascript/javascript-mian-xiang-dui-xiang/"/>
      <url>2021/03/03/ziliao/javascript/javascript-mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript面向对象"><a href="#JavaScript面向对象" class="headerlink" title="JavaScript面向对象"></a>JavaScript面向对象</h2><h1 id="JavaScript面向对象-1"><a href="#JavaScript面向对象-1" class="headerlink" title="JavaScript面向对象"></a>JavaScript面向对象</h1><p>[<img src="https://upload.jianshu.io/users/upload_avatars/12323997/4baf502b-274d-4914-8cad-e410e6f402e3?imageMogr2/auto-orient/strip%7CimageView2/1/w/96/h/96" alt="img"><a href="https://www.jianshu.com/u/07b4cf0c78a1">https://www.jianshu.com/u/07b4cf0c78a1</a>)</p><p>收录于：<a href="https://www.jianshu.com/p/f9792fdd9915">https://www.jianshu.com/p/f9792fdd9915</a></p><h4 id="一、面向对象基本特征"><a href="#一、面向对象基本特征" class="headerlink" title="一、面向对象基本特征"></a>一、面向对象基本特征</h4><ol><li>封装：也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</li><li>继承：通过继承创建的新类称为“子类”或“派生类”。继承的过程，就是从一般到特殊的过程。</li><li>多态：对象的多功能，多方法，一个方法多种表现形式。</li><li>Javascript是一种基于对象（object-based）的语言。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）—–es6以前是这样的。所以es5只有使用函数模拟的面向对象。</li></ol><h4 id="二、对象实例化方式"><a href="#二、对象实例化方式" class="headerlink" title="二、对象实例化方式"></a>二、对象实例化方式</h4><ol><li>原始模式：这样的写法有两个缺点，一是如果多生成几个（100个！）实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出没有什么联系。</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> Car <span class="token operator">=</span> <span class="token punctuation">{</span>    color<span class="token punctuation">:</span> <span class="token string">'red'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//车的颜色</span>    wheel<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//车轮数量</span><span class="token punctuation">}</span><span class="token keyword">var</span> Car2 <span class="token operator">=</span> <span class="token punctuation">{</span>    color<span class="token punctuation">:</span> <span class="token string">'blue'</span><span class="token punctuation">,</span>    wheel<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token function">alert</span><span class="token punctuation">(</span>Car<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//red</span></code></pre><ol><li>原始模式的改进：通过写一个函数，解决代码重复的问题。</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createCar</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span>wheel<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        color<span class="token punctuation">:</span>color<span class="token punctuation">,</span>        wheel<span class="token punctuation">:</span>wheel    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//然后生成实例对象，就等于是在调用函数：</span><span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token function">createCar</span><span class="token punctuation">(</span><span class="token string">"红色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token function">createCar</span><span class="token punctuation">(</span><span class="token string">"蓝色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//红色</span></code></pre><ol><li>工厂模式</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createCar</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span>wheel<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//createCar工厂</span>    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//或obj = {} 原材料阶段</span>    obj<span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加工</span>    obj<span class="token punctuation">.</span>wheel <span class="token operator">=</span> wheel<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加工</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出产品</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//实例化</span><span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token function">createCar</span><span class="token punctuation">(</span><span class="token string">"红色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token function">createCar</span><span class="token punctuation">(</span><span class="token string">"蓝色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//红色</span></code></pre><ol><li>构造函数模式：为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。  所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。加<code>new</code>执行的函数构造内部变化：自动生成一个对象，this指向这个新创建的对象，函数自动返回这个新创建的对象</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">CreateCar</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span>wheel<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//构造函数首字母大写</span>    <span class="token comment" spellcheck="true">//不需要自己创建对象了</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加属性，this指向构造函数的实例对象</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>wheel <span class="token operator">=</span> wheel<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加属性</span>    <span class="token comment" spellcheck="true">//不需要自己return了</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//实例化</span><span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateCar</span><span class="token punctuation">(</span><span class="token string">"红色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateCar</span><span class="token punctuation">(</span><span class="token string">"蓝色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//红色</span></code></pre><h4 id="三、构造函数注意事项"><a href="#三、构造函数注意事项" class="headerlink" title="三、构造函数注意事项"></a>三、构造函数注意事项</h4><ol><li>此时CreateCar称之为构造函数，也可以称之类，构造函数就是类 。</li><li>cat1，cat2均为CreateCar的实例对象。</li><li>CreateCar构造函数中this指向CreateCar实例对象即 <code>new CreateCar( )</code>出来的对象。</li><li>必须带new 。</li><li>构造函数首字母大写，这是规范，官方都遵循这一个规范，如Number() Array()。</li><li>contructor：这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数,即CreateCar。</li></ol><pre class=" language-js"><code class="language-js"><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>constructor <span class="token operator">==</span> CreateCar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span><span class="token function">alert</span><span class="token punctuation">(</span>cat2<span class="token punctuation">.</span>constructor <span class="token operator">==</span> CreateCar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><ol><li>每定义一个函数，这个函数就有一个 prototype 的属性{}，<code>__proto__</code> 指向被实例化的构造函数的prototype，prototype默认带constructor属性，constructor指向构造函数。</li><li>instanceof 运算符：<code>object instanceof constructor</code>运算符，验证构造函数与实例对象之间的关系。</li></ol><pre class=" language-js"><code class="language-js"><span class="token function">alert</span><span class="token punctuation">(</span>cat1 <span class="token keyword">instanceof</span> <span class="token class-name">CreateCar</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span><span class="token function">alert</span><span class="token punctuation">(</span>cat2 <span class="token keyword">instanceof</span> <span class="token class-name">CreateCar</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><h4 id="四、构造函数的问题"><a href="#四、构造函数的问题" class="headerlink" title="四、构造函数的问题"></a>四、构造函数的问题</h4><p>构造函数方法很好用，但是存在一个浪费内存的问题。如果现在为其再添加一个方法<code>showWheel</code>。那么，CreateCar就变成了下面这样，这样做有一个很大的弊端，对于每一个实例对象，<code>showWheel</code>都是一模一样的内容，每一次生成一个实例，都必须生成重复的内容，多占用一些内存。这样既不环保，也缺乏效率。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">CreateCar</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span>wheel<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>wheel <span class="token operator">=</span> wheel<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>showWheel <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//添加一个新方法</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>wheel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//还是采用同样的方法，生成实例：</span><span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateCar</span><span class="token punctuation">(</span><span class="token string">"红色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateCar</span><span class="token punctuation">(</span><span class="token string">"蓝色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>showWheel <span class="token operator">==</span> cat2<span class="token punctuation">.</span>showWheel<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span></code></pre><h4 id="五、Prototype-原型"><a href="#五、Prototype-原型" class="headerlink" title="五、Prototype 原型"></a>五、Prototype 原型</h4><p>Javascript规定，每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。 这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。<code>__proto__</code>是原型链，指向实例化的函数原型。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">CreateCar</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span>wheel<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//属性写构造函数里面</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>wheel <span class="token operator">=</span> wheel<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//方法写原型里面</span>CreateCar<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>showWheel <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>wheel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>CreateCar<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>showName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'车'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//生成实例。</span><span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateCar</span><span class="token punctuation">(</span><span class="token string">"红色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateCar</span><span class="token punctuation">(</span><span class="token string">"蓝色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cat1<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//'车'</span><span class="token comment" spellcheck="true">//这时所有实例的showWheel属性和showName方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。</span><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>showWheel <span class="token operator">==</span> cat2<span class="token punctuation">.</span>showWheel <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>showName <span class="token operator">==</span> cat2<span class="token punctuation">.</span>showName <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> CreateCar<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><h4 id="六、对象和函数的关系"><a href="#六、对象和函数的关系" class="headerlink" title="六、对象和函数的关系"></a>六、对象和函数的关系</h4><p>对象是由函数构造出来的。</p><ol><li>Object是Function 的一个实例。</li></ol><pre class=" language-js"><code class="language-js">Object<span class="token punctuation">.</span>constructor  <span class="token operator">==</span> Function  <span class="token comment" spellcheck="true">//true</span></code></pre><ol><li>函数是Function 的实例，但不是Object 的实例。</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>fn<span class="token punctuation">.</span>constructor  <span class="token operator">==</span> Function  <span class="token comment" spellcheck="true">//true</span>fn<span class="token punctuation">.</span>constructor  <span class="token operator">==</span> Object    <span class="token comment" spellcheck="true">//false </span></code></pre><ol><li>{} 与 Object 的关系。</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>constructor  <span class="token operator">===</span> Object   <span class="token comment" spellcheck="true">//true</span></code></pre><h4 id="七、静态方法和静态属性"><a href="#七、静态方法和静态属性" class="headerlink" title="七、静态方法和静态属性"></a>七、静态方法和静态属性</h4><p>只属于类而不属于实例化对象</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>foo<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//静态属性</span>foo<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span>foo<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//实例化的新的对象，this指向这个新的对象，不能访问类的静态方法</span>fn<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Noname1.html:45 Uncaught TypeError: fn.say is not a function</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> fn<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="八、对象继承"><a href="#八、对象继承" class="headerlink" title="八、对象继承"></a>八、对象继承</h4><ol><li>利用<code>call()</code>及<code>for in</code>继承 。<br> 给对象的constructor.prototype添加方法属性，对象就会继承，如果要实现一个对象继承其他对象，采用如下方法。</li></ol><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//人类</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>run <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'跑路~'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'说话~'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//男人</span><span class="token keyword">function</span> <span class="token function">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">"男"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Man<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>Man<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>yyy <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'嘤嘤嘤'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//会发现Person的prototype也改变了，因为复杂对象的赋值操作是引用而不是赋值</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//人类</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>run <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'跑路~'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'说话~'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//男人</span><span class="token keyword">function</span> <span class="token function">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">"男"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">{</span>    Man<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">}</span>Man<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>yyy <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'嘤嘤嘤'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> xm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xm<span class="token punctuation">.</span><span class="token function">yyy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol><li>采用中介</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">ClassA</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>ClassA<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//中继来做准备工作</span><span class="token keyword">function</span> <span class="token function">Ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//</span>Ready<span class="token punctuation">.</span>prototype <span class="token operator">=</span> ClassA<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引用</span><span class="token comment" spellcheck="true">//需要来继承ClassA</span><span class="token keyword">function</span> <span class="token function">ClassB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>ClassB<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//new 返回了一个新对象 __proto__指向被实例化的构造函数的prototype</span>ClassB<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> ClassB<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ClassB<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol><li>采用中介，使用<code>call</code>改变this指向</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">ClassA</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>ClassA<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>showName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//中继来做准备工作</span><span class="token keyword">function</span> <span class="token function">Ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//</span>Ready<span class="token punctuation">.</span>prototype <span class="token operator">=</span> ClassA<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引用</span><span class="token comment" spellcheck="true">//需要来继承ClassA</span><span class="token keyword">function</span> <span class="token function">ClassB</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    ClassA<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ClassB<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//new 返回了一个新对象 __proto__指向被实例化的构造函数的prototype</span>ClassB<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> ClassB<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ClassB<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> xiaoming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassB</span><span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xiaoming<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="九、多态"><a href="#九、多态" class="headerlink" title="九、多态"></a>九、多态</h4><p>同一个方法,面对不同的对象有不同的表现形式就叫做多态。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    eat <span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>_type<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>_type <span class="token operator">==</span> <span class="token string">'猫'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'猫粮'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>_type <span class="token operator">==</span> <span class="token string">"狗"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'狗粮'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"吃饭"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token string">"狗"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="十、hasOwnProperty"><a href="#十、hasOwnProperty" class="headerlink" title="十、hasOwnProperty"></a>十、hasOwnProperty</h4><p>查看该属性是否在这个对象本身上，只有在自身属性上才会返回真，在原型链上会返回假。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>ClassA<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span></code></pre><h4 id="十一、描述符（修饰符）"><a href="#十一、描述符（修饰符）" class="headerlink" title="十一、描述符（修饰符）"></a>十一、描述符（修饰符）</h4><p>描述符是对一个属性的特性的描述，<code>defineProperty</code>设置描述符（修饰符），<code>value</code>设置属性值，<code>configurable</code>是否允许修饰符被改变 默认为false，<code>enumerable</code> 是否可以被枚举 默认为false，<code>writable</code> 是否可以被 = 等号改变 默认为false。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//value : 233,</span>    <span class="token comment" spellcheck="true">//enumerable : false,</span>    <span class="token comment" spellcheck="true">//writable : true,//他的值能否改变</span>                <span class="token comment" spellcheck="true">//设置的时候调用</span>    <span class="token keyword">set</span> <span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//n 就是等号的右边的值</span>        c <span class="token operator">=</span> c<span class="token operator">*</span>n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//获取的时候调用</span>    <span class="token keyword">get</span> <span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    configurable <span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//是否可以再次修改修饰符</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>因为会MySQL查询优化，领导给我升职了</title>
      <link href="2021/03/03/niuke/sql/mysql-suo-yin-xiang-guan-mian-shi-ti/"/>
      <url>2021/03/03/niuke/sql/mysql-suo-yin-xiang-guan-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="因为会MySQL查询优化，领导给我升职了"><a href="#因为会MySQL查询优化，领导给我升职了" class="headerlink" title="因为会MySQL查询优化，领导给我升职了"></a>因为会MySQL查询优化，领导给我升职了</h1><p>查询优化本就不是一蹴而就的，需要学会使用对应的工具、借鉴别人的经验来对 SQL 进行优化，并且提升自己</p><p>先来巩固一下索引的优点，检索数据快、查询稳定、存储具有顺序性避免服务器建立临时表、将随机的 I/O 变为有序的 I/O。</p><p>但索引一旦创建的不规范就会造成以下问题，占用额外空间，浪费内存，降低数据的增、删、改性能。</p><p>所以只有在理解索引数据结构的基础上才能创建出高效的索引。本文所有操作均在 MySQL 8.0.12。</p><h2 id="创建索引规范"><a href="#创建索引规范" class="headerlink" title="创建索引规范"></a>创建索引规范</h2><p>在学习索引优化之前，需要对创建索引的规范有一定的了解，此规范来自于阿里巴巴开发手册。</p><p><strong>主键索引：</strong>pk_column_column。</p><p><strong>唯一索引：</strong>uk_column_column。</p><p><strong>普通索引：</strong>idx_column_column。</p><h2 id="索引失效原因"><a href="#索引失效原因" class="headerlink" title="索引失效原因"></a>索引失效原因</h2><p>创建索引需知道在什么情况下索引会失效，只有了解索引失效的原因，在创建索引时才不会出现一些已知错误。</p><h3 id="带头大哥不能死"><a href="#带头大哥不能死" class="headerlink" title="带头大哥不能死"></a><strong>带头大哥不能死</strong></h3><p>这局经典的语句就是涵盖创建索引时一定要符合最左侧原则。</p><p>例如表结构为 u_id，u_name，u_age，u_sex，u_phone，u_time，创建索引为 idx_user_name_age_sex。</p><p>查询条件必须带上 u_name 这一列。</p><h3 id="不在索引列上做任何操作"><a href="#不在索引列上做任何操作" class="headerlink" title="不在索引列上做任何操作"></a><strong>不在索引列上做任何操作</strong></h3><p>不在索引列上做任何计算、函数、自动或者手动的类型转换，否则会进行全表扫描。简而言之不要在索引列上做任何操作。</p><h3 id="俩边类型不等"><a href="#俩边类型不等" class="headerlink" title="俩边类型不等"></a><strong>俩边类型不等</strong></h3><p>例如建立了索引 idx_user_name，name 字段类型为 varchar。在查询时使用 where name = kaka，这样的查询方式会直接造成索引失效。</p><p>正确的用法为 where name = “kaka”。</p><h3 id="不适当的-like-查询会导致索引失效"><a href="#不适当的-like-查询会导致索引失效" class="headerlink" title="不适当的 like 查询会导致索引失效"></a><strong>不适当的 like 查询会导致索引失效</strong></h3><p>创建索引为 idx_user_name，执行语句为 select * from user where name like “kaka%”；可以命中索引。</p><p>执行语句为 select name from user where name like “%kaka”；可以使用到索引（仅在 8.0 以上版本）。</p><p>执行语句为 select * from user where name like ‘’%kaka”；会直接导致索引失效。</p><h3 id="范围条件之后的索引会失效"><a href="#范围条件之后的索引会失效" class="headerlink" title="范围条件之后的索引会失效"></a><strong>范围条件之后的索引会失效</strong></h3><p>创建索引为：idx_user_name_age_sex</p><p>执行语句</p><p>select * from user where name = ‘kaka’ and age &gt; 11 and sex = 1;</p><p>上面这条 SQL 语句只会命中 name 和 age 索引，sex 索引会失效。复合索引失效需要查看 key_len 的长度即可。</p><p>总结：% 在后边会命令索引，当使用了覆盖索引时任何查询方式都可命中索引。</p><p>以上就是我关于索引失效会出现的原因总结，在很多文章中没有标注 MySQL 版本，所以你有可能会看到 is null 、or 索引会失效的结论。</p><h2 id="SQL-优化杀手锏之-Explain"><a href="#SQL-优化杀手锏之-Explain" class="headerlink" title="SQL 优化杀手锏之 Explain"></a>SQL 优化杀手锏之 Explain</h2><p>在写完 SQL 语句之后必须要做的一件事情就是使用 Explain 进行 SQL 语句检测，看是否命中索引。</p><p><img src="../../../../../../images/image-20210303225229769.png" alt="image-20210303225229769"></p><p>上图就是使用 Explain 输出格式，接下来将会对输出格式进行简单的解释：</p><p><strong>①id：</strong>这列就是查询的编号，如果查询语句中没有子查询或者联合查询这个标识就一直是 1。如存在子查询或者联合查询这个编号会自增。</p><p><strong>②select_type：</strong>最常见的类型就是 SIMPLE 和 PRIMARY，此列知道就行了。**<br>**</p><p><strong>③table：</strong>理解为表名即可。**<br>**</p><p><strong>④\</strong>type：**此列是在优化 SQL 语句时最需要关注的列之一，此列显示了查询使用了何种类型。</p><p>以下排序从最优到最差：</p><ul><li><strong>system：</strong>表内只有一行数据。</li><li><strong>const：</strong>最多只会有一条记录匹配，常用于主键或者唯一索引为条件查询。</li><li><strong>eq_ref：</strong>当连接使用的索引为主键和唯一时会出现。</li><li><strong>ref：</strong>使用普通索引 = 或 &lt;=&gt; 运算符进行比较将会出现。</li><li><strong>fulltext：</strong>使用全文索引。</li><li><strong>ref_or_null：</strong>跟 ref 类型类似，只是增加了 null 值的判断，实际用的不多。语句为 where name = ‘kaka’ and name is null，name 为普通索引。</li><li><strong>index_merge：</strong>查询语句使用了俩个以上的索引，常见在使用 and、or 会出现，官方文档将此类型放在 ref_or_null 之后，但是在很多的情况下由于读取索引过多性能有可能还不如 range。</li><li><strong>unique_subquery：</strong>用于 where 中的 in 查询，完全替换子查询，效率更高。语句为 value IN (SELECT primary_key FROM single_table WHERE some_expr)</li><li><strong>index_subquery：</strong>子查询中的返回结果字段组合是一个索引（或索引组合），但不是一个主键或唯一索引。</li><li><strong>range：</strong>索引范围查询，常见于使用 =，&lt;&gt;，&gt;，&gt;=，&lt;，&lt;=，IS NULL，&lt;=&gt;，BETWEEN，IN() 或者 like 等运算符的查询中。</li><li><strong>index：</strong>索引全表扫描，把索引从头到尾扫一遍。</li><li><strong>all：</strong>全表扫描，性能最差。</li></ul><p><strong>⑤possible_keys：</strong>此列显示的可能会使用到的索引。</p><p><strong>⑥\</strong>key：**优化器从 possible_keys 中命中的索引。</p><p><strong>⑦key_len：</strong>查询用到的索引长度（字节数），key_len 只计算 where 条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到 key_len 中。</p><p><strong>⑧ref：</strong>如果是使用的常数等值查询，这里会显示 const。</p><p>如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段。如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为 func。</p><p><strong>⑨\</strong>rows：**这是 MySQL 估算的需要扫描的行数（不是精确值）。这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。</p><p><strong>⑩filtered：</strong>此列表示存储引擎返回的数据在 server 层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。</p><p><strong>⑪\</strong>extra：**在大多数情况下会出现以下几种情况。</p><ul><li>Using index：使用了覆盖索引，查询列都为索引字段。</li><li>Using where：使用了 where 语句。</li><li>Using temporary：查询结果进行排序的时候使用了一张临时表。</li><li>Using filesort：对数据使用一个外部的索引排序。</li><li>Using index condition：使用了索引下推。</li></ul><p>关于索引下推可以查看我之前的一篇文章《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&mid=2655842725&idx=1&sn=2c207731cb368e3d055671632172114d&chksm=bd74bc728a03356417750e561e790add150c2575306da987b274b92ad8609f4e92661b018dc2&scene=21#wechat_redirect">MySQL 索引</a>》。</p><p><strong>总结：</strong>以上就是关于 Explain 所有列的说明，在平时开发的过程中，一般只会关注 type、key、rows、extra 这四列。</p><p>type 优化目标至少达到 range 级别，要求是 ref 级别，如果可以 consts 最好。key 是查询使用到的索引，如果此列为空，要么未建立索引，要么索引失效。</p><p>rows 是这条 SQL 语句扫描的行数，越少越好。extra：此列为扩展列，如果出现临时表、文件排序则需要优化。</p><h2 id="SQL-优化杀手锏之慢查询"><a href="#SQL-优化杀手锏之慢查询" class="headerlink" title="SQL 优化杀手锏之慢查询"></a>SQL 优化杀手锏之慢查询</h2><p>上文说到了可以直接使用 Explain 来分析自己的 SQL 语句是否合理，接下来再聊一个点那就是慢查询。</p><p>查看慢查询是否打开：</p><p><img src="../../../../../../images/image-20210303225349781.png" alt="image-20210303225349781"></p><p>查看是否记录没有使用索引的 SQL 语句：</p><p><img src="../../../../../../images/image-20210303225400938.png" alt="image-20210303225400938"></p><p>开启慢查询、开启记录没有使用到索引的 SQL 语句</p><p>set global log_queries_not_using_idnexes=‘on’;<br>set global log_queries_not_using_indexes=‘on’;</p><p><img src="../../../../../../images/image-20210303225419735.png" alt="image-20210303225419735"></p><p>查询以上俩个配置是否打开：</p><p><img src="../../../../../../images/image-20210303225431247.png" alt="image-20210303225431247"></p><p>设置慢查询时间，这个时间由自己把控，一般 1s 即可：</p><p>set globle long_query_time=1;</p><p>如果查看这个时间没有变，则关于客户端在重新连接一次即可。</p><p><img src="../../../../../../images/image-20210303225458539.png" alt="image-20210303225458539"></p><p>查看慢查询存储位置：</p><p><img src="../../../../../../images/image-20210303225515519.png" alt="image-20210303225515519"></p><p>然后随便执行一条不执行索引的语句即可在这个日志中查看到此语句：</p><p><img src="../../../../../../images/image-20210303225531585.png" alt="image-20210303225531585"></p><p>上图中一般需要主要观察的是 Query_time、SQL 语句内容。以上就是关于如何使用慢查询来查看项目中出现问题的 SQL 语句。</p><h2 id="优化大法"><a href="#优化大法" class="headerlink" title="优化大法"></a>优化大法</h2><p>此处跟大家聊一些常用的 SQL 语句优化方案，以上的俩个工具要好好的利用，辅助我们进行打怪：</p><p><strong>①</strong>禁止使用 select *，需要什么字段查询什么字段。</p><p><strong>②</strong>where 字段设置索引。</p><p><strong>③</strong>group by、order by 字段设置索引。</p><p><strong>④</strong>舍弃 offset，limit 分页，使用延迟关联来实现分页（数据量不大时可不用）。</p><p><strong>⑤</strong>写分页时当 count 为 0 时，直接返回避免执行分页语句。</p><p><strong>⑥</strong>利用覆盖索引进行查询避免回表。</p><p><strong>⑦</strong>建立复合索引时区分度最高的放在最左侧。</p><p><strong>⑧</strong>统计数据行数只用 count(*)，别整的花里胡哨的。</p><p><strong>⑨</strong>关于 in 和 exist，如果查询的俩个表大小一致则性能差别可忽略，如果子查询表大用 exist，否则使用 in。</p><p><strong>⑩</strong>查询一行数据时加上 limit 1。</p><p><strong>⑪</strong>选择合理的数据类型，在满足条件下数据类型越小越好。</p><p><strong>⑫</strong>联合查询 join 最多三个表，并且需要 join 的字段数据类型保持一致。</p><p><strong>⑬</strong>in 操作能避免尽量避免，无法避免的情况下 in 元素控制在 1000 以内。</p><p><strong>⑭</strong>数据更新频繁，区分度不高的列不适合建立索引。</p><p><strong>⑮</strong>explain 中的 type 至少要达到 range，要求为 ref。</p><p><strong>⑯</strong>联合索引满足最左侧原则。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL查询优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网华为机试02</title>
      <link href="2021/03/03/niuke/suanfa/huaweijs-01/"/>
      <url>2021/03/03/niuke/suanfa/huaweijs-01/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客网华为机试在线训练JavaScript-V8-版02"><a href="#牛客网华为机试在线训练JavaScript-V8-版02" class="headerlink" title="牛客网华为机试在线训练JavaScript(V8)版02"></a>牛客网华为机试在线训练JavaScript(V8)版02</h1><h2 id="HJ3-易-明明的随机数-数组，排序，去重"><a href="#HJ3-易-明明的随机数-数组，排序，去重" class="headerlink" title="HJ3.[易]明明的随机数 [数组，排序，去重]"></a>HJ3.[易]明明的随机数 [数组，排序，去重]</h2><p><strong>题目描述</strong></p><p>   明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理)。  </p><p>  注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 </p><p>  当没有新的输入时，说明输入结束。 </p><p>输入描述:</p><pre><code>注意：输入可能有多组数据(用于不同的调查)。每组数据都包括多行，第一行先输入随机整数的个数N，接下来的N行再输入相应个数的整数。具体格式请看下面的&quot;示例&quot;。</code></pre><p>输出描述:</p><pre><code>返回多行，处理后的结果</code></pre><p>输入</p><pre><code>322111102040326740208930040015</code></pre><p>输出</p><pre><code>1210152032406789300400</code></pre><p>说明</p><pre><code>样例输入解释：样例有两组测试第一组是3个数字，分别是：2，2，1。第二组是11个数字，分别是：10，20，40，32，67，40，20，89，300，400，15。  </code></pre><p>自己首次解析</p><pre><code>while( line = readline())&#123;    //保存原始数据    var arr=[];    for(var i=0;i&lt; line;i++)&#123;        arr.push( readline());            &#125;    //利用set特性去重    var tSet=[...new Set(arr)];    //排序方法    var setSort=tSet.sort(function(a,b)&#123;        return a-b;    &#125;)    //结果输出    for(var j=0;j&lt;setSort.length;j++)&#123;        console.log(setSort[j]);    &#125;&#125;</code></pre><p><strong>查看其他解法</strong>：总体利用一个数组，很好的利用数组下标排序的</p><pre><code>while(num = parseInt(readline()))&#123;    //利用数组下标的特性，存入数据表示有此数值    let arr =[];    for(let i = 0;i&lt;num;i++)&#123;        let temp = parseInt(readline());           arr[temp] = 1;    &#125;    //遍历数组，如果有标记，则输出下标    arr.forEach((val,index)=&gt;&#123;        if(val===1)&#123;            console.log(index)        &#125;    &#125;)&#125;</code></pre><pre><code>while(num = readline())&#123;    //利用对象的属性    const obj = &#123;&#125;;    while(num--)&#123;       const number = readline();       if(!obj[number])&#123;           obj[number]=1;       &#125;    &#125;    for(let result in obj)&#123;        console.log(result)    &#125; &#125;</code></pre><p>题目描述</p><p>  •连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；<br> •长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。  </p><p>输入描述:</p><pre><code>连续输入字符串(输入多次,每个字符串长度小于100)</code></pre><p>输出描述:</p><pre><code>输出到长度为8的新字符串数组</code></pre><p>输入</p><pre><code>abc123456789</code></pre><p>输出</p><pre><code>abc000001234567890000000</code></pre><h2 id="HJ4-易"><a href="#HJ4-易" class="headerlink" title="HJ4.[易]"></a>HJ4.[易]</h2><p>  编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次 </p><p>  例如，对于字符串abaca而言，有a、b、c三种不同的字符，因此输出3。 </p><p>输入描述:</p><pre><code>输入一行没有空格的字符串。</code></pre><p>输出描述:</p><pre><code>输出范围在(0~127)字符的个数。</code></pre><p>输入</p><pre><code>abc</code></pre><p>输出</p><pre><code>3</code></pre><p>解析：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">while</span> <span class="token punctuation">(</span>line <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>line<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        s1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>line<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">Array</span><span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="2-易"><a href="#2-易" class="headerlink" title="2.(易)"></a>2.(易)</h1><p>题目描述</p><p>给定n个字符串，请对n个字符串按照字典序排列。</p><p>输入描述:</p><pre><code>输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。</code></pre><p>输出描述:</p><pre><code>数据输出n行，输出结果为按照字典序排列的字符串。</code></pre><p>输入</p><pre><code>9captocatcardtwotooupboatboot</code></pre><p>输出</p><pre><code>boatbootcapcardcattotootwoup</code></pre><p>解答：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span> <span class="token punctuation">(</span>line <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">var</span> list <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   list <span class="token operator">=</span>list<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>自己解析</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> arr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>line<span class="token operator">=</span><span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> strLength <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//取整取完整的行数</span>    <span class="token keyword">var</span> N <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>strLength<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> mLast <span class="token operator">=</span> strLength<span class="token operator">%</span><span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//最后需要补充的数目</span>    <span class="token keyword">var</span> addnum <span class="token operator">=</span><span class="token number">8</span><span class="token operator">-</span>mLast<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出整行的数据</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//输出补充的数据</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>mLast<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> sstr<span class="token operator">=</span><span class="token string">'0'</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>addnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           sstr<span class="token operator">+</span><span class="token operator">=</span><span class="token string">'0'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> firstr <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">,</span>strLength<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">print</span><span class="token punctuation">(</span> firstr <span class="token operator">+</span> sstr<span class="token punctuation">)</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//N整次的</span><span class="token punctuation">}</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span><span class="token punctuation">(</span>line <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> line<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ans <span class="token operator">=</span> ans <span class="token operator">+</span> line<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">''</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span>length <span class="token operator">>=</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>               <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">8</span> <span class="token operator">&amp;&amp;</span> ans<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> ans <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'0'</span>        <span class="token function">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token punctuation">}</span></code></pre><p>最佳：先加8位0，然后只取前面整除的部分</p><pre><code>while(str=readline())&#123;    str +=&#39;0000000&#39;    const length = Math.floor(str.length/8)    for(i=0;i&lt;length;i++)&#123;        console.log(str.substr(i*8,8))    &#125;&#125;</code></pre><h2 id="3-易"><a href="#3-易" class="headerlink" title="3:(易)"></a>3:(易)</h2><p>  输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。 </p><p>输入描述:</p><pre><code> 输入一个整数（int类型）</code></pre><p>输出描述:</p><pre><code> 这个数转换成2进制后，输出1的个数</code></pre><p>输入</p><pre><code>5</code></pre><p>输出</p><pre><code>2</code></pre><p>解析：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span> <span class="token punctuation">(</span>line <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> count <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>b<span class="token punctuation">.</span>length <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            count <span class="token operator">=</span>count <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">print</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="4（难）"><a href="#4（难）" class="headerlink" title="4（难）"></a>4（难）</h2><p>题目描述</p><p>王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><table><thead><tr><th>主件</th><th>附件</th></tr></thead><tbody><tr><td>电脑</td><td>打印机，扫描仪</td></tr><tr><td>书柜</td><td>图书</td></tr><tr><td>书桌</td><td>台灯，文具</td></tr><tr><td>工作椅</td><td>无</td></tr></tbody></table><p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等：用整数 1 <strong>~</strong> 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。</p><p>  设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品，编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为：</p><p>v[j 1 ]*w[j 1 ]+v[j 2 ]*w[j 2 ]+ … +v[j k ]*w[j k ] 。（其中 * 为乘号）</p><p>  请你帮助王强设计一个满足要求的购物单。</p><p>输入描述:</p><pre><code>输入的第 1 行，为两个正整数，用一个空格隔开：N m（其中 N （ &lt;32000 ）表示总钱数， m （ &lt;60 ）为希望购买物品的个数。）从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q（其中 v 表示该物品的价格（ v&lt;10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q&gt;0 ，表示该物品为附件， q 是所属主件的编号） </code></pre><p>输出描述:</p><pre><code> 输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ &lt;200000 ）。</code></pre><p>输入</p><pre><code>1000 5800 2 0400 5 1300 5 1400 3 0500 2 0</code></pre><p>输出</p><pre><code>2200</code></pre><p>初步解题思路：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//输入</span><span class="token comment" spellcheck="true">//总金额   物品个数</span><span class="token comment" spellcheck="true">//价格  重要度  0主件/q附件 主件编号</span><span class="token comment" spellcheck="true">//输出 max（价格* 重要程度）&lt;总金额</span><span class="token comment" spellcheck="true">//解题思路：</span><span class="token comment" spellcheck="true">//接受输入 总金额money   物品个数 num</span><span class="token comment" spellcheck="true">//循环接受多行输入  价格price  重要度inport   0主件/q附件 主件编号 q</span><span class="token keyword">while</span> <span class="token punctuation">(</span>line <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> lines <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> money <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>lines<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>lines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> zjlist <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">let</span> lineitem <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">let</span> price <span class="token operator">=</span><span class="token function">parseInt</span><span class="token punctuation">(</span>lineitem<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">let</span> inport <span class="token operator">=</span><span class="token function">parseInt</span><span class="token punctuation">(</span>lineitem<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">let</span> fj <span class="token operator">=</span><span class="token function">parseInt</span><span class="token punctuation">(</span>lineitem<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>fj<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">var</span> item <span class="token operator">=</span> zjlist<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token operator">></span>x<span class="token punctuation">.</span>ID<span class="token operator">==</span>fj<span class="token punctuation">)</span><span class="token punctuation">;</span>          zjlist<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">.</span>allimpt <span class="token operator">+</span><span class="token operator">=</span> inport；          zjlist<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">.</span>alln <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>；          zjlist<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">.</span>price <span class="token operator">+</span><span class="token operator">=</span> price；                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>          <span class="token keyword">var</span> zj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateFoo</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>price<span class="token punctuation">,</span>inport<span class="token punctuation">)</span><span class="token punctuation">;</span>          zjlist<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>zj<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//定义一个主件列表  加入主件</span><span class="token comment" spellcheck="true">//对象  ID  ，价格price  ，重要度 inport，总重要度allimpt，总数量 n</span><span class="token comment" spellcheck="true">//下一个是附件时，添加到主件信息 ，价格累计，重要度累计（价格乘以重要度）</span><span class="token keyword">function</span> <span class="token function">CreateFoo</span><span class="token punctuation">(</span>ID<span class="token punctuation">,</span>price<span class="token punctuation">,</span>inport<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//构造函数首字母大写</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>ID <span class="token operator">=</span> ID<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>goal <span class="token operator">=</span> price<span class="token operator">*</span>inport<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>allimpt <span class="token operator">=</span> inport<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>alln <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 计算最大总和</span><span class="token comment" spellcheck="true">// 物品总数量k[i] 主件数量n[i]*k[i]的和&lt;=num</span><span class="token comment" spellcheck="true">// 物品总价格v[i] 主件总价格 n[i]*v[i] 的和&lt;=money</span><span class="token keyword">function</span> <span class="token function">SumMaxImp</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//求最大重要度  allimpt[i]*n[i] 最大</span><span class="token comment" spellcheck="true">//求值思路   总重要度/总数量  重要比 优先给重要比大的物件购买数量 </span><span class="token comment" spellcheck="true">//  例如  总金额处理 金额  最大数如果小于总数量限制，则设定最大值，如果大于最大值，则取最大数量限制数</span><span class="token comment" spellcheck="true">//  剩余金额迭代</span><span class="token comment" spellcheck="true">//</span></code></pre><p>参考解析：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span> <span class="token punctuation">(</span>str1 <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> arr <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//总钱数</span>    <span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//希望购买物品的件数</span>    <span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> goods <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第j行数据表示编号j-1的物品的基本数据 价格 重要度 主附件（0 主件 >0 附件值为其所属主件的编号）</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token operator">&lt;=</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> item <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>val <span class="token operator">=</span><span class="token operator">></span> <span class="token function">parseInt</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 是主件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            goods<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>v<span class="token punctuation">:</span>item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">,</span> w<span class="token punctuation">:</span>item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">10</span><span class="token operator">*</span>item<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 是附件， 同时必须购买相应的主件</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> add <span class="token operator">=</span> goods<span class="token punctuation">[</span>item<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>val <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token punctuation">{</span>                    v<span class="token punctuation">:</span> item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">10</span> <span class="token operator">+</span> val<span class="token punctuation">.</span>v<span class="token punctuation">,</span>                    w<span class="token punctuation">:</span> item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">10</span><span class="token operator">*</span>item<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span>val<span class="token punctuation">.</span>w                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            goods<span class="token punctuation">[</span>item<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>goods<span class="token punctuation">[</span>item<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">...</span>add<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">choose</span><span class="token punctuation">(</span>goods<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">choose</span><span class="token punctuation">(</span>goods<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>goods<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>val <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>val<span class="token punctuation">.</span>v <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 买权重较高的物品</span>                        res<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span>j<span class="token operator">-</span>val<span class="token punctuation">.</span>v<span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">.</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="5（中）"><a href="#5（中）" class="headerlink" title="5（中）"></a>5（中）</h2><p>题目描述</p><p>  开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。 </p><p>  输入： </p><p>  合法坐标为A(或者D或者W或者S) + 数字（两位以内） </p><p>  坐标之间以;分隔。 </p><p>  非法坐标点需要进行丢弃。如AA10; A1A; $%$; YAD; 等。 </p><p>  下面是一个简单的例子 如： </p><p>  A10;S20;W10;D30;X;A1A;B10A11;;A10; </p><p>  处理过程： </p><p>  起点（0,0） </p><p>  +  A10  = （-10,0） </p><p>  +  S20  = (-10,-20) </p><p>  +  W10 = (-10,-10) </p><p>  +  D30 = (20,-10) </p><p>  +  x  = 无效 </p><p>  +  A1A  = 无效 </p><p>  +  B10A11  = 无效 </p><p>  + 一个空 不影响 </p><p>  +  A10 = (10,-10) </p><p>  结果 （10， -10） </p><p>  <strong>注意请处理多组输入输出</strong>  </p><p>输入描述:</p><pre><code>一行字符串</code></pre><p>输出描述:</p><pre><code>最终坐标，以逗号分隔</code></pre><p>输入</p><pre><code>A10;S20;W10;D30;X;A1A;B10A11;;A10;</code></pre><p>输出</p><pre><code>10,-10</code></pre><p>解答 注意parseInt 和Number的区别，isNaN</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span> <span class="token punctuation">(</span>line <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> lines <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> pos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>lines<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">des</span><span class="token punctuation">(</span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">print</span><span class="token punctuation">(</span> pos<span class="token punctuation">.</span><span class="token function">toShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>toShow <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//添加一个新方法</span>       <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span><span class="token string">','</span> <span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">des</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> pos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>str <span class="token operator">||</span> str<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> fangx <span class="token operator">=</span> str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> bushu <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>bushu<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>fangx<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token string">'A'</span><span class="token punctuation">:</span>            pos<span class="token punctuation">.</span>x <span class="token operator">-</span><span class="token operator">=</span> bushu<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'D'</span><span class="token punctuation">:</span>            pos<span class="token punctuation">.</span>x <span class="token operator">+</span><span class="token operator">=</span> bushu<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'W'</span><span class="token punctuation">:</span>            pos<span class="token punctuation">.</span>y <span class="token operator">+</span><span class="token operator">=</span> bushu<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'S'</span><span class="token punctuation">:</span>            pos<span class="token punctuation">.</span>y <span class="token operator">-</span><span class="token operator">=</span> bushu<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其他参考</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> rl <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'readline'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createInterface</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdin<span class="token punctuation">,</span> process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> index<span class="token punctuation">;</span><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> xvalue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> importance <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> m<span class="token punctuation">;</span><span class="token keyword">var</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span><span class="token keyword">var</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>rl<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'line'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token punctuation">{</span>    x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> tokens <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">";"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/^[WASD]\d{1,2}$/</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> nopro <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tokens<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> nopro<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nopro<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nopro<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'A'</span><span class="token punctuation">)</span> x <span class="token operator">-</span><span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>nopro<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nopro<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'D'</span><span class="token punctuation">)</span> x <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>nopro<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nopro<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'S'</span><span class="token punctuation">)</span> y <span class="token operator">-</span><span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>nopro<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nopro<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'W'</span><span class="token punctuation">)</span> y <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>nopro<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>6.识别有效的IP和掩码</p><p><strong>题目描述</strong></p><p>  请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。 </p><p>  所有的IP地址划分为 A,B,C,D,E五类 </p><p>  A类地址1.0.0.0~126.255.255.255; </p><p>  B类地址128.0.0.0~191.255.255.255; </p><p>  C类地址192.0.0.0~223.255.255.255; </p><p>  D类地址224.0.0.0~239.255.255.255； </p><p>  E类地址240.0.0.0~255.255.255.255 </p><p>  私网IP范围是： </p><p>  10.0.0.0～10.255.255.255 </p><p>  172.16.0.0～172.31.255.255 </p><p>  192.168.0.0～192.168.255.255 </p><p>  子网掩码为二进制下前面是连续的1，然后全是0。（例如：255.255.255.32就是一个非法的掩码） </p><p>  注意二进制下全是1或者全是0均为非法 </p><p>  注意： </p><ol><li><p>类似于【0.<em>.</em>.<em>】和【127.</em>.*.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址，计数时可以忽略 </p></li><li><p>私有IP地址和A,B,C,D,E类地址是不冲突的</p></li></ol><p><strong>输入描述:</strong></p><pre><code>多行字符串。每行一个IP地址和掩码，用~隔开。</code></pre><p><strong>输出描述:</strong></p><pre><code>统计A、B、C、D、E、错误IP地址或错误掩码、私有IP的个数，之间以空格隔开。</code></pre><p><strong>输入</strong></p><pre><code>10.70.44.68~255.254.255.01.0.0.1~255.0.0.0192.168.0.2~255.255.255.019..0.~255.255.255.0</code></pre><p><strong>输出</strong></p><pre><code>1 0 1 0 0 2 1</code></pre><p><strong>解答：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> A <span class="token operator">=</span> B <span class="token operator">=</span> C <span class="token operator">=</span> D <span class="token operator">=</span> E <span class="token operator">=</span> EIP  <span class="token operator">=</span> SIP <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>line <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> lines <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'~'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> ip <span class="token operator">=</span> lines<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> yanma <span class="token operator">=</span> lines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">deal</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span>yanma<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span> A<span class="token operator">+</span><span class="token string">' '</span><span class="token operator">+</span> B <span class="token operator">+</span><span class="token string">' '</span><span class="token operator">+</span> C <span class="token operator">+</span><span class="token string">' '</span><span class="token operator">+</span>D<span class="token operator">+</span><span class="token string">' '</span><span class="token operator">+</span>E<span class="token operator">+</span><span class="token string">' '</span><span class="token operator">+</span>EIP<span class="token operator">+</span><span class="token string">' '</span><span class="token operator">+</span> SIP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">deal</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> yanma<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> ipArr <span class="token operator">=</span> ip<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> yanmaArr <span class="token operator">=</span> yanma<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> ma2 <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> ele <span class="token keyword">in</span> yanmaArr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        yanmaArr<span class="token punctuation">[</span>ele<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>yanmaArr<span class="token punctuation">[</span>ele<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>yanmaArr<span class="token punctuation">[</span>ele<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">-</span> yanmaArr<span class="token punctuation">[</span>ele<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                yanmaArr<span class="token punctuation">[</span>ele<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span> <span class="token operator">+</span> yanmaArr<span class="token punctuation">[</span>ele<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        ma2 <span class="token operator">+</span><span class="token operator">=</span> yanmaArr<span class="token punctuation">[</span>ele<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//题意的理解 掩码和ip都正确，再判断ip的属性</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isYanma</span><span class="token punctuation">(</span>ma2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEip</span><span class="token punctuation">(</span>ipArr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">disip</span><span class="token punctuation">(</span>ipArr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            EIP<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        EIP<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//关键点在于二进制掩码的理解</span><span class="token keyword">function</span> <span class="token function">isYanma</span><span class="token punctuation">(</span>ma2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">(</span>ma2<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> ma2<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>ma2<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>ma2<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">isEip</span><span class="token punctuation">(</span>ipArr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> err <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> numlines <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ipArr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">===</span> <span class="token string">""</span> <span class="token operator">||</span> <span class="token function">isNaN</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">||</span> num <span class="token operator">></span> <span class="token number">255</span> <span class="token operator">||</span> num <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            err <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            numlines<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">!</span>err<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">disip</span><span class="token punctuation">(</span>ipstr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> numlines <span class="token operator">=</span> ipstr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token function">Number</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> firstN <span class="token operator">=</span> numlines<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstN <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> firstN <span class="token operator">&lt;</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        A<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstN <span class="token operator">></span> <span class="token number">127</span> <span class="token operator">&amp;&amp;</span> firstN <span class="token operator">&lt;</span> <span class="token number">192</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        B<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstN <span class="token operator">></span> <span class="token number">191</span> <span class="token operator">&amp;&amp;</span> firstN <span class="token operator">&lt;</span> <span class="token number">224</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        C<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstN <span class="token operator">></span> <span class="token number">223</span> <span class="token operator">&amp;&amp;</span> firstN <span class="token operator">&lt;</span> <span class="token number">240</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        D<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstN <span class="token operator">>=</span> <span class="token number">240</span> <span class="token operator">&amp;&amp;</span> firstN <span class="token operator">&lt;=</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        E<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstN <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">)</span> SIP<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstN <span class="token operator">==</span> <span class="token number">172</span> <span class="token operator">&amp;&amp;</span> numlines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">15</span> <span class="token operator">&amp;&amp;</span> numlines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">)</span> SIP<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstN <span class="token operator">==</span> <span class="token number">192</span> <span class="token operator">&amp;&amp;</span> numlines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">168</span><span class="token punctuation">)</span> SIP<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 牛客网华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引相关面试题</title>
      <link href="2021/03/03/niuke/sql/mysql-cha-xun-you-hua/"/>
      <url>2021/03/03/niuke/sql/mysql-cha-xun-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL索引相关面试题"><a href="#MySQL索引相关面试题" class="headerlink" title="MySQL索引相关面试题"></a>MySQL索引相关面试题</h1><p><strong><em>\</em>-   来源于网络资料   -**</strong></p><p>索引底层数据结构B+构详解<br>说下索引底层数据结构<br>什么是聚集索引<br>InnoDB表为什么必须有主键<br>InnoDB表主键为什么推荐使用自增的整型<br>如何建立高性能索引<br>面试关于索引都问些什么</p><p>正确的创建合适的索引是数据库优化的基础</p><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的数据结构</p><p>在RDBMS系统中数据的索引都是硬盘级索引</p><p>全表扫描：复杂度O(n)<br>数组扫描：复杂度O(1)<br>hash索引优劣势是什么？<br>查询快；hash冲突<br>不支持范围查询</p><p><img src="../../../../../../images/image-20210303091212732.png" alt="image-20210303091212732"></p><p><img src="../../../../../../images/image-20210303091224483.png" alt="image-20210303091224483"></p><p><img src="../../../../../../images/image-20210303091234197.png" alt="image-20210303091234197"></p><p><img src="../../../../../../images/image-20210303091244722.png" alt="image-20210303091244722"></p><p><img src="../../../../../../images/image-20210303101216332.png" alt="image-20210303101216332"></p><p><img src="../../../../../../images/image-20210303101224311.png" alt="image-20210303101224311"></p><p><img src="../../../../../../images/image-20210303101239974.png" alt="image-20210303101239974"></p><p>为什么mysql页文件默认16K?<br>假如我们一行数据大小为1k，那么一页就能存16条数据，也就是一个叶子节点能存16条数据；<br>再看非叶节子节点，假设主键ID为bigint类型，那么长度为8B，指针大小在Innodb源码中为6B，<br>一共就是14B，那么一页里就可以存储16K/14=1170个（主键+指针）</p><p>那么一颗高度为2的B+树能存储的数据为：1170*16=18720条，一颗高度为3的B+树能存储的数据为1170 * 1170 * 16 = 2190240（千万级条）</p><p><img src="../../../../../../images/image-20210303101303012.png" alt="image-20210303101303012"></p><p><img src="../../../../../../images/image-20210303101312106.png" alt="image-20210303101312106"></p><p>其他参考：<a href="https://mp.weixin.qq.com/s/TZvHp-lFON8IXYggKWUAHw">https://mp.weixin.qq.com/s/TZvHp-lFON8IXYggKWUAHw</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库性能优化</title>
      <link href="2021/03/02/zhaoxistu/sqlsuoyin/"/>
      <url>2021/03/02/zhaoxistu/sqlsuoyin/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库性能优化"><a href="#数据库性能优化" class="headerlink" title="数据库性能优化"></a>数据库性能优化</h1><p>如果不能设计一个合理的数据库模型，不仅会增加客户端和服务器段程序的编程和维护的难度，而且将会影响系统实际运行的性能。所以，在一个系统开始实施之前，完备的数据库模型的设计是必须的。</p><p><strong>一、数据库结构的设计</strong></p><p>在一个系统分析、设计阶段，因为数据量较小，负荷较低。我们往往只注意到功能的实现，而很难注意到性能的薄弱之处，等到系统投入实际运行一段时间后，才发现系统的性能在降低，这时再来考虑提高系统性能则要花费更多的人力物力，而整个系统也不可避免的形成了一个打补丁工程。</p><p>所以在考虑整个系统的流程的时候，我们必须要考虑，在高并发大数据量的访问情况下，我们的系统会不会出现极端的情况。（例如：对外统计系统在7月16日出现的数据异常的情况，并发大数据量的的访问造成，数据库的响应时间不能跟上数据刷新的速度造成。具体情况是：在日期临界时（00：00：00），判断数据库中是否有当前日期的记录，没有则插入一条当前日期的记录。在低并发访问的情况下，不会发生问题，但是当日期临界时的访问量相当大的时候，在做这一判断的时候，会出现多次条件成立，则数据库里会被插入多条当前日期的记录，从而造成数据错误。），数据库的模型确定下来之后，我们有必要做一个系统内数据流向图，分析可能出现的瓶颈。</p><p>为了保证数据库的一致性和完整性，在逻辑设计的时候往往会设计过多的表间关联，尽可能的降低数据的冗余。（例如用户表的地区，我们可以把地区另外存放到一个地区表中）如果数据冗余低，数据的完整性容易得到保证，提高了数据吞吐速度，保证了数据的完整性，清楚地表达数据元素之间的关系。而对于多表之间的关联查询（尤其是大数据表）时，其性能将会降低，同时也提高了客户端程序的编程难度，因此，物理设计需折衷考虑，根据业务规则，确定对关联表的数据量大小、数据项的访问频度，对此类数据表频繁的关联查询应适当提高数据冗余设计但增加了表间连接查询的操作，也使得程序的变得复杂，为了提高系统的响应时间，合理的数据冗余也是必要的。设计人员在设计阶段应根据系统操作的类型、频度加以均衡考虑。<br>另外，最好不要用自增属性字段作为主键与子表关联。不便于系统的迁移和数据恢复。对外统计系统映射关系丢失（**<strong><strong><strong>****</strong></strong></strong>）。</p><p>原来的表格必须可以通过由它分离出去的表格重新构建。使用这个规定的好处是，你可以确保不会在分离的表格中引入多余的列，所有你创建的表格结构都与它们的实际需要一样大。应用这条规定是一个好习惯，不过除非你要处理一个非常大型的数据，否则你将不需要用到它。（例如一个通行证系统，我可以将USERID，USERNAME，USERPASSWORD，单独出来作个表，再把USERID作为其他表的外键）</p><p><strong>表的设计具体注意的问题：</strong></p><p>1、数据行的长度不要超过8020字节，如果超过这个长度的话在物理页中这条数据会占用两行从而造成存储碎片，降低查询效率。<br>2、能够用数字类型的字段尽量选择数字类型而不用字符串类型的（电话号码），这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接回逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>3、对于不可变字符类型char和可变字符类型varchar  都是8000字节,char查询快，但是耗存储空间，varchar查询相对慢一些但是节省存储空间。在设计字段的时候可以灵活选择，例如用户名、密码等长度变化不大的字段可以选择CHAR，对于评论等长度变化大的字段可以选择VARCHAR。</p><p>4、字段的长度在最大限度的满足可能的需要的前提下，应该尽可能的设得短一些，这样可以提高查询的效率，而且在建立索引的时候也可以减少资源的消耗。</p><p>**<br>二、查询的优化**</p><p>保证在实现功能的基础上，尽量减少对数据库的访问次数；通过搜索参数，尽量减少对表的访问行数,最小化结果集，从而减轻网络负担；能够分开的操作尽量分开处理，提高每次的响应速度；在数据窗口使用SQL时，尽量把使用的索引放在选择的首列；算法的结构尽量简单；在查询时，不要过多地使用通配符如SELECT * FROM T1语句，要用到几列就选择几列如：SELECT COL1,COL2 FROM  T1；在可能的情况下尽量限制尽量结果集行数如：SELECT TOP 300 COL1,COL2,COL3 FROM  T1,因为某些情况下用户是不需要那么多的数据的。<br>在没有建索引的情况下，数据库查找某一条数据，就必须进行全表扫描了，对所有数据进行一次遍历，查找出符合条件的记录。在数据量比较小的情况下，也许看不出明显的差别，但是当数据量大的情况下，这种情况就是极为糟糕的了。<br>SQL语句在SQL SERVER中是如何执行的，他们担心自己所写的SQL语句会被SQL SERVER误解。比如： </p><pre><code>select * from table1 where name=&#39;zhangsan&#39; and tID &gt; 10000</code></pre><p>和执行: </p><pre><code>select * from table1 where tID &gt; 10000 and name=&#39;zhangsan&#39;</code></pre><p>一些人不知道以上两条语句的执行效率是否一样，因为如果简单的从语句先后上看，这两个语句的确是不一样，如果tID是一个聚合索引，那么后一句仅仅从表的10000条以后的记录中查找就行了；而前一句则要先从全表中查找看有几个name=’zhangsan’的，而后再根据限制条件条件tID&gt;10000来提出查询结果。<br>事实上，这样的担心是不必要的。SQL  SERVER中有一个“查询分析优化器”，它可以计算出where子句中的搜索条件并确定哪个索引能缩小表扫描的搜索空间，也就是说，它能实现自动优化。虽然查询优化器可以根据where子句自动的进行查询优化，但有时查询优化器就会不按照您的本意进行快速查询。<br>在查询分析阶段，查询优化器查看查询的每个阶段并决定限制需要扫描的数据量是否有用。如果一个阶段可以被用作一个扫描参数（SARG），那么就称之为可优化的，并且可以利用索引快速获得所需数据。<br>SARG的定义：用于限制搜索的一个操作，因为它通常是指一个特定的匹配，一个值的范围内的匹配或者两个以上条件的AND连接。形式如下：<br><strong>列名 操作符 &lt;常数 或 变量&gt; 或 &lt;常数 或 变量&gt; 操作符 列名</strong><br>列名可以出现在操作符的一边，而常数或变量出现在操作符的另一边。如：<br>Name=’张三’<br>价格&gt;5000<br>5000&lt;价格<br>Name=’张三’ and 价格&gt;5000<br>如果一个表达式不能满足SARG的形式，那它就无法限制搜索的范围了，也就是SQL SERVER必须对每一行都判断它是否满足WHERE子句中的所有条件。所以一个索引对于不满足SARG形式的表达式来说是无用的。<br>所以，优化查询最重要的就是，尽量使语句符合查询优化器的规则避免全表扫描而使用索引查询。</p><p><strong>具体要注意的：</strong></p><p>1.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><pre><code>select id from t where num is null</code></pre><p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</p><pre><code>select id from t where num=0</code></pre><p>2.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。</p><p>3.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><pre><code>select id from t where num=10 or num=20</code></pre><p>可以这样查询：</p><pre><code>select id from t where num=10 union all select id from t where num=20</code></pre><p>4.in 和 not in 也要慎用，因为IN会使系统无法使用索引,而只能直接搜索表中的数据。如：</p><pre><code>select id from t where num in(1,2,3)</code></pre><p>对于连续的数值，能用 between 就不要用 in 了：</p><pre><code>select id from t where num between 1 and 3</code></pre><p>5.尽量避免在索引过的字符数据中，使用非打头字母搜索。这也使得引擎无法利用索引。<br>见如下例子： </p><pre><code>SELECT * FROM T1 WHERE NAME LIKE ‘%L%&#39;  SELECT * FROM T1 WHERE SUBSTING(NAME,2,1)=&#39;L&#39;  SELECT * FROM T1 WHERE NAME LIKE ‘L%&#39;</code></pre><p>即使NAME字段建有索引，前两个查询依然无法利用索引完成加快操作，引擎不得不对全表所有数据逐条操作来完成任务。而第三个查询能够使用索引来加快操作。</p><p>6.必要时强制查询优化器使用某个索引，如在 where  子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><pre><code>select id from t where num=@num</code></pre><p>可以改为强制查询使用索引：</p><pre><code>select id from t with(index(索引名)) where num=@num</code></pre><p>7.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><pre><code>SELECT * FROM T1 WHERE F1/2=100 </code></pre><p>应改为: </p><pre><code>SELECT * FROM T1 WHERE F1=100*2SELECT * FROM RECORD WHERE SUBSTRING(CARD_NO,1,4)=&#39;5378&#39;</code></pre><p>应改为: </p><pre><code>SELECT * FROM RECORD WHERE CARD_NO LIKE ‘5378%&#39;SELECT member_number, first_name, last_name FROM members  WHERE DATEDIFF(yy,datofbirth,GETDATE()) &gt; 21</code></pre><p>应改为: </p><pre><code>SELECT member_number, first_name, last_name FROM members  WHERE dateofbirth &lt; DATEADD(yy,-21,GETDATE()) </code></pre><p>即：任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。</p><p>8.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><pre><code>select id from t where substring(name,1,3)=&#39;abc&#39;--name以abc开头的id select id from t where datediff(day,createdate,&#39;2005-11-30&#39;)=0--‘2005-11-30&#39;生成的id</code></pre><p>应改为:</p><pre><code>select id from t where name like &#39;abc%&#39; select id from t where createdate&gt;=&#39;2005-11-30&#39; and createdate&lt;&#39;2005-12-1&#39;</code></pre><p>9.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><p>10.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><p>11.很多时候用 exists是一个好的选择：</p><pre><code>select num from a where num in(select num from b)</code></pre><p>用下面的语句替换：</p><pre><code>select num from a where exists(select 1 from b where num=a.num)  SELECT SUM(T1.C1)FROM T1 WHERE(  (SELECT COUNT(*)FROM T2 WHERE T2.C2=T1.C2&gt;0)  SELECT SUM(T1.C1) FROM T1WHERE EXISTS(  SELECT * FROM T2 WHERE T2.C2=T1.C2) </code></pre><p>两者产生相同的结果，但是后者的效率显然要高于前者。因为后者不会产生大量锁定的表扫描或是索引扫描。</p><p>如果你想校验表里是否存在某条纪录，不要用count(*)那样效率很低，而且浪费服务器资源。可以用EXISTS代替。如： </p><pre><code>IF (SELECT COUNT(*) FROM table_name WHERE column_name = &#39;xxx&#39;) </code></pre><p>可以写成： </p><pre><code>IF EXISTS (SELECT * FROM table_name WHERE column_name = &#39;xxx&#39;)</code></pre><p>经常需要写一个T_SQL语句比较一个父结果集和子结果集，从而找到是否存在在父结果集中有而在子结果集中没有的记录，如： </p><pre><code>SELECT a.hdr_key FROM hdr_tbl a---- tbl a 表示tbl用别名a代替  WHERE NOT EXISTS (SELECT * FROM dtl_tbl b WHERE a.hdr_key = b.hdr_key)  SELECT a.hdr_key FROM hdr_tbl a  LEFT JOIN dtl_tbl b ON a.hdr_key = b.hdr_key WHERE b.hdr_key IS NULL SELECT hdr_key FROM hdr_tbl  WHERE hdr_key NOT IN (SELECT hdr_key FROM dtl_tbl) </code></pre><p>三种写法都可以得到同样正确的结果，但是效率依次降低。</p><p>12.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><p>13.避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><p>14.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p><p>15.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p><p>16.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><p>17.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p><p>18.尽量避免大事务操作，提高系统并发能力。</p><p>19.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p><p>\20. 避免使用不兼容的数据类型。例如float和int、char和varchar、binary和varbinary是不兼容的。数据类型的不兼容可能使优化器无法执行一些本来可以进行的优化操作。例如: </p><pre><code>SELECT name FROM employee WHERE salary &gt; 60000</code></pre><p>在这条语句中,如salary字段是money型的,则优化器很难对其进行优化,因为60000是个整型数。我们应当在编程时将整型转化成为钱币型,而不要等到运行时转化。</p><p>21.充分利用连接条件，在某种情况下，两个表之间可能不只一个的连接条件，这时在 WHERE 子句中将连接条件完整的写上，有可能大大提高查询速度。<br>例： </p><pre><code>SELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NO  SELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NO AND A.ACCOUNT_NO=B.ACCOUNT_NO </code></pre><p>第二句将比第一句执行快得多。</p><p>22、使用视图加速查询<br>把表的一个子集进行排序并创建视图，有时能加速查询。它有助于避免多重排序 操作，而且在其他方面还能简化优化器的工作。例如：</p><pre><code>SELECT cust.name，rcvbles.balance，……other columns  FROM cust，rcvbles  WHERE cust.customer_id = rcvlbes.customer_id  AND rcvblls.balance&gt;0  AND cust.postcode&gt;“98000”  ORDER BY cust.name</code></pre><p>如果这个查询要被执行多次而不止一次，可以把所有未付款的客户找出来放在一个视图中，并按客户的名字进行排序： </p><pre><code>CREATE VIEW DBO.V_CUST_RCVLBES  AS SELECT cust.name，rcvbles.balance，……other columns  FROM cust，rcvbles  WHERE cust.customer_id = rcvlbes.customer_id  AND rcvblls.balance&gt;0  ORDER BY cust.name</code></pre><p>然后以下面的方式在视图中查询： </p><pre><code>SELECT ＊ FROM V_CUST_RCVLBES  WHERE postcode&gt;“98000” </code></pre><p>视图中的行要比主表中的行少，而且物理顺序就是所要求的顺序，减少了磁盘I/O，所以查询工作量可以得到大幅减少。</p><p>23、能用DISTINCT的就不用GROUP BY </p><pre><code>SELECT OrderID FROM Details WHERE UnitPrice &gt; 10 GROUP BY OrderID</code></pre><p>可改为： </p><pre><code>SELECT DISTINCT OrderID FROM Details WHERE UnitPrice &gt; 10</code></pre><p>24.能用UNION ALL就不要用UNION<br>UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源</p><p>25.尽量不要用SELECT INTO语句。<br>SELECT INOT 语句会导致表锁定，阻止其他用户访问该表。</p><p>上面我们提到的是一些基本的提高查询速度的注意事项,但是在更多的情况下,往往需要反复试验比较不同的语句以得到最佳方案。最好的方法当然是测试，看实现相同功能的SQL语句哪个执行时间最少，但是数据库中如果数据量很少，是比较不出来的，这时可以用查看执行计划，即：把实现相同功能的多条SQL语句考到查询分析器，按CTRL+L看查所利用的索引，表扫描次数（这两个对性能影响最大），总体上看询成本百分比即可。</p><p><strong>三、算法的优化</strong></p><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD  游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。<br>　　游标提供了对特定集合中逐行扫描的手段，一般使用游标逐行遍历数据，根据取出的数据不同条件进行不同的操作。尤其对多表和大表定义的游标（大的数据集合）循环很容易使程序进入一个漫长的等特甚至死机。<br>　 在有些场合，有时也非得使用游标，此时也可考虑将符合条件的数据行转入临时表中，再对临时表定义游标进行操作，可时性能得到明显提高。<br>（例如：对内统计第一版）<br>封装存储过程</p><p><strong>四、建立高效的索引</strong></p><p>　  创建索引一般有以下两个目的：维护被索引列的唯一性和提供快速访问表中数据的策略。大型数据库有两种索引即簇索引和非簇索引，一个没有簇索引的表是按堆结构存储数据，所有的数据均添加在表的尾部，而建立了簇索引的表，其数据在物理上会按照簇索引键的顺序存储，一个表只允许有一个簇索引，因此，根据B树结构，可以理解添加任何一种索引均能提高按索引列查询的速度，但会降低插入、更新、删除操作的性能，尤其是当填充因子（Fill  Factor）较大时。所以对索引较多的表进行频繁的插入、更新、删除操作，建表和索引时因设置较小的填充因子，以便在各数据页中留下较多的自由空间，减少页分割及重新组织的工作。<br>索引是从数据库中获取数据的最高效方式之一。95%  的数据库性能问题都可以采用索引技术得到解决。作为一条规则，我通常对逻辑主键使用唯一的成组索引，对系统键（作为存储过程）采用唯一的非成组索引，对任何外键列[字段]采用非成组索引。不过，索引就象是盐，太多了菜就咸了。你得考虑数据库的空间有多大，表如何进行访问，还有这些访问是否主要用作读写。<br>实际上，您可以把索引理解为一种特殊的目录。微软的SQL SERVER提供了两种索引：聚集索引（clustered index，也称聚类索引、簇集索引）和非聚集索引（nonclustered  index，也称非聚类索引、非簇集索引）。下面，我们举例来说明一下聚集索引和非聚集索引的区别：<br>其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。<br>我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。<br>如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。<br>我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。<br>进一步引申一下，我们可以很容易的理解：每个表只能有一个聚集索引，因为目录只能按照一种方法进行排序。</p><p>**（一）何时使用聚集索引或非聚集索引<br>**下面的表总结了何时使用聚集索引或非聚集索引（很重要）。<br>动作描述 使用聚集索引 使用非聚集索引<br>列经常被分组排序 应 应<br>返回某范围内的数据 应 不应<br>一个或极少不同值 不应 不应<br>小数目的不同值 应 不应<br>大数目的不同值 不应 应<br>频繁更新的列 不应 应<br>外键列 应 应<br>主键列 应 应<br>频繁修改索引列 不应 应</p><p>事实上，我们可以通过前面聚集索引和非聚集索引的定义的例子来理解上表。如：返回某范围内的数据一项。比如您的某个表有一个时间列，恰好您把聚合索引建立在了该列，这时您查询2004年1月1日至2004年10月1日之间的全部数据时，这个速度就将是很快的，因为您的这本字典正文是按日期进行排序的，聚类索引只需要找到要检索的所有数据中的开头和结尾数据即可；而不像非聚集索引，必须先查到目录中查到每一项数据对应的页码，然后再根据页码查到具体内容。</p><p><strong>（二）结合实际，谈索引使用的误区</strong></p><p>理论的目的是应用。虽然我们刚才列出了何时应使用聚集索引或非聚集索引，但在实践中以上规则却很容易被忽视或不能根据实际情况进行综合分析。下面我们将根据在实践中遇到的实际问题来谈一下索引使用的误区，以便于大家掌握索引建立的方法。<br><strong>1、主键就是聚集索引</strong><br>这种想法笔者认为是极端错误的，是对聚集索引的一种浪费。虽然SQL SERVER默认是在主键上建立聚集索引的。<br>通常，我们会在每个表中都建立一个ID列，以区分每条数据，并且这个ID列是自动增大的，步长一般为1。我们的这个办公自动化的实例中的列Gid就是如此。此时，如果我们将这个列设为主键，SQL SERVER会将此列默认为聚集索引。这样做有好处，就是可以让您的数据在数据库中按照ID进行物理排序，但笔者认为这样做意义不大。<br>显而易见，聚集索引的优势是很明显的，而每个表中只能有一个聚集索引的规则，这使得聚集索引变得更加珍贵。<br>从我们前面谈到的聚集索引的定义我们可以看出，使用聚集索引的最大好处就是能够根据查询要求，迅速缩小查询范围，避免全表扫描。在实际应用中，因为ID号是自动生成的，我们并不知道每条记录的ID号，所以我们很难在实践中用ID号来进行查询。这就使让ID号这个主键作为聚集索引成为一种资源浪费。其次，让每个ID号都不同的字段作为聚集索引也不符合“大数目的不同值情况下不应建立聚合索引”规则；当然，这种情况只是针对用户经常修改记录内容，特别是索引项的时候会负作用，但对于查询速度并没有影响。<br>在办公自动化系统中，无论是系统首页显示的需要用户签收的文件、会议还是用户进行文件查询等任何情况下进行数据查询都离不开字段的是“日期”还有用户本身的“用户名”。<br>通常，办公自动化的首页会显示每个用户尚未签收的文件或会议。虽然我们的where语句可以仅仅限制当前用户尚未签收的情况，但如果您的系统已建立了很长时间，并且数据量很大，那么，每次每个用户打开首页的时候都进行一次全表扫描，这样做意义是不大的，绝大多数的用户1个月前的文件都已经浏览过了，这样做只能徒增数据库的开销而已。事实上，我们完全可以让用户打开系统首页时，数据库仅仅查询这个用户近3个月来未阅览的文件，通过“日期”这个字段来限制表扫描，提高查询速度。如果您的办公自动化系统已经建立的2年，那么您的首页显示速度理论上将是原来速度8倍，甚至更快。</p><p>**2、只要建立索引就能显著提高查询速度<br>**事实上，我们可以发现上面的例子中，第2、3条语句完全相同，且建立索引的字段也相同；不同的仅是前者在fariqi字段上建立的是非聚合索引，后者在此字段上建立的是聚合索引，但查询速度却有着天壤之别。所以，并非是在任何字段上简单地建立索引就能提高查询速度。<br>从建表的语句中，我们可以看到这个有着1000万数据的表中fariqi字段有5003个不同记录。在此字段上建立聚合索引是再合适不过了。在现实中，我们每天都会发几个文件，这几个文件的发文日期就相同，这完全符合建立聚集索引要求的：“既不能绝大多数都相同，又不能只有极少数相同”的规则。由此看来，我们建立“适当”的聚合索引对于我们提高查询速度是非常重要的。</p><p>**3、把所有需要提高查询速度的字段都加进聚集索引，以提高查询速度<br>**上面已经谈到：在进行数据查询时都离不开字段的是“日期”还有用户本身的“用户名”。既然这两个字段都是如此的重要，我们可以把他们合并起来，建立一个复合索引（compound index）。<br>很多人认为只要把任何字段加进聚集索引，就能提高查询速度，也有人感到迷惑：如果把复合的聚集索引字段分开查询，那么查询速度会减慢吗？带着这个问题，我们来看一下以下的查询速度（结果集都是25万条数据）：（日期列fariqi首先排在复合聚集索引的起始列，用户名neibuyonghu排在后列）<br>我们可以看到如果仅用聚集索引的起始列作为查询条件和同时用到复合聚集索引的全部列的查询速度是几乎一样的，甚至比用上全部的复合索引列还要略快（在查询结果集数目一样的情况下）；而如果仅用复合聚集索引的非起始列作为查询条件的话，这个索引是不起任何作用的。当然，语句1、2的查询速度一样是因为查询的条目数一样，如果复合索引的所有列都用上，而且查询结果少的话，这样就会形成“索引覆盖”，因而性能可以达到最优。同时，请记住：无论您是否经常使用聚合索引的其他列，但其前导列一定要是使用最频繁的列。</p><p><strong>（三）其他注意事项</strong><br>“水可载舟，亦可覆舟”，索引也一样。索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。<br>所以说，我们要建立一个“适当”的索引体系，特别是对聚合索引的创建，更应精益求精，以使您的数据库能得到高性能的发挥</p>]]></content>
      
      
      <categories>
          
          <category> 数据库性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端设计模式</title>
      <link href="2021/03/02/kaikeba/javascript-she-ji-mo-shi/"/>
      <url>2021/03/02/kaikeba/javascript-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="前端设计模式"><a href="#前端设计模式" class="headerlink" title="前端设计模式"></a>前端设计模式</h1><p>​        设计模式（Design Pattern）是⼀套被反复使⽤、多数⼈知晓的、经过分类的、代码设计经验的总结。</p><h2 id="订阅-发布模式-（观察者）"><a href="#订阅-发布模式-（观察者）" class="headerlink" title="订阅**/**发布模式 （观察者）"></a>订阅**/**发布模式 （观察者）</h2><p>pub/sub 这个应该⼤家⽤到最⼴的设计模式了，</p><p>​    在这种模式中，并不是⼀个对象调⽤另⼀个对象的⽅法，⽽是⼀个对象订阅另⼀个对象的 特定活动并在</p><p>​    状态改编后获得通知。订阅者因此也成为观察者，⽽被观察的对象成为发布者或者主题。当发⽣了⼀个</p><p>​    重要事件时候 发布者会通知（调⽤）所有订阅者并且可能经常已事件对象的形式传递消息。</p><pre><code>class Event&#123; constructor()&#123;     this.callbacks = &#123;&#125; &#125; $off(name)&#123;     this.callbacks[name] = null &#125; $emit(name, args)&#123;     let cbs = this.callbacks[name]     if (cbs) &#123;         cbs.forEach(c=&gt;&#123;             c.call(this, args)         &#125;)     &#125; &#125; $on(name, fn)&#123;     (this.callbacks[name] || (this.callbacks[name] = [])).push(fn) &#125;&#125;let event = new Event()event.$on(&#39;event1&#39;, function(arg)&#123; console.log(&#39;事件1&#39;,arg)&#125;)event.$on(&#39;event1&#39;, function(arg)&#123; console.log(&#39;⼜⼀个时间1&#39;,arg)&#125;)event.$on(&#39;event2&#39;, function(arg)&#123; console.log(&#39;事件2&#39;,arg)&#125;)event.$emit(&#39;event1&#39;,&#123;name:&#39;开课吧&#39;&#125;)event.$emit(&#39;event2&#39;,&#123;name:&#39;全栈&#39;&#125;)event.$off(&#39;event1&#39;)event.$emit(&#39;event1&#39;,&#123;name:&#39;开课吧&#39;&#125;)</code></pre><p>vue中的 emit,on源码 ⼤概也是这个样⼦</p><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/events.js#L54">https://github.com/vuejs/vue/blob/dev/src/core/instance/events.js#L54</a></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式的定义：保证⼀个类仅有⼀个实例，并提供⼀个访问它的全局访问点。实现的⽅法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了⼀个类只有⼀个实例对象。</p><p>适⽤场景：⼀个单⼀对象。⽐如：弹窗，⽆论点击多少次，弹窗只应该被创建⼀次’ 实现起来也很简单，⽤⼀个变量缓存即可.</p><pre><code>&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .model&#123; border:1px solid black; position: fixed; width:300px; height:300px; top:20%; left:50%; margin-left:-150px; text-align: center;  &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;loginBtn&quot;&gt;点我&lt;/div&gt; &lt;script&gt;  var getSingle = function( fn )&#123;     var result;     return function()&#123;         return result || ( result = fn.apply(this, arguments )              );  &#125;&#125;;var createLoginLayer = function()&#123;     var div = document.createElement( &#39;div&#39; );     div.innerHTML = &#39;我是登录浮窗&#39;;     div.className = &#39;model&#39;     div.style.display = &#39;none&#39;;      document.body.appendChild( div );     return div;&#125;;var createSingleLoginLayer = getSingle( createLoginLayer );document.getElementById( &#39;loginBtn&#39; ).onclick = function()&#123;     var loginLayer = createSingleLoginLayer();     loginLayer.style.display = &#39;block&#39;;&#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>应⽤场景</p><p>我们再element中的弹窗代码中，可以看到单例模式的实际案例 保证全局唯⼀性 <a href="https://github.com/ElemeFE/element/blob/dev/packages/message-box/src/main.js#L79">https://github.com/ElemeFE/element/blob/dev/packages/message-box/src/main.js#L79</a></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式的定义：定义⼀系列的算法，把他们⼀个个封装起来，并且使他们可以相互替换。</p><p>策略模式的⽬的就是将算法的使⽤算法的实现分离开来。</p><p>⼀个基于策略模式的程序⾄少由两部分组成。第⼀个部分是⼀组策略类（可变），策略类封装了具体的算法，并负责具体的计算过程。第⼆个部分是环境类Context（不变），Context接受客户的请求，随后将请求委托给某⼀个策略类。要做到这⼀点，说明Context中要维持对某个策略对象的引⽤举个栗⼦</p><p>奖⾦计算，绩效为 S 的⼈年 终奖有 4 倍⼯资，绩效为 A 的⼈年终奖有 3 倍⼯资，⽽绩效为 B 的⼈年终奖是 2 倍⼯资</p><pre><code>var calculateBonus = function( performanceLevel, salary )&#123; if ( performanceLevel === &#39;S&#39; )&#123; return salary * 4; &#125; if ( performanceLevel === &#39;A&#39; )&#123; return salary * 3; &#125; if ( performanceLevel === &#39;B&#39; )&#123; return salary * 2; &#125;&#125;;calculateBonus( &#39;B&#39;, 20000 ); // 输出:40000calculateBonus( &#39;S&#39;, 6000 ); // 输出:24000</code></pre><p>使⽤策略模式</p><pre><code>var strategies = &#123; &quot;S&quot;: function( salary )&#123; return salary * 4; &#125;, &quot;A&quot;: function( salary )&#123; return salary * 3; &#125;, &quot;B&quot;: function( salary )&#123; return salary * 2; &#125;&#125;;var calculateBonus = function( level, salary )&#123; return strategies[ level ]( salary );&#125;;console.log( calculateBonus( &#39;S&#39;, 20000 ) );// 输出:80000console.log( calculateBonus( &#39;A&#39;, 10000 ) );// 输出:30000</code></pre><p>表单校验</p><pre><code>// 正常写法var registerForm = document.getElementById( &#39;registerForm&#39; );registerForm.onsubmit = function()&#123; if ( registerForm.userName.value === &#39;&#39; )&#123; alert ( &#39;⽤户名不能为空&#39; ); return false; &#125; if ( registerForm.password.value.length &lt; 6 )&#123; alert ( &#39;密码⻓度不能少于 6 位&#39; ); return false; &#125; if ( !/(^1[3|5|8][0-9]&#123;9&#125;$)/.test( registerForm.phoneNumber.value ) )&#123; alert ( &#39;⼿机号码格式不正确&#39; ); return false; &#125;&#125;</code></pre><p>使⽤策略模式</p><pre><code>var strategies = &#123; isNonEmpty: function( value, errorMsg )&#123; if ( value === &#39;&#39; )&#123; return errorMsg ; &#125; &#125;, minLength: function( value, length, errorMsg )&#123; if ( value.length &lt; length )&#123; return errorMsg; &#125; &#125;, isMobile: function( value, errorMsg )&#123; // ⼿机号码格式 if ( !/(^1[3|5|8][0-9]&#123;9&#125;$)/.test( value ) )&#123; return errorMsg; &#125; &#125;&#125;;var Validator = function()&#123; this.cache = []; // 保存校验规则&#125;;Validator.prototype.add = function( var ary = rule.split( &#39;:&#39; ); this.cache.push(function()&#123; // var strategy = ary.shift(); ary.unshift( dom.value ); ary.push( errorMsg ); //  return strategies[strategy].apply(dom, ary); &#125;);&#125;;Validator.prototype.start = function()&#123; for ( var i = 0, validatorFunc; validatorFunc = this.cache[ i++ ]; )&#123; var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息 if ( msg )&#123; // 如果有确切的返回值，说明校验没有通过 return msg; &#125; &#125;&#125;;var validataFunc = function()&#123; var validator = new Validator(); // 创建⼀个 validator 对象 /***************添加⼀些校验规则****************/ validator.add( registerForm.userName, &#39;isNonEmpty&#39;, &#39;⽤户名不能为空&#39; );   validator.add( registerForm.password, &#39;minLength:6&#39;, &#39;密码⻓度不能少于 6位&#39;);  validator.add( registerForm.phoneNumber, &#39;isMobile&#39;, &#39;⼿机号码格式不正确&#39; ); var errorMsg = validator.start(); // 获得校验结果 return errorMsg; // 返回校验结果&#125;var registerForm = document.getElementById( &#39;registerForm&#39; );registerForm.onsubmit = function()&#123; var errorMsg = validataFunc(); // 如果 errorMsg 有确切的返回值，说明未通过校验 if ( errorMsg )&#123; alert ( errorMsg ); return false; // 阻⽌表单提交 &#125;s&#125;;</code></pre><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的定义：为⼀个对象提供⼀个代⽤品或占位符，以便控制对它的访问。</p><p>常⽤的虚拟代理形式：某⼀个花销很⼤的操作，可以通过虚拟代理的⽅式延迟到这种需要它的时候才去创建（例：使⽤虚拟代理实现图⽚懒加载）</p><p>图⽚懒加载的⽅式：先通过⼀张loading图占位，然后通过异步的⽅式加载图⽚，等图⽚加载好了再把完成的图⽚加载到img标签⾥⾯。</p><pre><code>var imgFunc = (function() &#123; var imgNode = document.createElement(&#39;img&#39;); document.body.appendChild(imgNode); return &#123; setSrc: function(src) &#123;  imgNode.src = src; &#125; &#125;&#125;)();var proxyImage = (function() &#123; var img = new Image(); img.onload = function() &#123; imgFunc.setSrc(this.src); &#125; return &#123; setSrc: function(src) &#123; imgFunc.setSrc(&#39;./loading,gif&#39;); img.src = src; &#125; &#125;&#125;)();proxyImage.setSrc(&#39;./pic.png&#39;);</code></pre><p>假设我们在做⼀个⽂件同步的功能，当我们选中⼀个 checkbox 的时候，它对应的⽂件就会被同 步到另外⼀台备⽤服务器上⾯。当⼀次选中过多时，会产⽣频繁的⽹络请求。将带来很⼤的开销。可以通过⼀个代理函数 proxySynchronousFile 来收集⼀段时间之内的请求， 最后⼀次性发送给服务器</p><pre><code>var synchronousFile = function( id )&#123; console.log( &#39;开始同步⽂件，id 为: &#39; + id );&#125;;var proxySynchronousFile = (function()&#123; var cache = [], // 保存⼀段时间内需要同步的 ID timer; // 定时器 return function( id )&#123; cache.push( id ); if ( timer )&#123; // 保证不会覆盖已经启动的定时器 return; &#125; timer = setTimeout(function()&#123; synchronousFile( cache.join( &#39;,&#39; ) ); clearTimeout( timer ); // 清空定时器 timer = null; cache.length = 0; // 清空 ID 集合 &#125;, 2000 ); &#125;// 2 秒后向本体发送需要同步的 ID 集合&#125;)();var checkbox = document.getElementsByTagName( &#39;input&#39; ); for ( var i = 0, c; c = checkbox[ i++ ]; )&#123; c.onclick = function()&#123; if ( this.checked === true )&#123; proxySynchronousFile( this.id ); &#125;  &#125;&#125;;</code></pre><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式的定义：通过⼀个中介者对象，其他所有的相关对象都通过该中介者对象来通信，⽽不是相互引⽤，当其中的⼀个对象发⽣改变时，只需要通知中介者对象即可。通过中介者模式可以解除对象与对象之间的紧耦合关系。</p><p>例如：现实⽣活中，航线上的⻜机只需要和机场的塔台通信就能确定航线和⻜⾏状态，⽽不需要和所有⻜机通信。同时塔台作为中介者，知道每架⻜机的⻜⾏状态，所以可以安排所有⻜机的起降和航线安排。</p><p>中介者模式适⽤的场景：例如购物⻋需求，存在商品选择表单、颜⾊选择表单、购买数量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。</p><p>redux，vuex 都属于中介者模式的实际应⽤，我们把共享的数据，抽离成⼀个单独的store， 每个都通过store这个中介来操作对象</p><p>⽬的就是减少耦合</p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰者模式的定义：在不改变对象⾃身的基础上，在程序运⾏期间给对象动态地添加⽅法。常⻅应⽤，react的⾼阶组件, 或者react-redux中的@connect 或者⾃⼰定义⼀些⾼阶组件</p><pre><code>import React from &#39;react&#39;const withLog = Component=&gt;&#123; // 类组件 class NewComponent extends React.Component&#123; componentWillMount()&#123; console.time(`CompoentRender`) console.log(`准备完毕了`) &#125; render()&#123; return &lt;Component &#123;...this.props&#125;&gt;&lt;/Component&gt; &#125;开课吧web全栈架构师  componentDidMount()&#123; console.timeEnd(`CompoentRender`) console.log(`渲染完毕了`) &#125; &#125; return NewComponent&#125;export &#123;withLog&#125;@withLogclass XXexport const connect = (mapStateToProps = state =&gt; state, mapDispatchToProps =&#123;&#125;) =&gt; (WrapComponent) =&gt; &#123; return class ConnectComponent extends React.Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor(props, context) &#123; super(props, context) this.state = &#123; props: &#123;&#125; &#125; &#125; componentDidMount() &#123; const &#123; store &#125; = this.context // 当前状态 update 后, 放⼊监听器中, ⽤于下⼀次的更新(每次 dispatch 后会执⾏subscribe 中的所有函数) store.subscribe(() =&gt; this.update()) this.update() &#125; update() &#123; const &#123; store &#125; = this.context const stateProps = mapStateToProps(store.getState()) const dispatchProps = bindActionCreators(mapDispatchToProps,store.dispatch) this.setState(&#123; props: &#123; ...this.state.props, ...stateProps, ...dispatchProps &#125; &#125;) &#125; render() &#123; return &lt;WrapComponent &#123;...this.state.props&#125;&gt;&lt;/WrapComponent&gt; &#125;  &#125;   &#125;</code></pre><p>假设我们在编写⼀个⻜机⼤战的游戏，随着经验值的增加，我们操作的⻜机对象可以升级成更厉害的⻜机，⼀开始这些⻜机只能发射普通的⼦弹，升到第⼆级时可以发射导弹，升到第三级时可以发射原⼦弹。</p><pre><code>Function.prototype.before = function( beforefn )&#123; var __self = this; // 保存原函数的引⽤ return function()&#123; // 返回包含了原函数和新函数的&quot;代理&quot;函数 beforefn.apply( this, arguments ); // 执⾏新函数，且保证 this 不被劫持，新函数接受的参数 // 也会被原封不动地传⼊原函数，新函数在原函数之前执⾏ return __self.apply( this, arguments ); // 执⾏原函数并返回原函数的执⾏结果， // 并且保证 this 不被劫持&#125; &#125;Function.prototype.after = function( afterfn )&#123; var __self = this; return function()&#123; var ret = __self.apply( this, arguments ); afterfn.apply( this, arguments ); return ret; &#125;&#125;;</code></pre><p>⽐如⻚⾯中有⼀个登录 button，点击这个 button 会弹出登录浮层，与此同时要进⾏数据上报， 来统计有多少⽤户点击了这个登录 button</p><pre><code>var showLogin = function()&#123; console.log( &#39;打开登录浮层&#39; ); log( this.getAttribute( &#39;tag&#39; ) );&#125;var log = function( tag )&#123; console.log( &#39;上报标签为: &#39; + tag ); (new Image).src = &#39;http:// xxx.com/report?tag=&#39; + tag; &#125;document.getElementById( &#39;button&#39; ).onclick = showLogin;</code></pre><p>使⽤装饰器</p><pre><code>var showLogin = function()&#123; console.log( &#39;打开登录浮层&#39; );&#125;var log = function()&#123; console.log( &#39;上报标签为: &#39; + this.getAttribute( &#39;tag&#39; ) );&#125;showLogin = showLogin.after( log ); // 打开登录浮层之后上报数据document.getElementById( &#39;button&#39; ).onclick = showLogin;</code></pre><p>装饰者模式和代理模式的结构看起来⾮常相像，这两种模式都描述了怎样为对象提供 ⼀定程度上的间接引⽤，它们的实现部分都保留了对另外⼀个对象的引⽤，并且向那个对象发送 请求。 代理模式和装饰者模式最重要的区别在于它们的意图和设计⽬的。代理模式的⽬的是，当直接访问本体不⽅便或者不符合需要时，为这个本体提供⼀个替代者。本体定义了关键功能，⽽代理提供或拒绝对它的访问，或者在访问本体之前做⼀些额外的事情。装饰者模式的作⽤就是为对 象动态加⼊⾏为。</p><p>其实Vue中的v-input，v-checkbox也可以认为是装饰器模式， 对原⽣的input和checkbox做⼀层装饰</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式即让多个⽅法⼀起被调⽤涉及到兼容性，参数⽀持多格式，有很多这种代码，对外暴露统⼀的api，⽐如上⾯的$on ⽀持数组，￥offff参数⽀持多个情况， 对⾯只⽤⼀个函数，内部判断实现</p><p>⾃⼰封装组件库 经常看到</p><pre><code>myEvent = &#123; stop: function(e) &#123; if (typeof e.preventDefault() === &quot;function&quot;) &#123; e.preventDefault(); &#125; if (typeof e.stopPropagation() === &quot;function&quot;) &#123; e.stopPropagation(); &#125; //for IE if (typeof e.returnValue === &quot;boolean&quot;) &#123; e.returnValue = false; &#125; if (typeof e.cancelBubble === &quot;boolean&quot;) &#123; e.cancelBubble = true; &#125; &#125; addEvent(dom, type, fn) &#123;  if (dom.addEventListener) &#123; dom.addEventListener(type, fn, false); &#125; else if (dom.attachEvent) &#123; dom.attachEvent(&#39;on&#39; + type, fn); &#125; else &#123; dom[&#39;on&#39; + type] = fn; &#125; &#125;&#125;</code></pre><h2 id="⼯⼚模式"><a href="#⼯⼚模式" class="headerlink" title="⼯⼚模式"></a>⼯⼚模式</h2><p>提供创建对象的接⼝，把成员对象的创建⼯作转交给⼀个外部对象，好处在于消除对象之间的耦合(也就</p><p>是相互影响)</p><p>常⻅的例⼦，我们的弹窗，message，对外提供的api，都是调⽤api，然后新建⼀个弹窗或者Message</p><p>的实例，就是典型的⼯⼚模式</p><pre><code>const Notification = function(options) &#123; if (Vue.prototype.$isServer) return; options = options || &#123;&#125;; const userOnClose = options.onClose; const id = &#39;notification_&#39; + seed++; const position = options.position || &#39;top-right&#39;; options.onClose = function() &#123; Notification.close(id, userOnClose); &#125;; instance = new NotificationConstructor(&#123; data: options &#125;); if (isVNode(options.message)) &#123; instance.$slots.default = [options.message]; options.message = &#39;REPLACED_BY_VNODE&#39;; &#125; instance.id = id; instance.$mount(); document.body.appendChild(instance.$el); instance.visible = true; instance.dom = instance.$el; instance.dom.style.zIndex = PopupManager.nextZIndex();  let verticalOffset = options.offset || 0; instances.filter(item =&gt; item.position === position).forEach(item =&gt; &#123; verticalOffset += item.$el.offsetHeight + 16; &#125;); verticalOffset += 16; instance.verticalOffset = verticalOffset; instances.push(instance); return instance;&#125;;</code></pre><p><a href="https://github.com/ElemeFE/element/blob/dev/packages/notifification/src/main.js#L11">https://github.com/ElemeFE/element/blob/dev/packages/notifification/src/main.js#L11</a></p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>和⼯⻓模式相⽐，参与了更多创建的过程 或者更复杂</p><pre><code>var Person = function(name, work) &#123; // 创建应聘者缓存对象 var _person = new Human(); // 创建应聘者姓名解析对象 _person.name = new Named(name); // 创建应聘者期望职位 _person.work = new Work(work); return _person;&#125;;var person = new Person(&#39;xiao ming&#39;, &#39;code&#39;);console.log(person)</code></pre><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式是指提供⼀种⽅法顺序访问⼀个聚合对象中的各个元素，⽽⼜不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来,在使⽤迭代器模式之后，即使不关⼼对象的内部构造，也可以按顺序访问其中的每个元素</p><p>这个⽤的就太多了 each map啥乱遭的</p><pre><code>var each = function( ary, callback )&#123; for ( var i = 0, l = ary.length; i &lt; l; i++ )&#123; callback.call( ary[i], i, ary[ i ] ); &#125;&#125;;each( [ 1, 2, 3 ], function( i, n )&#123; alert ( [ i, n ] );&#125;)</code></pre><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元(flflyweight)模式是⼀种⽤于性能优化的模式，“flfly”在这⾥是苍蝇的意思，意为蝇量级。享元模式的核⼼是象⽽导致内存占⽤过⾼，享元模式就⾮常有⽤了。在 JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了⼀件⾮常有意义的事情。</p><p>假设有个内⾐⼯⼚，⽬前的产品有 50 种男式内⾐和 50 种⼥⼠内⾐，为了推销产品，⼯⼚决定⽣产⼀些塑料模特来穿上他们的内⾐拍成⼴告照⽚。 正常情况下需要 50个男模特和50个⼥模特，然后让他们每⼈分别穿上⼀件内⾐来拍照</p><pre><code>var Model = function( sex, underwear)&#123; this.sex = sex; this.underwear = underwear;&#125;;Model.prototype.takePhoto = function()&#123; console.log( &#39;sex= &#39; + this.sex + &#39; underwear=&#39; + this.underwear);&#125;;for ( var i = 1; i &lt;= 50; i++ )&#123; var maleModel = new Model( &#39;male&#39;, &#39;underwear&#39; + i );  maleModel.takePhoto(); &#125;;for ( var j = 1; j &lt;= 50; j++ )&#123; var femaleModel= new Model( &#39;female&#39;, &#39;underwear&#39; + j ); femaleModel.takePhoto();&#125;;</code></pre><p>如上所述，现在⼀共有 50 种男内 ⾐和 50 种⼥内⾐，所以⼀共会产⽣ 100 个对象。如果将来⽣产了10000 种内⾐，那这个程序可能会因为存在如此多的对象已经提前崩溃。 下⾯我们来考虑⼀下如何优化这个场景。虽然有 100 种内⾐，但很显然并不需要 50 个男 模特和 50 个⼥模特。其实男模特和⼥模特各⾃有⼀个就⾜够了，他们可以分别穿上不同的内⾐来拍照。</p><pre><code>/*只需要区别男⼥模特那我们先把 underwear 参数从构造函数中 移除，构造函数只接收 sex 参数*/var Model = function( sex )&#123; this.sex = sex;&#125;;Model.prototype.takePhoto = function()&#123; console.log( &#39;sex= &#39; + this.sex + &#39; underwear=&#39; + this.underwear);&#125;;/*分别创建⼀个男模特对象和⼀个⼥模特对象*/var maleModel = new Model( &#39;male&#39; ), femaleModel = new Model( &#39;female&#39; );/*给男模特依次穿上所有的男装，并进⾏拍照*/for ( var i = 1; i &lt;= 50; i++ )&#123; maleModel.underwear = &#39;underwear&#39; + i; maleModel.takePhoto();&#125;;/*给⼥模特依次穿上所有的⼥装，并进⾏拍照*/for ( var j = 1; j &lt;= 50; j++ )&#123; femaleModel.underwear = &#39;underwear&#39; + j; femaleModel.takePhoto();&#125;;//只需要两个对象便完成了同样的功能</code></pre><p>内部状态存储于对象内部</p><p>内部状态可以被⼀些对象共享</p><p>内部状态独⽴于具体的场景，通常不会改变</p><p>外部状态取决于具体的场景，并根据场景⽽变化，外部状态不能被共享</p><p>性别是内部状态，内⾐是外部状态，通过区分这两种状态，⼤⼤减少了系 统中的对象数量。通常来讲，</p><p>内部状态有多少种组合，系统中便最多存在多少个对象，因为性别 通常只有男⼥两种，所以该内⾐⼚商最多只需要 2 个对象。</p><h2 id="应⽤案例"><a href="#应⽤案例" class="headerlink" title="应⽤案例"></a>应⽤案例</h2><p>消息组件</p><p>应⽤案例</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210302163543092.png" alt="image-20210302163543092"></p><p>需求</p><ol><li><p>弹窗逻辑⼀样</p></li><li><p>四中弹窗，颜⾊，icon不同</p></li><li><p>接收⽂案</p></li></ol><p>交互⽅式——弹出、隐藏，由共享对象所拥有</p><p>提示icon、背景样式、字体样式提供接⼝可配置</p><p>使⽤api统一</p><pre><code>export default &#123; install (Vue) &#123; // 在使⽤插件Vue.use(Message)时实例化⼀个Dialog组件对象 const Dialog = new Vue(&#123; data () &#123; return &#123; icon: &#39;&#39;, fontStyle: &#39;&#39;, backgroundStyle: &#39;&#39;, text: &#39;&#39; &#125; &#125; ... &#125;)  // 扩展Vue的`prototype` Vue.prototype.$Message = &#123; success (text) &#123; // 改变Dialog的data.xx的值触发Dialog的更新 Dialog.icon = successIcon Dialog.fontStyle = successFontStyle Dialog.backgroundStyle = successBackgroundStyle Dialog.text = text // 获取Dialog的最新DOM添加到body标签中 document.body.appendChild(Dialog.$el) &#125;, warning (text) &#123; // 同上 ... document.body.appendChild(Dialog.$el) &#125;, error (text) &#123; // 同上 ... document.body.appendChild(Dialog.$el) &#125; &#125; &#125;&#125;</code></pre><p>Dialog只会在项⽬初始化时被 new ⼀次，每次使⽤Message组件通过改变Dialog的状态获取组件DOM，其实很容易知道new⼀个组件的成本要⽐⼀个组件的更新成本⾼很多</p><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>职责链模式的定义是:使多个对象都有机会处理请求，从⽽避免请求的发送者和接收者之间的耦合关系，将这些对象连成⼀条链，并沿着这条链传递该请求，直到有⼀个对象处理它为⽌。 职责链模式的名字⾮常形象，⼀系列可能会处理请求的对象被连接成⼀条链，请求在这些对 象之间依次传递，直到遇到⼀个可以处理它的对象，我们把这些对象称为链中的节点</p><p>假设我们负责⼀个售卖⼿机的电商⽹站，经过分别交纳 500 元定⾦和 200 元定⾦的两轮预定后(订单已在此时⽣成)，现在已经到了正式购买的阶段。 公司针对⽀付过定⾦的⽤户有⼀定的优惠政策。在正式购买后，已经⽀付过 500 元定⾦的⽤ 户会收到 100 元的商城优惠券，200 元定⾦的⽤户可以收到 50 元的优惠券，⽽之前没有⽀付定⾦的⽤户只能进⼊普通购买模式，也就是没有优惠券，且在库存有限的情况下不⼀定保证能买到</p><pre><code>var order = function( orderType, pay, stock )&#123; if ( orderType === 1 )&#123; // 500 元定⾦购买模式 if ( pay === true )&#123; // 已⽀付定⾦ console.log( &#39;500 元定⾦预购, 得到 100 优惠券&#39; ); &#125; else&#123; // 未⽀付定⾦，降级到普通购买模式 if ( stock &gt; 0 )&#123; // ⽤于普通购买的⼿机还有库存 console.log( &#39;普通购买, ⽆优惠券&#39; ); &#125;else&#123; console.log( &#39;⼿机库存不⾜&#39; ); &#125; &#125; &#125; else if ( orderType === 2 )&#123; if ( pay === true )&#123; // 200 元定⾦购买模式 console.log( &#39;200 元定⾦预购, 得到 50 优惠券&#39; ); &#125;else&#123; if ( stock &gt; 0 )&#123; console.log( &#39;普通购买, ⽆优惠券&#39; ); &#125;else&#123; console.log( &#39;⼿机库存不⾜&#39; ); &#125; &#125; &#125; else if (orderType === 3) &#123; if ( stock &gt; 0 )&#123; console.log( &#39;普通购买, ⽆优惠券&#39; ); &#125; else&#123; console.log( &#39;⼿机库存不⾜&#39; ); &#125; &#125;&#125;;order( 1 , true, 500); // 输出: 500 元定⾦预购, 得到 100 优惠券</code></pre><p>现在我们采⽤职责链模式重构这段代码，先把 500 元订单、200 元订单以及普通购买分成 3 个函数。接下来把 orderType、pay、stock 这 3 个字段当作参数传递给 500 元订单函数，如果该函数不符合处理条件，则把这个请求传递给后⾯的 200 元订单函数，如果 200 元订单函数依然不能处理该请求，则继续传递请求给普通购买函数。</p><pre><code>var order500 = function( orderType, pay, stock )&#123; if ( orderType === 1 &amp;&amp; pay === true )&#123; console.log( &#39;500 元定⾦预购，得到 100 优惠券&#39; ); &#125; else&#123; return &#39;nextSuccessor&#39;; // 我不知道下⼀个节点是谁，反正把请求往后⾯传递 &#125;&#125;;var order200 = function( orderType, pay, stock )&#123; if ( orderType === 2 &amp;&amp; pay === true )&#123; console.log( &#39;200 元定⾦预购，得到 50 优惠券&#39; ); &#125; else&#123; return &#39;nextSuccessor&#39;; // 我不知道下⼀个节点是谁，反正把请求往后⾯传递 &#125;&#125;;var orderNormal = function( orderType, pay, stock )&#123; if ( stock &gt; 0 )&#123; console.log( &#39;普通购买，⽆优惠券&#39; ); &#125; else&#123; console.log( &#39;⼿机库存不⾜&#39; ); &#125;&#125;;// Chain.prototype.setNextSuccessor 指定在链中的下⼀个节点// Chain.prototype.passRequest 传递请求给某个节点var Chain = function( fn )&#123; this.fn = fn; this.successor = null;&#125;;Chain.prototype.setNextSuccessor = function( successor )&#123; return this.successor = successor;&#125;;Chain.prototype.passRequest = function()&#123; var ret = this.fn.apply( this, arguments ); if ( ret === &#39;nextSuccessor&#39; )&#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments ); &#125; return ret;&#125;;var chainOrder500 = new Chain( order500 );var chainOrder200 = new Chain( order200 );var chainOrderNormal = new Chain( orderNormal );chainOrder500.setNextSuccessor( chainOrder200 );chainOrder200.setNextSuccessor( chainOrderNormal);chainOrder500.passRequest( 1, true, 500 ); // 输出:500 元定⾦预购，得到 100 优惠券chainOrder500.passRequest( 2, true, 500 ); // 输出:200 元定⾦预购，得到 50 优惠券chainOrder500.passRequest( 3, true, 500 ); // 输出:普通购买，⽆优惠券chainOrder500.passRequest( 1, false, 0 ); // 输出:⼿机库存不⾜</code></pre><p>通过改进，我们可以⾃由灵活地增加、移除和修改链中的节点顺序，假如某天⽹站运营⼈员 ⼜想出了⽀持 300 元定⾦购买，那我们就在该链中增加⼀个节点即可</p><pre><code>var order300 = function()&#123;// 具体实现略&#125;;chainOrder300= new Chain( order300 );chainOrder500.setNextSuccessor( chainOrder300);chainOrder300.setNextSuccessor( chainOrder200);</code></pre><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式的作⽤是解决两个软件实体间的接⼝不兼容的问题。使⽤适配器模式之后，原本 由于接⼝不兼容⽽不能⼯作的两个软件实体可以⼀起⼯作。 适配器的别名是包装器(wrapper)，这是⼀个相对简单的模式。在程序开发中有许多这样的 场景:当我们试图调⽤模块或者对象的某个接⼝时，却发现这个接⼝的格式并不符合⽬前的需求。 这时候有两种解决办法，第⼀种是修改原来的接⼝实现，但如果原来的模块很复杂，或者我们拿 到的模块是⼀段别⼈编写的经过压缩的代码，修改原接⼝就显得不太现实了。第⼆种办法是创建 ⼀个适配器，将原接⼝转换为客户希望的另⼀个接⼝，客户只需要和适配器打交道。</p><pre><code>var googleMap = &#123; show: function()&#123; console.log( &#39;开始渲染⾕歌地图&#39; ); &#125;&#125;;var baiduMap = &#123; display: function()&#123; console.log( &#39;开始渲染百度地图&#39; ); &#125;&#125;;var baiduMapAdapter = &#123; show: function()&#123; return baiduMap.display(); &#125;&#125;;renderMap( googleMap ); // 输出:开始渲染⾕歌地图renderMap( baiduMapAdapter ); // 输出:开始渲染百度地图</code></pre><p>适配器模式主要⽤来解决两个已有接⼝之间不匹配的问题，它不考虑这些接⼝是怎样实 现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接⼝，就能够 使它们协同作⽤。</p><p>装饰者模式和代理模式也不会改变原有对象的接⼝，但装饰者模式的作⽤是为了给对象 增加功能。装饰者模式常常形成⼀条⻓的装饰链，⽽适配器模式通常只包装⼀次。代理 模式是为了控制对对象的访问，通常也只包装⼀次。</p><p>我们设计很多插件，有默认值，也算是适配器的⼀种应⽤， vue的prop校验，default也算是适配器的应⽤了</p><p>外观模式的作⽤倒是和适配器⽐较相似，有⼈把外观模式看成⼀组对象的适配器，但外观模式最显著的特点是定义了⼀个新的接⼝。</p><h2 id="模板⽅法模式"><a href="#模板⽅法模式" class="headerlink" title="模板⽅法模式"></a>模板⽅法模式</h2><p>模板⽅法模式在⼀个⽅法中定义⼀个算法的⻣架，⽽将⼀些步骤的实现延迟到⼦类中。模板⽅法使得⼦类可以在不改变算法结构的情况下，重新定义算法中某些步骤的具体实现</p><p>这个我们⽤的很多，vue中的slot，react中的children</p><pre><code>class Parent &#123; constructor() &#123;&#125; render () &#123; &lt;div&gt; &lt;div name=&quot;tom&quot;&gt;&lt;/div&gt; &lt;!-- 算法过程：children要渲染在name为joe的div中 --&gt; &lt;div name=&quot;joe&quot;&gt;&#123;this.props.children&#125;&lt;/div&gt; &lt;/div&gt; &#125;&#125;class Stage &#123; constructor() &#123;&#125; render () &#123; // 在parent中已经设定了children的渲染位置算法 &lt;Parent&gt; // children的具体实现 &lt;div&gt;child&lt;/div&gt; &lt;/Parent&gt; &#125; &#125;</code></pre><pre><code>&lt;template&gt;&lt;div&gt; &lt;div name=&quot;tom&quot;&gt;&lt;/div&gt; &lt;div name=&quot;joe&quot;&gt; &lt;!--vue中的插槽渲染children--&gt; &lt;slot /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;template&gt; &lt;div&gt; &lt;parent&gt; &lt;!-- children的具体实现 --&gt; &lt;div&gt;child&lt;/div&gt; &lt;/parent&gt; &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>可以恢复到对象之前的某个状态，其实⼤家学习react或者redux的时候，时间旅⾏的功能，就算是备忘录模式的⼀个应⽤</p><p><a href="https://zh-hans.reactjs.org/tutorial/tutorial.html#implementing-time-travel">https://zh-hans.reactjs.org/tutorial/tutorial.html#implementing-time-travel</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>创建设计模式： ⼯⼚，单例，建造者 原型</p><p>结构化设计模式：外观，适配器，代理，装饰器，享元 桥接，组合</p><p>⾏为型：策略，模板⽅法，观察者，迭代器，责任链，命令，备忘录，状态，访问者，终结者，解释器</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6、ES7、ES8、ES9、ES10、ES11、ES12新特性</title>
      <link href="2021/03/01/ziliao/javascript/es6/"/>
      <url>2021/03/01/ziliao/javascript/es6/</url>
      
        <content type="html"><![CDATA[<h2 id="ES6、ES7、ES8、ES9、ES10、ES11、ES12新特性"><a href="#ES6、ES7、ES8、ES9、ES10、ES11、ES12新特性" class="headerlink" title="ES6、ES7、ES8、ES9、ES10、ES11、ES12新特性"></a>ES6、ES7、ES8、ES9、ES10、ES11、ES12新特性</h2><p>本文集合了 ES6 至 ES11 常用到的特性，包括还在规划的 ES12，只列举大概使用，详细介绍的话内容量将十分巨大<del>.</del>。PS：使用新特性需要使用最新版的 bable 就行转义</p><hr><h1 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a><strong>新特性</strong></h1><h2 id="ES6（2015）"><a href="#ES6（2015）" class="headerlink" title="ES6（2015）"></a><strong>ES6（2015）</strong></h2><h3 id="1-类（class）"><a href="#1-类（class）" class="headerlink" title="1. 类（class）"></a><strong>1. 类（class）</strong></h3><pre><code>class Man &#123;  constructor(name) &#123;    this.name = &#39;小豪&#39;;  &#125;  console() &#123;    console.log(this.name);  &#125;&#125;const man = new Man(&#39;小豪&#39;);man.console(); // 小豪</code></pre><h3 id="2-模块化-ES-Module"><a href="#2-模块化-ES-Module" class="headerlink" title="2. 模块化(ES Module)"></a><strong>2. 模块化(ES Module)</strong></h3><pre><code>// 模块 A 导出一个方法export const sub = (a, b) =&gt; a + b;// 模块 B 导入使用import &#123; sub &#125; from &#39;./A&#39;;console.log(sub(1, 2)); // 3</code></pre><h3 id="3-箭头（Arrow）函数"><a href="#3-箭头（Arrow）函数" class="headerlink" title="3. 箭头（Arrow）函数"></a><strong>3. 箭头（Arrow）函数</strong></h3><pre><code>const func = (a, b) =&gt; a + b;func(1, 2); // 3</code></pre><h3 id="4-函数参数默认值"><a href="#4-函数参数默认值" class="headerlink" title="4. 函数参数默认值"></a><strong>4. 函数参数默认值</strong></h3><pre><code>function foo(age = 25,)&#123; // ...&#125;</code></pre><h3 id="5-模板字符串"><a href="#5-模板字符串" class="headerlink" title="5. 模板字符串"></a><strong>5. 模板字符串</strong></h3><pre><code>const name = &#39;小豪&#39;;const str = `Your name is $&#123;name&#125;`;</code></pre><h3 id="6-解构赋值"><a href="#6-解构赋值" class="headerlink" title="6. 解构赋值"></a><strong>6. 解构赋值</strong></h3><pre><code>let a = 1, b= 2;[a, b] = [b, a]; // a 2  b 1</code></pre><h3 id="7-延展操作符"><a href="#7-延展操作符" class="headerlink" title="7. 延展操作符"></a><strong>7. 延展操作符</strong></h3><pre><code>let a = [...&#39;hello world&#39;]; // [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;]</code></pre><h3 id="8-对象属性简写"><a href="#8-对象属性简写" class="headerlink" title="8. 对象属性简写"></a><strong>8. 对象属性简写</strong></h3><pre><code>const name=&#39;小豪&#39;,const obj = &#123; name &#125;;</code></pre><h3 id="9-Promise"><a href="#9-Promise" class="headerlink" title="9. Promise"></a><strong>9. Promise</strong></h3><pre><code>Promise.resolve().then(() =&gt; &#123; console.log(2); &#125;);console.log(1);// 先打印 1 ，再打印 2</code></pre><h3 id="10-let和const"><a href="#10-let和const" class="headerlink" title="10. let和const"></a><strong>10. let和const</strong></h3><pre><code>let name = &#39;小豪&#39;；const arr = [];</code></pre><h2 id="ES7（2016）"><a href="#ES7（2016）" class="headerlink" title="ES7（2016）"></a><strong>ES7（2016）</strong></h2><h3 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1. Array.prototype.includes()"></a><strong>1. Array.prototype.includes()</strong></h3><pre><code>[1].includes(1); // true</code></pre><h3 id="2-指数操作符"><a href="#2-指数操作符" class="headerlink" title="2. 指数操作符"></a><strong>2. 指数操作符</strong></h3><pre><code>2**10; // 1024</code></pre><hr><h2 id="ES8（2017）"><a href="#ES8（2017）" class="headerlink" title="ES8（2017）"></a><strong>ES8（2017）</strong></h2><h3 id="1-async-await"><a href="#1-async-await" class="headerlink" title="1. async/await"></a><strong>1. async/await</strong></h3><p>异步终极解决方案</p><pre><code>async getData()&#123;    const res = await api.getTableData(); // await 异步任务    // do something    &#125;</code></pre><h3 id="2-Object-values"><a href="#2-Object-values" class="headerlink" title="2. Object.values()"></a><strong>2. Object.values()</strong></h3><pre><code>Object.values(&#123;a: 1, b: 2, c: 3&#125;); // [1, 2, 3]</code></pre><h3 id="3-Object-entries"><a href="#3-Object-entries" class="headerlink" title="3. Object.entries()"></a><strong>3. Object.entries()</strong></h3><pre><code>Object.entries(&#123;a: 1, b: 2, c: 3&#125;); // [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]</code></pre><h3 id="4-String-padding"><a href="#4-String-padding" class="headerlink" title="4. String padding"></a><strong>4. String padding</strong></h3><pre><code>// padStart&#39;hello&#39;.padStart(10); // &quot;     hello&quot;// padEnd&#39;hello&#39;.padEnd(10) &quot;hello     &quot;</code></pre><h3 id="5-函数参数列表结尾允许逗号"><a href="#5-函数参数列表结尾允许逗号" class="headerlink" title="5. 函数参数列表结尾允许逗号"></a><strong>5. 函数参数列表结尾允许逗号</strong></h3><h3 id="6-Object-getOwnPropertyDescriptors"><a href="#6-Object-getOwnPropertyDescriptors" class="headerlink" title="6. Object.getOwnPropertyDescriptors()"></a><strong>6. Object.getOwnPropertyDescriptors()</strong></h3><blockquote><p>获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。</p></blockquote><h3 id="7-SharedArrayBuffer对象"><a href="#7-SharedArrayBuffer对象" class="headerlink" title="7. SharedArrayBuffer对象"></a><strong>7. SharedArrayBuffer对象</strong></h3><blockquote><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，</p></blockquote><pre><code>/** *  * @param &#123;*&#125; length 所创建的数组缓冲区的大小，以字节(byte)为单位。 * @returns &#123;SharedArrayBuffer&#125; 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。 */new SharedArrayBuffer(10)</code></pre><h3 id="8-Atomics对象"><a href="#8-Atomics对象" class="headerlink" title="8. Atomics对象"></a><strong>8. Atomics对象</strong></h3><blockquote><p>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。</p></blockquote><hr><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="ES9（2018）"><a href="#ES9（2018）" class="headerlink" title="ES9（2018）"></a><strong>ES9（2018）</strong></h2><h3 id="1-异步迭代"><a href="#1-异步迭代" class="headerlink" title="1. 异步迭代"></a><strong>1. 异步迭代</strong></h3><p>await可以和for…of循环一起使用，以串行的方式运行异步操作</p><pre><code>async function process(array) &#123;  for await (let i of array) &#123;    // doSomething(i);  &#125;&#125;</code></pre><h3 id="2-Promise-finally"><a href="#2-Promise-finally" class="headerlink" title="2. Promise.finally()"></a><strong>2. Promise.finally()</strong></h3><pre><code>Promise.resolve().then().catch(e =&gt; e).finally();</code></pre><h3 id="3-Rest-Spread-属性"><a href="#3-Rest-Spread-属性" class="headerlink" title="3. Rest/Spread 属性"></a><strong>3. Rest/Spread 属性</strong></h3><pre><code>const values = [1, 2, 3, 5, 6];console.log( Math.max(...values) ); // 6</code></pre><h3 id="4-正则表达式命名捕获组"><a href="#4-正则表达式命名捕获组" class="headerlink" title="4. 正则表达式命名捕获组"></a><strong>4. 正则表达式命名捕获组</strong></h3><pre><code>const reg = /(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/;const match = reg.exec(&#39;2021-02-23&#39;);</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0eXyeV3DhlcSziaeQOfC1BD4fbFGHUKE0xaOw1OA4wFBS2eSyYpongxtIbX96j9fEw5F9vVOFYTcFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="5-正则表达式反向断言"><a href="#5-正则表达式反向断言" class="headerlink" title="5. 正则表达式反向断言"></a><strong>5. 正则表达式反向断言</strong></h3><pre><code>(?=p)、(?&lt;=p)  p 前面(位置)、p 后面(位置)(?!p)、(?&lt;!p&gt;) 除了 p 前面(位置)、除了 p 后面(位置)</code></pre><p>(?&lt;=w)</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0eXyeV3DhlcSziaeQOfC1BD4aZx6EK0wGkEJPaUAEBqbOSEEEBoIPVh7qQZDEI2VBdvV5uuralgoRQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>(?&lt;!w)</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0eXyeV3DhlcSziaeQOfC1BD4FxVOk82vM23akL4SFN018MWK8WajfL8PuyjVYh3UWAUoZgVMfIx07A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="6-正则表达式dotAll模式"><a href="#6-正则表达式dotAll模式" class="headerlink" title="6. 正则表达式dotAll模式"></a><strong>6. 正则表达式dotAll模式</strong></h3><blockquote><p>正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许行终止符的出现</p></blockquote><pre><code>/hello.world/.test(&#39;hello\nworld&#39;); // false</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0eXyeV3DhlcSziaeQOfC1BD4AfQsEJ47aG753VYERIeNDH0n4ZH66RWiaOtYibXzPfGsl0ibHXbt023mg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="ES10（2019）"><a href="#ES10（2019）" class="headerlink" title="ES10（2019）"></a><strong>ES10（2019）</strong></h2><h3 id="1-Array-flat-和Array-flatMap"><a href="#1-Array-flat-和Array-flatMap" class="headerlink" title="1. Array.flat()和Array.flatMap()"></a><strong>1. Array.flat()和Array.flatMap()</strong></h3><p>flat()</p><pre><code>[1, 2, [3, 4]].flat(Infinity); // [1, 2, 3, 4]</code></pre><p>flatMap()</p><pre><code>[1, 2, 3, 4].flatMap(a =&gt; [a**2]); // [1, 4, 9, 16]</code></pre><h3 id="2-String-trimStart-和String-trimEnd"><a href="#2-String-trimStart-和String-trimEnd" class="headerlink" title="2. String.trimStart()和String.trimEnd()"></a><strong>2. String.trimStart()和String.trimEnd()</strong></h3><p>去除字符串首尾空白字符</p><h3 id="3-String-prototype-matchAll"><a href="#3-String-prototype-matchAll" class="headerlink" title="3. String.prototype.matchAll"></a><strong>3. String.prototype.matchAll</strong></h3><blockquote><p>matchAll（）为所有匹配的匹配对象返回一个迭代器</p></blockquote><pre><code>const raw_arr = &#39;test1  test2  test3&#39;.matchAll((/t(e)(st(\d?))/g));const arr = [...raw_arr];</code></pre><h3 id="4-Symbol-prototype-description"><a href="#4-Symbol-prototype-description" class="headerlink" title="4. Symbol.prototype.description"></a><strong>4. Symbol.prototype.description</strong></h3><blockquote><p>只读属性，回 Symbol 对象的可选描述的字符串。</p></blockquote><pre><code>Symbol(&#39;description&#39;).description; // &#39;description&#39;</code></pre><h3 id="5-Object-fromEntries"><a href="#5-Object-fromEntries" class="headerlink" title="5. Object.fromEntries()"></a><strong>5. Object.fromEntries()</strong></h3><blockquote><p>返回一个给定对象自身可枚举属性的键值对数组</p></blockquote><pre><code>// 通过 Object.fromEntries， 可以将 Map 转化为 Object:const map = new Map([ [&#39;foo&#39;, &#39;bar&#39;], [&#39;baz&#39;, 42] ]);console.log(Object.fromEntries(map)); // &#123; foo: &quot;bar&quot;, baz: 42 &#125;</code></pre><h3 id="6-可选-Catch"><a href="#6-可选-Catch" class="headerlink" title="6. 可选 Catch"></a><strong>6. 可选 Catch</strong></h3><hr><h2 id="ES11（2020）"><a href="#ES11（2020）" class="headerlink" title="ES11（2020）"></a><strong>ES11（2020）</strong></h2><h3 id="1-Nullish-coalescing-Operator-空值处理"><a href="#1-Nullish-coalescing-Operator-空值处理" class="headerlink" title="1. Nullish coalescing Operator(空值处理)"></a><strong>1. Nullish coalescing Operator(空值处理)</strong></h3><p>表达式在 ?? 的左侧 运算符求值为undefined或null，返回其右侧。</p><pre><code>let user = &#123;    u1: 0,    u2: false,    u3: null,    u4: undefined    u5: &#39;&#39;,&#125;let u2 = user.u2 ?? &#39;用户2&#39;  // falselet u3 = user.u3 ?? &#39;用户3&#39;  // 用户3let u4 = user.u4 ?? &#39;用户4&#39;  // 用户4let u5 = user.u5 ?? &#39;用户5&#39;  // &#39;&#39;</code></pre><h3 id="2-Optional-chaining（可选链）"><a href="#2-Optional-chaining（可选链）" class="headerlink" title="2. Optional chaining（可选链）"></a><strong>2. Optional chaining（可选链）</strong></h3><p>?.用户检测不确定的中间节点</p><pre><code>let user = &#123;&#125;let u1 = user.childer.name // TypeError: Cannot read property &#39;name&#39; of undefinedlet u1 = user.childer?.name // undefined</code></pre><h3 id="3-Promise-allSettled"><a href="#3-Promise-allSettled" class="headerlink" title="3. Promise.allSettled"></a><strong>3. Promise.allSettled</strong></h3><blockquote><p>返回一个在所有给定的promise已被决议或被拒绝后决议的promise，并带有一个对象数组，每个对象表示对应的promise结果</p></blockquote><pre><code>const promise1 = Promise.resolve(3);const promise2 = 42;const promise3 = new Promise((resolve, reject) =&gt; reject(&#39;我是失败的Promise_1&#39;));const promise4 = new Promise((resolve, reject) =&gt; reject(&#39;我是失败的Promise_2&#39;));const promiseList = [promise1,promise2,promise3, promise4]Promise.allSettled(promiseList).then(values=&gt;&#123;  console.log(values)&#125;);</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0eXyeV3DhlcSziaeQOfC1BD4Ok2DTTaWpCraTLMeAtRicdy0F6cjZHG5cmEJcEFNMPzezejSJibLmKog/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="4-import"><a href="#4-import" class="headerlink" title="4. import()"></a><strong>4. import()</strong></h3><p>按需导入</p><h3 id="5-新基本数据类型BigInt"><a href="#5-新基本数据类型BigInt" class="headerlink" title="5. 新基本数据类型BigInt"></a><strong>5. 新基本数据类型BigInt</strong></h3><blockquote><p>任意精度的整数</p></blockquote><h3 id="6-globalThis"><a href="#6-globalThis" class="headerlink" title="6. globalThis"></a><strong>6. globalThis</strong></h3><ul><li>浏览器：window</li><li>worker：self</li><li>node：global</li></ul><h2 id="ES12（2021）"><a href="#ES12（2021）" class="headerlink" title="ES12（2021）"></a><strong>ES12（2021）</strong></h2><h3 id="1-replaceAll"><a href="#1-replaceAll" class="headerlink" title="1. replaceAll"></a><strong>1. replaceAll</strong></h3><blockquote><p>返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉</p></blockquote><pre><code>const str = &#39;hello world&#39;;str.replaceAll(&#39;l&#39;, &#39;&#39;); // &quot;heo word&quot;</code></pre><h3 id="2-Promise-any"><a href="#2-Promise-any" class="headerlink" title="2. Promise.any"></a><strong>2. Promise.any</strong></h3><blockquote><p>Promise.any() 接收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise</p></blockquote><pre><code>const promise1 = new Promise((resolve, reject) =&gt; reject(&#39;我是失败的Promise_1&#39;));const promise2 = new Promise((resolve, reject) =&gt; reject(&#39;我是失败的Promise_2&#39;));const promiseList = [promise1, promise2];Promise.any(promiseList).then(values=&gt;&#123;  console.log(values);&#125;).catch(e=&gt;&#123;  console.log(e);&#125;);</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0eXyeV3DhlcSziaeQOfC1BD4lt4KQZdfNJsf0xauWce8C915PDbDFn0Nnhulsq89ib0JTvmO6S4RHBg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="3-WeakRefs"><a href="#3-WeakRefs" class="headerlink" title="3. WeakRefs"></a><strong>3. WeakRefs</strong></h3><blockquote><p>使用WeakRefs的Class类创建对对象的弱引用(对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为)</p></blockquote><h3 id="4-逻辑运算符和赋值表达式"><a href="#4-逻辑运算符和赋值表达式" class="headerlink" title="4. 逻辑运算符和赋值表达式"></a><strong>4. 逻辑运算符和赋值表达式</strong></h3><blockquote><p>逻辑运算符和赋值表达式，新特性结合了逻辑运算符（&amp;&amp;，||，??）和赋值表达式而JavaScript已存在的 复合赋值运算符有：</p></blockquote><pre><code>a ||= b//等价于a = a || (a = b)a &amp;&amp;= b//等价于a = a &amp;&amp; (a = b)a ??= b//等价于a = a ?? (a = b)</code></pre><h3 id="5-数字分隔符"><a href="#5-数字分隔符" class="headerlink" title="5. 数字分隔符"></a><strong>5. 数字分隔符</strong></h3><blockquote><p>数字分隔符，可以在数字之间创建可视化分隔符，通过_下划线来分割数字，使数字更具可读性</p></blockquote><pre><code>const money = 1_000_000_000;//等价于const money = 1000000000;1_000_000_000 === 1000000000; // true</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0eXyeV3DhlcSziaeQOfC1BD4z9GDBholQBmLqRUNNnGbqick6aHVslKQeib6HsXuTluibhTibWjFFT7BIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>作者：小豪看世界</p><p>来源：SegmentFault 思否社区</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> ES7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>52 条 SQL 语句性能优化策略</title>
      <link href="2021/03/01/niuke/sql/sql-lin-shi-biao-he-biao-bian-liang/"/>
      <url>2021/03/01/niuke/sql/sql-lin-shi-biao-he-biao-bian-liang/</url>
      
        <content type="html"><![CDATA[<h1 id="52-条-SQL-语句性能优化策略"><a href="#52-条-SQL-语句性能优化策略" class="headerlink" title="52 条 SQL 语句性能优化策略"></a>52 条 SQL 语句性能优化策略</h1><p><strong><em>\</em>-   52 条 SQL 语句性能优化策略   -**</strong></p><p>1、对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。</p><p>2、应尽量避免在where子句中对字段进行null值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默认值。</p><p>3、应尽量避免在where子句中使用!=或&lt;&gt;操作符，MySQL只有对以下操作符才使用索引：&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE。</p><p>4、应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用UNION合并查询：select id from t where num=10 union all select id from t where num=20。</p><p>5、in和not in也要慎用，否则会导致全表扫描，对于连续的数值，能用between就不要用in了：Select id from t where num between 1 and 3。</p><p>6、下面的查询也将导致全表扫描：select id from t where name like‘%abc%’或者select id from t where name like‘%abc’若要提高效率，可以考虑全文检索。而select id from t where name like‘abc%’才用到索引。</p><p>7、如果在where子句中使用参数，也会导致全表扫描。</p><p>8、应尽量避免在where子句中对字段进行表达式操作，应尽量避免在where子句中对字段进行函数操作。</p><p>9、很多时候用exists代替in是一个好的选择：select num from a where num in(select num from b)。用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)。</p><p>10、索引固然可以提高相应的select的效率，但同时也降低了insert及update的效率，因为insert或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><p>11、应尽可能的避免更新clustered索引数据列， 因为clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新clustered索引数据列，那么需要考虑是否应将该索引建为clustered索引。</p><p>12、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</p><p>13、尽可能的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>14、最好不要使用”“返回所有：select from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p><p>15、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p><p>16、使用表的别名(Alias)：当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个Column上。这样一来，就可以减少解析的时间并减少那些由Column歧义引起的语法错误。</p><p>17、使用“临时表”暂存中间结果 ：</p><p>简化SQL语句的重要方法就是采用临时表暂存中间结果，但是临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。</p><p>18、一些SQL查询语句应加上nolock，读、写是会相互阻塞的，为了提高并发性能，对于一些查询，可以加上nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。</p><p>使用nolock有3条原则：</p><ul><li>查询的结果用于“插、删、改”的不能加nolock；</li><li>查询的表属于频繁发生页分裂的，慎用nolock ；</li><li>使用临时表一样可以保存“数据前影”，起到类似Oracle的undo表空间的功能，能采用临时表提高并发性能的，不要用nolock。</li></ul><p>19、常见的简化规则如下：</p><p>不要有超过5个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。少用子查询，视图嵌套不要过深，一般视图嵌套不要超过2个为宜。</p><p>20、将需要查询的结果预先计算好放在表中，查询的时候再Select。这在SQL7.0以前是最重要的手段，例如医院的住院费计算。</p><p>21、用OR的字句可以分解成多个查询，并且通过UNION 连接多个查询。他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用UNION all执行的效率更高。多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。</p><p>22、在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。</p><p>23、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。</p><p>存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL，可以使用临时存储过程，该过程（临时表）被放在Tempdb中。</p><p>24、当服务器的内存够多时，配制线程数量 = 最大连接数+5，这样能发挥最大的效率；否则使用 配制线程数量&lt;最大连接数启用SQL SERVER的线程池来解决，如果还是数量 = 最大连接数+5，严重的损害服务器的性能。</p><p>25、查询的关联同写的顺序 ：</p><p>select a.personMemberID, * from chineseresume a,personmember b where personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ （A = B ,B = ‘号码’） </p><p>select a.personMemberID, * from chineseresume a,personmember b where a.personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ and b.referenceid = ‘JCNPRH39681’ （A = B ,B = ‘号码’， A = ‘号码’） </p><p>select a.personMemberID, * from chineseresume a,personmember b where b.referenceid = ‘JCNPRH39681’ and a.personMemberID = ‘JCNPRH39681’ （B = ‘号码’， A = ‘号码’）</p><p>26、尽量使用exists代替select count(1)来判断是否存在记录，count函数只有在统计表中所有行数时使用，而且count(1)比count(*)更有效率。</p><p>27、尽量使用“&gt;=”，不要使用“&gt;”。</p><p>28、索引的使用规范：</p><ul><li>索引的创建要与应用结合考虑，建议大的OLTP表不要超过6个索引；</li><li>尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index_name来强制指定索引；</li><li>避免对大表查询时进行table scan，必要时考虑新建索引；</li><li>在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用；</li><li>要注意索引的维护，周期性重建索引，重新编译存储过程。　　</li></ul><p>29、下列SQL条件语句中的列都建有恰当的索引，但执行速度却非常慢： </p><p>SELECT * FROM record WHERE substrINg(card_no,1,4)=’5378’ (13秒) </p><p>SELECT * FROM record WHERE amount/30&lt; 1000 （11秒） </p><p>SELECT * FROM record WHERE convert(char(10),date,112)=’19991201’ （10秒） </p><p><strong>分析：</strong> </p><p>WHERE子句中对列的任何操作结果都是在SQL运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引。</p><p>如果这些结果在查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免表搜索，因此将SQL重写成下面这样： </p><p>SELECT * FROM record WHERE card_no like ‘5378%’ （&lt; 1秒） </p><p>SELECT * FROM record WHERE amount&lt; 1000*30 （&lt; 1秒） </p><p>SELECT * FROM record WHERE date= ‘1999/12/01’ （&lt; 1秒）</p><p>30、当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新。</p><p>31、在所有的存储过程中，能够用SQL语句的，我绝不会用循环去实现。</p><p>例如：列出上个月的每一天，我会用connect by去递归查询一下，绝不会去用循环从上个月第一天到最后一天。</p><p>32、选择最有效率的表名顺序（只在基于规则的优化器中有效）： </p><p>Oracle的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表（基础表 driving table）将被最先处理，在FROM子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。</p><p>如果有3个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表。</p><p>33、提高GROUP BY语句的效率，可以通过将不需要的记录在GROUP BY之前过滤掉。下面两个查询返回相同结果，但第二个明显就快了许多。 </p><p>低效：</p><p>SELECT JOB , AVG(SAL) </p><p>FROM EMP </p><p>GROUP BY JOB </p><p>HAVING JOB =’PRESIDENT’ </p><p>OR JOB =’MANAGER’ </p><p>高效: </p><p>SELECT JOB , AVG(SAL) </p><p>FROM EMP </p><p>WHERE JOB =’PRESIDENT’ </p><p>OR JOB =’MANAGER’ </p><p>GROUP BY JOB</p><p>34、SQL语句用大写，因为Oracle总是先解析SQL语句，把小写的字母转换成大写的再执行。</p><p>35、别名的使用，别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询速度要比建连接表快1.5倍。</p><p>36、避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序；事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量；永远不要在事务中等待用户输入。</p><p>37、避免使用临时表，除非却有需要，否则应尽量避免使用临时表，相反，可以使用表变量代替；大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在TempDb数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。</p><p>38、最好不要使用触发器：</p><ul><li>触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程；</li><li>如果能够使用约束实现的，尽量不要使用触发器；</li><li>不要为不同的触发事件(Insert，Update和Delete)使用相同的触发器；</li><li>不要在触发器中使用事务型代码。</li></ul><p>39、索引创建规则： </p><ul><li>表的主键、外键必须有索引； </li><li>数据量超过300的表应该有索引； </li><li>经常与其他表进行连接的表，在连接字段上应该建立索引； </li><li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引； </li><li>索引应该建在选择性高的字段上； </li><li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； </li><li>复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替； </li><li>正确选择复合索引中的主列字段，一般是选择性较好的字段； </li><li>复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引； </li><li>如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引； </li><li>如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段； </li><li>如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引； </li><li>频繁进行数据操作的表，不要建立太多的索引； </li><li>删除无用的索引，避免对执行计划造成负面影响； </li><li>表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。 </li><li>尽量不要对数据库中某个含有大量重复的值的字段建立索引。</li></ul><p>40、MySQL查询优化总结：</p><p>使用慢查询日志去发现慢查询，使用执行计划去判断查询是否正常运行，总是去测试你的查询看看是否他们运行在最佳状态下。</p><p>久而久之性能总会变化，避免在整个表上使用count(*)，它可能锁住整张表，使查询保持一致以便后续相似的查询可以使用查询缓存，在适当的情形下使用GROUP BY而不是DISTINCT，在WHERE、GROUP BY和ORDER BY子句中使用有索引的列，保持索引简单，不在多个索引中包含同一个列。</p><p>有时候MySQL会使用错误的索引，对于这种情况使用USE INDEX，检查使用SQL_MODE=STRICT的问题，对于记录数小于5的索引字段，在UNION的时候使用LIMIT不是是用OR。 </p><p>为了避免在更新前SELECT，使用INSERT ON DUPLICATE KEY或者INSERT IGNORE，不要用UPDATE去实现，不要使用MAX，使用索引字段和ORDER BY子句，LIMIT M，N实际上可以减缓查询在某些情况下，有节制地使用，在WHERE子句中使用UNION代替子查询，在重新启动的MySQL，记得来温暖你的数据库，以确保数据在内存和查询速度快，考虑持久连接，而不是多个连接，以减少开销。</p><p>基准查询，包括使用服务器上的负载，有时一个简单的查询可以影响其他查询，当负载增加在服务器上，使用SHOW PROCESSLIST查看慢的和有问题的查询，在开发环境中产生的镜像数据中测试的所有可疑的查询。</p><p>41、MySQL备份过程：</p><ul><li>从二级复制服务器上进行备份；</li><li>在进行备份期间停止复制，以避免在数据依赖和外键约束上出现不一致；</li><li>彻底停止MySQL，从数据库文件进行备份；</li><li>如果使用MySQL dump进行备份，请同时备份二进制日志文件 – 确保复制没有中断；</li><li>不要信任LVM快照，这很可能产生数据不一致，将来会给你带来麻烦；</li><li>为了更容易进行单表恢复，以表为单位导出数据——如果数据是与其他表隔离的。 </li><li>当使用mysqldump时请使用–opt；</li><li>在备份之前检查和优化表；</li><li>为了更快的进行导入，在导入时临时禁用外键约束。；</li><li>为了更快的进行导入，在导入时临时禁用唯一性检测；</li><li>在每一次备份后计算数据库，表以及索引的尺寸，以便更够监控数据尺寸的增长；</li><li>通过自动调度脚本监控复制实例的错误和延迟；</li><li>定期执行备份。</li></ul><p>42、查询缓冲并不自动处理空格，因此，在写SQL语句时，应尽量减少空格的使用，尤其是在SQL首和尾的空格（因为查询缓冲并不自动截取首尾空格）。</p><p>43、member用mid做标准进行分表方便查询么？一般的业务需求中基本上都是以username为查询依据，正常应当是username做hash取模来分表。</p><p>而分表的话MySQL的partition功能就是干这个的，对代码是透明的；在代码层面去实现貌似是不合理的。</p><p>44、我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。</p><p>45、在所有的存储过程和触发器的开始处设置SET NOCOUNT ON，在结束时设置SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC消息。</p><p>46、MySQL查询可以启用高速查询缓存。这是提高数据库性能的有效MySQL优化方法之一。当同一个查询被执行多次时，从缓存中提取数据和直接从数据库中返回数据快很多。</p><p>47、EXPLAIN SELECT查询用来跟踪查看效果：</p><p>使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的。</p><p>48、当只要一行数据时使用LIMIT 1 ：</p><p>当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。</p><p>在这种情况下，加上LIMIT 1可以增加性能。这样一来，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。</p><p>49、选择表合适存储引擎： </p><ul><li><p>myisam：应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。 </p></li><li><p>InnoDB：事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（InnoDB有效地降低删除和更新导致的锁定）。</p><p>对于支持事务的InnoDB类型的表来说，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行SQL前调用begin，多条SQL形成一个事物（即使autocommit打开也可以），将大大提高性能。</p></li></ul><p>50、优化表的数据类型，选择合适的数据类型： </p><p>原则：更小通常更好，简单就好，所有字段都得有默认值，尽量避免null。 </p><p>例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型。(mediumint就比int更合适) </p><p>比如时间字段：datetime和timestamp，datetime占用8个字节，而timestamp占用4个字节，只用了一半，而timestamp表示的范围是1970—2037适合做更新时间 </p><p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。 </p><p>因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p><p>例如：在定义邮政编码这个字段时，如果将其设置为CHAR(255)，显然给数据库增加了不必要的空间。甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。</p><p>同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段，应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。 </p><p>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p><p>51、字符串数据类型：char，varchar，text选择区别。</p><p>52、任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。</p><p>转载于<a href="https://mp.weixin.qq.com/s/thMEKUvGUzznzbr8K0g5Rg">https://mp.weixin.qq.com/s/thMEKUvGUzznzbr8K0g5Rg</a></p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript入门</title>
      <link href="2021/03/01/niuke/qianduan/ts-kuai-su-ru-men/"/>
      <url>2021/03/01/niuke/qianduan/ts-kuai-su-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript入门"><a href="#TypeScript入门" class="headerlink" title="TypeScript入门"></a>TypeScript入门</h1><h2 id="1：TypeScript简介"><a href="#1：TypeScript简介" class="headerlink" title="1：TypeScript简介"></a>1：TypeScript简介</h2><p>中文官网：<a href="http://www.tslang.cn/">http://www.tslang.cn</a></p><p>英文官网<a href="http://www.typescriptlang.org/">http://www.typescriptlang.org</a></p><p>学习前景：</p><ol><li><p>Egret游戏开发工程师20-40K  h5游戏开发</p></li><li><p>angular  vue</p></li><li><p>typescript-&gt;  ES6 ES7  ES8</p></li><li><p>后台协作</p></li><li><p>大幅度提升工作效率，减少错误</p></li></ol><h2 id="2：开始使用ts"><a href="#2：开始使用ts" class="headerlink" title="2：开始使用ts"></a>2：开始使用ts</h2><p>安装node</p><p>安装TypeScript编译环境 npm install -g typescript</p><p>tsc helloworld.ts</p><h2 id="3-class导入-import-“-second”"><a href="#3-class导入-import-“-second”" class="headerlink" title="3.class导入 import “./second”"></a>3.class导入 import “./second”</h2><h2 id="4-ts项目开发编译配置"><a href="#4-ts项目开发编译配置" class="headerlink" title="4.ts项目开发编译配置"></a>4.ts项目开发编译配置</h2><pre><code>tsc --init</code></pre><p>tsconfig.json</p><pre><code>&quot;files&quot;:[    &quot;helloworld.ts&quot;,    &quot;main.ts&quot;],//编译的文件&quot;outDir&quot;:&quot;./dist&quot;, //输出目录</code></pre><h2 id="5-使用ts操作html"><a href="#5-使用ts操作html" class="headerlink" title="5.使用ts操作html"></a>5.使用ts操作html</h2><pre><code>document.body.innerHtml();</code></pre><h2 id="6-常见数据类型：-类型检查严格"><a href="#6-常见数据类型：-类型检查严格" class="headerlink" title="6.常见数据类型： 类型检查严格"></a>6.常见数据类型： 类型检查严格</h2><pre><code>//先定义let username:string =&quot;dabing&quot;;let age:number=12;//默认 any类型</code></pre><h2 id="7-枚举类型"><a href="#7-枚举类型" class="headerlink" title="7.枚举类型"></a>7.枚举类型</h2><pre><code>let arrNum:number[]=[12,3,,6,9];//混合let MixArr:(number|string)[] =[&#39;123&#39;,&#39;hah&#39;,15]//枚举enum Direction &#123;    up =38;    down, //39    left, //40    right //41&#125;//自动赋值function paly(dir:Direction)&#123;    if(dir==38)&#123;        console.log(&quot;向上&quot;)    &#125;else&#123;        connsole.log(dir);    &#125;&#125;play(666);</code></pre><h2 id="8-函数参数与强类型"><a href="#8-函数参数与强类型" class="headerlink" title="8.函数参数与强类型"></a>8.函数参数与强类型</h2><pre><code>function showIfno(age:number):number&#123;    return age;&#125;</code></pre><h2 id="9-class创建、实例化、属性、方法"><a href="#9-class创建、实例化、属性、方法" class="headerlink" title="9.class创建、实例化、属性、方法"></a>9.class创建、实例化、属性、方法</h2><pre><code>class Person&#123;    name:string;    age:number;    food:string =&#39;剁椒鱼头&#39;;    private money:nummber=2000;    constructor(name:string,age:number)&#123;        this.name =name;        this.age=age;    &#125;    favoriteFood()&#123;        return this.food;    &#125;    makeMoney(salary:number):number&#123;        return this.money +=salary;    &#125;&#125;//实例化let dabingge =new Person(&#39;dabing&#39;,28);console.log(dabingge.makeMoney(99));</code></pre><h2 id="10-类继承"><a href="#10-类继承" class="headerlink" title="10.类继承"></a>10.类继承</h2><pre><code>class binSons extends Person&#123;    isRich:boolean =true;    constructor(name:string,age:number)&#123;        suber(name,age);    &#125;&#125;let bigSon = new bigSons(&#39;dabing&#39;,20)console.log(bigSon.favariteFood());</code></pre><h2 id="11-抽象类"><a href="#11-抽象类" class="headerlink" title="11.抽象类"></a>11.抽象类</h2><pre><code>abstract class Jigoubiaozhun&#123;    abstract jigouName:string;    age:number =50;    abstract showMoney(money:number):number;&#125;class shamoChild extends Jigoubiaozhun&#123;    public jigouName =&quot;沙漠挖金基金协会&quot;；    private money :number=50000;    shouwMoney():number&#123;        return this.money;    &#125;    constructor(name:string,age:number)&#123;        super(name,age);    &#125;&#125;</code></pre><h2 id="12-接口-约束"><a href="#12-接口-约束" class="headerlink" title="12.接口  约束"></a>12.接口  约束</h2><pre><code>interface girl&#123;    dongshi:boolean;    job:string;    tenNi():boolean;&#125;class girlFriend implements girl&#123;    dongshi =true;    job=&quot;good&quot;;    tenNi():boolean&#123;        return true;    &#125;&#125;let CuiHua = new girlFriend();console.log(CuiHua.job);</code></pre><h2 id="13-泛型-gt-安全"><a href="#13-泛型-gt-安全" class="headerlink" title="13.泛型-&gt; 安全"></a>13.泛型-&gt; 安全</h2><pre><code>function showData(person any)&#123;    return person;&#125;//不安全function shoWData&lt;T&gt;(person T)&#123;    return person;&#125;shoWData([21,32,4]).length;const arr:Array&lt;number&gt; = [12,5,6];function showArr&lt;T&gt;(data:T[])&#123;    for(let i =0;i&lt;data.length;i++)&#123;        console.log(data);    &#125;&#125;</code></pre><h2 id="14-装饰器-decorator"><a href="#14-装饰器-decorator" class="headerlink" title="14.装饰器  decorator"></a>14.装饰器  decorator</h2><pre><code>tsconfig.json&#123;    &quot;compilerOpeions&quot;:&#123;        &quot;experimentalDecorators&quot;:true,    &#125;&#125;</code></pre><pre><code>function hasKey(constructor:Function)&#123;    console.log(&#39;kkkkk&#39;);&#125;@hasKeyclass Person&#123;    name:string;    age:number;    constructor(name:string,age:number)&#123;        this.name=name;        this.age=age;        console.log(&#39;我是‘+name+&#39;今年&#39;+age+&#39;岁&#39;);    &#125;&#125;const baifumei = new Person(&#39;baifumei&#39;,18);console.log(baifumei);</code></pre><h2 id="15-模块化的定义与导入"><a href="#15-模块化的定义与导入" class="headerlink" title="15.模块化的定义与导入"></a>15.模块化的定义与导入</h2><p>为了代码的简洁</p><p>参考视频：<a href="https://www.bilibili.com/video/BV1Wt411V7yc?p=12&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1Wt411V7yc?p=12&amp;spm_id_from=pageDriver</a></p><p>根据参数学习视频总结</p>]]></content>
      
      
      <categories>
          
          <category> TypeScrip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScrip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js面向对象</title>
      <link href="2021/02/28/niuke/qianduan/js-oo/"/>
      <url>2021/02/28/niuke/qianduan/js-oo/</url>
      
        <content type="html"><![CDATA[<h1 id="js面向对象"><a href="#js面向对象" class="headerlink" title="js面向对象"></a>js面向对象</h1><h1 id="创建对象的三种方式"><a href="#创建对象的三种方式" class="headerlink" title="创建对象的三种方式"></a>创建对象的三种方式</h1><h2 id="1-单体模式"><a href="#1-单体模式" class="headerlink" title="1.单体模式"></a>1.单体模式</h2><pre><code>var Teacher =&#123;    name:&quot;大兵&quot;，    age:18,    showName:function()&#123;        return this.name;    &#125;&#125;Teacher.showName();</code></pre><h2 id="2-原型模式-ES5"><a href="#2-原型模式-ES5" class="headerlink" title="2.原型模式 ES5"></a>2.原型模式 ES5</h2><p>属性放在构造函数里，方法放在原型上</p><pre><code>function Teacher(name,age)&#123;    this.name =name;    this.age=age;&#125;Teacher.prototype.showName =function()&#123;    return this.name;&#125;var dabinge = new Teacher(&#39;dabing&#39;,18);dabinge.showName();</code></pre><h2 id="3-伪类模式（class）-ES6推荐"><a href="#3-伪类模式（class）-ES6推荐" class="headerlink" title="3.伪类模式（class） ES6推荐"></a>3.伪类模式（class） ES6推荐</h2><pre><code>class Teacher&#123;    constructor(name,age)&#123;        this.name = name;        this.age=age;    &#125;    showName()&#123;        return this.name;    &#125;&#125;var dabinge = new Teacher(&#39;dabing&#39;,18);dabinge.showName();</code></pre><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><pre><code>var Teacher =&#123;    name:&quot;大兵&quot;，    age:18,    job:&#39;10year&#39;    showName:function()&#123;        return this.name;    &#125;&#125;var student =Object.create(Teacher);student.name =&#39;wangteichui&#39;;student.job = &#39;2Month&#39;;conssole.log(student.showName());student.showJob = funtion(job)&#123;    return this.job;&#125;conssole.log(student.showJob());</code></pre><pre><code>class Person()&#123;    constructor(name,age)&#123;        this.name =name;        this.age=age;    &#125;    showName()&#123;        return this.name;    &#125;&#125;class Teacher extends Person&#123;    constructor(name,age,job)&#123;        super(name,age);        this.job= job;    &#125;    showInof()&#123;        return this.job +&#39;---&#39;+super.showName();    &#125;&#125;var t1 = new Teacher(&#39;dabing&#39;,18,&#39;搬砖&#39;);t1.showInfo();</code></pre><p>面试原理，工作必须会技术，数据交互 跨域</p><p>1.JSONP原理</p><pre><code>1.js是可以跨域2.服务器返回的数据，show([12,5,8])3.本地 方法的定义function show(data)&#123;    console.log(data);&#125;JSONP只能get方式</code></pre><p>2.CROS</p><pre><code>必须需要服务器端配合，否则没戏access-alow</code></pre><p>基本数据类型</p><p>数据类型转换</p><p>isNaN</p><p>严格模式</p><p>作用域</p><p>时间</p><p>对象</p><p>数据交互</p><p>————————前端就业方向——–</p><p>新闻  :数据交互,JSONP,AJAX,fetch,promise</p><p>00编程  -框架vue。。</p><p>游戏： canvas动画</p><p>数据可视化绘图（地图）：webgl</p>]]></content>
      
      
      <categories>
          
          <category> js面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网华为机试01</title>
      <link href="2021/02/28/niuke/suanfa/huaweijs-00/"/>
      <url>2021/02/28/niuke/suanfa/huaweijs-00/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客网华为机试在线训练JavaScript-V8-版-01"><a href="#牛客网华为机试在线训练JavaScript-V8-版-01" class="headerlink" title="牛客网华为机试在线训练JavaScript(V8)版 01"></a>牛客网华为机试在线训练JavaScript(V8)版 01</h1><h2 id="注意！输入得到的都是字符串"><a href="#注意！输入得到的都是字符串" class="headerlink" title="注意！输入得到的都是字符串"></a>注意！输入得到的都是字符串</h2><blockquote><p>// 单行<br>var line = readline(); //获得的是一个字符串<br>//如果需要对其进行处理，比如 “1 2 3 4 5”，我们想以数组形式获取每个数字<br>var arr = line.split(“ “); // 数组内元素为字符串，eg: arr[0]=”1”</p><p>// 多行<br>// 如果每一行的操作相同<br>while(line = readline()){<br>    // 代码<br>}<br>/<em>如果每一行操作不同<br>eg: 第一行给数组长度<br>     第二行给用空格分开的字符串<br>那就每一次按照单行输入的方式来获取即可</em>/<br>var num = parseInt(readline()); // 获得数组长度<br>var arr = readline().split(“ “); // 获得数组</p></blockquote><h2 id="HJ1-计算字符串最后一个单词的长度（易）-字符串-split"><a href="#HJ1-计算字符串最后一个单词的长度（易）-字符串-split" class="headerlink" title="HJ1.计算字符串最后一个单词的长度（易）(字符串) split"></a>HJ1.计算字符串最后一个单词的长度（易）(字符串) split</h2><p><strong>计算字符串最后一个单词的长度，单词以空格隔开。(<a href="https://www.nowcoder.com/questionCenter?questionTypes=000100&mutiTagIds=579">字符串</a>)</strong><br>输入描述:<br>输入一行，代表要计算的字符串，非空，长度小于5000。<br>输出描述:<br>输出一个整数，表示输入字符串最后一个单词的长度。<br>示例1<br>输入:hello nowcoder<br>输出:8<br>解答：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span> <span class="token punctuation">(</span>line <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> stringlist  <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> lastlen <span class="token operator">=</span>stringlist<span class="token punctuation">[</span>stringlist<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>lastlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="HJ2-计算字符个数-字符串-toLowerCase（易）"><a href="#HJ2-计算字符个数-字符串-toLowerCase（易）" class="headerlink" title="HJ2.计算字符个数(字符串)toLowerCase（易）"></a>HJ2.计算字符个数(字符串)toLowerCase（易）</h2><p><strong>写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字母，然后输出输入字符串中该字母的出现次数。不区分大小写。 (字符串，哈希）</strong><br>输入描述:第一行输入一个由字母和数字以及空格组成的字符串，第二行输入一个字母。<br>输出描述:输出输入字符串中含有该字符的个数。<br>示例1<br>输入<br>ABCabc<br>A<br>输出2<br>解答</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> aStr <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> bStr <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> aStr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>aStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> bStr<span class="token punctuation">)</span><span class="token punctuation">{</span>    count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="HJ3-易-明明的随机数-数组，排序，去重"><a href="#HJ3-易-明明的随机数-数组，排序，去重" class="headerlink" title="HJ3.[易]明明的随机数 数组，排序，去重"></a>HJ3.[易]明明的随机数 <a href="%E6%95%B0%E7%BB%84">数组，排序，去重</a></h2><p><strong>题目描述</strong><br>   明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 </p><p>  注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 当没有新的输入时，说明输入结束。<br><strong>输入描述:</strong></p><pre><code>注意：输入可能有多组数据。每组数据都包括多行，第一行先输入随机整数的个数N，接下来的N行再输入相应个数的整数。具体格式请看下面的&quot;示例&quot;。</code></pre><p><strong>输出描述:</strong></p><pre><code>返回多行，处理后的结果</code></pre><p>示例1<br><strong>输入</strong></p><pre><code>322111102040326740208930040015</code></pre><p><strong>输出</strong></p><pre><code>1210152032406789300400</code></pre><p>说明</p><pre><code>样例输入解释：样例有两组测试第一组是3个数字，分别是：2，2，1。第二组是11个数字，分别是：10，20，40，32，67，40，20，89，300，400，15。 </code></pre><p>解答：<br>每组分段返回</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> lines <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">var</span> scoreList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>line <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">if</span><span class="token punctuation">(</span>lines <span class="token operator">==</span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>     lines <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">outPut</span><span class="token punctuation">(</span>scoreList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>     lines<span class="token operator">--</span><span class="token punctuation">;</span>     scoreList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">outPut</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span> arr <span class="token operator">=</span> <span class="token function">unique</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">return</span> a<span class="token operator">-</span>b<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>通过解答</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span><span class="token punctuation">(</span>line<span class="token operator">=</span><span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> arr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>line<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span> <span class="token keyword">var</span> tSet<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">var</span> setSort<span class="token operator">=</span>tSet<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> a<span class="token operator">-</span>b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>setSort<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>setSort<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>查看其他解法</strong>：总体利用一个数组，很好的利用数组下标排序的</p><pre><code>while(num = parseInt(readline()))&#123;    //利用数组下标的特性，存入数据表示有此数值    let arr =[];    for(let i = 0;i&lt;num;i++)&#123;        let temp = parseInt(readline());           arr[temp] = 1;    &#125;    //遍历数组，如果有标记，则输出下标    arr.forEach((val,index)=&gt;&#123;        if(val===1)&#123;            console.log(index)        &#125;    &#125;)&#125;</code></pre><pre><code>while(num = readline())&#123;    //利用对象的属性    const obj = &#123;&#125;;    while(num--)&#123;       const number = readline();       if(!obj[number])&#123;           obj[number]=1;       &#125;    &#125;    for(let result in obj)&#123;        console.log(result)    &#125; &#125;</code></pre><h2 id="HJ4-字符串-字符串分隔（中）"><a href="#HJ4-字符串-字符串分隔（中）" class="headerlink" title="HJ4(字符串) 字符串分隔（中）"></a>HJ4(字符串) <strong>字符串分隔</strong>（中）</h2><p><strong>题目描述</strong></p><p>  •连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；<br> •长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。  </p><p><strong>输入描述:</strong></p><pre><code>连续输入字符串(输入多次,每个字符串长度小于100)</code></pre><p>输出描述:</p><pre><code>输出到长度为8的新字符串数组</code></pre><p>输入</p><pre><code>abc123456789</code></pre><p>输出</p><pre><code>abc000001234567890000000</code></pre><p> 解答：</p><p>第一次</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> arr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>line<span class="token operator">=</span><span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> strLength <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//取整取完整的行数</span> <span class="token keyword">var</span> N <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>strLength<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">var</span> mLast <span class="token operator">=</span> strLength<span class="token operator">-</span>N<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//最后需要补充的数目</span> <span class="token keyword">var</span> addnum <span class="token operator">=</span><span class="token number">8</span><span class="token operator">-</span>mLast<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出整行的数据</span> <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//输出补充的数据</span> <span class="token keyword">if</span><span class="token punctuation">(</span>mLast<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">var</span> sstr<span class="token operator">=</span><span class="token string">'0'</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>addnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sstr<span class="token operator">+</span><span class="token operator">=</span><span class="token string">'0'</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">var</span> firstr <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">,</span>strLength<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">print</span><span class="token punctuation">(</span> firstr <span class="token operator">+</span> sstr<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>参考</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> q<span class="token operator">=</span><span class="token string">'00000000'</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token operator">&lt;=</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> t<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>q<span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>     <span class="token keyword">var</span> len<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">+</span><span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">var</span> s<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">var</span> p<span class="token operator">=</span>s<span class="token operator">+</span>q<span class="token punctuation">;</span>             console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span><span class="token punctuation">(</span>line <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> line<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ans <span class="token operator">=</span> ans <span class="token operator">+</span> line<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">''</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span>length <span class="token operator">>=</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>               <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">8</span> <span class="token operator">&amp;&amp;</span> ans<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> ans <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'0'</span>        <span class="token function">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token punctuation">}</span></code></pre><p>最佳：先加8位0，然后只取前面整除的部分</p><pre><code>while(str=readline())&#123;    str +=&#39;0000000&#39;    const length = Math.floor(str.length/8)    for(i=0;i&lt;length;i++)&#123;        console.log(str.substr(i*8,8))    &#125;&#125;</code></pre><h2 id="HJ5-字符串-进制转换（易）"><a href="#HJ5-字符串-进制转换（易）" class="headerlink" title="HJ5(字符串)进制转换（易）"></a>HJ5(字符串)进制转换（易）</h2><p><strong>题目描述</strong></p><p>  写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。 </p><p><strong>输入描述:</strong></p><pre><code>输入一个十六进制的数值字符串。注意：一个用例会同时有多组输入数据，请参考帖子https://www.nowcoder.com/discuss/276处理多组输入的问题。</code></pre><p>输出描述:</p><pre><code>输出该数值的十进制字符串。不同组的测试用例用\n隔开。</code></pre><p>输入</p><pre><code>0xA0xAA</code></pre><p>输出</p><pre><code>10170</code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span><span class="token punctuation">(</span>line<span class="token operator">=</span><span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> output <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="HJ6质数因子（难）"><a href="#HJ6质数因子（难）" class="headerlink" title="HJ6质数因子（难）"></a>HJ6<strong>质数因子</strong>（难）</h2><p><strong>题目描述</strong></p><p>  功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2 2 3 3 5 ） </p><p>  最后一个数后面也要有空格  </p><p>输入描述:</p><pre><code>输入一个long型整数</code></pre><p>输出描述:</p><pre><code>按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。</code></pre><p>输入</p><pre><code>180</code></pre><p>输出</p><pre><code>2 2 3 3 5</code></pre><p>解析:</p><p>第一次的思路</p><p> 查找质数的方法，从2开始除,不能被2除，则尝试3，不能被3除，也不能被4除，尝试5。。。 每除一次进行一次循环。从小到大找出所有质数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span><span class="token punctuation">(</span>line<span class="token operator">=</span><span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       num<span class="token operator">=</span>num<span class="token operator">/</span>i<span class="token punctuation">;</span>       arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>       i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token operator">+</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//3800ms</span><span class="token comment" spellcheck="true">//为了除完2，做了过多的循环判断</span></code></pre><p><strong>优化解法：</strong></p><p>扩展补充：就分解的质数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">getPrimGens</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token function">getGens</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token function">getGens</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> c<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">getGens</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">var</span> n <span class="token operator">=</span> a<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">%</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>优化解:运行时间减少一半</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span><span class="token punctuation">(</span>line<span class="token operator">=</span><span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">getPreGens</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token operator">+</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">getPreGens</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">var</span> n <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>a<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">var</span> t <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token keyword">var</span> i<span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span>t<span class="token punctuation">)</span>     <span class="token punctuation">{</span>         arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">break</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>t<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">%</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>          <span class="token punctuation">{</span>             arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>             a <span class="token operator">=</span> a<span class="token operator">/</span>i<span class="token punctuation">;</span>             t <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>a<span class="token operator">/</span><span class="token number">2</span> <span class="token punctuation">)</span><span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//1900ms</span></code></pre><h2 id="HJ7-取近似值（易）"><a href="#HJ7-取近似值（易）" class="headerlink" title="HJ7 取近似值（易）"></a>HJ7 取近似值（易）</h2><p>题目描述</p><p>  写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。 </p><p>输入描述:</p><pre><code>输入一个正浮点数值</code></pre><p>输出描述:</p><pre><code>输出该数值的近似整数值</code></pre><p>输入</p><pre><code>5.5</code></pre><p>输出</p><pre><code>6</code></pre><p>解析</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span><span class="token punctuation">(</span>line<span class="token operator">=</span><span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> num <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>扩展</p><ul><li>只保留整数部分（丢弃小数部分）parseInt(5.1234); </li><li>向下取整（&lt;= 该数值的最大整数，和parseInt()一样)Math.floor(5.1234); </li><li>向上取整（有小数，整数部分就+1）Math.ceil(5.1234);  </li><li>四舍五入（小数部分）Math.round(5.1234)；</li><li>取绝对值Math.abs(-1);   </li><li>返回两数中的较大者Math.max(1,2);   Math.min(1,2);  </li><li>随机数（0-1）Math.random();</li></ul><h2 id="HJ8合并表记录-中"><a href="#HJ8合并表记录-中" class="headerlink" title="HJ8合并表记录(中)"></a>HJ8合并表记录(中)</h2><p>题目描述</p><p>  数据表记录包含表索引和数值（int范围的正整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。 </p><p>输入描述:</p><pre><code>先输入键值对的个数然后输入成对的index和value值，以空格隔开</code></pre><p>输出描述:</p><pre><code>输出合并后的键值对（多行）</code></pre><p>输入</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">4</span><span class="token number">0</span> <span class="token number">1</span><span class="token number">0</span> <span class="token number">2</span><span class="token number">1</span> <span class="token number">2</span><span class="token number">3</span> <span class="token number">4</span></code></pre><p>输出</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">0</span> <span class="token number">3</span><span class="token number">1</span> <span class="token number">2</span><span class="token number">3</span> <span class="token number">4</span></code></pre><p> 解析: 利用 map 缓存键，后续判断，如果有值组累加结果，如果没有，继续添加新的值</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span><span class="token punctuation">(</span>line<span class="token operator">=</span><span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">let</span> lines <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">let</span> arrs <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>lines<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> m<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>m<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">parseInt</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>         m<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token function">parseInt</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">let</span> keys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">of</span> m<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     keys<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">}</span> keys<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>key1<span class="token punctuation">,</span> key2<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> key1 <span class="token operator">-</span> key2 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> keys<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>     <span class="token function">print</span><span class="token punctuation">(</span>key <span class="token operator">+</span><span class="token string">' '</span> <span class="token operator">+</span> m<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>优解: 利用对象的属性不重复，保存键</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> count<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printAll</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">printAll</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>obj<span class="token punctuation">[</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            obj<span class="token punctuation">[</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> str<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            obj<span class="token punctuation">[</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>优解：写法简洁</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> amount <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">[</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>map<span class="token punctuation">[</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Number</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    amount<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> map<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>HJ9,提取不重复的数字</p><p>题目描述</p><p>  输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 </p><p>  保证输入的整数最后一位不是0。</p><p>输入描述:</p><pre class=" language-javascript"><code class="language-javascript">输入一个int型整数</code></pre><p>输出描述:</p><pre class=" language-javascript"><code class="language-javascript">按照从右向左的阅读顺序，返回一个不含重复数字的新的整数</code></pre><p>输入</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">9876673</span></code></pre><p>输出</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">37689</span></code></pre><p>解析</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span><span class="token punctuation">(</span>line<span class="token operator">=</span><span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 空Set</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> i <span class="token operator">=</span> line<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           s1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>line<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> result<span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 牛客网华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="2021/02/27/niuke/suanfa/sort/"/>
      <url>2021/02/27/niuke/suanfa/sort/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-算法-排序"><a href="#第一章-算法-排序" class="headerlink" title="第一章 算法-排序"></a>第一章 算法-排序</h1><p><strong>归并排序的时间复杂度（B ）</strong></p><p>A:O(log(N))</p><p>B:O(N*log(N))</p><p>C:O(N)</p><p>D:O(N^2)</p><p>解答：</p><p><img src="https://uploadfiles.nowcoder.com/images/20170825/838172_1503666046674_C5D4F39E60A08C51D0B825E76F6E68BC" alt="img"></p><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><p>​    和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。   </p><h4 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote><p>​      归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and  Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。     </p></blockquote><h4 id="2-算法描述和实现"><a href="#2-算法描述和实现" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>​     具体算法描述如下：    </p><ul><li>​      &lt;1&gt;.把长度为n的输入序列分成两个长度为n/2的子序列；          </li><li>​      &lt;2&gt;.对这两个子序列分别采用归并排序；          </li><li>​      &lt;3&gt;.将两个排序好的子序列合并成一个最终的排序序列。         </li></ul><p>​     <strong>Javscript代码实现:</strong>   </p><blockquote><p>function mergeSort(arr) {  </p><p>​    //采用自上而下的递归方法     </p><p>​    ar len = arr.length;     </p><p>​    if(len &lt; 2) {         return arr;     }    </p><pre><code> var middle =  Math.floor(len / 2),            left = arr.slice(0, middle),        </code></pre><p>​     right = arr.slice(middle);    </p><p>​     return merge(mergeSort(left), mergeSort(right)); </p><p>}</p><p> function merge(left, right) {     </p><p>var result = [];    </p><p>  console.time(‘归并排序耗时’);     </p><p>while (left.length &amp;&amp; right.length) { </p><p>​        if (left[0] &lt;= right[0]) { result.push(left.shift()); } </p><p>​        else result.push(right.shift()); </p><p>while (left.length) (right.length) console.timeend(‘归并排序耗时’);</p><p> return result; </p><p>var arr=”[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];” console.log(mergesort(arr));</p></blockquote><p><strong>一组记录的值为(12,38,35,25,74,50,63,90),按2路归并排序方法对序列进行一趟归并后的结果为(  A  )</strong></p><p>A:12,38,25,35,50,74,63,90</p><p>B:12,38,35,25,74,50,63,90</p><p>C:12,25,35,38,50,74,63,90</p><p>D:12,35,38,25,63,50,74,90</p><p>解析：</p><p><img src="https://uploadfiles.nowcoder.com/images/20181213/530580337_1544714285748_772E62849C030C48EBF52D9B1548A428" alt="img"></p><p><img src="https://uploadfiles.nowcoder.com/images/20170701/6428287_1498913261898_265C7FA7B7393A64D86043C1E57DD398" alt="img"></p><p>将两个相邻位置的有序子列，归并为一个有序列的序列，是典型的 <strong>分治法</strong> 应用 </p><h3 id><a href="#" class="headerlink" title></a></h3><p><strong>数据表A中有10000个元案，如果仅要求求出其中最大的10个元素，则采用()排序算法最节省时间。</strong>   </p><p>A:简单选择排序</p><p>B:希尔排序</p><p>C:堆排序</p><p>D:快速排序</p><p>解析：堆排序，利用到了树的结构，树的顶端就是最大值，很快就能找到，最值</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>下面的哪种排序算法在算复杂度平均不是O(nlogn)的?（B）</strong></p><p>A:快速排序</p><p>B:桶排序</p><p>C:合并排序</p><p>D:二叉树排序树排序</p><p>E:堆排序</p><p>解答：  </p><p><img src="http://uploadfiles.nowcoder.com/images/20160507/426198_1462607057516_67578A2B2E254243415482C36347C471" alt="img"></p><p>  桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。  当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序的时间复杂度是线性的，即O(n)的。比如：对n个数排序，这n个数的值在一定范围内（比如在1到100之间），那么直接构建一个大小为100的数组arr，在遍历包含n个数的数组num时，令arr[num[i]]++即可，最后从头到尾遍历arr，若arr[i]=m，则输出m个i即可。</p><p>  <strong>对  n  个记录的文件进行快速排序，所需要的辅助存储空间大致为(C)</strong></p><p>A:O（1）</p><p>B:O（n）</p><p>C:O（1og2n）</p><p>D:O（n2）</p><p>解析：</p><p>  辅助存储空间 = 时间复杂度 </p><p>  额外存储空间 = 空间复杂度</p><p>快速排序对待排序序列得划分大约是log2n次，因为快速排序是通过递归算法来实现的，递归深度大约是log2n，所以所需得辅助空间为log2n</p><p>如果选取的主元使得枢纽值将T(n)划分成T(n - 1)和一个T(0)，并且接下来的递归都是这样划分，那么就要递归n -  1次，需要n-1个栈空间单元(?)，考虑选取枢纽值用去的O(n)代价，总复杂度：T(n) = T(n - 1) +  O(n),用递归树得到T(n) = O(n ^ 2), ；如果主元使得T(n)恰好划分成T(n) = 2T(n / 2) +  O(n)，递归树共lgn层，T(n) = O(nlgn)，需要的栈空间：O(lgn)。</p><p>  对图B-2进行拓扑排序，可以得到不同的拓扑序列的个数是（B）。</p><p><img src="https://uploadfiles.nowcoder.com/images/20180512/7574500_1526106876774_1739550CD29F99D6FC52E3E6A49E8DFF" alt="img"> </p><p>A:4</p><p>B:3</p><p>C:2</p><p>D:1</p><p>解析</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>  拓扑排序的过程如下图所示。 </p><p>  <img src="https://uploadfiles.nowcoder.com/images/20180512/7574500_1526106976712_CA170FCB84F41A75AE0AF731CA65B4C7" alt="img"></p><p>   可以得到3个不同的拓扑序列，分别为：abced、abecd、aebcd。  </p><p><img src="https://uploadfiles.nowcoder.com/images/20190826/591802503_1566796873401_90C481E22DA191B81E3913D8E3698AB8" alt="img"></p><p><strong>设一组初始记录关键字序列为（49,38,65,97,76,13,27,49），则以第一个关键字49为基准而得到的一趟快速排序结果是：（）</strong></p><p>A:38，13，27，49，49，65，97，76</p><p>B:13，27，38，49，65，76，97，49</p><p>C:27，38，13，49，76，97，65，49</p><p>D:27，38，13，49，97，76，65，49</p><p>解析：</p><p>基本思想： </p><p> 第一步：(初始化)设置两个指针i和j，它们的初值分别为区间的下界和上界，即i=low，i=high；选取无序区的第一个记录R<a href="%E5%8D%B3R%5Blow%5D">i</a>作为基准记录，并将它保存在变量pivot中；<br>  第二步：令j自high起向左扫描，直到找到第1个关键字小于pivot.key的记录R[j]，将R[j])移至i所指的位置上，这相当于R[j]和基准R<a href="%E5%8D%B3pivot">i</a>进行了交换，使关键字小于基准关键字pivot.key的记录移到了基准的左边，交换后R[j]中相当于是pivot；然后，令i指针自i+1位置开始向右扫描，直至找到第1个关键字大于pivot.key的记录R[i]，将R[i]移到i所指的位置上，这相当于交换了R[i]和基准R[j]，使关键字大于基准关键字的记录移到了基准的右边，交换后R[i]中又相当于存放了pivot；接着令指针j自位置j-1开始向左扫描，如此交替改变扫描方向，从两端各自往中间靠拢，直至i=j时，i便是基准pivot最终的位置，将pivot放在此位置上就完成了一次划分。</p><p> 排序过程：<br> [49 38 65 97 76 13 27 49] //初始关键字<br> [27 38 13] 49 [76 97 65 49] //第1次划分完成之后，对应递归树第2层</p><p>以49为基准，取出49，两个指针，前指针指向38，后指针指向最后一个49<br> 首先移动后指针，找到27&lt;49，将27放在 0 位置，后指针前移<br> 再根据前指针查找，65&gt;49，将65放在原27的位置<br> 现在结果是 27,38, ,97,76,13,65,49<br> 继续用后指针查找，13&lt;49,放在空位中，后指针前移，<br> 结果是 27,38,13,97,76, ,65,49<br> 继续前指针查找，97&gt;49，放在空位，变成27,38,13, ,76,97,65,49<br> 然后前后指针都指向76，结束，将49放入空位中，得到27,38,13,49,76,97,65,49</p><p><strong>下列排序算法的常规实现中，哪些空间复杂度是O(1)(A B E)</strong></p><p>A:冒泡</p><p>B:选择</p><p>C:归并</p><p>D:快排</p><p>E:堆排序</p><p>解析：  冒泡排序,选择排序,堆排序的空间复杂度为O(1),因为需要一个临时变量来交换元素位置,(另外遍历序列时自然少不了用一个变量来做索引). </p><p>  快速排序空间复杂度为logn(因为递归调用了) ,归并排序空间复杂是O(n),需要一个大小为n的临时数组.</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
            <tag> 堆排序 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web前端</title>
      <link href="2021/02/26/niuke/qianduan/qianduan/"/>
      <url>2021/02/26/niuke/qianduan/qianduan/</url>
      
        <content type="html"><![CDATA[<h1 id="web前端"><a href="#web前端" class="headerlink" title="web前端"></a>web前端</h1><p><strong>元素的alt和title有什么异同，选出正确的说法？（B）</strong></p><p>A:不同的浏览器，表现一样</p><p>B:alt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字</p><p>C:alt和title同时设置的时候，title作为图片的替代文字出现，alt是图片的解释文字</p><p>D:以上说法都不正确</p><p>解析：</p><p>  alt是html标签的属性，而title既是html标签，又是html属性。<br>  title标签这个不用多说，网页的标题就是写在<title></title>这对标签之内的。<br>  title作为属性时，用来为元素提供额外说明信息。例如，给超链接标签a添加了title属性，把鼠标移动到该链接上面是，就会显示title的内容，以达到补充说明或者提示的效果。<br>  而alt属性则是用来指定替换文字，只能用在img、area和input元素中（包括applet元素），用于网页中图片无法正常显示时给用户提供文字说明使其了解图像信息。</p><p><strong>下面有关浏览器中使用js跨域获取数据的描述，说法错误的是？</strong>正确答案: A</p><p>A:域名、端口相同，协议不同，属于相同的域</p><p>B:js可以使用jsonp进行跨域</p><p>C:通过修改document.domain来跨子域</p><p>D:使用window.name来进行跨域</p><p>解析：</p><p>  <strong>1.CORS</strong></p><p>  CORS（Corss-Origin Resource  Sharing,跨资源共享），基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应的成功或失败。即给请求附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部决定是否给予响应。 </p><p>  <strong>2.document.domain</strong></p><p>  将页面的document.domain设置为相同的值，页面间可以互相访问对方的JavaScript对象。 </p><p>  注意： </p><p>  不能将值设置为URL中不包含的域； </p><p>  松散的域名不能再设置为紧绷的域名。 </p><p>  <strong>3.图像Ping</strong></p><p>  var img=new Image(); </p><p>  img.onload=img.onerror=function(){ </p><p>  … … </p><p>  } </p><p>  img.src=”url?name=value”; </p><p>  请求数据通过查询字符串的形式发送，响应可以是任意内容，通常是像素图或204响应。 </p><p>  图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。 </p><p>  缺点： </p><p>  只能发送GET请求； </p><p>  无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信。 </p><p>  <strong>4.Jsonp</strong></p><p>  var script=document.createElement(“script”); </p><p>  script.src=”url?callback=handleResponse”; </p><p>  document.body.insertBefore(script,document.body.firstChild); </p><p>  JSONP由两部分组成：回调函数和数据 </p><p>  回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。 </p><p>  数据是传入回调函数中的JSON数据。 </p><p>  优点： </p><p>  能够直接访问响应文本，可用于浏览器与服务器间的双向通信。 </p><p>  缺点： </p><p>  JSONP从其他域中加载代码执行，其他域可能不安全； </p><p>  难以确定JSONP请求是否失败。 </p><p>  <strong>5.Comet</strong></p><p>  Comet可实现服务器向浏览器推送数据。 </p><p>  Comet是实现方式：长轮询和流 </p><p>  短轮询即浏览器定时向服务器发送请求，看有没有数据更新。 </p><p>  长轮询即浏览器向服务器发送一个请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又向服务器发起一个新请求。其优点是所有浏览器都支持，使用XHR对象和setTimeout()即可实现。 </p><p>  流即浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据，页面的整个生命周期内只使用一个HTTP连接。 </p><p>  <strong>6.WebSocket</strong></p><p>  WebSocket可在一个单独的持久连接上提供全双工、双向通信。</p><p>  WebSocket使用自定义协议，未加密的连接时ws://；加密的链接是wss://。 </p><p>  var webSocket=new WebSocket(“ws://“); </p><p>  webSocket.send(message); </p><p>  webSocket.onmessage=function(event){ </p><p>  var data=event.data; </p><p>  … …. </p><p>  } </p><p>  注意： </p><p>  必须给WebSocket构造函数传入绝对URL； </p><p>  WebSocket可以打开任何站点的连接，是否会与某个域中的页面通信，完全取决于服务器；</p><p>  WebSocket只能发送纯文本数据，对于复杂的数据结构，在发送之前必须进行序列化JSON.stringify(message))。</p><p>   优点：  </p><p>   在客户端和服务器之间发送非常少的数据，减少字节开销。  </p><p>下面有关CSS sprites说法错误的是？正确答案: C</p><p>A:允许你将一个页面涉及到的所有零星图片都包含到一张大图中去</p><p>B:利用CSS的“background-image”，“background-repeat”，“background-position”的组合进行背景定位</p><p>C:CSS Sprites虽然增加了总的图片的字节，但是很好地减少网页的http请求，从而大大的提高页面的性能</p><p>D:CSS Sprites整理起来更为方便，同一个按钮不同状态的图片也不需要一个个切割出来并个别命名</p><p>解析：</p><h4 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h4><p>   1.简介  </p><p>   CSS    Sprites在国内很多人叫css精灵，是一种网页图片应用处理方式。它允许将一个页面涉及到的所有零星图片都包含到一张大图中，    利用CSS的“background-image”，“background-    repeat”，“background-position”的组合进行背景定位， 访问页面时避免图片载入缓慢的现象。  </p><p>   2.优点  </p><p> （1）CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能，这是CSS  Sprites最大的优点，也是其被广泛传播和应用的主要原因；  </p><p>   （2）CSS Sprites能减少图片的字节；  </p><p>   （3）CSS    Sprites解决了网页设计师在图片命名上的困扰，只需对一张集合的图片命名，不需要对每一个小图片进行命名，从而提高了网页制作效率。  </p><p>   （4）CSS Sprites只需要修改一张或少张图片的颜色或样式来改变整个网页的风格。  </p><p>   3.缺点  </p><p>   （1）图片合并麻烦：图片合并时，需要把多张图片有序的合理的合并成一张图片，并留好足够的空间防止版块出现不必要的背景。  </p><p>   （2）图片适应性差：在高分辨的屏幕下自适应页面，若图片不够宽会出现背景断裂。  </p><p>   （3）图片定位繁琐：开发时需要通过工具测量计算每个背景单元的精确位置。  </p><p>​    （4）可维护性差：页面背景需要少许改动，可能要修改部分或整张已合并的图片，进而要改动css。在避免改动图片的前提下，又只能（最好）往下追加图片，但这样增加了图片字节。  </p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法</title>
      <link href="2021/02/26/niuke/suanfa/search/"/>
      <url>2021/02/26/niuke/suanfa/search/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-算法-查找"><a href="#第一章-算法-查找" class="headerlink" title="第一章 算法-查找"></a>第一章 算法-查找</h1><p><strong>在长度为n的顺序线性表中顺序查找值为x的元素时，查找成功时的平均查找长度（假定查找每个元素的概率均相等）为（D）。</strong></p><p>A:n</p><p>B:(n-1)/2</p><p>C:n/2</p><p>D:(n+1)/2</p><p>解答：长度为n的线性表顺序查找x，则查找次数可能是1,2,3,…,n次，则和sum为n*(1+n)/2，所以平均查找次数为sum/n=(n+1)/2</p><p><strong>二叉查找树的查找效率与二叉树的树型有关，在（）时其查找效率最低（C）</strong></p><p>A:结点太多</p><p>B:完全二叉树</p><p>C:是单枝树</p><p>D:节点太复杂</p><p>解答：当二叉查询树变成一条链表效率最差。所以有AVL平衡树 限制节点深度差不超过1，避免产生链表一般的树。</p><p><strong>KMP算法下，长为n的字符串中匹配长度为m的子串的复杂度为（B）</strong></p><p>A:O(n)</p><p>B:O（M+N）</p><p>C:O（M+LOGM）</p><p>D:O（N+LOGM）</p><p>解答：给定两个字符串O和f，长度分别为n和    m，判断f是否在O中出现，如果出现则返回出现的位置。常规方法是遍历O的每一个位置，然后从该位置开始和f进行匹配，但是这种方法的复杂度是 O(nm)。kmp算法通过一个O(m)的预处理，使匹配的复杂度降为O(n+m)。</p><h2 id="kmp算法思想—字符串比较"><a href="#kmp算法思想—字符串比较" class="headerlink" title="kmp算法思想—字符串比较"></a>kmp算法思想—字符串比较</h2><p>​    我们首先用一个图来描述kmp算法的思想。在字符串O中寻       找f，当匹配到位置i时两个字符串不相等，这时我们需要将字符串f向前移动。常规方法是每次向前移动一位，但是它没有考虑前i-1位已经比较过这个事实，  所以效率不高。事实上，如果我们提前计算某些信息，就有可能一次前移多位。假设我们根据已经获得的信息知道可以前移k位，我们分析移位前后的f有什么特点。我们可以得到如下的结论：  </p><ul><li>​              A段字符串是f的一个前缀。          </li><li>​              B段字符串是f的一个后缀。          </li><li>​              A段字符串和B段字符串相等。        </li></ul><p>​    所以前移k位之后，可以继续比较位置i的前提是f的前i-1个位置满足：<strong>长度为i-k-1的前缀A和后缀B相同</strong>。只有这样，我们才可以前移k位后从新的位置继续比较。  </p><p><img src="http://img.blog.csdn.net/20130924000026250" alt="img"></p><p>​          所以kmp算法的核心即是计算字符串f每一个位置之前的字       符串的前缀和后缀公共部分的最大长度（不包括字符串本身，否则最大长度始终是字符串本身）。获得f每一个位置的最大公共长度之后，就可以利用该最大公共长       度快速和字符串O比较。当每次比较到两个字符串的字符不同时，我们就可以根据最大公共长度将字符串f向前移动(已匹配长度-最大公共长度)位，接着继续比 较下一个位置。事实上，字符串f的前移只是概念上的前移，只要我们在比较的时候从最大公共长度之后比较f和O即可达到字符串f前移的目的。</p><p><img src="http://img.blog.csdn.net/20130924000843031" alt="img"></p><h3 id="next数组计算"><a href="#next数组计算" class="headerlink" title="next数组计算"></a>next数组计算</h3><p>理解了kmp算法的基本原理，下一步就是要获得字符串f每一个位置的最大公共长度。这个最大公共长度在算法导论里面被记为next数组。在这里要注意一点，      next      数组表示的是长度，下标从      1      开始；但是在遍历原字符串时，下标还是从      0      开始。假设我们现在已经求得next[1]、next[2]、……next[i]，分别表示长度为1到i的字符串的前缀和后缀最大公共长度，现在要求next[i+1]。由上图我们可以看到，如果位置i和位置next[i]处的两个字符相同（下标从零开始），      则next[i+1]等于next[i]加1。如果两个位置的字符不相同，我们可以将长度为next[i]的字符串继续分割，获得其最大公共长度      next[next[i]]，然后再和位置i的字符比较。这是因为长度为next[i]前缀和后缀都可以分割成上部的构造，如果位置      next[next[i]]和位置i的字符相同，则next[i+1]就等于next[next[i]]加1。如果不相等，就可以继续分割长度为        next[next[i]]的字符串，直到字符串长度为0为止。由此我们可以写出求next数组的代码（<a href="http://lib.csdn.net/base/17">Java</a>版）：</p><blockquote><pre class=" language-java"><code class="language-java">publicint<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getNext</span><span class="token punctuation">(</span>String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">int</span> len<span class="token operator">=</span>b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//next表示长度为i的字符串前缀和后缀的最长公共部分，从1开始 </span>  next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//i表示字符串的下标，从0开始 </span>  <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//j在每次循环开始都表示next[i]的值，同时也表示需要比较的下一个位置 </span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>b<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">!=</span>b<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>j<span class="token operator">=</span>next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">==</span>b<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>j<span class="token operator">++</span><span class="token punctuation">;</span>     next<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>j<span class="token punctuation">;</span>   <span class="token punctuation">}</span>        retur nnext<span class="token punctuation">;</span> <span class="token punctuation">}</span> </code></pre></blockquote><p>上述代码需要注意的问题是，我们求取的next数组表示长度为1      到m的字符串f前缀的最大公共长度，所以需要多分配一个空间。而在遍历字符串f的时候，还是从下标0开始(位置0和1的next值为0，所以放在循环外 面)，到m-1为止。代码的结构和上面的讲解一致，都是利用前面的next值去求下一个next值。</p><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><p>计算完成next数组之后，我们就可以利用next数组在      字符串O中寻找字符串f的出现位置。匹配的代码和求next数组的代码非常相似，因为匹配的过程和求next数组的过程其实是一样的。假设现在字符串f的      前i个位置都和从某个位置开始的字符串O匹配，现在比较第i+1个位置。如果第i+1个位置相同，接着比较第i+2个位置；如果第i+1个位置不同，则出      现不匹配，我们依旧要将长度为i的字符串分割，获得其最大公共长度next[i]，然后从next[i]继续比较两个字符串。这个过程和求next数组一 致，所以可以匹配代码如下（java版）：</p><blockquote><pre><code>public void search(String original, String find, int next[]) &#123;   int j = 0;   for (int i = 0; i &lt; original.length(); i++) &#123;     while (j &gt; 0 &amp;&amp; original.charAt(i) != find.charAt(j))       j = next[j];     if (original.charAt(i) == find.charAt(j))       j++;     if (j == find.length()) &#123;       System.out.println(&quot;find at position &quot; + (i - j));       System.out.println(original.subSequence(i - j + 1, i + 1));       j = next[j];     &#125;   &#125; &#125; </code></pre></blockquote><p><strong>推荐这篇博客里对KMP算法的讲解很清晰，通过一个实际的例子来讲解了如何进行匹配：</strong></p><h3 id="http-www-ruanyifeng-com-blog-2013-05-Knuth"><a href="#http-www-ruanyifeng-com-blog-2013-05-Knuth" class="headerlink" title="http://www.ruanyifeng.com/blog/2013/05/Knuth"></a><strong><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">http://www.ruanyifeng.com/blog/2013/05/Knuth</a></strong></h3><h3 id="https-blog-csdn-net-yutianzuijin-article-details-11954939"><a href="#https-blog-csdn-net-yutianzuijin-article-details-11954939" class="headerlink" title="https://blog.csdn.net/yutianzuijin/article/details/11954939/"></a><a href="https://blog.csdn.net/yutianzuijin/article/details/11954939/">https://blog.csdn.net/yutianzuijin/article/details/11954939/</a></h3><p>已知字符串S 为“abaabaabacacaabaabcc”，模式串 t 为“abaabc”。采用 KMP 算法进行匹配，第一     次出现“失配”(s[i]≠t[j])  时，i=j=5，则下次开始匹配时，i 和 j 的值分别是 （C） 。  </p><p>A:i=1,j=0</p><p>B:i=5,j=0</p><p>C:i=5,j=2</p><p>D:i=6,j=2</p><p><strong>给定一个整数sum,从有N个有序元素的数组中寻找元素a,b,使得a+b的结果最接近sum,最快的平均时间复杂度是：(A)</strong></p><p>A:O(n)</p><p>B:O(nlogn)</p><p>C:O(n^2)</p><p>D:O(logn)</p><p>解答：  思想类似于两端向中间扫描 </p><p>  1、设定两个指针P1、P2，分别指向数组开始和结尾，即P1指向最小值，P2指向最大值； </p><p>  2、计算 *P1+*P2 的值为 SUM，与 sum 比较，记录它们的差值 DIF 和 SUM，若 SUM&lt;sum，P1++，若SUM&gt;sum，P2–;</p><p>  3、重复以上过程直到DIF最小</p><p><img src="https://uploadfiles.nowcoder.com/images/20170630/6428287_1498792227319_82DC6157EE49E83E8E9BFC64AAA92B29" alt="img"></p><p><strong>下面关于查找算法的论述中哪个不是正确的？</strong></p><p>A:顺序查找需要查找表为有序表</p><p>B:折半查找需要查找表为有序表</p><p>C:查找表可分为静态查找表和动态查找表</p><p>D:动态查找表的特点是表结构本身在查找过程中动态生成的</p><p>解答：</p><p>  <strong>静态查找表</strong>：仅做查询和检索操作的查找表； </p><p>  <strong>动态查找表</strong>：在查询之后，还需要将查询结果为不在查找表中的数据元素插入到查找表中；或者，从查找表中删除其查询结果为在查找表中的数据元素； </p><p>  简而言之，动态查找表的结构是可以随时修改或变化的，表结构本身在查找过程中动态生成，一般而言链式结构有这个特征，比如二叉查找树、三棵B树等，另外，基于顺序存储的Hash查找应该也算动态查找表；而静态查找表的结构一次性生成后就不再允许改变，就像在有序数组上使用折半查找那样。 </p><p><strong>具有12个关键字的有序表，折半查找的平均查找长度（A）</strong></p><p>A:3.1</p><p>B:4</p><p>C:2.5</p><p>D:5</p><p>解答：</p><p>方法一：12个关键字的有序表，折半查找的判定树如下：<br>     6        （1<em>1）次<br>    /  <br>    3  9       （2</em>2）次<br>   / \  / <br>   1 4 7 11     （3<em>4）次<br>   \  \  \   / <br>   2 5 8 10 12  （4</em>5）次</p><p>  平均查找长度=1/12*(1<em>1+2</em>2+3<em>4+4</em>5)=37/12</p><p>方法二：  查找长度是底数为2的logn 即log12，2^3=8,2^4=16，查12个也就是说长度在3~4之间…..故答案A</p><p><strong>设顺序线性表的长度为30，分成5块，每块6个元素，如果采用分块查找，则其平均查找长度为（D）。</strong></p><p>A:6</p><p>B:11</p><p>C:5</p><p>D:6.5</p><p>解析</p><p>找块：（1+2+3+4+5）/5=3<br> 在块内找元素：  (1+2+3+4+5+6)/6=3.5<br> 合计：3+3.5=6.5</p><p><strong>对于静态表的顺序查找法，若在表头设置监视哨，则正确的查找方式为（C）。</strong> </p><p>A:从第0个元素往后查找该数据元素</p><p>B:从第1个元素往后查找该数据元素</p><p>C:从第n个元素往开始前查找该数据元素</p><p>D:与查找顺序无关</p><p>解析</p><p>  常把第一个或最后一个元素作为哨兵 </p><p>  表头设置监视哨，就是将空出来的下标为0的这个元素的值设为Key, </p><p>  这样我们就不用多次判断 i 是否越界，因为就算静态表中找不到，也会在0位置上配对成功，返回0！</p><p>   n个元素都要比较一次,但都不成功,最后监视哨也要比较一次,比较成功,一共比较n+1次.  </p><p>   例子：有5个元素,分别是1,2,3,4,5.要找的元素是8.那么8就是监视哨,数列如下：  </p><p>   8,1,2,3,4,5.  </p><p>   从5开始向前查找,一共要比较6次,比较到监视哨成功,监视哨所在的下标是0,所以返回值为0.  </p><p>  <strong>下列选项中，不能构成折半查找中关键字比较序列的是 （A）。</strong>  </p><p>A:500,200,450,180</p><p>B:500,450,200,180</p><p>C:180,500,200,450</p><p>D:180,200,500,450</p><p>解析  画出查找路径图，因为折半查找的判定树是一棵二叉排序树，看其是否满足二叉排序树的要求。</p><p>  很显然，选项  A  的查找路径不满足</p><p><img src="https://uploadfiles.nowcoder.com/images/20170408/7031383_1491662188654_B034E3196CEA908FE6A93789F835033F" alt="img"></p><p><strong>在ASC算法team日常开发中，常常面临一些数据结构的抉择，令人纠结。目前大家在策划一个FBI项目（Fast Binary  Indexing），其中用到的词汇有6200条，词汇长度在10-15之间，词汇字符是英文字母，区分大小写。请在下面几个数据结构中选择一个使检索速度最快的：（D）</strong></p><p>A:二叉搜索树，比较函数开销：1次运算/每字符</p><p>B:哈希表，hash算法开销：10次运算/每字符</p><p>C:链表，比较函数开销：1次运算/每字符</p><p>D:TRIE树，寻找子节点开销：1次运算/每字符</p><p>解析：又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p><p><strong>关于红黑树和AVL树，以下哪种说法不正确？（D）</strong></p><p>A:两者都属于自平衡二叉树</p><p>B:两者查找,插入，删除的时间复杂度相同</p><p>C:包含n个内部节点的红黑树的高度是O(log(n))</p><p>D:JDK的TreeMap是一个AVL的实现</p><p>解析：</p><p>​                  <strong><em>1 好处 及 用途\</em></strong>            </p><p>​       红黑树      <strong>并不追求“完全平衡</strong>    ”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。  </p><p>​      红黑树能够以      <strong>O(*log2*         n)</strong>      的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构    能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高。  </p><p>​        当然，红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。  </p><p>​    在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。  </p><p>​          <em>典型的用途是实现关联数组</em>      </p><p>​          <strong><em>2\</em></strong>     AVL树是最先发明的自平衡二叉查    找树。在AVL树中任何节点的两个儿子子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O(log    n)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和    E.M. Landis，他们在 1962 年的论文 “An algorithm for the organization of    information” 中发表了它。  </p><p>   引入二叉树的目的是为了提高二叉树的搜索的效率,减少树的平均搜索长度.为此,就必须每向二叉树插入一个结点时调整树的结构,使得二叉树搜索保持平衡,从而可能降低树的高度,减少的平均树的搜索长度. </p><p> AVL树的定义:<br> 一棵AVL树满足以下的条件:<br> 1&gt;它的左子树和右子树都是AVL树<br>    2&gt;左子树和右子树的高度差不能超过1<br> 从条件1可能看出是个递归定义,如GNU一样. </p><p> 性质:<br>    1&gt;一棵n个结点的AVL树的其高度保持在0(log2(n)),不会超过3/2log2(n+1)<br>      2&gt;一棵n个结点的AVL树的平均搜索长度保持在0(log2(n)).<br> 3&gt;一棵n个结点的AVL树删除一个结点做平衡化旋转所需要的时间为0(log2(n)). </p><p> 从1这点来看              <strong><em>红黑树是牺牲了严格的高度平衡的优越条件</em></strong>          为 代价红黑树能够以O(log2    n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构    能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高.  </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找 </tag>
            
            <tag> 字符串比较 </tag>
            
            <tag> kmp </tag>
            
            <tag> 分块查找 </tag>
            
            <tag> 二分法 </tag>
            
            <tag> 算法 </tag>
            
            <tag> AVL树 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js试题</title>
      <link href="2021/02/26/niuke/qianduan/js-shi-ti/"/>
      <url>2021/02/26/niuke/qianduan/js-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="js试题"><a href="#js试题" class="headerlink" title="js试题"></a>js试题</h1><p><strong>下面这个JS程序的输出是什么：</strong> </p><pre><code>function Foo() &#123;  var i = 0;  return function() &#123;    console.log(i++);  &#125;&#125;</code></pre><pre><code>var f1 = Foo(),  f2 = Foo();f1();f1();f2();</code></pre><p>正确答案: A</p><p>A:0 1 0</p><p>B:0 1 2</p><p>C:0 0 0</p><p>D:0 0 2</p><p>解析：</p><p>这道题考察<strong>闭包</strong>和<strong>引用类型对象</strong>的知识点：<br>1.一般来说函数执行完后它的局部变量就会随着函数调用结束被销毁，但是此题foo函数返回了一个匿名函数的引用（即一个<strong>闭包</strong>），它可以访问到foo()被调用产生的环境，而局部变量i一直处在这个环境中，只要一个环境有可能被访问到，它就不会被销毁，所以说闭包有延续变量作用域的功能。这就好理解为什么：</p><pre><code>f1();//0f1();//1</code></pre><p>2.我一开始认为f1和f2都=foo()是都指向了同一个function引用类型，所以顺理成章就会答错认为：</p><pre><code>f2();//2</code></pre><p>但其实foo()返回的是一个匿名函数，所以f1,f2相当于指向了两个不同的函数对象，所以结果也就顺理成章的变为：</p><p><a href="https://www.nowcoder.com/test/question/done?tid=41312304&qid=14899#">复制代码</a></p><pre><code>f2();//0</code></pre><p>下面有关JavaScript中 call和apply的描述，错误的是？</p><p>都是非正确答案: B </p><p>A:call与apply都属于Function.prototype的一个方法，所以每个function实例都有call、apply属性</p><p>B:两者传递的参数不同，call函数第一个参数都是要传入给当前对象的对象，apply不是</p><p>C:apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入</p><p>D:call传入的则是直接的参数列表。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</p>]]></content>
      
      
      <categories>
          
          <category> js试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第十二章 特殊集合</title>
      <link href="2021/02/25/c-10/c-10th-12/"/>
      <url>2021/02/25/c-10/c-10th-12/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第十二章-特殊集合"><a href="#c-语言-第十二章-特殊集合" class="headerlink" title="c#语言 第十二章 特殊集合"></a>c#语言 第十二章 特殊集合</h1><h3 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h3><p>​        使用位数组和位矢量</p><p>​        使用可观察的集合</p><p>​        使用不可变得集合</p><p>​        使用并发的集合</p><p>12.1概述</p><p>   11张介绍了列表、队列、堆栈、字典和链表。</p><p>12.2处理位</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 特殊的集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第十一章 集合</title>
      <link href="2021/02/23/c-10/c-10th-11/"/>
      <url>2021/02/23/c-10/c-10th-11/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第十一章-集合"><a href="#c-语言-第十一章-集合" class="headerlink" title="c#语言 第十一章 集合"></a>c#语言 第十一章 集合</h1><h2 id="1-集合接口和类型"><a href="#1-集合接口和类型" class="headerlink" title="1.集合接口和类型"></a>1.集合接口和类型</h2><table><thead><tr><th>接口</th><th>说明</th></tr></thead><tbody><tr><td>IEnumerable<T></T></td><td>如果foreach语句用于集合,就需要IEnumerable接口.这个借口定义了方法GetEnumerator(),他返回一个实现了IEnumerator接口的枚举</td></tr><tr><td>ICollection<T></T></td><td>ICollection<T>接口有泛型集合类实现.使用这个借口可以获得集合中的元素个数(Count属性),把集合复制到数组中(CopyTo()方法),还可以从集合中添加和删除元素(Add(),Remove(),Clear())</T></td></tr><tr><td>List<T></T></td><td>IList<T>接口用于可通过位置访问其中的元素列表,这个接口定义了一个 索引器,可以在集合的指定位置插入或删除 mount些项(Insert()和Remove()方法).IList<T>接口派生自ICollection<T>接口</T></T></T></td></tr><tr><td>ISet<T></T></td><td>ISet<T>接口是.NET4中新增的.实现这个接口的集允许合并不同的集.获得两个集的交集,检查两个集合是否重叠.ISet<T>接口派生自ICollection<T>接口</T></T></T></td></tr><tr><td>IDictionary&lt;TKey,TValue&gt;</td><td>IDictionary&lt;TKey,TValue&gt;接口由包含键和值的泛型集合类 实现.使用这个接口可以访问所有的键和值,使用键类型的索引器可以访问某些项,还可以添加或删除某些项</td></tr><tr><td>ILookup&lt;TKey,TValue&gt;</td><td>ILookup&lt;TKey,TValue&gt;接口类似于IDictionary&lt;TKey,TValue&gt;接口,实现该接口的集合有键和值,且可以通过一个键包含多个值</td></tr><tr><td>IComparer<T></T></td><td>接口ICommparer<T>由比较器实现,通过Comparer()方法给集合中的元素排序</T></td></tr><tr><td>IEqualityComparer<T></T></td><td>接口IEqualityComparer<T>由一个比较器实现,该比较器可用于字典中的键.使用这个接口,可以对对象进行相等性比较.在.NET中,这个接口也由数组和元组实现</T></td></tr><tr><td>IProducerConsumerColllection<T></T></td><td>IProducerConsumerCollection<T>接口是.NET4中新增的,它支持新的线程安全的集合类</T></td></tr><tr><td>IReadOnlyList<T>、 IReadOnlyDictionary<T>、 IReadOnlyCollection<T></T></T></T></td><td>初始化后不能修改的集合，只能检索对象，不能添加和删除.</td></tr></tbody></table><h2 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h2><blockquote><pre><code>[Serializable]  public class Racer : IComparable&lt;Racer&gt;, IFormattable  &#123;    public int Id &#123; get; private set; &#125;    public string FirstName &#123; get; set; &#125;    public string LastName &#123; get; set; &#125;    public string Country &#123; get; set; &#125;    public int Wins &#123; get; set; &#125;    public Racer(int id, string firstName, string lastName, string country)      : this(id, firstName, lastName, country, wins: 0)    &#123;    &#125;    public Racer(int id, string firstName, string lastName, string country, int wins)    &#123;      this.Id = id;      this.FirstName = firstName;      this.LastName = lastName;      this.Country = country;      this.Wins = wins;    &#125;    public override string ToString()    &#123;      return String.Format(&quot;&#123;0&#125; &#123;1&#125;&quot;, FirstName, LastName);    &#125;    public string ToString(string format, IFormatProvider formatProvider)    &#123;      if (format == null) format = &quot;N&quot;;      switch (format.ToUpper())      &#123;        case null:        case &quot;N&quot;: // name          return ToString();        case &quot;F&quot;: // first name          return FirstName;        case &quot;L&quot;: // last name          return LastName;        case &quot;W&quot;: // Wins          return String.Format(&quot;&#123;0&#125;, Wins: &#123;1&#125;&quot;, ToString(), Wins);        case &quot;C&quot;: // Country          return String.Format(&quot;&#123;0&#125;, Country: &#123;1&#125;&quot;, ToString(), Country);        case &quot;A&quot;: // All          return String.Format(&quot;&#123;0&#125;, &#123;1&#125; Wins: &#123;2&#125;&quot;, ToString(), Country, Wins);        default:          throw new FormatException(String.Format(formatProvider,                &quot;Format &#123;0&#125; is not supported&quot;, format));      &#125;    &#125;    public string ToString(string format)    &#123;      return ToString(format, null);    &#125;    public int CompareTo(Racer other)    &#123;      if (other == null) return -1;      int compare = string.Compare(this.LastName, other.LastName);      if (compare == 0)        return string.Compare(this.FirstName, other.FirstName);      return compare;    &#125;  &#125;</code></pre></blockquote><p>​        使用默认的构造函数创建一个空列表，元素添加到列表后，列表容量会扩大到可接纳4个元素。<br>​        如果添加了第5个元素，列表大小会重新设置为8个元素。每次都会将列表的容量重新设置为原来的2倍.</p><blockquote><pre><code>var intList=new List&lt;int&gt;();</code></pre></blockquote><p>​        如果列表的容量变了，整个集合就要重新分配到新的内存块中，我们可以在初始化时设置它的容量：</p><blockquote><pre><code>List&lt;int&gt; intList=new List&lt;int&gt;(10);</code></pre></blockquote><p>如果列表的个数超过10个，可以设置容量Capacity：</p><blockquote><pre><code>intList.Capacity = 20;</code></pre></blockquote><p>如果列表的元素已经添加完了，列表会存在多余的容量空间。可以使用TrimExcess方法去除不要的容量:</p><blockquote><pre><code>intList.TrimExcess();</code></pre></blockquote><h3 id="a-集合初始值设定项"><a href="#a-集合初始值设定项" class="headerlink" title="a.集合初始值设定项"></a>a.集合初始值设定项</h3><p>使用初始化构造器初始化设定项</p><blockquote><pre><code>int[] arr = &#123; 1, 2, 3 &#125;;var intList = new List&lt;int&gt;(arr) ;</code></pre></blockquote><p>括号中初始化</p><pre><code>var intList = new List&lt;int&gt;() &#123; 4, 5 &#125;;</code></pre><h3 id="b-添加元素"><a href="#b-添加元素" class="headerlink" title="b.添加元素"></a>b.添加元素</h3><pre><code>intList.Add(5);</code></pre><h3 id="添加数组"><a href="#添加数组" class="headerlink" title="添加数组"></a>添加数组</h3><pre><code>intList.AddRange(new int[] &#123; 3, 5 &#125;);</code></pre><h3 id="c-插入元素"><a href="#c-插入元素" class="headerlink" title="c.插入元素"></a>c.插入元素</h3><pre><code>intList.Insert(3, 4);</code></pre><h3 id="d-访问元素"><a href="#d-访问元素" class="headerlink" title="d.访问元素"></a>d.访问元素</h3><p>使用索引获取：</p><pre><code>var value = intList[3];</code></pre><p>循环遍历：</p><pre><code>foreach (var item in intList)&#123;     var res = item;&#125;</code></pre><p>forEach方法：</p><pre><code>class List&lt;T&gt; : IList&lt;T&gt;&#123;    private T[] items;    public void forEach(Action&lt;T&gt; action)    &#123;        if (action == null) throw new ArgumentNullException(&quot;action&quot;);        foreach (var item in items)        &#123;            action(item);        &#125;    &#125;&#125;</code></pre><p>然后我们可以这样调用：</p><pre><code>intList.ForEach(m =&gt; Console.WriteLine(m));</code></pre><h3 id="e-删除元素"><a href="#e-删除元素" class="headerlink" title="e.删除元素"></a>e.删除元素</h3><p>按索引删除,比较快</p><pre><code>intList.RemoveAt(3);</code></pre><p>按元素值删除</p><pre><code>intList.Remove(4);</code></pre><h3 id="f-搜索"><a href="#f-搜索" class="headerlink" title="f.搜索"></a>f.搜索</h3><p>在集合中搜索元素。可以查找索引和元素。</p><p>FindIndex通过匹配元素值，获得索引：</p><pre><code>intList.FindIndex(m =&gt; m==4);</code></pre><p>FindIndex方法参数Predicate<T>传入匹配的表达式，返回匹配的元素索引值,Predicate<T>委托表示定义一组条件并确定指定对象是否符合这些条件的方法</T></T></p><pre><code>intList.Find(m =&gt; m == 4);intList.FindAll(m =&gt; m &gt; 2);</code></pre><p>Find返回了匹配条件的元素值，FindAll返回了匹配条件的所有元素</p><h3 id="g-排序"><a href="#g-排序" class="headerlink" title="g.排序"></a>g.排序</h3><p>列表使用Sort方法进行元素排序</p><pre><code>intList.Sort();intList.Sort((m, n) =&gt; m);</code></pre><p>Sort(Comparison<T> comparison)方法参数中的委托Comparison含有2个参数,方法将这2个元素进行比较，然后返回绝对值,如果返回-1的，元素需要排前面，返回1的元素需要排后面.</T></p><p>Sort(IComparer<T> comparer)方法参数中是一个比较接口，接口实现Comparer方法</T></p><pre><code>public enum CompareType  &#123;    FirstName,    LastName,    Country,    Wins  &#125;  public class RacerComparer : IComparer&lt;Racer&gt;  &#123;    private CompareType compareType;    public RacerComparer(CompareType compareType)    &#123;      this.compareType = compareType;    &#125;    public int Compare(Racer x, Racer y)    &#123;      if (x == null &amp;&amp; y == null) return 0;      if (x == null) return -1;      if (y == null) return 1;      int result;      switch (compareType)      &#123;        case CompareType.FirstName:          return string.Compare(x.FirstName, y.FirstName);        case CompareType.LastName:          return string.Compare(x.LastName, y.LastName);        case CompareType.Country:          result = string.Compare(x.Country, y.Country);          if (result == 0)            return string.Compare(x.LastName, y.LastName);          else            return result;        case CompareType.Wins:          return x.Wins.CompareTo(y.Wins);        default:          throw new ArgumentException(&quot;Invalid Compare Type&quot;);      &#125;    &#125;  &#125;</code></pre><h3 id="h-类型转换"><a href="#h-类型转换" class="headerlink" title="h.类型转换"></a>h.类型转换</h3><p> Converter委托</p><pre><code>public delegate TOutput Converter&lt;in TInput, out TOutput&gt;(TInput input);ConvertAll可以将一种类型的集合转换为另一种类型的集合。intList.ConvertAll(m =&gt; m.ToString());</code></pre><h6 id="只读集合"><a href="#只读集合" class="headerlink" title="只读集合"></a>只读集合</h6><p>创建集合后，它们是只读的。</p><h2 id="3-队列"><a href="#3-队列" class="headerlink" title="3.队列"></a>3.队列</h2><p>代表了一个<strong>先进先出</strong>的对象集合。当您需要对各项进行先进先出的访问时，则使用队列。当您在列表中添加一项，称为<strong>入队</strong>，当您从列表中移除一项时，称为<strong>出队</strong>。</p><p>添加队列元素时加上lock,因为多线程可以同时访问，所以对队列进行锁定访问。</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523112249101-324688636.png" alt="img"></p><pre><code>using System;using System.Collections;namespace CollectionsApplication&#123;   class Program   &#123;      static void Main(string[] args)      &#123;         Queue q = new Queue();         q.Enqueue(&#39;A&#39;);         q.Enqueue(&#39;M&#39;);         q.Enqueue(&#39;G&#39;);         q.Enqueue(&#39;W&#39;);                  Console.WriteLine(&quot;Current queue: &quot;);         foreach (char c in q)            Console.Write(c + &quot; &quot;);         Console.WriteLine();         q.Enqueue(&#39;V&#39;);         q.Enqueue(&#39;H&#39;);         Console.WriteLine(&quot;Current queue: &quot;);                  foreach (char c in q)            Console.Write(c + &quot; &quot;);         Console.WriteLine();         Console.WriteLine(&quot;Removing some values &quot;);         char ch = (char)q.Dequeue();         Console.WriteLine(&quot;The removed value: &#123;0&#125;&quot;, ch);         ch = (char)q.Dequeue();         Console.WriteLine(&quot;The removed value: &#123;0&#125;&quot;, ch);         Console.ReadKey();      &#125;   &#125;&#125;</code></pre><p>当上面的代码被编译和执行时，它会产生下列结果：</p><pre><code>Current queue: A M G W Current queue: A M G W V H Removing valuesThe removed value: AThe removed value: M</code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>class Program    &#123;        static void Main()        &#123;            var dm = new DocumentManager();            ProcessDocuments.Start(dm);            // Create documents and add them to the DocumentManager            for (int i = 0; i &lt; 1000; i++)            &#123;                Document doc = new Document(&quot;Doc &quot; + i.ToString(), &quot;content&quot;);                dm.AddDocument(doc);                Console.WriteLine(&quot;Added document &#123;0&#125;&quot;, doc.Title);                Thread.Sleep(new Random().Next(20));            &#125;        &#125;    &#125;</code></pre><p>Program</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>public class ProcessDocuments  &#123;    public static void Start(DocumentManager dm)    &#123;      Task.Factory.StartNew(new ProcessDocuments(dm).Run);    &#125;    protected ProcessDocuments(DocumentManager dm)    &#123;      if (dm == null)        throw new ArgumentNullException(&quot;dm&quot;);      documentManager = dm;    &#125;    private DocumentManager documentManager;    protected void Run()    &#123;      while (true)      &#123;        if (documentManager.IsDocumentAvailable)        &#123;          Document doc = documentManager.GetDocument();          Console.WriteLine(&quot;Processing document &#123;0&#125;&quot;, doc.Title);        &#125;        Thread.Sleep(new Random().Next(20));      &#125;    &#125;  &#125;</code></pre><p>ProcessDocuments</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>public class DocumentManager  &#123;    private readonly Queue&lt;Document&gt; documentQueue = new Queue&lt;Document&gt;();    public void AddDocument(Document doc)    &#123;      lock (this)      &#123;        documentQueue.Enqueue(doc);      &#125;    &#125;    public Document GetDocument()    &#123;      Document doc = null;      lock (this)      &#123;        doc = documentQueue.Dequeue();      &#125;      return doc;    &#125;    public bool IsDocumentAvailable    &#123;      get      &#123;        return documentQueue.Count &gt; 0;      &#125;    &#125;  &#125;</code></pre><p>DocumentManager</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>public class Document  &#123;    public string Title &#123; get; private set; &#125;    public string Content &#123; get; private set; &#125;    public Document(string title, string content)    &#123;      this.Title = title;      this.Content = content;    &#125;  &#125;</code></pre><h2 id="4-栈"><a href="#4-栈" class="headerlink" title="4.栈"></a>4.栈</h2><p>代表了一个<strong>后进先出</strong>的对象集合。当您需要对各项进行后进先出的访问时，则使用堆栈。当您在列表中添加一项，称为<strong>推入</strong>元素，当您从列表中移除一项时，称为<strong>弹出</strong>元素。</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523134233945-207787536.png" alt="img"></p><pre><code>class Program    &#123;        static void Main()        &#123;            var alphabet = new Stack&lt;char&gt;();            alphabet.Push(&#39;A&#39;);            alphabet.Push(&#39;B&#39;);            alphabet.Push(&#39;C&#39;);            Console.Write(&quot;First iteration: &quot;);            foreach (char item in alphabet)            &#123;                Console.Write(item);            &#125;            Console.WriteLine();            Console.Write(&quot;Second iteration: &quot;);            while (alphabet.Count &gt; 0)            &#123;                Console.Write(alphabet.Pop());            &#125;            Console.WriteLine();        &#125;    &#125;</code></pre><h2 id="5-链表"><a href="#5-链表" class="headerlink" title="5.链表"></a>5.链表</h2><p>LinkedList<T>是一个双向链表，其元素指向它前面和后面的元素，这样通过移动下一个元素就可以正向遍历整个链表。通过移动到前一个元素可以反向遍历这个链表</T></p><p>链表的优点是，如果将元素插入列表的中间位置，使用链表会很快，在插入一个元素时，只需要修改上一个元素的Next引用和下一个元素的Previous引用，使他们引用所插入的元素。</p><pre><code>public class Document  &#123;    public string Title &#123; get; private set; &#125;    public string Content &#123; get; private set; &#125;    public byte Priority &#123; get; private set; &#125;    public Document(string title, string content, byte priority)    &#123;      this.Title = title;      this.Content = content;      this.Priority = priority;    &#125;  &#125;</code></pre><pre><code>public class PriorityDocumentManager  &#123;    private readonly LinkedList&lt;Document&gt; documentList;    // priorities 0.9    private readonly List&lt;LinkedListNode&lt;Document&gt;&gt; priorityNodes;    public PriorityDocumentManager()    &#123;      documentList = new LinkedList&lt;Document&gt;();      priorityNodes = new List&lt;LinkedListNode&lt;Document&gt;&gt;(10);      for (int i = 0; i &lt; 10; i++)      &#123;        priorityNodes.Add(new LinkedListNode&lt;Document&gt;(null));      &#125;    &#125;    public void AddDocument(Document d)    &#123;      Contract.Requires&lt;ArgumentNullException&gt;(d != null, &quot;argument d must not be null&quot;);      //  if (d == null) throw new ArgumentNullException(&quot;d&quot;);      AddDocumentToPriorityNode(d, d.Priority);    &#125;    private void AddDocumentToPriorityNode(Document doc, int priority)    &#123;      Contract.Requires&lt;ArgumentException&gt;(priority &gt;= 0 &amp;&amp; priority &lt; 10, &quot;priority value must be between 0 and 9&quot;);      //if (priority &gt; 9 || priority &lt; 0)      //    throw new ArgumentException(&quot;Priority must be between 0 and 9&quot;);      if (priorityNodes[priority].Value == null)      &#123;        --priority;        if (priority &gt;= 0)        &#123;          // check for the next lower priority          AddDocumentToPriorityNode(doc, priority);        &#125;        else // now no priority node exists with the same priority or lower        // add the new document to the end        &#123;          documentList.AddLast(doc);          priorityNodes[doc.Priority] = documentList.Last;        &#125;        return;      &#125;      else // a priority node exists      &#123;        LinkedListNode&lt;Document&gt; prioNode = priorityNodes[priority];        if (priority == doc.Priority)        // priority node with the same priority exists        &#123;          documentList.AddAfter(prioNode, doc);          // set the priority node to the last document with the same priority          priorityNodes[doc.Priority] = prioNode.Next;        &#125;        else // only priority node with a lower priority exists        &#123;          // get the first node of the lower priority          LinkedListNode&lt;Document&gt; firstPrioNode = prioNode;          while (firstPrioNode.Previous != null &amp;&amp;             firstPrioNode.Previous.Value.Priority == prioNode.Value.Priority)          &#123;            firstPrioNode = prioNode.Previous;            prioNode = firstPrioNode;          &#125;          documentList.AddBefore(firstPrioNode, doc);          // set the priority node to the new value          priorityNodes[doc.Priority] = firstPrioNode.Previous;        &#125;      &#125;    &#125;    public void DisplayAllNodes()    &#123;      foreach (Document doc in documentList)      &#123;        Console.WriteLine(&quot;priority: &#123;0&#125;, title &#123;1&#125;&quot;, doc.Priority, doc.Title);      &#125;    &#125;    // returns the document with the highest priority    // (that&#39;s first in the linked list)    public Document GetDocument()    &#123;      Document doc = documentList.First.Value;      documentList.RemoveFirst();      return doc;    &#125;  &#125;</code></pre><pre><code> class Program  &#123;    static void Main()    &#123;        PriorityDocumentManager pdm = new PriorityDocumentManager();        pdm.AddDocument(new Document(&quot;one&quot;, &quot;Sample&quot;, 8));        pdm.AddDocument(new Document(&quot;two&quot;, &quot;Sample&quot;, 3));        pdm.AddDocument(new Document(&quot;three&quot;, &quot;Sample&quot;, 4));        pdm.AddDocument(new Document(&quot;four&quot;, &quot;Sample&quot;, 8));        pdm.AddDocument(new Document(&quot;five&quot;, &quot;Sample&quot;, 1));        pdm.AddDocument(new Document(&quot;six&quot;, &quot;Sample&quot;, 9));        pdm.AddDocument(new Document(&quot;seven&quot;, &quot;Sample&quot;, 1));        pdm.AddDocument(new Document(&quot;eight&quot;, &quot;Sample&quot;, 1));        pdm.DisplayAllNodes();    &#125;  &#125;</code></pre><h2 id="6-有序列表"><a href="#6-有序列表" class="headerlink" title="6.有序列表"></a>6.有序列表</h2><p>SortedList基于键对集合进行排序.</p><pre><code>class Program  &#123;    static void Main()    &#123;      var books = new SortedList&lt;string, string&gt;();      books.Add(&quot;sty&quot;, &quot;&quot;);      books.Add(&quot;abc&quot;, &quot;&quot;);      books.Add(&quot;123&quot;, &quot;&quot;);      foreach (var item in books.Keys)      &#123;          Console.WriteLine(item);      &#125;    &#125;  &#125;</code></pre><h2 id="7-字典"><a href="#7-字典" class="headerlink" title="7.字典"></a>7.字典</h2><p>字典：用于在名称/值对中存储信息，字典的名称即键不能重复.</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523142813132-1598220317.png" alt="img"></p><p>HashTable和Dictionary</p><p>1.HashTable大数据量插入数据时需要花费比Dictionary大的多的时间。</p><p>2.for方式遍历HashTable和Dictionary速度最快。</p><p>3.在foreach方式遍历时Dictionary遍历速度更快。</p><p>4.HashTable在取值时需要进行类型转换,Dictionary不用做类型转换。</p><p>在单线程的时候使用Dictionary更好一些，多线程的时候使用HashTable更好。</p><p>有序字典SortedList和SortedDictionary</p><p><strong>SortedDictionary</strong> 泛型类是检索运算复杂度为 O(log n) 的二叉搜索树，其中 n 是字典中的元素数。就这一点而言，它与 <a href="http://blog.csdn.net/nma_123456/article/details/7298343">SortedList</a> 泛型类相似。这两个类具有相似的对象模型，并且都具有 O(log n) 的检索运算复杂度。这两个类的区别在于内存的使用以及插入和移除元素的速度：</p><ul><li><strong>SortedList</strong> 使用的内存比 <strong>SortedDictionary</strong> 少。</li><li><strong>SortedDictionary</strong> 可对未排序的数据执行更快的插入和移除操作：它的时间复杂度为 O(log n)，而<strong>SortedList</strong> 为 O(n)。</li><li>如果使用排序数据一次性填充列表，则 <strong>SortedList</strong> 比 <strong>SortedDictionary</strong> 快。</li><li></li></ul><h2 id="8-集"><a href="#8-集" class="headerlink" title="8.集"></a>8.集</h2><p>包含不重复元素的集合，叫“集”。.NET包含2个集。HashSet<T>和SortedSet<T>，它们继承ISet;SortedSet是一个有序集.</T></T></p><p>ISet提供了Add方法,如果HashSet中存在这个元素，再次使用Add方法不会抛出异常，返回bool值是否添加</p><blockquote><p>var companyTeams = new HashSet<string>() { “Ferrari”, “McLaren”, “Mercedes” };<br>var traditionalTeams = new HashSet<string>() { “Ferrari”, “McLaren” };<br>var privateTeams = new HashSet<string>() { “Red Bull”, “Lotus”, “Toro Rosso”, “Force India”, “Sauber” };</string></string></string></p><p>if (privateTeams.Add(“Williams”))<br>    Console.WriteLine(“Williams added”);<br>if (!companyTeams.Add(“McLaren”))<br>    Console.WriteLine(“McLaren was already in this set”);</p></blockquote><pre><code>IsSubsetOf方法判断了traditionalTeams集合是否companyTeams的子集IsSupersetOf方法判断了companyTeams集合是否traditionalTeams的超集(包含它拥有的所有元素，并且多余它的元素)</code></pre><pre><code>var companyTeams = new HashSet&lt;string&gt;() &#123; &quot;Ferrari&quot;, &quot;McLaren&quot;, &quot;Mercedes&quot; &#125;;var traditionalTeams = new HashSet&lt;string&gt;() &#123; &quot;Ferrari&quot;, &quot;McLaren&quot; &#125;;var privateTeams = new HashSet&lt;string&gt;() &#123; &quot;Red Bull&quot;, &quot;Lotus&quot;, &quot;Toro Rosso&quot;, &quot;Force India&quot;, &quot;Sauber&quot; &#125;;if (traditionalTeams.IsSubsetOf(companyTeams))&#123;  Console.WriteLine(&quot;traditionalTeams is subset of companyTeams&quot;);&#125;if (companyTeams.IsSupersetOf(traditionalTeams))&#123;   Console.WriteLine(&quot;companyTeams is a superset of traditionalTeams&quot;);&#125;SortedSet的UnionWith方法可以修改这个集合，并且包含传入的集合var allTeams = new SortedSet&lt;string&gt;(companyTeams);allTeams.UnionWith(privateTeams);allTeams.UnionWith(traditionalTeams);</code></pre><h2 id="9-可视察的集合"><a href="#9-可视察的集合" class="headerlink" title="9.可视察的集合"></a>9.可视察的集合</h2><p>如果需要记录集合何时添加和删除元素的信息，可以使用ObservableCollection<T>,这个本身是为WPF定制的。</T></p><p>ObservableCollection<T>类用于创建自定义集合，在内部使用List<T>类,重写虚方法RemoveItem和SetItem()方法触发CollectionChanged事件。</T></T></p><pre><code>class Program  &#123;    static void Main()    &#123;      var data = new ObservableCollection&lt;string&gt;();      data.CollectionChanged += Data_CollectionChanged;      data.Add(&quot;One&quot;);      data.Add(&quot;Two&quot;);      data.Insert(1, &quot;Three&quot;);      data.Remove(&quot;One&quot;);    &#125;    static void Data_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)    &#123;      Console.WriteLine(&quot;action: &#123;0&#125;&quot;, e.Action.ToString());      if (e.OldItems != null)      &#123;        Console.WriteLine(&quot;starting index for old item(s): &#123;0&#125;&quot;, e.OldStartingIndex);        Console.WriteLine(&quot;old item(s):&quot;);        foreach (var item in e.OldItems)        &#123;          Console.WriteLine(item);        &#125;      &#125;      if (e.NewItems != null)      &#123;        Console.WriteLine(&quot;starting index for new item(s): &#123;0&#125;&quot;, e.NewStartingIndex);        Console.WriteLine(&quot;new item(s): &quot;);        foreach (var item in e.NewItems)        &#123;          Console.WriteLine(item);        &#125;      &#125;      Console.WriteLine();    &#125;  &#125;</code></pre><p>Data_CollectionChanged方法接收了NotifyCollectionChangedEventArgs，包含了集合的变化信息，Action属性给出了是否添加或删除一项的信息，对于删除的项，会设置OldItems属性，列出删除的项</p><p>对于添加的项，会设置NewItems属性，列出添加的项。</p><pre><code>action: Addstarting index for new item(s): 0new item(s):Oneaction: Addstarting index for new item(s): 1new item(s):Twoaction: Addstarting index for new item(s): 1new item(s):Threeaction: Removestarting index for old item(s): 0old item(s):One</code></pre><h2 id="10-位数组"><a href="#10-位数组" class="headerlink" title="10.位数组"></a>10.位数组</h2><h3 id="BitArray类的方法和属性"><a href="#BitArray类的方法和属性" class="headerlink" title="BitArray类的方法和属性"></a>BitArray类的方法和属性</h3><p>下表列出了一些BitArray类的常用属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Count</td><td>获取包含在BitArray元素的数量</td></tr><tr><td>IsReadOnly</td><td>获取一个值，指示BitArray是否是只读</td></tr><tr><td>Item</td><td>获取或设置在所述BitArray的特定位置的比特的值</td></tr><tr><td>Length</td><td>获取或设置在BitArray元素的数量</td></tr></tbody></table><p>下表列出了一些BitArray类的常用方法：</p><table><thead><tr><th>S.N</th><th>方法名称及用途</th></tr></thead><tbody><tr><td>1</td><td><strong>public BitArray And( BitArray value );</strong>  执行对指定BitArray的相应元素在当前BitArray元素的按位与运算</td></tr><tr><td>2</td><td><strong>public bool Get( int index );</strong>  获取在所述BitArray的特定位置的比特的值</td></tr><tr><td>3</td><td><strong>public BitArray Not();</strong> 反转当前BitArray所有的位值，使设置为true的元素被更改为false，并设置为false元素更改为true</td></tr><tr><td>4</td><td><strong>public BitArray Or( BitArray value );</strong>  在执行对指定BitArray的相应元素在当前BitArray的元素的按位或操作</td></tr><tr><td>5</td><td><strong>public void Set( int index, bool value );</strong>  设置在所述BitArray为指定值的特定位置的比特值</td></tr><tr><td>6</td><td><strong>public void SetAll( bool value );</strong>  设置在BitArray所有位设置为指定值</td></tr><tr><td>7</td><td><strong>public BitArray Xor( BitArray value );</strong>  执行关于对在指定BitArray的相应元素中的当前BitArray的元素按位异或运算</td></tr></tbody></table><p>当需要存储位，但不知道事先比特数就使用它。您可以通过使用一个整数索引，它从零开始访问BitArray集合中的项。</p><pre><code>using System;using System.Collections;namespace CollectionsApplication&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //creating two  bit arrays of size 8            BitArray ba1 = new BitArray(8);            BitArray ba2 = new BitArray(8);            byte[] a = &#123; 60 &#125;;            byte[] b = &#123; 13 &#125;;                        //storing the values 60, and 13 into the bit arrays            ba1 = new BitArray(a);            ba2 = new BitArray(b);            //content of ba1            Console.WriteLine(&quot;Bit array ba1: 60&quot;);            for (int i = 0; i &lt; ba1.Count; i++)            &#123;                Console.Write(&quot;&#123;0, -6&#125; &quot;, ba1[i]);            &#125;            Console.WriteLine();                        //content of ba2            Console.WriteLine(&quot;Bit array ba2: 13&quot;);            for (int i = 0; i &lt; ba2.Count; i++)            &#123;                Console.Write(&quot;&#123;0, -6&#125; &quot;, ba2[i]);            &#125;            Console.WriteLine();                                   BitArray ba3 = new BitArray(8);            ba3 = ba1.And(ba2);            //content of ba3            Console.WriteLine(&quot;Bit array ba3 after AND operation: 12&quot;);            for (int i = 0; i &lt; ba3.Count; i++)            &#123;                Console.Write(&quot;&#123;0, -6&#125; &quot;, ba3[i]);            &#125;            Console.WriteLine();            ba3 = ba1.Or(ba2);            //content of ba3            Console.WriteLine(&quot;Bit array ba3 after OR operation: 61&quot;);            for (int i = 0; i &lt; ba3.Count; i++)            &#123;                Console.Write(&quot;&#123;0, -6&#125; &quot;, ba3[i]);            &#125;            Console.WriteLine();                        Console.ReadKey();        &#125;    &#125;&#125;</code></pre><p>让我们编译和运行上面的程序，这将产生以下结果：</p><pre><code>Bit array ba1: 60 False False True True True True False False Bit array ba2: 13True False True True False False False False Bit array ba3 after AND operation: 12False False True True False False False False Bit array ba3 after OR operation: 61True False True True False False False False </code></pre><h6 id="BitVector32"><a href="#BitVector32" class="headerlink" title="BitVector32"></a><a href="http://www.cnblogs.com/kingdom_0/articles/2024941.html">BitVector32</a></h6><p>提供了一个简单结构，该结构以32位内存存储布尔和小数值</p><p>对于内部使用的布尔值和小整数，BitVector32 比 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.bitarray.aspx">BitArray</a> 更有效。 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.bitarray.aspx">BitArray</a> 可以按需要无限地扩大，但它有内存和性能方面的系统开销，这是类实例所要求的。 相比之下，BitVector32 只使用 32 位。</p><p>BitVector32 结构可以设置成包含小整数的若干节或包含布尔值的若干位标志，但不能同时包含两者。<a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.section.aspx">BitVector32.Section</a> 是 BitVector32 中的窗口，且由最小数量的连续位构成，连续位可以包含 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.createsection.aspx">CreateSection</a> 中指定的最大值。 例如，带有最大值 1 的节只由一个位构成，而带有最大值 5 的节由三个位构成。 可以创建带有最大值 1 的 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.section.aspx">BitVector32.Section</a> 作为布尔值，从而使您能够在同一 BitVector32 中存储整数和布尔值。</p><p>BitVector32 既可以设置为节，也可以设置为位标志，分别有成员可以应用于这两种情形。 例如，<a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.item.aspx">BitVector32.Item</a> 属性是作为节设置的 BitVector32 的索引器，而 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.item.aspx">BitVector32.Item</a> 属性是作为位标志设置的BitVector32 的索引器。 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.createmask.aspx">CreateMask</a> 创建一系列屏蔽，这些屏蔽可用于访问作为位标志设置的 BitVector32 中的单个位。</p><p>在作为节设置的 BitVector32 上使用屏蔽可能会导致意外的结果</p><pre><code>using System;using System.Collections.Specialized;public class SamplesBitVector32  &#123;   public static void Main()  &#123;      // Creates and initializes a BitVector32 with all bit flags set to FALSE.      BitVector32 myBV = new BitVector32( 0 );      // Creates masks to isolate each of the first five bit flags.      int myBit1 = BitVector32.CreateMask();      int myBit2 = BitVector32.CreateMask( myBit1 );      int myBit3 = BitVector32.CreateMask( myBit2 );      int myBit4 = BitVector32.CreateMask( myBit3 );      int myBit5 = BitVector32.CreateMask( myBit4 );      // Sets the alternating bits to TRUE.      Console.WriteLine( &quot;Setting alternating bits to TRUE:&quot; );      Console.WriteLine( &quot;   Initial:         &#123;0&#125;&quot;, myBV.ToString() );      myBV[myBit1] = true;      Console.WriteLine( &quot;   myBit1 = TRUE:   &#123;0&#125;&quot;, myBV.ToString() );      myBV[myBit3] = true;      Console.WriteLine( &quot;   myBit3 = TRUE:   &#123;0&#125;&quot;, myBV.ToString() );      myBV[myBit5] = true;      Console.WriteLine( &quot;   myBit5 = TRUE:   &#123;0&#125;&quot;, myBV.ToString() );   &#125;&#125;/*This code produces the following output.Setting alternating bits to TRUE:   Initial:         BitVector32&#123;00000000000000000000000000000000&#125;   myBit1 = TRUE:   BitVector32&#123;00000000000000000000000000000001&#125;   myBit3 = TRUE:   BitVector32&#123;00000000000000000000000000000101&#125;   myBit5 = TRUE:   BitVector32&#123;00000000000000000000000000010101&#125;*/BitVector用作节集合using System;using System.Collections.Specialized;public class SamplesBitVector32  &#123;   public static void Main()  &#123;      // Creates and initializes a BitVector32.      BitVector32 myBV = new BitVector32( 0 );      // Creates four sections in the BitVector32 with maximum values 6, 3, 1, and 15.      // mySect3, which uses exactly one bit, can also be used as a bit flag.      BitVector32.Section mySect1 = BitVector32.CreateSection( 6 );      BitVector32.Section mySect2 = BitVector32.CreateSection( 3, mySect1 );      BitVector32.Section mySect3 = BitVector32.CreateSection( 1, mySect2 );      BitVector32.Section mySect4 = BitVector32.CreateSection( 15, mySect3 );      // Displays the values of the sections.      Console.WriteLine( &quot;Initial values:&quot; );      Console.WriteLine( &quot;\tmySect1: &#123;0&#125;&quot;, myBV[mySect1] );      Console.WriteLine( &quot;\tmySect2: &#123;0&#125;&quot;, myBV[mySect2] );      Console.WriteLine( &quot;\tmySect3: &#123;0&#125;&quot;, myBV[mySect3] );      Console.WriteLine( &quot;\tmySect4: &#123;0&#125;&quot;, myBV[mySect4] );      // Sets each section to a new value and displays the value of the BitVector32 at each step.      Console.WriteLine( &quot;Changing the values of each section:&quot; );      Console.WriteLine( &quot;\tInitial:    \t&#123;0&#125;&quot;, myBV.ToString() );      myBV[mySect1] = 5;      Console.WriteLine( &quot;\tmySect1 = 5:\t&#123;0&#125;&quot;, myBV.ToString() );      myBV[mySect2] = 3;      Console.WriteLine( &quot;\tmySect2 = 3:\t&#123;0&#125;&quot;, myBV.ToString() );      myBV[mySect3] = 1;      Console.WriteLine( &quot;\tmySect3 = 1:\t&#123;0&#125;&quot;, myBV.ToString() );      myBV[mySect4] = 9;      Console.WriteLine( &quot;\tmySect4 = 9:\t&#123;0&#125;&quot;, myBV.ToString() );      // Displays the values of the sections.      Console.WriteLine( &quot;New values:&quot; );      Console.WriteLine( &quot;\tmySect1: &#123;0&#125;&quot;, myBV[mySect1] );      Console.WriteLine( &quot;\tmySect2: &#123;0&#125;&quot;, myBV[mySect2] );      Console.WriteLine( &quot;\tmySect3: &#123;0&#125;&quot;, myBV[mySect3] );      Console.WriteLine( &quot;\tmySect4: &#123;0&#125;&quot;, myBV[mySect4] );   &#125;&#125;</code></pre><h2 id="11-不变的集合"><a href="#11-不变的集合" class="headerlink" title="11.不变的集合"></a>11.不变的集合</h2><p><strong>Net提供的不可变集合</strong></p><pre><code>ImmutableStack&lt;int&gt; a1 = ImmutableStack&lt;int&gt;.Empty;ImmutableStack&lt;int&gt; a2 = a1.Push(10);ImmutableStack&lt;int&gt; a3 = a2.Push(20);ImmutableStack&lt;int&gt; a4 = a3.Push(30);ImmutableStack&lt;int&gt; iv3 = a4.Pop(); </code></pre><p>使用Net不可变列表集合有一点要注意的是，当我们Push值时要重新赋值给原变量才正确，因为push后会生成一个新对象，原a1只是旧值：</p><pre><code>ImmutableStack&lt;int&gt; a1 = ImmutableStack&lt;int&gt;.Empty;a1.Push(10); //不正确，a1仍是空值值，push会生成新的栈。a1 = a1.Push(10); //需要将新栈重新赋值给a1</code></pre><p><strong>NET提供的常用数据结构</strong></p><p>1.ImmutableStack<br>2.ImmutableQueue<br>3.ImmutableList<br>4.ImmutableHashSet<br>5.ImmutableSortedSet<br>6.ImmutableDictionary&lt;K, V&gt;<br>7.ImmutableSortedDictionary&lt;K, V&gt;</p><p><strong>不可变优点</strong></p><p>1.集合共享安全，从不被改变<br>2.访问集合时，不需要锁集合（线程安全）<br>3.修改集合不担心旧集合被改变<br>4.书写更简洁，函数式风格。 var list = ImmutableList.Empty.Add(10).Add(20).Add(30);<br>5.保证数据完整性，安全性</p><p><strong>不可变对象缺点</strong></p><p>不可变本身的优点即是缺点，当每次对象/集合操作都会返回个新值。而旧值依旧会保留一段时间，这会使内存有极大开销，也会给GC造成回收负担，性能也比可变集合差的多。</p><h2 id="12-并发集合"><a href="#12-并发集合" class="headerlink" title="12.并发集合"></a>12.并发集合</h2><p>线程安全的集合可防止多个线程以相互冲突的方式访问集合</p><p>.NET 的System.Collections.Concurrent提供了几个安全的类和功能：</p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd267312.aspx">BlockingCollection</a></td><td>为实现 <a href="https://msdn.microsoft.com/zh-cn/library/dd287147.aspx">IProducerConsumerCollection</a> 的线程安全集合提供阻塞和限制功能。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd381779.aspx">ConcurrentBag</a></td><td>表示对象的线程安全的无序集合。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd287191.aspx">ConcurrentDictionary</a></td><td>表示可由多个线程同时访问的键/值对的线程安全集合。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd267265.aspx">ConcurrentQueue</a></td><td>表示线程安全的先进先出 (FIFO) 集合。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd267331.aspx">ConcurrentStack</a></td><td>表示线程安全的后进先出 (LIFO) 集合。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd394988.aspx">OrderablePartitioner</a></td><td>表示将可排序数据源拆分为多个分区的特定方式。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/system.collections.concurrent.partitioner.aspx">Partitioner</a></td><td>为数组、列表和可枚举对象提供常见的分区策略。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd381768.aspx">Partitioner</a></td><td>表示将数据源拆分为多个分区的特定方式。</td></tr></tbody></table><h3 id="1-创建管道"><a href="#1-创建管道" class="headerlink" title="1)创建管道"></a>1)创建管道</h3><p>将这些并发集合类用于管道,一个任务向一个集合类写入一些内容，同时另一个任务从该集合中读取内容</p><p>示例中多个任务形成一个管道.<br>第一个管道，<br>第1阶段的任务读取文件名，添加到队列，这个任务运行同时，<br>第2阶段的任务已经开始从队列中读取文件名并加载它们的程序,结果被写入另一个队列。<br>第3阶段同时启动，读取并处理第2个队列的内容，结果被写入一个字典。</p><p>第3阶段完成，并且内容已被最终处理，字典得到完整结果时，下一阶段才开始。<br>第4阶段从字典中读取内容，转换数据，然后写入队列中<br>第5阶段在项中添加颜色信息，然后把它们添加到另一个队列中，最后一个阶段显示信息。<br>第4到第6阶段也可以并发运行.</p><pre><code>class Program  &#123;    static void Main(string[] args)    &#123;      StartPipeline();      Console.ReadLine();    &#125;    private static async void StartPipeline()    &#123;      var fileNames = new BlockingCollection&lt;string&gt;();      var lines = new BlockingCollection&lt;string&gt;();      var words = new ConcurrentDictionary&lt;string, int&gt;();      var items = new BlockingCollection&lt;Info&gt;();      var coloredItems = new BlockingCollection&lt;Info&gt;();      Task t1 = PipelineStages.ReadFilenamesAsync(@&quot;../../..&quot;, fileNames);      ConsoleHelper.WriteLine(&quot;started stage 1&quot;);      Task t2 = PipelineStages.LoadContentAsync(fileNames, lines);      ConsoleHelper.WriteLine(&quot;started stage 2&quot;);      Task t3 = PipelineStages.ProcessContentAsync(lines, words);      await Task.WhenAll(t1, t2, t3);      ConsoleHelper.WriteLine(&quot;stages 1, 2, 3 completed&quot;);      Task t4 = PipelineStages.TransferContentAsync(words, items);      Task t5 = PipelineStages.AddColorAsync(items, coloredItems);      Task t6 = PipelineStages.ShowContentAsync(coloredItems);      ConsoleHelper.WriteLine(&quot;stages 4, 5, 6 started&quot;);      await Task.WhenAll(t4, t5, t6);      ConsoleHelper.WriteLine(&quot;all stages finished&quot;);    &#125;  &#125;</code></pre><pre><code>public class ConsoleHelper  &#123;    private static object syncOutput = new object();    public static void WriteLine(string message)    &#123;      lock (syncOutput)      &#123;        Console.WriteLine(message);      &#125;    &#125;    public static void WriteLine(string message, string color)    &#123;      lock (syncOutput)      &#123;        Console.ForegroundColor = (ConsoleColor)Enum.Parse(typeof(ConsoleColor), color);        Console.WriteLine(message);        Console.ResetColor();      &#125;    &#125;  &#125;</code></pre><pre><code>public static class PipelineStages  &#123;    public static Task ReadFilenamesAsync(string path, BlockingCollection&lt;string&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (string filename in Directory.EnumerateFiles(path, &quot;*.cs&quot;, SearchOption.AllDirectories))          &#123;            output.Add(filename);            ConsoleHelper.WriteLine(string.Format(&quot;stage 1: added &#123;0&#125;&quot;, filename));          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static async Task LoadContentAsync(BlockingCollection&lt;string&gt; input, BlockingCollection&lt;string&gt; output)    &#123;      foreach (var filename in input.GetConsumingEnumerable())      &#123;        using (FileStream stream = File.OpenRead(filename))        &#123;          var reader = new StreamReader(stream);          string line = null;          while ((line = await reader.ReadLineAsync()) != null)          &#123;            output.Add(line);            ConsoleHelper.WriteLine(string.Format(&quot;stage 2: added &#123;0&#125;&quot;, line));          &#125;        &#125;      &#125;      output.CompleteAdding();    &#125;    public static Task ProcessContentAsync(BlockingCollection&lt;string&gt; input, ConcurrentDictionary&lt;string, int&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var line in input.GetConsumingEnumerable())          &#123;            string[] words = line.Split(&#39; &#39;, &#39;;&#39;, &#39;\t&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;:&#39;, &#39;,&#39;, &#39;&quot;&#39;);            foreach (var word in words.Where(w =&gt; !string.IsNullOrEmpty(w)))            &#123;              output.AddOrIncrementValue(word);              ConsoleHelper.WriteLine(string.Format(&quot;stage 3: added &#123;0&#125;&quot;, word));            &#125;          &#125;        &#125;);    &#125;    public static Task TransferContentAsync(ConcurrentDictionary&lt;string, int&gt; input, BlockingCollection&lt;Info&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var word in input.Keys)          &#123;            int value;            if (input.TryGetValue(word, out value))            &#123;              var info = new Info &#123; Word = word, Count = value &#125;;              output.Add(info);              ConsoleHelper.WriteLine(string.Format(&quot;stage 4: added &#123;0&#125;&quot;, info));            &#125;          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static Task AddColorAsync(BlockingCollection&lt;Info&gt; input, BlockingCollection&lt;Info&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var item in input.GetConsumingEnumerable())          &#123;            if (item.Count &gt; 40)            &#123;              item.Color = &quot;Red&quot;;            &#125;            else if (item.Count &gt; 20)            &#123;              item.Color = &quot;Yellow&quot;;            &#125;            else            &#123;              item.Color = &quot;Green&quot;;            &#125;            output.Add(item);            ConsoleHelper.WriteLine(string.Format(&quot;stage 5: added color &#123;1&#125; to &#123;0&#125;&quot;, item, item.Color));          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static Task ShowContentAsync(BlockingCollection&lt;Info&gt; input)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var item in input.GetConsumingEnumerable())          &#123;            ConsoleHelper.WriteLine(string.Format(&quot;stage 6: &#123;0&#125;&quot;, item), item.Color);          &#125;        &#125;);    &#125;  &#125;</code></pre><p>2)使用<a href="https://msdn.microsoft.com/zh-cn/library/dd267312.aspx">BlockingCollection</a></p><p>第1阶段的ReadFilenamesAsync方法，实现了迭代目录文件名。在完成文件名添加后调用output.CompleteAdding();用以通知所有读取器不再等待集合中任何额外的项.如果没有调用的话，循环中读取器会添加等待更多的项.</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>public static Task ReadFilenamesAsync(string path, BlockingCollection&lt;string&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (string filename in Directory.EnumerateFiles(path, &quot;*.cs&quot;, SearchOption.AllDirectories))          &#123;            output.Add(filename);            ConsoleHelper.WriteLine(string.Format(&quot;stage 1: added &#123;0&#125;&quot;, filename));          &#125;          output.CompleteAdding();        &#125;);    &#125;</code></pre><p>ReadFilenamesAsync </p><p>下一阶段读取文件并将器内容添加到另一个集合中，由LoadContentAsync方法完成，该方法使用了输入集合传递的文件名，打开文件，把文件中的所有行添加到输出的集合中。在循环中用输入阻塞集合调用GetConsumingEnumerable()方法，以迭代各项，不使用也是可以的，但是值会迭代当前状态的集合。不会迭代以后添加的项。</p><p>如果在填充集合的同时，使用读取器读取集合，则需要使用GetConsumingEnumerable()方法获取阻塞集合的枚举器，而不是直接迭代集合</p><pre><code>public static async Task LoadContentAsync(BlockingCollection&lt;string&gt; input, BlockingCollection&lt;string&gt; output)    &#123;      foreach (var filename in input.GetConsumingEnumerable())      &#123;        using (FileStream stream = File.OpenRead(filename))        &#123;          var reader = new StreamReader(stream);          string line = null;          while ((line = await reader.ReadLineAsync()) != null)          &#123;            output.Add(line);            ConsoleHelper.WriteLine(string.Format(&quot;stage 2: added &#123;0&#125;&quot;, line));          &#125;        &#125;      &#125;      output.CompleteAdding();    &#125;</code></pre><p>3)使用<a href="https://msdn.microsoft.com/zh-cn/library/dd287191.aspx">ConcurrentDictionary</a></p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523162236413-845354975.png" alt="img"></p><pre><code>public static Task ProcessContentAsync(BlockingCollection&lt;string&gt; input, ConcurrentDictionary&lt;string, int&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var line in input.GetConsumingEnumerable())          &#123;            string[] words = line.Split(&#39; &#39;, &#39;;&#39;, &#39;\t&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;:&#39;, &#39;,&#39;, &#39;&quot;&#39;);            foreach (var word in words.Where(w =&gt; !string.IsNullOrEmpty(w)))            &#123;              output.AddOrIncrementValue(word);              ConsoleHelper.WriteLine(string.Format(&quot;stage 3: added &#123;0&#125;&quot;, word));            &#125;          &#125;        &#125;);    &#125;</code></pre><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523162311476-1014974724.png" alt="img"></p><pre><code>public static class ConcurrentDictionaryExtension  &#123;    public static void AddOrIncrementValue(this ConcurrentDictionary&lt;string, int&gt; dict, string key)    &#123;      bool success = false;      while (!success)      &#123;        int value;        if (dict.TryGetValue(key, out value))        &#123;          if (dict.TryUpdate(key, value + 1, value))          &#123;            success = true;          &#125;        &#125;        else        &#123;          if (dict.TryAdd(key, 1))          &#123;            success = true;          &#125;        &#125;      &#125;    &#125;  &#125;</code></pre><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523162341117-33389163.png" alt="img"></p><p>在完成第3个阶段后，第4到6阶段也可以并行运行，TransferContentAsync从字典中获取数据，进行类型转换，输出到BlockingCollection<string>中</string></p><pre><code>public static Task ProcessContentAsync(BlockingCollection&lt;string&gt; input, ConcurrentDictionary&lt;string, int&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var line in input.GetConsumingEnumerable())          &#123;            string[] words = line.Split(&#39; &#39;, &#39;;&#39;, &#39;\t&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;:&#39;, &#39;,&#39;, &#39;&quot;&#39;);            foreach (var word in words.Where(w =&gt; !string.IsNullOrEmpty(w)))            &#123;              output.AddOrIncrementValue(word);              ConsoleHelper.WriteLine(string.Format(&quot;stage 3: added &#123;0&#125;&quot;, word));            &#125;          &#125;        &#125;);    &#125;    public static Task TransferContentAsync(ConcurrentDictionary&lt;string, int&gt; input, BlockingCollection&lt;Info&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var word in input.Keys)          &#123;            int value;            if (input.TryGetValue(word, out value))            &#123;              var info = new Info &#123; Word = word, Count = value &#125;;              output.Add(info);              ConsoleHelper.WriteLine(string.Format(&quot;stage 4: added &#123;0&#125;&quot;, info));            &#125;          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static Task AddColorAsync(BlockingCollection&lt;Info&gt; input, BlockingCollection&lt;Info&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var item in input.GetConsumingEnumerable())          &#123;            if (item.Count &gt; 40)            &#123;              item.Color = &quot;Red&quot;;            &#125;            else if (item.Count &gt; 20)            &#123;              item.Color = &quot;Yellow&quot;;            &#125;            else            &#123;              item.Color = &quot;Green&quot;;            &#125;            output.Add(item);            ConsoleHelper.WriteLine(string.Format(&quot;stage 5: added color &#123;1&#125; to &#123;0&#125;&quot;, item, item.Color));          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static Task ShowContentAsync(BlockingCollection&lt;Info&gt; input)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var item in input.GetConsumingEnumerable())          &#123;            ConsoleHelper.WriteLine(string.Format(&quot;stage 6: &#123;0&#125;&quot;, item), item.Color);          &#125;        &#125;);    &#125;</code></pre><h2 id="13-性能"><a href="#13-性能" class="headerlink" title="13.性能"></a>13.性能</h2><p>集合的方法常常有性能提示，给出大写O记录操作时间。</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523162826570-2112606748.png" alt="img"></p><p>O(1)表示无论集合中有多少数据项，这个操作需要的时间都不变。<br>O(n)表示对于集合执行一个操作需要的事件在最坏情况时是N.<br>O(log n)表示操作需要的时间随集合中元素的增加而增加</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523163051320-952892312.png" alt="img"></p><h3 id="非泛型类集合"><a href="#非泛型类集合" class="headerlink" title="非泛型类集合"></a>非泛型类集合</h3><p>泛型集合类是在.NET2.0的时候出来的,也就是说在1.0的时候是没有这么方便的东西的。现在基本上我们已经不使用这些集合类了，除非在做一些和老代码保持兼容的工作的时候。来看看1.0时代的.NET程序员们都有哪些集合类可以用。</p><p>ArraryList后来被List<T>替代。</T></p><p>HashTable 后来被Dictionary&lt;TKey,TValue&gt;替代。<br>Queue 后来被Queue<T>替代。<br>SortedList 后来被SortedList<T>替代。<br>Stack 后来被Stack<T>替代。</T></T></T></p><h3 id="线程安全的集合类"><a href="#线程安全的集合类" class="headerlink" title="线程安全的集合类"></a>线程安全的集合类</h3><p>ConcurrentQueue 线程安全版本的Queue<br>ConcurrentStack线程安全版本的Stack<br>ConcurrentBag线程安全的对象集合<br>ConcurrentDictionary线程安全的Dictionary<br>BlockingCollection</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第十章 字符串和正则表达式</title>
      <link href="2021/02/20/c-10/c-10th-10/"/>
      <url>2021/02/20/c-10/c-10th-10/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第十章-字符串和正则表达式"><a href="#c-语言-第十章-字符串和正则表达式" class="headerlink" title="c#语言 第十章 字符串和正则表达式"></a>c#语言 第十章 字符串和正则表达式</h1><p>10.1 System.String类</p><p>​        System.String是一个类，专门用于存储字符串，允许对字符串进行许多操作。C#提供了关键字string和相关的语法，以便使用这个类更轻松。</p><blockquote><pre><code>你可以通过运算符重载连接字符串string message1 = &quot;hello&quot;;message1 += &quot; world&quot;;Console.WriteLine(message1);</code></pre></blockquote><blockquote><pre><code>C#还允许通过使用类似索引器的语法来提取字符串中的指定字符：string message1 = &quot;hello&quot;;char char1 = message1[0];Console.WriteLine(char1);</code></pre></blockquote><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Compare</td><td>比较字符串的内容，考虑区域设置之间的某些字符的等价性。</td></tr><tr><td>CompareOrdinal</td><td>比较字符串的内容，但不考虑区域设置。</td></tr><tr><td>Concat</td><td>将不同的字符串实例合并成一个字符串实例。</td></tr><tr><td>CopyTo</td><td>将指定序号，指定长度的字符拷贝到另外一个新建的数组中。</td></tr><tr><td>Format</td><td>根据指定的格式格式化一个含有多种数值的字符串。</td></tr><tr><td>IndexOf</td><td>定位某个字符或者子串在字符串中首次出现的位置。</td></tr><tr><td>IndexOfAny</td><td>定位一组字符中任意一个字符在字符串中首次出现的位置。</td></tr><tr><td>Insert</td><td>在指定位置插入另外一个字符串。</td></tr><tr><td>Join</td><td>按照要求将一个字符串数组合并成一个字符串实例。</td></tr><tr><td>LastIndexOf</td><td>跟IndexOf一样，但返回最后一次出现的位置。</td></tr><tr><td>LastIndexOfAny</td><td>跟IndexOfAny一样，但返回最后一次出现的位置。</td></tr><tr><td>PadLeft</td><td>如果字符串不够指定位数，则在其左侧按给定字符补全位数。</td></tr><tr><td>PadRight</td><td>如果字符串不够指定位数，则在其右侧按给定字符补全位数。</td></tr><tr><td>Replace</td><td>将指定字符或者子串替换成另外一个字符或者子串。</td></tr><tr><td>Split</td><td>根据指定字符分隔成若干子串。</td></tr><tr><td>Substring</td><td>根据指定位置和长度获取一个子串。</td></tr><tr><td>ToLower</td><td>转成小写。</td></tr><tr><td>ToUpper</td><td>转成大写。</td></tr><tr><td>Trim</td><td>移除字符串开头与结尾的空格。</td></tr></tbody></table><p>10.1.1构建字符串</p><p>​        String类存在一个问题：重复修改给定的字符串，效率会很低，它实际上是一个不可变的数据类型，一旦对字符串对象进行了初始化，该字符串对象就不能改变了</p><blockquote><pre><code>string message1 = &quot;hello&quot;;message1 = &quot;hello world&quot;;</code></pre></blockquote><p>​        表面上message1修改了字符串的内容，实际上是创建了一个新的字符串hello world然后将其指向meesage1，原来的hello字符串就没有变量引用它，下一次垃圾收集器清理时就会删除它</p><p>10.1.2 StringBuilder成员</p><p>​        实例化StringBuilder时有很多重载可以选择，其中就有提供一个字符串和给定容量</p><blockquote><pre><code>StringBuilder strb1 = new StringBuilder(&quot;hello&quot;);StringBuilder strb2 = new StringBuilder(100);</code></pre></blockquote><p>​        还可以随时显示地设置容量，当字符串长度超出时，就会抛出异常：</p><blockquote><pre><code>StringBuilder strb = new StringBuilder(&quot;1个字符&quot;);strb.Capacity = 1;</code></pre></blockquote><p>​        StringBuilder类上可以进行的处理仅限于替换和追加或删除字符串中的文本。StringBuilder转换为string的唯一方法就是使用ToString()方法。StringBuilder类基本上应在处理多个字符串时使用。</p><p>10.2字符串格式</p><p><strong>格式字符串</strong></p><p>例子：</p><pre><code>Console.WriteLine(&quot;张三有存款：&#123;0,10:C&#125;&quot;,1000);Console.WriteLine(&quot;李四有存款：&#123;0,10:C&#125;&quot;, 800);Console.WriteLine(&quot;赵六有存款：&#123;0,10:C&#125;&quot;, 20000);</code></pre><p>运行以上代码，结果如下：</p><p>​        解释一下{0,10:C}的作用，其中{0}是占位符，逗号后的数字是表示该项字符串要占用的字符宽度，冒号后面的字母是格式说明符。在使用格式说明符时，会检查占位符替换内容的类型是否实现IFormattable接口，如果没有则调用对象的ToString()方法。</p><p>​        在自定义类中实现IFormattable</p><blockquote><pre><code>1 class Program2 &#123;3     static void Main(string[] args)4     &#123;5         Person p = new Person();6         p.FirstName = &quot;zhang&quot;;7         p.SecondName = &quot;san&quot;;8         Console.WriteLine(&quot;无格式说明符：&#123;0&#125;&quot;, p);9         Console.WriteLine(&quot;格式说明符C：&#123;0:C&#125;&quot;, p);10         Console.WriteLine(&quot;格式说明符A：&#123;0:A&#125;&quot;, p);11     &#125;12 13 &#125;14 public class Person : IFormattable15 &#123;16     public string FirstName &#123; get; set; &#125;17     public string SecondName &#123; get; set; &#125;18     public string ToString(string format, IFormatProvider formatProvider)19     &#123;20         //当没有传入格式说明符时，直接调用ToString()21         if (format == null)22         &#123;23             return ToString();24         &#125;25         //C表示返回中国格式名字  A表示返回美国格式名字26         switch (format.ToUpper())27         &#123;28             case &quot;C&quot;:29                 return FirstName + SecondName;30             case &quot;A&quot;:31                 return SecondName + FirstName;32             default:33                 return ToString();34         &#125;35     &#125;36 &#125;</code></pre></blockquote><p>10.2.1字符串插值</p><p>10.2.2日期事件和数字格式</p><p>10.2.3自定义字符串格式</p><p>10.3正则表达式</p><p>​        .NET正则表达式引擎用于兼容Perl 5 的正则表达式</p><p>10.3.1正则表达式概述</p><p>​        正则表达式是一种专门用于字符串处理的语言</p><p>10.3.2RegularExpressionsPlayaround示例</p><blockquote><pre><code>MatchCollection match = Regex.Matches(&quot;happy hapy hay&quot;, &quot;ha.+?y&quot;);foreach (Match item in match)&#123;    Console.WriteLine(&quot;&#123;0&#125;位置，匹配到&#123;1&#125;&quot;, item.Index, item.Value);&#125;Console.ReadKey();</code></pre></blockquote><p>10.3.3显示结果</p><p>10.3.4匹配、组合捕获</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 字符串和正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第九章 委托、lambda表达式和事件</title>
      <link href="2021/02/20/c-10/c-10th-09/"/>
      <url>2021/02/20/c-10/c-10th-09/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第九章-委托、lambda表达式和事件"><a href="#c-语言-第九章-委托、lambda表达式和事件" class="headerlink" title="c#语言 第九章 委托、lambda表达式和事件"></a>c#语言 第九章 委托、lambda表达式和事件</h1><p>9.1引用方法</p><p>​        委托是寻址方法的.NET版本。委托是类型安全的类，它定义了返回类型和参数的类型。委托不仅包含对方法的引用，也可以包含对多个方法的引用。</p><p>​        Lambda表达式与委托直接相关。当参数是委托类型时，就可以使用lambda表达式实现委托引用的方法。</p><p>9.2委托</p><p>​        当要把方法传递给其它方法时，需要使用委托。委托是一种特殊类型的对象，其特殊之处在于，我们以前定义的所有对象都包含数据，而委托包含的只是一个或多个方法的地址。</p><p>9.2.1声明委托</p><p>​    委托使用关键字 delegate 进行定义。</p><p>例子：</p><p>​    定义一个返回类型为void参数为一个int的名为IntMethodInvoker的委托</p><blockquote><p>delegate void IntMethodInvoker(int x);</p></blockquote><p>​    因为定义委托基本上就是定义一个新类，所以可以在定义类的任何相同地方定义委托。可以在委托定义上应用常见的访问修饰符：public、private、protected等。</p><p>9.2.2使用委托</p><p>9.2.3简单的委托示例</p><blockquote><p>delegate int CalculateMethodInvoker(int x, int y);<br>class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        CalculateMethodInvoker calculateMethodInvoker = CalculateMethodHelper.Sum;<br>        int x = 100, y = 200;<br>        Console.WriteLine(“x,y相加：{0}”, Calculate(calculateMethodInvoker, x, y));<br>        calculateMethodInvoker = CalculateMethodHelper.Multiply;<br>        Console.WriteLine(“x,y相乘：{0}”, Calculate(calculateMethodInvoker, x, y));<br>        Console.ReadKey();<br>    }<br>    public static int Calculate(CalculateMethodInvoker calculateMethodInvoker, int x, int y)<br>    {<br>        return calculateMethodInvoker(x, y);<br>    }<br>}<br>public class CalculateMethodHelper<br>{<br>    public static int Sum(int x, int y)<br>    {<br>        return x + y;<br>    }<br>    public static int Multiply(int x, int y)<br>    {<br>        return x * y;<br>    }<br>}</p></blockquote><p>​        为了减少输入量，只需要委托实例，就可以只传递地址的名称。这称为委托推断。</p><p>9.2.4action<T>和Func<T>委托</T></T></p><p>​        除了为每个参数和返回类型定义一个新的委托类型外，还可以使用Action<T>和Func<T>委托。</T></T></p><p>​        泛型Action<T>委托表示引用一个void返回类型的方法，没有泛型参数的Action类可调用没有参数的方法。</T></p><p>​        泛型Func<T>委托表示引用一个有返回值的方法</T></p><p>9.2.5BubbleSorter示例</p><p>9.2.6 多播委托</p><p>​        委托也可以包含多个方法。这种委托成为多播委托。如果调用多播委托，就可以按顺序连续调用多个方法。为此，委托的签名就必须返回void；否则，就只能得到委托调用的最后一个方法的结果。多播委托识别运算符“-”、“+”、“-=”、“+=”以从委托中增加或删除方法调用。</p><blockquote><p>class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        Action&lt;int, int&gt; calFunc = CalculateMethodHelper.Sum;<br>        calFunc += CalculateMethodHelper.Multiply;<br>        int x = 100, y = 200;<br>        Calculate(calFunc, x, y);<br>        Console.ReadKey();<br>    }<br>    public static void Calculate(Action&lt;int, int&gt; calculateMethodInvoker, int x, int y)<br>    {<br>        Console.WriteLine(“运行结果：”);<br>        calculateMethodInvoker(x, y);<br>    }<br>}<br>public class CalculateMethodHelper<br>{<br>    public static void Sum(int x, int y)<br>    {<br>        Console.WriteLine(“x,y相加：{0}”, x + y);<br>    }<br>    public static void Multiply(int x, int y)<br>    {<br>        Console.WriteLine(“x,y相乘：{0}”, x * y);<br>    }<br>}</p></blockquote><p>​        如果通过委托调用的其中一个方法抛出异常，整个迭代就会停止。解决的方法是，使用Delegate类中定义的GetInvocationList()方法获取Delegate对象数组，再使用循环遍历执行，在过程中捕获异常，来继续下一次迭代。</p><p>9.2.7匿名方法</p><p>匿名方法是用作委托的参数的一段代码。</p><blockquote><pre><code>Action&lt;int, int&gt; calFunc = delegate (int i, int j)&#123;    Console.WriteLine(&quot;x,y相加：&#123;0&#125;&quot;, i + j);&#125;;</code></pre></blockquote><p>在匿名方法中不可使用跳转语句（break、goto或continue），在匿名方法内部不能访问不安全代码，不能访问在匿名方法外部使用的ref和out参数。</p><p>9.3lambda表达式</p><p>自C#3.0开始，可以使用新的语法把实现代码赋予委托，只要有委托参数类型的地方，就可以使用lambda表达式。</p><blockquote><pre><code>Action&lt;int, int&gt; calFunc = (i, j) =&gt;&#123;    Console.WriteLine(&quot;x,y相加：&#123;0&#125;&quot;, i + j);&#125;;</code></pre></blockquote><p>9.3.1参数</p><p>lambda表达式有几种定义参数的方式。如果只有一个参数，只写出参数名就足够了。如果除一个参数以外，需要圆括号把参数名括起来。</p><blockquote><p>Action<int> one = i =&gt;<br>{<br>    //方法内容<br>};<br>Action&lt;int, int&gt; two = (i, j) =&gt;<br>{<br>    //方法内容<br>};</int></p></blockquote><p>9.3.2多行代码</p><p>如果lambda表示只有一条语句，在方法块内就不需要花括号和return语句，因为编译器会隐式添加return</p><blockquote><pre><code>Func&lt;int&gt; lambdaOne = () =&gt; 0;</code></pre></blockquote><p>如果实现代码超过一行，就需要使用return语句显式返回</p><blockquote><p>Func<int> lambdaOne = () =&gt;<br>{<br>    int i = 0;<br>    i++;<br>    ++i;<br>    return i;<br>};</int></p></blockquote><p>9.3.3闭包</p><p>通过lambda表达式可以访问lambda表达式块外部的变量。这称为闭包。</p><blockquote><p>int param = 10;<br>Action<int> lambdaSecond = (i) =&gt;<br>{<br>    Console.WriteLine(i + param);<br>};<br>lambdaSecond(3);<br>Console.ReadKey();</int></p></blockquote><p>9.4事件</p><p>事件基于委托，为委托提供了一种发布/订阅机制。</p><blockquote><p>class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        AlarmClock alarmClock = new AlarmClock();<br>        Student zsStudent = new Student(“张三”);<br>        alarmClock.ItsGetUpClockEvent += zsStudent.ItsGetUpClock;<br>        alarmClock.ItsGetUpClock();<br>        Student lsStudent = new Student(“李四”);<br>        WeakEventManager&lt;AlarmClock, EventArgs&gt;.AddHandler(alarmClock, “ItsGetUpClockEvent”, lsStudent.ItsGetUpClock);//弱事件<br>        alarmClock.ItsGetUpClock();<br>        Console.ReadKey();<br>    }</p><p>}<br>//事件发布类<br>public class AlarmClock<br>{<br>    public event EventHandler<EventArgs> ItsGetUpClockEvent;<br>    public void ItsGetUpClock()<br>    {<br>        Console.WriteLine(“时间到，起床了！”);<br>        ItsGetUpClockEvent?.Invoke(this, new EventArgs());<br>    }<br>}<br>//事件侦听类<br>public class Student<br>{<br>    public string Name { get; set; }<br>    public Student(string name)<br>    {<br>        this.Name = name;<br>    }<br>    public void ItsGetUpClock(object sender, EventArgs e)<br>    {<br>        Console.WriteLine(“{0}关掉闹钟，起床了。”,Name);<br>    }<br>}</EventArgs></p></blockquote><p>9.4.1事件发布程序</p><p>9.4.2事件侦听器</p><p>9.4.3弱事件</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 运算符和强制类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第八章 运算符和强制类型转换</title>
      <link href="2021/02/20/c-10/c-10th-08/"/>
      <url>2021/02/20/c-10/c-10th-08/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第八章-运算符和强制类型转换"><a href="#c-语言-第八章-运算符和强制类型转换" class="headerlink" title="c#语言 第八章 运算符和强制类型转换"></a>c#语言 第八章 运算符和强制类型转换</h1><h2 id="本章要点："><a href="#本章要点：" class="headerlink" title="本章要点："></a>本章要点：</h2><p>​    c#中的运算符</p><p>​    使用c#6的新运算符nameof和控制传播</p><p>​    隐式和显示转换</p><p>​    使用装箱技术把值类型转换为引用类型</p><p>​    比较值类型和引用类型</p><p>​    重载标准的运算符以支持自定义类型</p><p>​    实现索引运算符</p><p>​    通过类型强制转换在引用类型之间的转换</p><h2 id="8-1运算符和类型转换"><a href="#8-1运算符和类型转换" class="headerlink" title="8.1运算符和类型转换"></a>8.1运算符和类型转换</h2><h2 id="8-2运算符"><a href="#8-2运算符" class="headerlink" title="8.2运算符"></a>8.2运算符</h2><table><thead><tr><th>类别</th><th>运算符</th></tr></thead><tbody><tr><td>算术运算符</td><td>+ - * / %</td></tr><tr><td>逻辑运算符</td><td>&amp; | ^ ~ &amp;&amp; || !</td></tr><tr><td>字符串连接运算符</td><td>+</td></tr><tr><td>增量和减量运算符</td><td>++ –</td></tr><tr><td>移位运算符</td><td>&lt;&lt; &gt;&gt;</td></tr><tr><td>比较运算符</td><td>== != &lt; &gt; &lt;= &gt;=</td></tr><tr><td>赋值运算符</td><td>= += -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=</td></tr><tr><td>成员访问运算符（用于对象和结构）</td><td>.</td></tr><tr><td>索引运算符（用于数组和索引器）</td><td>[]</td></tr><tr><td>类型转换运算符</td><td>()</td></tr><tr><td>条件运算符（三元运算符）</td><td>?:</td></tr><tr><td>委托连接和删除运算符</td><td>+ -</td></tr><tr><td>对象创建运算符</td><td>new</td></tr><tr><td>类型信息运算符</td><td>sizeof is typeof as</td></tr><tr><td>溢出异常控制运算符</td><td>checked unchecked</td></tr><tr><td>间接寻址运算符</td><td>[]</td></tr><tr><td>名称空间别名限定符</td><td>::</td></tr><tr><td>空合并运算符</td><td>??</td></tr></tbody></table><p>​        有4个运算符（sizeof()、*、-&gt;和&amp;）只能用于不安全的代码（这些代码忽略了c#的类型安全性检查），这些不安全的代码见第五章细节</p><p>​        c#中很少用到指针，因此很少用到间接寻址运算符（-&gt;）。</p><h3 id="8-2-1运算符的简化操作"><a href="#8-2-1运算符的简化操作" class="headerlink" title="8.2.1运算符的简化操作"></a>8.2.1运算符的简化操作</h3><p>​        x+=y等同于x=x+y，赋值运算符中（+= -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=）都是相同的模式。</p><p>​        当x++和++x单独一行时等同于x=x+1。当他们用于较长的表达式内部时，运算符放在前面（++x）会在计算表达式之前增加x。</p><blockquote><p>int x = 0,y=0;</p><p>x++;</p><p>++y;</p><p>if (x==y)</p><p>{</p><p>   Console.WriteLine(“单独一行++在前在后结果一样”);</p><p>}</p><p>if (++x==2)</p><p>{</p><p>   Console.WriteLine(“++在前提前计算”);</p><p>}</p><p>if (y++==2)</p><p>{</p><pre class=" language-c#"><code class="language-c#">Console.WriteLine("++在后没有提前计算");</code></pre><p>}</p></blockquote><h4 id="（1）条件运算符"><a href="#（1）条件运算符" class="headerlink" title="（1）条件运算符"></a>（1）<strong>条件运算符</strong></h4><p>​        条件运算符（?:）也称单元运算符，是if…else的简化形式。它判断一个条件真假来返回对应的值（为真返回:之前的值，为假返回:之后的值）。</p><blockquote><pre><code>int x = 0;string str = x == 0 ? &quot;x等于0&quot; : &quot;x不等于0&quot;;Console.WriteLine(str)</code></pre></blockquote><h4 id="（2）checked运算符和unchecked运算符"><a href="#（2）checked运算符和unchecked运算符" class="headerlink" title="（2）checked运算符和unchecked运算符"></a>（2）<strong>checked运算符和unchecked运算符</strong></h4><p>​        C#提供checked运算符和unchecked运算符，来对一个代码块进行标记，是否执行溢出检查。</p><blockquote><pre><code>byte x = 255;x++;Console.WriteLine(x);</code></pre></blockquote><p>​        运行以上代码，结果如下：</p><p> <img src="https://images2015.cnblogs.com/blog/682781/201703/682781-20170327225436358-244304394.png" alt="img"></p><p>​        这是因为，C#默认使用unchecked运算符不对溢出执行检查，这会导致数据丢失（byte不能超过255，溢出的位会丢失，所以结果为0）。</p><p>​        如果要防止溢出导致的数据丢失，可以使用checked运算符对代码块进行标记。</p><blockquote><p>byte x = 255;</p><p>checked</p><p>{</p><p>   x++;</p><p>}</p><p>Console.WriteLine(x);</p></blockquote><p>​    运行以上代码，结果如下：</p><p> <img src="https://images2015.cnblogs.com/blog/682781/201703/682781-20170327225448951-1311569589.png" alt="img"></p><p>​    程序会抛出异常，这个时候我们就能捕捉异常，来防止溢出丢失数据。</p><h4 id="（3）is运算符"><a href="#（3）is运算符" class="headerlink" title="（3）is运算符"></a><strong>（3）is运算符</strong></h4><p>​        Is运算符检查对象是否与特定类型兼容（是该类型或者派生自该类型）。</p><blockquote><p>int x = 0;</p><p>if (x is object)</p><p>{</p><p>   Console.WriteLine(“x是object类型或派生自object的类型”);</p><p>}</p></blockquote><h4 id="（4）as运算符"><a href="#（4）as运算符" class="headerlink" title="（4）as运算符"></a>（4）<strong>as运算符</strong></h4><p>​        as运算符用于执行引用类型的显式类型转换。如果要转换的类型与指定的类型兼容，转换就会成功；如果不兼容，as运算符就会返回null。</p><blockquote><p>object obj1 = “字符串”;</p><p>object obj2 = 0;</p><p>string str1 = obj1 as string;</p><p>string str2 = obj2 as string;</p><p>Console.WriteLine(“obj1 as string转换结果：” + str1);</p><p>Console.WriteLine(“obj2 as string转换结果：” + str2);</p></blockquote><p>​        运行以上代码，结果如下：</p><p> <img src="https://images2015.cnblogs.com/blog/682781/201703/682781-20170327225525951-930522724.png" alt="img"></p><p>​        as运算符允许在一步中执行安全的类型转换，不需要先使用is运算符测试类型，再执行转换。</p><h4 id="（5）sizeof运算符"><a href="#（5）sizeof运算符" class="headerlink" title="（5）sizeof运算符"></a>（5）<strong>sizeof运算符</strong></h4><p>​        使用sizeof运算符可以确定栈中值类型的长度（单位是字节）：</p><blockquote><pre><code>Console.WriteLine(sizeof(int));//4</code></pre></blockquote><h4 id="（6）typeof运算符"><a href="#（6）typeof运算符" class="headerlink" title="（6）typeof运算符"></a>（6）<strong>typeof运算符</strong></h4><p>​        typeof运算符返回一个表示特定类型的System.Type对象。例如，typeof(string)返回表示System.String类型的Type类型。在使用反射技术动态地查找对象的信息时，这个运算符很有用。</p><h4 id="7-nameof运算符"><a href="#7-nameof运算符" class="headerlink" title="(7)nameof运算符"></a>(7)nameof运算符</h4><p>​        nameof是新的c#6运算符，该运算符接受一个符号、属性或方法，并返回其名称</p><h4 id="8-index运算符"><a href="#8-index运算符" class="headerlink" title="(8)index运算符[]"></a>(8)index运算符[]</h4><blockquote><p>int x = arr[2];</p></blockquote><h4 id="9-可空类型和运算符"><a href="#9-可空类型和运算符" class="headerlink" title="(9)可空类型和运算符"></a>(9)可空类型和运算符</h4><p>如果在程序中使用可空类型，就必须考虑null值与各种运算符一起使用时的影响。</p><blockquote><pre><code>int? x = null;int? y = x + 1;//null</code></pre></blockquote><h4 id="10-空合并运算符"><a href="#10-空合并运算符" class="headerlink" title="(10)空合并运算符"></a>(10)<strong>空合并运算符</strong></h4><p>​        空合并运算符（??）提供了一种快捷方式，可以在处理可空类型和引用类型时表示null可能的值。</p><p>例子：</p><blockquote><p>int? x = null;</p><p>int y;</p><p>y = x ?? 0;</p><p>Console.WriteLine(y);</p></blockquote><h4 id="11-空值传播运算符"><a href="#11-空值传播运算符" class="headerlink" title="(11)空值传播运算符"></a>(11)空值传播运算符</h4><blockquote><p>public void ShowPerson(Person p){</p><p>​    string firstName = p?.FirstName;</p><p>}</p></blockquote><h3 id="8-2-2运算符的优先级和关联性"><a href="#8-2-2运算符的优先级和关联性" class="headerlink" title="8.2.2运算符的优先级和关联性"></a>8.2.2运算符的优先级和关联性</h3><p>优先级由上到下依次递减</p><table><thead><tr><th>组</th><th>运算符</th></tr></thead><tbody><tr><td>初级运算符</td><td>() . [] x++ x– new typeof sizeof checked unchecked</td></tr><tr><td>一元运算符</td><td>+ - ! ~ ++x –x 和数据类型强制转换</td></tr><tr><td>乘除运算符</td><td>* / %</td></tr><tr><td>加减运算符</td><td>+ -</td></tr><tr><td>移位运算符</td><td>&lt;&lt; &gt;&gt;</td></tr><tr><td>关系运算符</td><td>&lt; &gt; &gt;= &lt;= is as</td></tr><tr><td>比较运算符</td><td>== !=</td></tr><tr><td>按位AND运算符</td><td>&amp;</td></tr><tr><td>按位XOR运算符</td><td>^</td></tr><tr><td>按位OR运算符</td><td>|</td></tr><tr><td>布尔AND运算符</td><td>&amp;&amp;</td></tr><tr><td>布尔OR运算符</td><td>||</td></tr><tr><td>条件运算符</td><td>?:</td></tr><tr><td>赋值运算符</td><td>= += -= *= /= %= &amp;= |= ^= &lt;&lt;== &gt;&gt;= &gt;&gt;&gt;=</td></tr></tbody></table><p>​        除了运算符优先级外，对于二元运算符，需要注意运算符是从左到右还是从右到左计算，除了少数运算符外，所有的运算符都是做关联的。例如</p><blockquote><p>x+y+z  就等于 （x+y）+z</p></blockquote><p>​        <strong>关联性的重要例外就是赋值运算符，他们是右关联的</strong>。例如</p><blockquote><p>x=y=z=3  从右向左赋值，所以x、y、z的值都是3</p></blockquote><p>​        <strong>一个重要的，可能误导的有关联运算符是条件运算符</strong></p><blockquote><p>a?b:c?d:e   </p><p>等于</p><p>a=b:(c?d:e)</p></blockquote><p>​        在复杂的表达式中，应避免利用运算符优先级来生成正确的结果，使用圆括号制定运算符的执行顺序，可以是代码更整洁，避免出现潜在的冲突。</p><h2 id="8-3类型的安全性"><a href="#8-3类型的安全性" class="headerlink" title="8.3类型的安全性"></a>8.3类型的安全性</h2><p>​        c#也支持不同引用类型之间的转换，在与其他类型相互转换时还允许定义所创建的数据类型的行为方式，</p><h3 id="8-3-1类型转换"><a href="#8-3-1类型转换" class="headerlink" title="8.3.1类型转换"></a>8.3.1类型转换</h3><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>​        只要保证值不会发生任何变化，类型转换就可以自动（隐式）进行。当值的数量级不受影响，而精度可能受到影响时，也可以进行隐式转换，因为编译器认为这是可以接受的错误。</p><h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><p>​        当无法保证值不会发生任何变化时，就需要使用显式转换，否则编译器会报错。</p><p>例子：</p><p>​        long类型无法隐式的转换为int，但我们可以显式地进行转换</p><blockquote><pre><code>long lon = 1;int i = (int)lon;</code></pre></blockquote><p>​        显式转换是一种比较危险的操作，因为有可能造成溢出，这样导致结果与正确值不同。在进行隐式转换时，应使用checked运算符进行检查。</p><h3 id="8-3-2装箱和拆箱"><a href="#8-3-2装箱和拆箱" class="headerlink" title="8.3.2装箱和拆箱"></a>8.3.2装箱和拆箱</h3><p>​    装箱用于描述一个值类型转换为引用类型</p><blockquote><pre><code>int i = 100;object obj = i;</code></pre></blockquote><p>​    拆箱用于描述相反的过程，其中以前装箱的值类型强制转换回值类型</p><blockquote><pre><code>int i = 100;object obj = i;int _i = (int)obj;</code></pre></blockquote><h2 id="8-4比较对象的相等性"><a href="#8-4比较对象的相等性" class="headerlink" title="8.4比较对象的相等性"></a>8.4比较对象的相等性</h2><p>​        对象相等的机制有所不同，这取决于比较的是引用类型（类的实例）还是值类型（基本数据类型、结构或枚举的实例）</p><h3 id="8-4-1比较引用类型的相等性"><a href="#8-4-1比较引用类型的相等性" class="headerlink" title="8.4.1比较引用类型的相等性"></a>8.4.1比较引用类型的相等性</h3><p>（1）<strong>ReferenceEquals()方法</strong></p><p>​        ReferenceEquals()是一个静态方法，测试两个引用是否引用类的同一个实例，特别是两个引用是否包含内存中的相同地址。最为静态方法，它不可重写。</p><blockquote><p>Person p1, p2;</p><p>p1 = new Person();</p><p>p2 = new Person();</p><p>bool b1 = ReferenceEquals(null, null);</p><p>bool b2 = ReferenceEquals(null, p1);</p><p>bool b3 = ReferenceEquals(p1, p2);</p><p>Console.WriteLine(“ReferenceEquals(null, null) 的结果：{0}”, b1);</p><p>Console.WriteLine(“ReferenceEquals(null, p1) 的结果：{0}”, b2);</p><p>Console.WriteLine(“ReferenceEquals(p1, p2) 的结果：{0}”, b3);</p></blockquote><p>（2）<strong>虚拟的Equals()方法</strong></p><p>​        Equals()方法是虚拟方法，所以可以在自己的类中重写，从而按值来比较对象。</p><p>（3）<strong>静态的Equals()方法</strong></p><p>Equals()静态版本与其虚拟实例版本的作用相同，其区别是静态版本带有两个参数，并对它们进行相等性比较。</p><p>（4）<strong>比较运算符==</strong></p><p>​    最好将比较运算符看作严格的值比较和严格的引用比较之间的中间选项</p><h3 id="8-4-2比较值类型的相等性"><a href="#8-4-2比较值类型的相等性" class="headerlink" title="8.4.2比较值类型的相等性"></a>8.4.2比较值类型的相等性</h3><p>​        在比较值类型的相等性时，采用与引用类型相同的规则：ReferenceEquals()用于比较引用，Equals()用于比较值，比较运算符可以看作一个中间选项。但最大的区别是值类型需要进行装箱，才能把它们转换为引用类型，进而才能对它们执行方法。</p><p>​        在System.ValueType类中重载了实例方法Equals()，以便对值类型进行合适的相等性测试。</p><h2 id="8-5运算符重载"><a href="#8-5运算符重载" class="headerlink" title="8.5运算符重载"></a>8.5运算符重载</h2><p>​        如果要对自定义的类使用运算符，就必须告诉编译器相关的运算符在这个类的上下文中的含义，此时就需要使用运算符重载。</p><p>​        C#要求所有的运算符重载都声明为public和static，这表示它们与它们的类相关联而不是特定实例。重载运算符需要使用operator关键字。编译器处理运算符重载和处理方法重载是一样的。C#要求成对的重载比较运算符，且必须返回布尔值。</p><blockquote><p>public static decimal operator +(Person lhs, Person rhs)</p><p>{</p><pre><code>return lhs.Money + rhs.Money;</code></pre><p>}</p></blockquote><h3 id="8-5-1运算符的工作方式"><a href="#8-5-1运算符的工作方式" class="headerlink" title="8.5.1运算符的工作方式"></a>8.5.1运算符的工作方式</h3><p>​        它们会根据参数类型查找最匹配的运算符重载。</p><h3 id="8-5-2运算符重载的示例"><a href="#8-5-2运算符重载的示例" class="headerlink" title="8.5.2运算符重载的示例"></a>8.5.2运算符重载的示例</h3><h3 id="8-5-3比较运算符的重载"><a href="#8-5-3比较运算符的重载" class="headerlink" title="8.5.3比较运算符的重载"></a>8.5.3比较运算符的重载</h3><h3 id="8-5-4可以重载的运算符"><a href="#8-5-4可以重载的运算符" class="headerlink" title="8.5.4可以重载的运算符"></a>8.5.4可以重载的运算符</h3><table><thead><tr><th>类别</th><th>运算符</th><th>限制</th></tr></thead><tbody><tr><td>算术二元运算符</td><td>+、*、/、-、%</td><td>无</td></tr><tr><td>算术一元运算符</td><td>+、-、++、–</td><td>无</td></tr><tr><td>按位二元运算符</td><td>&amp;、|、^、&lt;&lt;、&gt;&gt;</td><td>无</td></tr><tr><td>按位一元运算符</td><td>!、~、true、false</td><td>true和false运算符必须成对重载</td></tr><tr><td>比较运算符</td><td>==、!=、&gt;=、&lt;、&lt;=、&gt;</td><td>比较运算符必须成对重载</td></tr><tr><td>赋值运算符</td><td>+=、-=、*=、/=、&gt;&gt;=、&lt;&lt;=、%=、&amp;=、|=、^=</td><td>不能显式地重载这些运算符，在重写单个运算符（如+、-等）时，它们会被隐式地重写</td></tr><tr><td>索引运算符</td><td>[]</td><td>不能直接重载索引运算符。索引器成员类型允许在类和结构上支持索引运算符。</td></tr><tr><td>数据类型强制转换运算符</td><td>()</td><td>不能直接重载类型强制运算符。用户定义的类型强制转换允许定义定制的类型强制转换。</td></tr></tbody></table><p>8.6实现自定义的索引运算符</p><p>​    可以给自定义类创建一个索引器，索引器看起来非常类似于属性，因为它也包含get和set访问器。指定索引器要使用this关键字，this关键字后面的括号指定索引使用的类型。数组体用int类型的索引器，所以这里使用int类型直接把信息传递给包含的数组people。</p><blockquote><p>public Person this[int index]{</p><p>​    get{return _people[index];}</p><p>​    set{_people[index]=value;}</p><p>}</p></blockquote><p>​        对于索引器，不能仅定义int类型作为索引类型。任何类型都是有效的。例如：</p><blockquote><p>public IEnumerable<Person> this[DateTime birthday]{</Person></p><p>​    get{ return _people.where(p=&gt;p.Birthday ==birthday);}</p><p>}</p></blockquote><p>8.7实现用户定义的类型强制转换</p><p>​        C#允许定义自己的数据类型（结构和类），这意味着需要某些工具支持在自定义的数据类型之间进行类型转换。方法是把类型强制转换运算符定义为相关类的成员运算符，类型强制装换运算符必须标记为隐式或显式，以说明希望如何使用它。我们应遵守与预定义的类型强制转换相同的规则，如果知道无论在元变量中存储什么值，类型强制转换总是安全的，就可以把它定义为隐式强制转换。然而，如果某些数值可能会出错，如丢失数据或抛出异常，就应把数据类型转换定义为显式强制转换。</p><p>例子：</p><p>显式关键字explicit，隐式关键字implicit</p><blockquote><p>class Program</p><p>{</p><pre><code>static void Main(string[] args)&#123;    Water water = new Water(100);            Ice ice = (Ice)water;//Water显示转换为Ice            Water water2 = ice;//Ice隐式转换为Water            Console.ReadKey();&#125;</code></pre><p>}</p><p>public class Water</p><p>{</p><pre><code>public int Volume &#123; get; set; &#125;public Water(int volume)&#123;    this.Volume = volume;&#125;public static explicit operator Ice(Water lhs)&#123;    return new Ice(lhs.Volume+1);&#125;</code></pre><p>}</p><p>public class Ice</p><p>{</p><pre><code>public int Volume &#123; get; set; &#125;public Ice(int volume)&#123;    this.Volume = volume;&#125;public static implicit operator Water(Ice lhs)&#123;    return new Water(lhs.Volume-1);&#125;</code></pre><p>}</p></blockquote><p>​    定义不同结构或类的实例之间的类型强制转换时完全合法的，但有两个限制：</p><ul><li>如果某个类派生自另一个类，就不能定义这两个类之间的类型强制转换（这些类型的类型转换已经存在）。</li><li>类型强制转换必须在源数据类型或目标数据类型的内部定义。</li></ul><p>​     C#要求把类型强制转换的定义放置在源类（或结构）或目标类（或结构）的内部。它的副作用是不能定义两个类之间的类型强制转换，除非至少可以编辑其中一个类的源代码。这是因为，这样可以防止第三方把类型转换引入类中。</p><p>8.7.1实现用户定义的类型强制转换</p><p>类之间的强制转换</p><p>基类和派生类之间的类型强制转换</p><p>装箱和拆箱类型强制转换</p><p>8.7.2多重类型强制转换</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 运算符和强制类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第七章 数组和元祖</title>
      <link href="2021/02/19/c-10/c-10th-07/"/>
      <url>2021/02/19/c-10/c-10th-07/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第七章-数组和元祖"><a href="#c-语言-第七章-数组和元祖" class="headerlink" title="c#语言 第七章 数组和元祖"></a>c#语言 第七章 数组和元祖</h1><h2 id="7-1-同一类型Array和不同类型Tuple的多个对象"><a href="#7-1-同一类型Array和不同类型Tuple的多个对象" class="headerlink" title="7.1 同一类型Array和不同类型Tuple的多个对象"></a>7.1 同一类型Array和不同类型Tuple的多个对象</h2><p>​        对于同一个类型的多个对象，我们可以使用集合和数组。</p><p>​        C#用特殊的记号声明、初始化和使用数组。Array类在后台发挥作用，它为数组中元素的排序和过滤提供了几个方法。使用枚举器，就可以迭代数组中的所有元素。</p><p>​        对于不同类型的多个对象，可以使用Tuple（元组）类型。</p><h2 id="7-2简单数组"><a href="#7-2简单数组" class="headerlink" title="7.2简单数组"></a>7.2简单数组</h2><p>​        数组是一种数据结构，可以包含统一类型的多个元素。</p><h3 id="7-2-1数组的声明"><a href="#7-2-1数组的声明" class="headerlink" title="7.2.1数组的声明"></a>7.2.1数组的声明</h3><p>​        在声明数组时，应先定义元素的类型，其后是一对空方括号，后面是变量名</p><h3 id="7-2-2数组的初始化"><a href="#7-2-2数组的初始化" class="headerlink" title="7.2.2数组的初始化"></a>7.2.2数组的初始化</h3><p>​        在声明了数组之后，我们需要为数组的元素分配内存。因为数组时引用类型，所以我们必须用new来给它分配堆上的内存。使用new运算符，制定数组中元素的类型和数量来初始化数组的变量</p><blockquote><p>int[] myArray ;//声明数组</p><p>myArray = new int [4]；//分配内存</p><p>int[] myArray = new int [4]{1,2,3,4};</p><p>//如果我们在声明时使用初始化器为数组赋值，那就可以不必指定数组的大小，因为编译器会自动统计元素的个数</p><p>int[] myArray = new int []{1,2,3,4};</p><p>int[] myArray = {1,2,3,4}; //简化写法</p></blockquote><p><strong>如果你不知道数组应包含多少个元素个数，那你应该用集合而不是数组。</strong></p><h3 id="7-2-3访问数组元素"><a href="#7-2-3访问数组元素" class="headerlink" title="7.2.3访问数组元素"></a>7.2.3访问数组元素</h3><p>​        访问数组元素的下标都是从0开始，0代表第一个数组元素。</p><p><img src="https://img-blog.csdnimg.cn/2020050810080638.png" alt="img"></p><blockquote><p>int[] myArray = new int[]{1,2,3,4};</p><p>int v1 = myArray[0];</p><p>myArray[2]=5;</p></blockquote><h3 id="7-2-4使用引用类型"><a href="#7-2-4使用引用类型" class="headerlink" title="7.2.4使用引用类型"></a>7.2.4使用引用类型</h3><p>​        数组不仅可以声明值类型的元素，还可以声明引用类型的元素，而且往往使用引用类型的元素还挺常见。</p><p>​        要注意的是，使用引用类型如类类型，那你需要为该类型里面的每个元素分配内存，都要初始化值。</p><blockquote><p>public class Person<br>{<br>   public string name;<br>   public int age;</p><p>   public void GETAge()<br>   {<br>       DO…..<br>   }<br>}</p><p>public class M<br>{<br>   // 使用类的实例作为数组元素<br>   Person[] myPerson= new Person[2];</p><pre class=" language-c#"><code class="language-c#">// 每次初始化都是初始化这个对象myPerson[0] = new Person{ name = "马云"，age = 55};myPerson[1] = new Person{ name = "totoro"，age = 18};</code></pre><p>}</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200508100700528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RPVE9MT0c=,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="7-3多维数组"><a href="#7-3多维数组" class="headerlink" title="7.3多维数组"></a>7.3多维数组</h2><p>  <strong>声明数组后，就不能修改其阶数了</strong></p><blockquote><p>int[,] arr2 = new int[1, 2];<br>int[,,] arr3 = new int[2,2,2] {<br>                                {<br>                                    {1,2 },   //0,0,0 - 0,0,1<br>                                    {3,4 }    //0,1,0 - 0,1,1<br>                                },<br>                                {<br>                                    {5,6 },   //1,0,0 - 1,0,1<br>                                    {7,8 }    //1,1,0 - 1,1,1<br>                                }<br>                               };</p><p>Console.WriteLine(arr3[0, 0, 0]);  // 输出1<br>Console.WriteLine(arr3[0, 1, 0]);  // 输出3</p></blockquote><h2 id="7-4锯齿数组"><a href="#7-4锯齿数组" class="headerlink" title="7.4锯齿数组"></a>7.4锯齿数组</h2><p><img src="https://img-blog.csdnimg.cn/20200508104822207.png" alt="img"></p><blockquote><p>{<br>    // 声明一个3维的锯齿数组，最外维包有2个2维<br>    int[][][] arr = new int[2][][];</p><pre class=" language-c#"><code class="language-c#">// 表示最外围的第一个二维数组，该2为数组包含3个一维数组arr[0] = new int[3][]; // 表示中间的第一个一维数组，该一维数组包含2个元素arr[0][0] = new int[3] { 1,2,3};arr[0][1] = new int[5] { 4,5,6,7,8};arr[0][2] = new int[2] { 9,10}; // 验证，输出7Console.WriteLine(arr[0][1][3]);     </code></pre><p>}</p></blockquote><h2 id="7-5Array类"><a href="#7-5Array类" class="headerlink" title="7.5Array类"></a>7.5Array类</h2><p>​        上面声明数组都是通过Array类来实现的，就是说使用[]就是使用Array类的表示法。c#语法，会创建一个派生自抽象类基类Array类的新类。</p><p>​        Length属性和foreach语句迭代数组，其实是使用了Array类中的GetEnumerator()方法。</p><p>​        <strong>如果数组中包含的元素个数超过了整数范围，就可以使用LongLength属性获得元素个数。</strong></p><h3 id="7-5-1创建数组"><a href="#7-5-1创建数组" class="headerlink" title="7.5.1创建数组"></a>7.5.1创建数组</h3><p>​        Array类是一个抽象类，所以不能用构造函数来创建数组。</p><p>​        除了我们常规类如上面的[]创建数组,还有一种方法可以创建数组，那就是使用静态方法CreateInstance( )创建数组。如果你开始不知道数组的类型，那这方法就显得非常有用了。</p><p>​        <strong>CreateInstance()方法有许多重载版本，可以创建多维数组和不基于0的数组。</strong></p><blockquote><p>int[] lengths = { 2, 3 };<br>int[] lowerBounds = { 1, 10 };</p><p>// lengths 表示你要创建一个2*3维的数组，不能创建锯齿数组<br>// lowerBounds表示自定义每个维度的初始下标，默认是0开始，这里最外围自定义最小是1，最里维是从10开始<br>Array arr = Array.CreateInstance(typeof(string), lengths, lowerBounds);</p><p>// 给这个2维数组赋值<br>arr.SetValue(“A”, 1, 10); // 就相当于[0,0]<br>arr.SetValue(“B”, 1, 11);<br>arr.SetValue(“C”, 1, 12);<br>arr.SetValue(“D”, 2, 10); // 就相当于[1,0]<br>arr.SetValue(“E”, 2, 11);<br>arr.SetValue(“F”, 2, 12); // 就相当于[1,2]</p><p>// 对于Array类型的我们不能直接输出Console.Write(arr[1][11])，需要通过遍历数组<br>System.Collections.IEnumerator arr1  = arr.GetEnumerator();</p><p>// arr1.Rank得到数组的维度，这里arr1.Rank - 1得到1，即0-1<br>// arr1.GetLength(1),表示第二维上有几个元素<br>// arr1.MoveNext()表示是否存在元素<br>while (arr1.MoveNext())<br>{<br>   // 存在就输出该元素值<br>   Console.Write(“\t{0}”, arr1.Current);<br>}</p></blockquote><h3 id="7-5-2复制数组"><a href="#7-5-2复制数组" class="headerlink" title="7.5.2复制数组"></a>7.5.2复制数组</h3><p>​        因为数组是引用类型，所以将一个数组变量赋予另一个数组的变量，就会得到两个引用同一数组的变量。就是在栈上有两个引用的值都是一个堆上的某个地址。而复制数组，会使数组实现ICloneable接口。这个接口定义的Clone( )方法会创建数组的浅表副本。如：</p><blockquote><p>{<br>    int[] arr = {1,2,3，4,5};</p><pre><code>// 实现浅表复制（只动栈），对于引用类型复制引用而不动到对象，对于值类型直接复制值int[] arr1 = (int[])arr.Clone(); // 还有一种是复制堆对象数据 int[] arr2 = new int[3]; Array.Copy(arr, arr2, arr2.Length);</code></pre><p>}</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200508144252355.png" alt="img">    </p><p>​        如果元素是值类型，就会赋值所有值</p><p><img src="https://img-blog.csdnimg.cn/20200508144212691.png" alt="img"></p><p><strong>除了Clone()方法之外，还可以使用Array.Copy()方法创建浅表副本。但clone和copy的一个重要区别：</strong></p><p>​    clone会创建一个新数组</p><p>​    copy方法必须传递阶数相同且有足够元素的已有数组</p><h3 id="7-5-3排序"><a href="#7-5-3排序" class="headerlink" title="7.5.3排序"></a>7.5.3排序</h3><p>​        Array使用Quicksort算法对数组中的元素进行排序。Sort方法需要数组中元素实现IComparable接口。例如简单类型 string和int32实现IComparable接口，所以可以对包含这些类型的元素排序</p><blockquote><p>{<br>    int[] arr = { 5, 2, 1,4,3 };<br>    string[] brr = { “H”, “U”, “A”, “N”, “Z” };</p><pre><code>// 无论数字还是字符串都从小到大输出（对字符串判断首字母）Array.Sort(arr);Array.Sort(brr);</code></pre><p>}</p></blockquote><p>​        对于我们自定义的类类型数组也是可以排序的，但是一定要注意，使用自定义类做排序，那么这个自定义类一定要是实现Icomparable&lt;自定义类名&gt; 这个接口的</p><blockquote><p>public  class Class1: IComparable<Class1><br>{<br>     // 姓<br>     public string FirstName { get; set; }</Class1></p><pre><code>// 名public string LastName &#123; get; set; &#125; // 别忘了重写Tostring(),这样你才能狗输出字符串内容public override string ToString() =&gt; $&quot;&#123;FirstName&#125; &#123;LastName&#125;&quot;; // 也前往别忘了要实现接口public int CompareTo(Class1 other)&#123;    if (other == null) throw new ArgumentNullException(&quot;other&quot;);     // 比较 姓 先,不一致默认返回1，一致默认返回0    int result = FirstName .CompareTo(other.FirstName );    if (result == 0)    &#123;        result = LastName.CompareTo(other.LastName);    &#125;    return result;&#125;</code></pre><p>}</p><p>public class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        Class1[] arr = new Class1[]<br>        {<br>            new Class1 { FirstName=”马”, LastName=”云” },<br>            new Class1 { FirstName=”马”, LastName=”化腾” },<br>            new Class1 { FirstName=”李”, LastName=”庆国” },<br>            new Class1 { FirstName=”董”, LastName=”明珠” },<br>            new Class1 { FirstName=”宗”, LastName=”庆后” }<br>        }</p><pre><code>    // 进行排序，会触发CompareTo    Array.Sort(arr);             // 输出结果    foreach (var a in arr)    &#123;        Console.WriteLine(a);    &#125;    &#125;</code></pre><p>}</p></blockquote><h2 id="7-6数组作为参数"><a href="#7-6数组作为参数" class="headerlink" title="7.6数组作为参数"></a>7.6数组作为参数</h2><h3 id="7-6-1数组协变"><a href="#7-6-1数组协变" class="headerlink" title="7.6.1数组协变"></a>7.6.1数组协变</h3><p>​        数组支持协变，表示数组可以声明为基类，其派生类型的元素可以赋予数组元素。我们可以把自定义的Class1类数组赋值给object数组，因为Class1派生自object，这就是数组协变的表示，数组协变只能用于引用类型，不能用于值类型！！！如：</p><blockquote><p>// 接着上面代码<br>public class Program<br>{<br>    public static void DispalyArray(object[] data)<br>    {<br>        DO……<br>    }</p><pre><code>DispalyArray(arr);</code></pre><p>}</p></blockquote><h3 id="7-6-2ArraySegment"><a href="#7-6-2ArraySegment" class="headerlink" title="7.6.2ArraySegment"></a>7.6.2ArraySegment<T></T></h3><p>​        结构ArraySegment<T>表示数组的一个部分。如果需要使用不同的方法处理某个大型数组的不同部分，那么可以把相应的数组部分传到各个方法中。具体的使用如下：</T></p><blockquote><p>public class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        int[] ar1 = { 1, 4, 5, 11, 13, 18 };<br>        int[] ar2 = { 3, 4, 5, 18, 21, 27, 33 };</p><pre><code>    // 我们可以将一个数组或者多个数组的部分传给某个函数做处理    var segments = new ArraySegment&lt;int&gt;[2]    &#123;        new ArraySegment&lt;int&gt;(ar1, 0, 3),        new ArraySegment&lt;int&gt;(ar2, 3, 3)    &#125;             SumOfSegments(segments);&#125; static void SumOfSegments(ArraySegment&lt;int&gt;[] segments)&#123;    foreach (var segment in segments)    &#123;        for (int i = segment.Offset; i &lt; segment.Offset + segment.Count; i++)        &#123;            Console.WriteLine(segment.Array[i]);        &#125;    &#125;&#125;</code></pre><p>}</p></blockquote><p>​        来了来了，动脑的地方来了，数组段不复制原数组的元素，但是原数组可以通过ArraySegment<T>访问。如果数组段中的元素改变了，这些变化就会反映到原数组中。如：</T></p><blockquote><p>// 接着上面的代码，我们改一下：<br>{<br>        static void SumOfSegments(ArraySegment<int>[] segments)<br>        {<br>            foreach (var segment in segments)<br>            {<br>                for (int i = segment.Offset; i &lt; segment.Offset + segment.Count; i++)<br>                {<br>                    // 改一下这里，改一下数组的值<br>                    segment.Array[i] = 998 ;<br>                }</int></p><pre><code>        &#125;                    &#125;             // 在最后    foreach (var a in ar1)    &#123;        Console.WriteLine(a);    &#125;</code></pre><p>}</p></blockquote><p>​        </p><h2 id="7-7枚举-foreach"><a href="#7-7枚举-foreach" class="headerlink" title="7.7枚举 foreach"></a>7.7枚举 foreach</h2><h3 id="7-7-1IEnumrtator接口"><a href="#7-7-1IEnumrtator接口" class="headerlink" title="7.7.1IEnumrtator接口"></a>7.7.1IEnumrtator接口</h3><p>​        在上面谈Array类的时候，代码中我们有用到这么一个方法——GetEnumerator( )，数组或集合都有实现带GetEnumerator()方法的IEumerator接口。调用了foreach方法的客户端和集合之间的关系显示如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200509104613177.png" alt="img"></p><p>​    IEumerator定义了current属性，来返回光标所在的元素，改接口的MoveNext( )方法移动到集合的下一个元素上，如果有这个元素，就返回true，否则返回false。</p><p>​    这个接口的泛型版本IEnumerator<T>派生自IDispossable,因此定义了Dispose()方法，来清理给枚举器分配的资源。</T></p><h3 id="7-7-2foreach语句"><a href="#7-7-2foreach语句" class="headerlink" title="7.7.2foreach语句"></a>7.7.2foreach语句</h3><p>​        foreach语句的实现并不真的需要在集合类中实现这个接口，它只需要通过一个名为GetEnumerator( )的方法，它返回实现了IEumerator接口就足够了</p><h3 id="7-7-3yield语句"><a href="#7-7-3yield语句" class="headerlink" title="7.7.3yield语句"></a>7.7.3yield语句</h3><p>​        c#2.0添加了yield语句，以便于创建枚举器。</p><p>​        yield return 语句返回集合的一个元素，并移动到下一个元素上，yield break可停止迭代。</p><blockquote><p>using System;</p><p>using System.Collections;</p><p>namespace Wrox.ProCSarp.Arrays{</p><p>​    public class HelloCollection{</p><p>​        public IEnumerator<string>  GetEnumerator(){</string></p><p>​            yield return “Hello”,</p><p>​            yield return “world”,</p><p>​        }</p><p>​    }</p><p>}</p></blockquote><p>​        迭代集合的不同方式</p><p>​        用yield return返回枚举器</p><h2 id="7-8元祖"><a href="#7-8元祖" class="headerlink" title="7.8元祖"></a>7.8元祖</h2><p>​        来讲讲元组吧，前面一直在说数组(同类型)，元组就是支持不同类型的元素。</p><p>​        元组的使用和数组不同，数组是new创建的，元组不是，且元组一直都是作为方法的类型。例如Tuple<T1>包含一个元素，Tuple&lt;T1,T2&gt;包含两个元素，以此类推。元组用静态的Create( )方法创建。Create( )方法的泛型参数定义了要实例化的元组类型。如：</T1></p><blockquote><p> public class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        int[] a = { 1, 2, 3, 4, 5 };<br>        string b = “HeeloWorld!”;</p><pre><code>    var result = TT(a,b);&#125; // 通过Item取对应的类型值foreach (var i in result.Item1)&#123;    Console.WriteLine(i);&#125; // 元组可接纳不同类型的参数，返回不同类型的结果static Tuple&lt;int[], string&gt; SumOfSegments(int[] a,string b)&#123;    // Tuple.Create将计算结果打包成元组返回去    return Tuple.Create(a, b);&#125;</code></pre><p>}</p></blockquote><h2 id="7-9结构比较"><a href="#7-9结构比较" class="headerlink" title="7.9结构比较"></a>7.9结构比较</h2>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 数组和元祖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第六章 泛型</title>
      <link href="2021/02/18/c-10/c-10th-06/"/>
      <url>2021/02/18/c-10/c-10th-06/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第六章-泛型"><a href="#c-语言-第六章-泛型" class="headerlink" title="c#语言 第六章 泛型"></a>c#语言 第六章 泛型</h1><h2 id="6-1泛型概述"><a href="#6-1泛型概述" class="headerlink" title="6.1泛型概述"></a>6.1泛型概述</h2><p>​        有了泛型就可以创建独立于被包含类型的类和方法，不必给不同的类型编写功能相同的许多方法或类，只创建一个方法和类即可</p><p>​        另一个减少代码的选项是使用object类，但使用派生自object类的类型进行传递不是类型安全的</p><p>​        泛型使用泛型类型，根据需要用特定的类型替换泛型类型，保证了类型安全性</p><h3 id="6-1-1-性能"><a href="#6-1-1-性能" class="headerlink" title="6.1.1 性能"></a>6.1.1 性能</h3><p>​        对值类型使用非泛型集合类，则在把值类型转换为引用类型和把引用类型转换为值类型时，需要进行装箱和拆箱操作。操作很容易，但是性能损失比较大，遍历许多项时尤其如此。</p><p>​        使用List<T>定义泛型为int时，就不需要再进行装箱和拆箱操作。</T></p><h3 id="6-1-2类型安全"><a href="#6-1-2类型安全" class="headerlink" title="6.1.2类型安全"></a>6.1.2类型安全</h3><p>​        泛型类List<T>中，泛型类型T定义了允许使用过的类型，有了List<int> 的定义，就只能把证书类型添加到集合中。</int></T></p><h3 id="6-1-3二进制代码的重用"><a href="#6-1-3二进制代码的重用" class="headerlink" title="#6.1.3二进制代码的重用"></a>#6.1.3二进制代码的重用</h3><p>​        泛型允许更好的重用二进制代码，泛型类可以定义一次，并且可以用许多不同的类型实例化。</p><h3 id="6-1-4代码的扩展"><a href="#6-1-4代码的扩展" class="headerlink" title="6.1.4代码的扩展"></a>6.1.4代码的扩展</h3><p>​        JIT编译器会把泛型类型编译为本地代码时，会给每个值类型创建一个新类</p><h3 id="6-1-5命名约定"><a href="#6-1-5命名约定" class="headerlink" title="6.1.5命名约定"></a>6.1.5命名约定</h3><p>​        泛型类型的命名名称用字母T作为前缀</p><p>​        如果没有特需要求，泛型类型允许用任意类代替</p><p>​        如果泛型类型有特殊要求，（必须实现一个借口）或使用多个泛型类型，就应给泛型类型使用描述性的名称</p><h2 id="6-2创建泛型类"><a href="#6-2创建泛型类" class="headerlink" title="6.2创建泛型类"></a>6.2创建泛型类</h2><p>​    每个处理兑现类型的类都可以有泛型的实现方式，另外，如果类使用了层次结构，泛型就非常有助于消除类型强制转换操作</p><h2 id="6-3泛型类的功能"><a href="#6-3泛型类的功能" class="headerlink" title="6.3泛型类的功能"></a>6.3泛型类的功能</h2><h3 id="6-3-1默认值"><a href="#6-3-1默认值" class="headerlink" title="6.3.1默认值"></a>6.3.1默认值</h3><p>​    不能把null赋值非泛型类型，因为泛型类型也可以实例化为值类型，而null只能用于引用;</p><p>​    使用default关键字，将null值赋予引用类型，将0赋予值类型</p><h3 id="6-3-2约束"><a href="#6-3-2约束" class="headerlink" title="6.3.2约束"></a>6.3.2约束</h3><p>​    如果泛型需要调用泛型类型中的方法，就必须添加约束</p><p>​    泛型支持的几种约束</p><p>​        where T:struct  必须是值类型</p><p>​        where T:class 必须是引用类型</p><p>​        where T:IFoo 必须是实现接口IFoo</p><p>​        where T:Foo 必须是派生自Foo</p><p>​        where T:new() 构造函数约束，指定T必须有一个默认构造函数</p><p>​        where T1:T2  类型T1派生自泛型类型T2</p><h3 id="6-3-3-继承"><a href="#6-3-3-继承" class="headerlink" title="6.3.3 继承"></a>6.3.3 继承</h3><p>​        泛型类可以实现泛型接口，也可以派生自一个类，泛型类可以派生自泛型类</p><p>​        要求必须重复接口的泛型类型，或者必须制定基类的类型</p><p>​        派生类可以是泛型类型或非泛型类型</p><h3 id="6-3-4静态成员"><a href="#6-3-4静态成员" class="headerlink" title="6.3.4静态成员"></a>6.3.4静态成员</h3><h2 id="6-4泛型接口"><a href="#6-4泛型接口" class="headerlink" title="6.4泛型接口"></a>6.4泛型接口</h2><p>6.4.1协变和抗变</p><p>.net 4之前泛型接口是不变的，。net4通过协变和抗变为泛型接口和泛型委托添加了一个重要的扩展。</p><p>协变和抗变指对参数和返回值的类型进行转换</p><p>6.4.2泛型接口的协变</p><p>​        如果泛型类型用out关键字标注，泛型接口是协变得。这也意味着返回类型只能是T</p><p>6.4.3泛型接口的抗变</p><p>​        如果泛型类型用in关键字标注，泛型接口是抗变的。这也意味着输入只能是T</p><h2 id="6-5泛型结构"><a href="#6-5泛型结构" class="headerlink" title="6.5泛型结构"></a>6.5泛型结构</h2><p>Nullable<T>  =&gt;Nullable<int> =&gt; int?</int></T></p><blockquote><p>int y1 = x1??0; </p></blockquote><h2 id="6-6泛型方法"><a href="#6-6泛型方法" class="headerlink" title="6.6泛型方法"></a>6.6泛型方法</h2><p>6.6.1泛型方法示例</p><p>6.6.2带约束的泛型方法</p><p>6.6.3带委托的泛型方法</p><p>6.6.4泛型方法规范</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第五章 托管和非托管的资源</title>
      <link href="2021/02/18/c-10/c-10th-05/"/>
      <url>2021/02/18/c-10/c-10th-05/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第五章-托管和非托管的资源"><a href="#c-语言-第五章-托管和非托管的资源" class="headerlink" title="c#语言 第五章 托管和非托管的资源"></a>c#语言 第五章 托管和非托管的资源</h1><h2 id="5-1资源"><a href="#5-1资源" class="headerlink" title="5.1资源"></a>5.1资源</h2><p>使用托管和非托管的资源—存储在托管或本机堆中的对象，尽管垃圾收集齐释放存储在托管堆中的托管对象，但不释放本机堆中的对象，必须由开发人员自己释放</p><p>什么是大小对象堆？</p><p>什么数据类型存储在堆栈上是非常有益的？</p><p>垃圾收集器处理托管的资源，那么非托管的资源呢？</p><h2 id="5-2后台内存管理"><a href="#5-2后台内存管理" class="headerlink" title="5.2后台内存管理"></a>5.2后台内存管理</h2><h3 id="5-2-1值类型数据"><a href="#5-2-1值类型数据" class="headerlink" title="5.2.1值类型数据"></a>5.2.1值类型数据</h3><p>虚拟内存：执行代码、代码加载的所有DLL、以及程序运行时使用的所有变量</p><p>栈–值类型数据</p><p>​    块作用域或结构作用域：生存期嵌套</p><p>​    编译器在内部确保先放在内存中的那个变量后删除</p><h3 id="5-2-2引用数据类型"><a href="#5-2-2引用数据类型" class="headerlink" title="5.2.2引用数据类型"></a>5.2.2引用数据类型</h3><p>​    所有引用类型，托管堆</p><p>首先创建对象时，分配堆上的内存以存储对象（真正的对象），然后把变量的值设置为分配给新对象的内存地址</p><p>把一个引用变量的值赋予两一个相同类型的变量，就有两个变量引用内存中的同一对象了；当一个引用变量超出作用域时，它会从栈中删除，但是引用对象的数据让保留在堆中</p><p>只有到程序停止，或垃圾回收器删除为止。只有数据不再被任何变量引用时，它才会被删除</p><h3 id="5-2-3-垃圾回收-System-GC-Collect"><a href="#5-2-3-垃圾回收-System-GC-Collect" class="headerlink" title="5.2.3 垃圾回收  System.GC.Collect()"></a>5.2.3 垃圾回收  System.GC.Collect()</h3><p>​    在垃圾回收器运行时，它会从堆中删除不再引用的所有对象</p><p>​    只要释放了能释放的所有对象，就会把其它对象移动回堆的端部，再次形成一个连续的内存块</p><p>​    垃圾回收器的这个压缩操作是托管的堆与非托管的堆的区别所在，使用托管的堆，就只需要读取指针的值即可，而不需要遍历地址的链表，来查找一个地方放置新数据</p><p>​    大对象堆：在.net 下，较大对象有自己的托管堆，使用大于85000个字节的对象时，就会放在这个特殊的堆上</p><h2 id="5-3强引用-和弱引用"><a href="#5-3强引用-和弱引用" class="headerlink" title="5.3强引用 和弱引用"></a>5.3强引用 和弱引用</h2><p>​    垃圾回收器不能回收仍在引用的对象的内存 —-这是一个强引用</p><p>​    弱引用WeakPeference：允许创建和使用对象，但垃圾回收器碰巧在运行，就会回收对象并释放内存，由于潜在的bug和性能问题，一般不这么做</p><h2 id="5-4处理非托管的资源"><a href="#5-4处理非托管的资源" class="headerlink" title="5.4处理非托管的资源"></a>5.4处理非托管的资源</h2><p>​    垃圾回收器不知道如何释放非托管的资源，例如：文件句柄、网络连接、和数据库连接</p><p>​    定义一个类时，可以使用两种机制来自动释放非托管的资源</p><p>​            声明一个析构函数（终结器），作为类的一个成员</p><p>​            在类中实现System.IDispossable接口</p><h3 id="5-4-1析构函数或终结器finalizer"><a href="#5-4-1析构函数或终结器finalizer" class="headerlink" title="5.4.1析构函数或终结器finalizer"></a>5.4.1析构函数或终结器finalizer</h3><p>​    c#编译器在编译析构函数时，会隐式的把析构函数的代码编译为等价于重写Finalize（）方法的代码，从而确保执行父类的Finalize（）方法</p><p>缺点：</p><p>​    无法确定c#对象的析构函数何时执行，所以不能再析构函数中放置需要在某一时刻运行的代码</p><p>​    c#析构函数的实现会延迟对象最终从内存中删除的时间</p><p>5.4.2IDispossable接口</p><pre><code> 在c#中，推荐使用System.IDispossable接口代替析构函数，接口定义了一种模式（具有语言级的支持）该模式为释放非托管资源提供了确定的机制，并避免产生析构函数固有的与垃圾回收器相关的问题。</code></pre><p>​    IDispossable接口声明了一个Dispose()方法，不带参数，返回void。显示的释放有对象直接使用的所有非托管资源</p><blockquote><p>ResourceGobbler theInstance =null;</p><p>try{</p><p>​    theInstance = new ResourceGobbler ()</p><p> }</p><p>finally{</p><p>theInstance ?.Dispose()</p><p>}</p></blockquote><p>​    </p><h3 id="5-4-3using语句"><a href="#5-4-3using语句" class="headerlink" title="5.4.3using语句"></a>5.4.3using语句</h3><p>​    使用try/finally，即使处理过程中出现异常，也可以确保总是在调用Dispose方法释放了资源，但是每个都需要这样重复度的结构；</p><p>​        c#提供另一种语法using，实现IDispossable接口的对象在超出作用域时，自动调用Dipose方法；</p><blockquote><p>using(var    theInstance = new ResourceGobbler ()){</p><p>//do something()</p><p>}</p></blockquote><h3 id="5-4-4-实现IDispossable接口和析构函数"><a href="#5-4-4-实现IDispossable接口和析构函数" class="headerlink" title="5.4.4 实现IDispossable接口和析构函数"></a>5.4.4 实现IDispossable接口和析构函数</h3><p>总结资源释放的两种方式：</p><p>​        利用运行库强制执行的析构函数，但它的执行是不确定的，而且由于垃圾回收的工作方式，会给运行库增加不可接受的系统开销</p><p>​        IDispossable接口提供了一种机制，允许类的用户控制释放资源的时间，但需要确保调用Dispose()方法</p><p>双重实现，创建终结器，实现IDispossabe结构，同时把析构函数作为一种安全机制，以防没有调用Dispose方法</p><h3 id="5-4-5IDispossable和终结器的规则"><a href="#5-4-5IDispossable和终结器的规则" class="headerlink" title="5.4.5IDispossable和终结器的规则"></a>5.4.5IDispossable和终结器的规则</h3><p>​    如果类定义实现了IDispossable的成员，该类也应该实现IDispossable</p><p>​    实现IDispossable并不以为也应该实现一个终结器，终结器会带来额外的开销</p><p>​    如果实现了终结器，也应该实现IDispossable接口，这样可以早些释放资源，不必等GC回收</p><p>​    如果使用的一个对象实现了IDispossable接口，就不在需要对象时调用Dispose方法。如果在方法中使用这个对象，using语句比较方便。如果对象时类的一个成员，就让类也实现IDispossable</p><h2 id="5-5不安全的代码"><a href="#5-5不安全的代码" class="headerlink" title="5.5不安全的代码"></a>5.5不安全的代码</h2><p>​    由于性能问题，要在外部的DLL中访问一个函数，该函数需要把一个指针当做参数来传递（WindowsAPI）,本节将讨论c#直接访问内存的内容的功能</p><h3 id="5-5-1用指针直接访问内存"><a href="#5-5-1用指针直接访问内存" class="headerlink" title="5.5.1用指针直接访问内存"></a>5.5.1用指针直接访问内存</h3><p>​    指针是一个以与引用相同的方式存储地址的变量；其区别是c#不允许直接访问在引用变量中包含的地址。</p><p>​    使用指针，就可以访问实际内存地址，执行新类型的操作</p><p>使用指针的两个原因：</p><p>​        向后兼容性：调用windowsAPI函数，这些函数都是用c++或c#语言编写的，通常要求把指针作为其参数，</p><p>​        性能：在一些情况下，速度是最重要的，而指针可以提供最优性能，</p><p>这种地接别的访问也是有代价的</p><p>​        指针使用起来比较困难，需要非常高的变成技巧和很强的能力</p><pre><code>     很容易重写其他变量，导致栈溢出，访问某些没有存储变量的内存区域，甚至重写.net运行库，使程序崩溃</code></pre><p>​        另外，如果使用指针，就必须授予代码运行库的代码访问安全机制的最高级别</p><p>强烈建议轻易不要使用指针，不仅难以编写，还无法通过CLR施加的内存类型和安全检查</p><h4 id="用unsafe编写不安全的代码"><a href="#用unsafe编写不安全的代码" class="headerlink" title="用unsafe编写不安全的代码"></a>用unsafe编写不安全的代码</h4><p>​    任何方法都可以标记为unsafe，还允许把指针作为参数，也可以把整个类或结构标记为unsafe，假定所有的成员都是不安全的</p><p>​    也可以把方法中的一块代码标记为unsafe；不能把局部变量本身标记为unsafe</p><h4 id="指针的语法"><a href="#指针的语法" class="headerlink" title="指针的语法 *"></a>指针的语法 *</h4><p>指针可以声明为任意一种值类型，也可以声明为一个结构</p><p>int* pWidth,pHeight;</p><p>&amp;表示取地址</p><p>*表示获取地址的内容</p><h4 id="将指针强制转换为整数类型"><a href="#将指针强制转换为整数类型" class="headerlink" title="将指针强制转换为整数类型"></a>将指针强制转换为整数类型</h4><h4 id="指针类型之间的强制转换"><a href="#指针类型之间的强制转换" class="headerlink" title="指针类型之间的强制转换"></a>指针类型之间的强制转换</h4><h4 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a>void指针</h4><h4 id="指针算术的运算"><a href="#指针算术的运算" class="headerlink" title="指针算术的运算"></a>指针算术的运算</h4><h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><h4 id="结构指针，指针成员访问运算符"><a href="#结构指针，指针成员访问运算符" class="headerlink" title="结构指针，指针成员访问运算符"></a>结构指针，指针成员访问运算符</h4><h4 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h4><h3 id="5-5-2指针实例-：PointerPlayground"><a href="#5-5-2指针实例-：PointerPlayground" class="headerlink" title="5.5.2指针实例  ：PointerPlayground"></a>5.5.2指针实例  ：PointerPlayground</h3><h3 id="5-5-3使用指针优化性能"><a href="#5-5-3使用指针优化性能" class="headerlink" title="5.5.3使用指针优化性能"></a>5.5.3使用指针优化性能</h3><p>创建一个基于栈的数组</p><p>QuickArray示例</p><h2 id="5-6平台调用"><a href="#5-6平台调用" class="headerlink" title="5.6平台调用"></a>5.6平台调用</h2>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 托管 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="2021/02/18/rabbitmq/rabbitmq/"/>
      <url>2021/02/18/rabbitmq/rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-RabbitMQ简介"><a href="#第一章-RabbitMQ简介" class="headerlink" title="第一章 RabbitMQ简介"></a>第一章 RabbitMQ简介</h1><h2 id="1-1-什么是消息中间件"><a href="#1-1-什么是消息中间件" class="headerlink" title="1.1 什么是消息中间件"></a>1.1 什么是消息中间件</h2><p> 　　消息是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串、Json等，也可以很复杂，比如内嵌对象。</p><p> 　　消息队列中间件是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。</p><p>　　一般有两种传递模式：点对点模式和发布/订阅模式。点对点模式是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息，队列的存在使得消息的异步传输称为可能。发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者从主题中订阅想消息。主题使得消息订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布/订阅模式在消息的一对多广播时采用。</p><p>　　比较流行的消息中间件有：RabbitMQ、Kafka、ActiveMQ、RocketMQ等。</p><p>　　消息中间件适用于需要可靠的数据传送的分布式环境。采用消息中间件的系统中，不同的对象之间通过传递消息来激活对方的事件，已完成相应的操作。发送者将消息发送给消息服务器，消息服务器将消息存放在若干队列中，在合适的时候，再将消息转发给接收者。</p><h2 id="1-2-消息中间件的作用"><a href="#1-2-消息中间件的作用" class="headerlink" title="1.2 消息中间件的作用"></a>1.2 消息中间件的作用</h2><p>　　解耦：在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束即可。</p><p>　　冗余（存储）：有些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。</p><p> 　　扩展性：因为消息中间件解耦了应用程序的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。</p><p>　　削峰：在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发方访压力，不会因为突发的超负荷请求而完全奔溃。</p><p>　　可恢复性：当系统一部分组件失效时，不会影响到整个系统，消息中间件降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。</p><p>　　顺序保证：在大多数情景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。</p><p>　　缓冲：在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制和优化数据流经过系统的速度。</p><p>　　异步通信：在很多时候应用不想在不需要立即处理消息。消息中间件提供了异步处理机制，允许应用把一些消息放入消息中间件中，但不立即处理它，在之后需要的时候再慢慢处理。</p><h2 id="1-3-RabbitMQ的起源"><a href="#1-3-RabbitMQ的起源" class="headerlink" title="1.3 RabbitMQ的起源"></a>1.3 RabbitMQ的起源</h2><p>　　RabbitMQ是采用Erlang语言实现的AMQP（Advanced Message Queuing Protocol，高级消息队列协议）的消息 中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p><h2 id="1-4-RabbitMQ的安装及简单实用"><a href="#1-4-RabbitMQ的安装及简单实用" class="headerlink" title="1.4 RabbitMQ的安装及简单实用"></a>1.4 RabbitMQ的安装及简单实用</h2><p>　　本示例演示在ubuntu18.04.3中安装和使用rabbitMQ</p><blockquote><p>sudo apt-get update -y<br>sudo apt-get install erlang-nox rabbitmq-server -y<br>sudo rabbitmq-server start<br>sudo rabbitmq-server stop<br>sudo rabbitmq-server restart<br>sudo rabbitmqctl status</p><p>添加用户并且赋予权限</p><p>sudo rabbitmqctl add_user admin admin<br>sudo rabbitmqctl set_user_tags admin administrator<br>sudo rabbitmqctl  set_permissions -p / admin ‘.<em>‘ ‘.</em>‘ ‘.*’<br>sudo rabbitmq-plugins enable rabbitmq_management</p><p>sudo rabbitmqctl change_password admin ‘admin’</p></blockquote><h1 id="第二章-RabbitMQ-入门"><a href="#第二章-RabbitMQ-入门" class="headerlink" title="第二章 RabbitMQ 入门"></a>第二章 RabbitMQ 入门</h1><h2 id="2-1-相关概念介绍"><a href="#2-1-相关概念介绍" class="headerlink" title="2.1 相关概念介绍"></a>2.1 相关概念介绍</h2><p>　　RabbitMQ整体上市一个是生产者与消费者模型。主要负责接收、存储和转发消息。</p><p>　　RabbitMQ的整体模型架构如下图所示：</p><p>　　<img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200116100133957-524774026.png" alt="img"></p><h2 id="2-1-1-生产者和消费者"><a href="#2-1-1-生产者和消费者" class="headerlink" title="2.1.1 生产者和消费者"></a>2.1.1 生产者和消费者</h2><p>　　Producer：生产者，就是投递消息的一方。消息一般可以包含2个部分：消息体和标签（Label）。消息体也可以称之为payload，在实际应用中，消息体一般是一个带有业务逻辑结构的数据，比如一个JSON字符串。</p><p>　　Consumer：消费者，就算是接收消息的一方。</p><p>　　Broker：消息中间件的服务节点。</p><p>　　对于RabbitMQ来说，一个RabbitMQ Broker可以简单地看作一个RabbitMQ服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个RabbitMQ Broker看作一台RabbitMQ服务器。</p><p>　　下图展示了生产者将消息存入RabbitMQ Broker，以及消费者从Broker中消费数据的整个流程。</p><p>　　<img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200116101001502-1945693905.png" alt="img"></p><p> 2.1.2 队列</p><p>Queue：队列，是RabbitMQ的内部对象，用于存储消息。</p><p><img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200117113432130-466580577.png" alt="img"></p><p> RabbitMQ中消息都只能存储在队列中。U盾讴歌消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p><p><img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200117114049922-590796568.png" alt="img"></p><p> RabbitMQ不支持队列层面的广播消息，如果需要广播消息，需要在其上进行二次开发，处理逻辑会变得异常复杂，同时也不建议这么做。</p><p>2.1.3 交换器、路由件、绑定</p><p>Exchange：交换器。生产者将消息发送到Exchange（交换器，通常也可以用大写的“X”来表示）。由交换器将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃。</p><p><img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200117114708911-1388748529.png" alt="img"></p><p> RoutingKey：路右键。生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个Routing Key需要与交换器类型和绑定建（BindingKey）联合使用才能最终生效。</p><p>在交换器类型和绑定建（BindingKey）固定的情况下，生产者可以发送消息给交换器时，通过指定RoutingKey来决定消息流向哪里。</p><p>备注：本文转载于<a href="https://www.cnblogs.com/yuzhou133/p/12197311.html">https://www.cnblogs.com/yuzhou133/p/12197311.html</a></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第四章 继承</title>
      <link href="2021/02/17/c-10/c-10th-04/"/>
      <url>2021/02/17/c-10/c-10th-04/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第四章-继承"><a href="#c-语言-第四章-继承" class="headerlink" title="c#语言 第四章 继承"></a>c#语言 第四章 继承</h1><h2 id="4-1继承"><a href="#4-1继承" class="headerlink" title="4.1继承"></a>4.1继承</h2><p>面向对象的三个重要概念：继承、封装、多态</p><h2 id="4-2继承的类型"><a href="#4-2继承的类型" class="headerlink" title="4.2继承的类型"></a>4.2继承的类型</h2><p>面向对象（Object-Oriented,OO）术语，c#的继承</p><p>单重继承：c#</p><p>多重继承：一个类可以派生自多个类，c#不支持</p><p>多层继承：B派生自A，C派生自B，c#支持</p><p>接口继承：c#允许接口多继承</p><h3 id="4-2-1-多重继承-c"><a href="#4-2-1-多重继承-c" class="headerlink" title="4.2.1 多重继承 c++"></a>4.2.1 多重继承 c++</h3><p>多重继承会给生成的代码增加复杂性，还会带来一些开销。c#决定不支持多重继承。</p><p>c#允许派生自多个接口，一个类型可以实现多个接口。System.Object 是一个公共的基类，每个c#类（除了Object类之外）都有一个基类，还可以有人以多个基接口</p><h3 id="4-2-2-结构和类"><a href="#4-2-2-结构和类" class="headerlink" title="4.2.2 结构和类"></a>4.2.2 结构和类</h3><p>使用结构的一个限制是结构不支持继承，但每个结构都派生自system.ValueType . 但接口可以实现接口</p><h2 id="4-3实现继承-class-A：B"><a href="#4-3实现继承-class-A：B" class="headerlink" title="4.3实现继承 class A：B{}"></a>4.3实现继承 class A：B{}</h2><p>如果类和接口都用于派生，则类总是必须放在接口的前面</p><p>结构只能实现接口继承</p><p>类定义中更没有指定基类，c#编译器就假定 System.Object是基类</p><h3 id="4-3-1虚方法"><a href="#4-3-1虚方法" class="headerlink" title="4.3.1虚方法"></a>4.3.1虚方法</h3><p>  virtual </p><p>​    把一个基类方法声明为virtual，就可以在任何派生类中重写该方法</p><p>​    也可以把属性声明为virtual</p><p>​    成员字段和静态函数不能声明为virtual，因为这个概念只对类中实例函数成员有意义</p><p>override 显示声明重写</p><h3 id="4-3-2-多态性"><a href="#4-3-2-多态性" class="headerlink" title="4.3.2 多态性"></a>4.3.2 多态性</h3><p>多态性，动态地定义调用的方法，而不是在编译期间定义</p><h3 id="4-3-3隐藏方法"><a href="#4-3-3隐藏方法" class="headerlink" title="4.3.3隐藏方法"></a>4.3.3隐藏方法</h3><p>如果签名相同的方法在基类和派生类中都进行了声明，但该方法没有分别声明为virtual和override，派生类方法就会隐藏基类方法</p><p>用new关键词隐藏方法，避免出现编译器警告</p><h3 id="4-3-4调用基类版本方法base-fn"><a href="#4-3-4调用基类版本方法base-fn" class="headerlink" title="4.3.4调用基类版本方法base.fn()"></a>4.3.4调用基类版本方法base.fn()</h3><h3 id="4-3-5抽象类和抽象方法"><a href="#4-3-5抽象类和抽象方法" class="headerlink" title="4.3.5抽象类和抽象方法"></a>4.3.5抽象类和抽象方法</h3><p>abstract 抽象类不能实例化，抽象法法不能直接实现，必须在非抽象类的派生类中重写； 如果类包含抽象方法，则该类也是抽象的，也必须声明为抽象的</p><h3 id="4-3-6密封类和密封方法sealed"><a href="#4-3-6密封类和密封方法sealed" class="headerlink" title="4.3.6密封类和密封方法sealed"></a>4.3.6密封类和密封方法sealed</h3><p>对于密封类，编译器知道不能派生类</p><p>string是密封的</p><h3 id="4-3-7派生类的构造函数"><a href="#4-3-7派生类的构造函数" class="headerlink" title="4.3.7派生类的构造函数"></a>4.3.7派生类的构造函数</h3><p>​        创建派生类实例时，会有多个构造函数起作用个，要实例化类的构造函数本身不能初始化类，还必须调用其基类中的构造函数，通过层级结构进行构造</p><p>​        如果派生类没必要定义新的构造函数，仍可以提供一个构造函数，条用基构造函数base()</p><h2 id="4-4修饰符"><a href="#4-4修饰符" class="headerlink" title="4.4修饰符"></a>4.4修饰符</h2><p>4.4.1访问修饰符</p><p>逻辑访问修饰符  public protected private</p><p>物理访问修饰符 internal</p><p>不能把类型定义为protected、private或 protected internal，因为这些修饰符对包含在命名空间中的类型没有意义，这些只能用于成员。但可以修饰嵌套的类型，类型也具有成员的状态</p><p>如果有嵌套的类型，内部的类型总是可以访问外部类型的所有成员</p><p>4.4.2其他修饰符</p><p>new static virtual abstract override sealed  extern</p><h2 id="4-5接口"><a href="#4-5接口" class="headerlink" title="4.5接口"></a>4.5接口</h2><p>Microsoft 预定义的一个几口System.IDisposable的完整定义，包含一个方法Dispose（），该方法由类实现，用于清理代码</p><p>声明接口在于发生和声明抽象类完全相同，但不允许提供接口中任何成员的实现方式，一般情况下，接口只能包含方法、属性、索引器、和事件的声明</p><p>抽象类： 可以有实现代码或没有实现代码的抽象成员，</p><p>接口：不能有任何实现代码，纯粹抽象的；所以接口不需要abstract关键字</p><p>接口不能有构造函数，也不能有字段，不能声明为virtual</p><p>4.5.1定义和实现接口</p><p>从接口中派生独立于从类中派生</p><p>4.5.2派生的接口</p><h2 id="4-6-is-和as-运算符"><a href="#4-6-is-和as-运算符" class="headerlink" title="4.6 is 和as 运算符"></a>4.6 is 和as 运算符</h2><p>as返回对象的引用，如果对象不是所要求的的类型，则返回null</p><p>is运算符，判读是否满足，true则继续进行强制转换</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第三章 对象和类型</title>
      <link href="2021/02/17/c-10/c-10th-03/"/>
      <url>2021/02/17/c-10/c-10th-03/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第三章-对象和类型"><a href="#c-语言-第三章-对象和类型" class="headerlink" title="c#语言 第三章 对象和类型"></a>c#语言 第三章 对象和类型</h1><h2 id="3-2-类和结构的区别"><a href="#3-2-类和结构的区别" class="headerlink" title="3.2 类和结构的区别"></a>3.2 类和结构的区别</h2><p>​    类和结构实际上都是常见对象的模板</p><p>​    类是引用类型</p><p>​    结构是值类型</p><p>​    较小的数据类型使用结构可以提高性能</p><p>​    类和结构都用new来声明实例</p><h2 id="3-3-类"><a href="#3-3-类" class="headerlink" title="3.3 类"></a>3.3 类</h2><p>类包含成员。成员可以是静态成员或实例成员，static静态成员属于类；实例成员属于对象</p><p>成员：字段、常量、方法、属性、构造函数、索引器、运算符、事件、析构函数、类型</p><h3 id="3-3-1字段"><a href="#3-3-1字段" class="headerlink" title="3.3.1字段"></a>3.3.1字段</h3><p>​       const 常量 公开 public</p><p>​      最好把字段声明为private</p><h3 id="2-3-2属性"><a href="#2-3-2属性" class="headerlink" title="2.3.2属性"></a>2.3.2属性</h3><p> 一个方法或一对方法，看起来是一个字段</p><h4 id="自动实现的属性："><a href="#自动实现的属性：" class="headerlink" title="自动实现的属性："></a>自动实现的属性：</h4><p>​    set；get；访问器没有任何逻辑，属性会自动实现后备成员变量</p><p>​    属性初始化器来初始化 public int Age {get;set;}=42;</p><h4 id="属性的访问修饰符"><a href="#属性的访问修饰符" class="headerlink" title="属性的访问修饰符"></a>属性的访问修饰符</h4><p>​    public get private set</p><h3 id="3-3-3方法"><a href="#3-3-3方法" class="headerlink" title="3.3.3方法"></a>3.3.3方法</h3><p>非数据成员</p><p>​      正式的c#术语区分函数和方法，在c#术语中，函数成员不仅包含方法，也包含类或结构的一些非数据成员，如索引器、运算符、构造函数、析构函数等，还有属性，这些事非数据成员</p><p>数据成员</p><p>​    字段、常量、事件才是数据成员</p><h4 id="方法的声明"><a href="#方法的声明" class="headerlink" title="方法的声明"></a>方法的声明</h4><p>​    表达式体方法：  =&gt; 区分操作符左边的声明和右边的实现代码</p><p>​    调用方法</p><h4 id="方法的重载："><a href="#方法的重载：" class="headerlink" title="方法的重载："></a>方法的重载：</h4><p>​    方法名相同，但是参数的数量和/或数据类型不同</p><h4 id="命名的参数："><a href="#命名的参数：" class="headerlink" title="命名的参数："></a>命名的参数：</h4><p>​    任何方法都可以使用命名的参数调用，编译器会去掉变量名</p><p>这种方式更改变量的顺序，编译器会重新安排，获得正确的顺序</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>​    一个或多个，可选参数置后</p><h4 id="个数可变的参数-params关键字"><a href="#个数可变的参数-params关键字" class="headerlink" title="个数可变的参数 params关键字"></a>个数可变的参数 params关键字</h4><p>​    如果params关键字与方法签名定义的多个参数一起使用，params只能使用一次，且必须是最后一个参数</p><h3 id="3-3-4构造函数"><a href="#3-3-4构造函数" class="headerlink" title="3.3.4构造函数"></a>3.3.4构造函数</h3><p>​    如果没有构造函数，编译器会默认生成一个默认的构造函数（引用类型为空引用，数值类型为0，bool为false）</p><p>构造函数的重载遵循与其他方法相同的规则 ；</p><p>​    构造函数的重载遵循与其他方法相同的</p><p>​    如果提供了带参数的构造函数，编译器就不会自动提供默认的构造函数</p><p>​    可以把构造函数定义为private或者protected，这样不相关的类就不能访问他们</p><p><strong>没有公有或受保护的构造函数的用法</strong></p><p>​    类仅仅是静态成员或属性的容器，永远不会实例化，static修饰类，只能包含静态成员，不能实例化</p><p>​    希望仅通过条用个某个静态成员函数来实例化（对象实例化的类工厂方法）（单例模式的实现）</p><h4 id="从构造函数中调用其他构造函数"><a href="#从构造函数中调用其他构造函数" class="headerlink" title="从构造函数中调用其他构造函数"></a>从构造函数中调用其他构造函数</h4><p>​    this关键字仅条用参数最匹配的那个构造函数</p><p>​    c#构造函数初始化器可以包含对同一个类的另一个构造函数的调用，也可以对直接基类的构造函数的调用应使用base代替this关键字，初始化器不能有多个调用</p><h4 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h4><p>​    无参数的静态构造函数</p><p>​        不能带任何参数，一个类只有一个静态构造函数</p><h4 id="只读成员-readonly"><a href="#只读成员-readonly" class="headerlink" title="只读成员 readonly"></a>只读成员 readonly</h4><h4 id="只读字段-readonly"><a href="#只读字段-readonly" class="headerlink" title="只读字段 readonly"></a>只读字段 readonly</h4><h4 id="只读readonly与const的区别"><a href="#只读readonly与const的区别" class="headerlink" title="只读readonly与const的区别"></a>只读readonly与const的区别</h4><p>​        const 编译器通过值取代了使用它的变量，编译器知道它的值</p><p>​        readonly在运行期间通过构造函数制定，与常量字段相反，只读字段可以是实例成员，使用只读字段作为类成员时，需要把static修饰符分配给该字段</p><p>只读字段，不能在构造函数外部赋值</p><p>只读属性{get}</p><p>​    自动实现的只读属性</p><p>​    只读属性也可以在构造函数中初始化</p><p>表达式体属性</p><blockquote><p>public string FullName =&gt; $”{FirstName} {LastName}”;</p></blockquote><p>不可变的类型</p><p>​        例如String，，任何改变总会返回一个新的字符串</p><h2 id="3-4匿名类型"><a href="#3-4匿名类型" class="headerlink" title="3.4匿名类型"></a>3.4匿名类型</h2><h2 id="3-5结构-struct"><a href="#3-5结构-struct" class="headerlink" title="3.5结构 struct"></a>3.5结构 struct</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>​    数据小 提升性能</p><p>​    值类型</p><p>​    不支持继承</p><p>​    分配内存非常快，销毁也快</p><p>​    互相赋予时，会复制一份，有性能损失</p><p>​    当把结构作为参数传递时，应把它作为ref参数传递---避免性能损失，只传递地址；被调用的方法可以改变结构的值</p><h3 id="结构和继承"><a href="#结构和继承" class="headerlink" title="结构和继承"></a>结构和继承</h3><p>​    不能从一个结构中继承</p><p>​    例外： 结构最终派生于类System.Object ,因此可以访问System.Object 的方法</p><p>​    结构 &lt;= System.ValueType&lt;= System.Object</p><h3 id="结构的构造函数"><a href="#结构的构造函数" class="headerlink" title="结构的构造函数"></a>结构的构造函数</h3><h2 id="3-6按值和按引用传递参数"><a href="#3-6按值和按引用传递参数" class="headerlink" title="3.6按值和按引用传递参数"></a>3.6按值和按引用传递参数</h2><h3 id="ref参数-gt-可以通过引用传递结构"><a href="#ref参数-gt-可以通过引用传递结构" class="headerlink" title="ref参数 -&gt;可以通过引用传递结构"></a>ref参数 -&gt;可以通过引用传递结构</h3><p>out参数 -&gt;</p><p>​    如果一个方法返回多个值，可能类型还不同</p><h2 id="3-7可空类型-int-x2-null"><a href="#3-7可空类型-int-x2-null" class="headerlink" title="3.7可空类型  int? x2=null;"></a>3.7可空类型  int? x2=null;</h2><h2 id="3-8枚举-enum"><a href="#3-8枚举-enum" class="headerlink" title="3.8枚举 enum"></a>3.8枚举 enum</h2><p>​    默认enum的类型是int</p><p>​    使用强制类型转换可以把数字改为枚举值，把枚举改为数字</p><p>​    Flags</p><h2 id="3-9-部分类-partial"><a href="#3-9-部分类-partial" class="headerlink" title="3.9 部分类 partial"></a>3.9 部分类 partial</h2><p>​    可以把类分开放在两个文件中</p><p>声明类和结构，返回信息都是类成员</p><p>元组类型</p><h2 id="3-10-扩展方法"><a href="#3-10-扩展方法" class="headerlink" title="3.10 扩展方法"></a>3.10 扩展方法</h2><p>扩展</p><p>​    继承给对象添加功能的好方法</p><p>​    扩展方法是给对象添加功能的另一个选项，在不能使用继承时，可以使用这个选项（例如类是密封的）</p><p>扩展方法是静态方法，是类的一部分，但实际上没有放在类的源代码中</p><p>使用this关键字和第一个参数来扩展字符串，这个关键字定义了要扩展的类型</p><blockquote><p>public static class StringExtension{ public static int<br>GetWordCount(this string s)=&gt; s.Split().Length; ​} ​</p></blockquote><p>好处：</p><p>​    可以使用实例方法的语法，而不是从代码中直接调用静态方法</p><p>​    该方法的实现可以用另一个类取代，而不需要更改代码</p><p>编译器如何找到某个类型的扩展方法？</p><p>​    this关键字必须匹配类型的扩展方法</p><p>​    而且需要打开定义扩展方法的静态类所在名称空间</p><p>​    如果类型还定义了同名的实例方法，扩展方法就永远不会使用</p><p>​    类中已有的实例方法都优先</p><p>Object类，其他类型都从该类派生而来</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 对象和类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第二章 核心C#</title>
      <link href="2021/02/17/c-10/c-10th-02/"/>
      <url>2021/02/17/c-10/c-10th-02/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-2-核心c"><a href="#c-语言-2-核心c" class="headerlink" title="c#语言 2 核心c#"></a>c#语言 2 核心c#</h1><h2 id="2-3变量"><a href="#2-3变量" class="headerlink" title="2.3变量"></a>2.3变量</h2><p>c# 区分大小写</p><h3 id="2-3-1初始化变量"><a href="#2-3-1初始化变量" class="headerlink" title="2.3.1初始化变量"></a>2.3.1初始化变量</h3><p>​    c#编译器需要用某个初始值对变量进行初始化，之后才能在操作中引用变量；c#中有两个方法可确保变量使用前进行了初始化</p><p>​        变量是类或结构中的字段，如果没有显示初始化，则创建这些变量时，其默认值就是0</p><p>​        方法的局部变量必须在代码中显示初始化，变量初始化之前就使用了其值，编译器就会标记错误</p><h3 id="2-3-2类型推断"><a href="#2-3-2类型推断" class="headerlink" title="2.3.2类型推断"></a>2.3.2类型推断</h3><p>​    变量必须初始化，编译器推断类型的依据</p><p>​    初始化器不能为空</p><p>​    初始化器必须放在表达式中</p><p>​    不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象</p><h3 id="2-3-3变量的作用域"><a href="#2-3-3变量的作用域" class="headerlink" title="2.3.3变量的作用域"></a>2.3.3变量的作用域</h3><p>定义或规则</p><p>​    只要类在某个作用域内，其字段也在该作用域内</p><p>​    局部变量存在于表示声明该变量的块语句或方法结束的右花括号之前的作用域内</p><p>​    在 for whild 或类似语句中声明的局部变量存在于该循环体内</p><h4 id="局部变量的作用域冲突"><a href="#局部变量的作用域冲突" class="headerlink" title="局部变量的作用域冲突"></a>局部变量的作用域冲突</h4><h4 id="字段和局部变量的作用域冲突"><a href="#字段和局部变量的作用域冲突" class="headerlink" title="字段和局部变量的作用域冲突"></a>字段和局部变量的作用域冲突</h4><blockquote><p>class program{ static int j=20; static void Main(){ int<br>j=30;WriteLine(j); WriteLine(program.j) } ​}</p></blockquote><h3 id="2-3-4常量"><a href="#2-3-4常量" class="headerlink" title="2.3.4常量"></a>2.3.4常量</h3><p>特点</p><p>​    常量声明时必须初始化，指定其值后，就不能再改写了、</p><p>​    常量的值必须在编译时用于计算，因此不能用从变量中提取的值来初始化常亮</p><p>​    常量总是隐式静态的</p><p>好处</p><p>​    易于读取的名称</p><p>​    是程序更易于修改</p><p>​    更容易避免程序出现错误</p><h2 id="2-4预定义数据类型"><a href="#2-4预定义数据类型" class="headerlink" title="2.4预定义数据类型"></a>2.4预定义数据类型</h2><h3 id="2-4-1-值类型和引用类型"><a href="#2-4-1-值类型和引用类型" class="headerlink" title="2.4.1 值类型和引用类型"></a>2.4.1 值类型和引用类型</h3><p>堆栈</p><p>​    值类型存储在堆栈中stack</p><p>​    引用各类型存储在托管堆中 managed heap</p><p>bool 和long等都是值类型，值类型的赋予是通过值复制的</p><p>大多数更复杂的c#数据类型，包括自己声明的类，都是引用类型</p><p>​    CLR实现一种精细的算法，来跟踪哪些引用变量是可以访问的，哪些不能访问，CLR会定期删除不能访问的对象，把占用的内存返回给操作系统，垃圾回收器</p><p>​    如果要把自己的类型定义为值类型，就应把它声明为一个结构</p><h3 id="2-4-2-net-类型"><a href="#2-4-2-net-类型" class="headerlink" title="2.4.2 .net 类型"></a>2.4.2 .net 类型</h3><p>​    15个预定义类型，13个值类型，两个引用类型string 和 object</p><h3 id="2-4-3预定义的值类型"><a href="#2-4-3预定义的值类型" class="headerlink" title="2.4.3预定义的值类型"></a>2.4.3预定义的值类型</h3><p>整型 sbyte 8 short 16 int32 long64</p><p>浮点类型 float32位单精度浮点，double 64位双精度浮点 15/16</p><p>decimal类型 128位高精度十进制数表示法<br>（decimal类型不是基本类型，计算时有性能损失）(高精度计算)</p><blockquote><p>decimal d =12.30M;</p></blockquote><p>bool类型</p><p>字符类型 char 表示一个16位的Unicode字符</p><p>​    转义字符\</p><h3 id="2-4-4预定义的引用类型"><a href="#2-4-4预定义的引用类型" class="headerlink" title="2.4.4预定义的引用类型"></a>2.4.4预定义的引用类型</h3><h4 id="object-类型"><a href="#object-类型" class="headerlink" title="object 类型"></a>object 类型</h4><p>​     可以使用object引用来绑定任何特定子类型的对象;如值类型装箱，再移动到堆中，object引用也可以用于反射，此时必须有代码来处理类型未知的对象</p><p>​    object类型实现了许多一般用途的基本方法，包括Equals(),GetHashCode(),GetType()和ToString()用户定义的类型需要使用一种面向对象技术---重写</p><h4 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h4><p>​    字符串不可修改，修改会产生新的string对象</p><p>​    @的使用，看做所有字符保持原来的含义</p><p>​    字符串插值功能 $</p><h2 id="2-5程序流控制"><a href="#2-5程序流控制" class="headerlink" title="2.5程序流控制"></a>2.5程序流控制</h2><p>if</p><p>for</p><p>while</p><p>do while</p><p>foreach 不能改变集合中各项的值</p><p>跳转语句</p><p>goto语句<br>不能跳转像for循环这样的代码块中，也不能跳出类的范围，不能退出try<br>catch后面的finally</p><p>break语句</p><p>switch 中退出某个语句</p><p>也可用于for foreach whild do...while</p><p>continue语句 只能退出循环的当前迭代</p><p>return 语句 退出类的方法</p><h2 id="2-6-枚举"><a href="#2-6-枚举" class="headerlink" title="2.6 枚举"></a>2.6 枚举</h2><h3 id="枚举是用户定义的整数类型"><a href="#枚举是用户定义的整数类型" class="headerlink" title="枚举是用户定义的整数类型"></a>枚举是用户定义的整数类型</h3><p>优势</p><p>​    代码易于维护，有助于确保给变量制定合法的期望的值</p><p>​    枚举使代码更清晰，允许描述性的蒙城表示整数值，而不是含义模糊的数</p><p>​    更易于输入</p><p>​    枚举真正强大之处，在于实例化为派生自积累system.enum的结构，不会造成性能损失</p><h2 id="2-7名称空间"><a href="#2-7名称空间" class="headerlink" title="2.7名称空间"></a>2.7名称空间</h2><p>using语句</p><h3 id="2-7-2名称空间的别名"><a href="#2-7-2名称空间的别名" class="headerlink" title="2.7.2名称空间的别名"></a>2.7.2名称空间的别名</h3><h2 id="2-8main方法"><a href="#2-8main方法" class="headerlink" title="2.8main方法"></a>2.8main方法</h2><h2 id="2-9使用注释"><a href="#2-9使用注释" class="headerlink" title="2.9使用注释"></a>2.9使用注释</h2><h2 id="2-10-c-预处理指令"><a href="#2-10-c-预处理指令" class="headerlink" title="2.10 c#预处理指令"></a>2.10 c#预处理指令</h2><p>#define 和#undef</p><p>#if #elif #else #endif</p><p>#warning 和#ERROR</p><p>#region 和 #endregion</p><p>#LINE</p><p>#pragma</p><h2 id="2-11c-编程准则"><a href="#2-11c-编程准则" class="headerlink" title="2.11c#编程准则"></a>2.11c#编程准则</h2><h3 id="标识符的规则"><a href="#标识符的规则" class="headerlink" title="标识符的规则"></a>标识符的规则</h3><p>​    尽管可以包含数字字符，但他们必须以字母或下划线开头</p><p>​    不能把c#关键字用作标识符</p><p>用法约定</p><p>命名约定</p><p>​    名称的大小写 Pascal camel</p><p>​    名称的风格统一</p><p>​    名称和关键字</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第一章 .net 应用程序体系结构</title>
      <link href="2021/02/17/c-10/c-10th-01/"/>
      <url>2021/02/17/c-10/c-10th-01/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第一章-net-应用程序体系结构"><a href="#c-语言-第一章-net-应用程序体系结构" class="headerlink" title="c#语言 第一章 .net 应用程序体系结构"></a>c#语言 第一章 .net 应用程序体系结构</h1><h2 id="1-2-回顾net-历史"><a href="#1-2-回顾net-历史" class="headerlink" title="1.2.回顾net 历史"></a>1.2.回顾net 历史</h2><h3 id="net-版本"><a href="#net-版本" class="headerlink" title=".net 版本"></a>.net 版本</h3><p>​    CLR(Common Language Runtime) 公共语言运行库</p><p>​    c#</p><p>​    Visual Studio</p><h3 id="1-2-1c-1-0-新语言"><a href="#1-2-1c-1-0-新语言" class="headerlink" title="1.2.1c#1.0 新语言"></a>1.2.1c#1.0 新语言</h3><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><p>​        面向对象编程语言，具备继承，封装和多态性等特性</p><p>​        也提供了基于组件的变成改造，如委托和事件</p><h4 id="CLR"><a href="#CLR" class="headerlink" title="CLR"></a>CLR</h4><p>​     .net 编程语言都使用的运行库，类似java虚拟机</p><p>​     中间语言Intermediate Language IL代码，编译器生成IL代码，当程序运行时，JIT编译器会从IL代码生成本地代码</p><p>​     GC垃圾回收</p><p>​     调试器扩展</p><p>​     线程实用工具</p><p>​    CLR还负责线程的处理，C#中创建托管的线程不一定来自底层操作系统，线程的虚拟化和管理有CLR负责</p><h3 id="1-2-2带有泛型的c-2-和-net-2"><a href="#1-2-2带有泛型的c-2-和-net-2" class="headerlink" title="1.2.2带有泛型的c#2 和.net 2"></a>1.2.2带有泛型的c#2 和.net 2</h3><h3 id="1-2-3-net-3-0-WPF"><a href="#1-2-3-net-3-0-WPF" class="headerlink" title="1.2.3 .net 3.0 WPF"></a>1.2.3 .net 3.0 WPF</h3><p>​    WPF 矢量图形控件</p><p>​     WCF 通用通信</p><h3 id="1-2-4-c-LINQ-EF"><a href="#1-2-4-c-LINQ-EF" class="headerlink" title="1.2.4 c##  LINQ   EF"></a>1.2.4 c##  LINQ   EF</h3><h3 id="1-2-5-c-4-dynamic-TPL-任务并行库"><a href="#1-2-5-c-4-dynamic-TPL-任务并行库" class="headerlink" title="1.2.5  c# 4 dynamic TPL(任务并行库)"></a>1.2.5  c# 4 dynamic TPL(任务并行库)</h3><p>​    使用Task 和 Parallel 类抽象出线程</p><h3 id="1-2-6c-5-异步编程-async-和await"><a href="#1-2-6c-5-异步编程-async-和await" class="headerlink" title="1.2.6c#5 异步编程  async 和await"></a>1.2.6c#5 异步编程  async 和await</h3><h3 id="1-2-7-c-6-新的编译器引擎-Roslyn"><a href="#1-2-7-c-6-新的编译器引擎-Roslyn" class="headerlink" title="1.2.7 c#6 新的编译器引擎 Roslyn"></a>1.2.7 c#6 新的编译器引擎 Roslyn</h3><h4 id="1-3-2-net-core-1-0-CORE-CLI"><a href="#1-3-2-net-core-1-0-CORE-CLI" class="headerlink" title="1.3.2 .net core 1.0   CORE CLI"></a>1.3.2 .net core 1.0   CORE CLI</h4><p>特性：</p><p>​    开源</p><p>​    模块化的方式设计</p><p>​    可以很快更新</p><p>程序集 assembly：编译好的，面向.net framework的代码逻辑单元</p><p>​        私有程序集</p><p>​        共享程序集（Global Assembly Cache）</p><h3 id="1-3-5-公共语言运行库"><a href="#1-3-5-公共语言运行库" class="headerlink" title="1.3.5 公共语言运行库"></a>1.3.5 公共语言运行库</h3><p>​       编译器将源代码编译为Microsoft中间语言(Intermediate Language, IL)生成IL代码，当程序运行时，JIT编译器会从IL代码生成本地代码</p><p>​       CLR还负责线程的处理，C#中创建托管的线程不一定来自底层操作系统，线程的虚拟化和管理有CLR负责</p><h3 id="1-3-7windows运行库-windows-runtime"><a href="#1-3-7windows运行库-windows-runtime" class="headerlink" title="1.3.7windows运行库 windows runtime"></a>1.3.7windows运行库 windows runtime</h3><h2 id="net-2015"><a href="#net-2015" class="headerlink" title=".net 2015"></a>.net 2015</h2><h3 id="1-5-net-4-6编译"><a href="#1-5-net-4-6编译" class="headerlink" title="1.5.net 4.6编译"></a>1.5.net 4.6编译</h3><p>​    c# 命令行编译器（csc.exe）: csc HelloWorld.cs -&gt; 中间语言代码</p><p>​    DASM中间语言反汇编程序 （ildasm.exe）</p><p>.net core cli编译</p><p>​    repl学习 ： dotnet repl</p><h2 id="1-7应用程序类型与技术"><a href="#1-7应用程序类型与技术" class="headerlink" title="1.7应用程序类型与技术"></a>1.7应用程序类型与技术</h2><h3 id="1-7-1数据访问"><a href="#1-7-1数据访问" class="headerlink" title="1.7.1数据访问"></a>1.7.1数据访问</h3><pre><code>Database FirstModel First</code></pre><p>CodeFirst:<br>   代码优先有一定意味着数据库不能事先存在；数据库可以动态创建，属性和流利的API可以以编程方式定义映射</p><h3 id="1-7-2桌面应用程序"><a href="#1-7-2桌面应用程序" class="headerlink" title="1.7.2桌面应用程序"></a>1.7.2桌面应用程序</h3><p>WF WPF</p><h3 id="1-7-3-UWP"><a href="#1-7-3-UWP" class="headerlink" title="1.7.3 UWP"></a>1.7.3 UWP</h3><h3 id="1-7-4soap服务和WCF"><a href="#1-7-4soap服务和WCF" class="headerlink" title="1.7.4soap服务和WCF"></a>1.7.4soap服务和WCF</h3><h3 id="1-7-5WEB服务-WEB-API-基于REST"><a href="#1-7-5WEB服务-WEB-API-基于REST" class="headerlink" title="1.7.5WEB服务 WEB API 基于REST"></a>1.7.5WEB服务 WEB API 基于REST</h3><h3 id="1-7-6WebHooks-和SignalR-基于-webSocket"><a href="#1-7-6WebHooks-和SignalR-基于-webSocket" class="headerlink" title="1.7.6WebHooks 和SignalR 基于 webSocket"></a>1.7.6WebHooks 和SignalR 基于 webSocket</h3><h3 id="1-7-7windows服务"><a href="#1-7-7windows服务" class="headerlink" title="1.7.7windows服务"></a>1.7.7windows服务</h3><pre><code>world wide web服务 可以监听客户端的web请求</code></pre><h3 id="Microsoft-Azure服务"><a href="#Microsoft-Azure服务" class="headerlink" title="Microsoft Azure服务"></a>Microsoft Azure服务</h3><p>​    SaaS IaaS PaaS</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> .net 应用程序体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello MyBlog</title>
      <link href="2021/02/17/hello-myblog/"/>
      <url>2021/02/17/hello-myblog/</url>
      
        <content type="html"><![CDATA[<h2 id="使用github-page-和hexo搭建第一个网站"><a href="#使用github-page-和hexo搭建第一个网站" class="headerlink" title="使用github page 和hexo搭建第一个网站"></a>使用github page 和hexo搭建第一个网站</h2><p><a href="https://www.zhihu.com/question/22197688">https://www.zhihu.com/question/22197688</a></p><h2 id="博客美化-博客主题之hexo-theme-matery的介绍"><a href="#博客美化-博客主题之hexo-theme-matery的介绍" class="headerlink" title="博客美化 博客主题之hexo-theme-matery的介绍"></a>博客美化 博客主题之hexo-theme-matery的介绍</h2><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#alipay">https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#alipay</a></p><p>pdf展示</p><p><a href="https://blog.csdn.net/qq_43701912/article/details/107291518">https://blog.csdn.net/qq_43701912/article/details/107291518</a></p><h3 id="hexo扩展学习"><a href="#hexo扩展学习" class="headerlink" title="hexo扩展学习"></a>hexo扩展学习</h3><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p><a href="https://hexo.io/themes/index.html">https://hexo.io/themes/index.html</a></p><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><h3 id="window下pandoc的如何使用-文档类型转换"><a href="#window下pandoc的如何使用-文档类型转换" class="headerlink" title="window下pandoc的如何使用 文档类型转换"></a>window下pandoc的如何使用 文档类型转换</h3><p><a href="https://www.jianshu.com/p/f4a9ceb68088">https://www.jianshu.com/p/f4a9ceb68088</a></p><p>代码高亮没有大括号问题</p><p><a href="https://blog.csdn.net/xingranzhihuo/article/details/113830311">https://blog.csdn.net/xingranzhihuo/article/details/113830311</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
            <tag> github gage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客资源站收集</title>
      <link href="2021/02/17/she-ji-gui-fan/wei-shi-me-bu-jian-yi-lian-biao-cha-xun/"/>
      <url>2021/02/17/she-ji-gui-fan/wei-shi-me-bu-jian-yi-lian-biao-cha-xun/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么强烈建议你不要做联表查询？"><a href="#为什么强烈建议你不要做联表查询？" class="headerlink" title="为什么强烈建议你不要做联表查询？"></a>为什么强烈建议你不要做联表查询？</h1><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png" alt="img"></p><p><a href="https://javazhiyin.blog.csdn.net/">Java笔记虾</a> 2021-02-15 18:10:00 <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes.png" alt="img"> 152 <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect.png" alt="img"> 收藏 1</p><p>文章标签： <a href="https://www.csdn.net/tags/NtzaUgysMTg1NC1ibG9n.html">数据库</a> <a href="https://www.csdn.net/tags/MtTaEg5sOTYwNC1ibG9n.html">mysql</a> <a href="https://www.csdn.net/tags/NtTaIg5sMzYyLWJsb2cO0O0O.html">java</a> <a href="https://www.csdn.net/tags/MtTaEg0sMTkwNjUtYmxvZwO0O0OO0O0O.html">orm</a> <a href="https://www.csdn.net/tags/MtTaYg3sMjQ0My1ibG9n.html">spark</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直想要聊一聊关于开发中更建议使用<code>单表查询+代码层组装</code> or <code>联表查询</code> 的问题，在开发中每个同学的开发中有各自的习惯，笔者在公司也和一些同事关于这方面有一些探讨。</p><p>关于本文，更像是一些个人的看法，想到什么说什么，一定有不同的意见，欢迎大家留言，一起讨论。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>在实际开发中，我们不可避免的要关联几张数据表来合成最终的展示数据，如：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">select</span> <span class="token operator">*</span> from tagjoin tag_post on tag_post<span class="token punctuation">.</span>tag_id<span class="token operator">=</span>tag<span class="token punctuation">.</span>idjoin post on tag_post<span class="token punctuation">.</span>post_id<span class="token operator">=</span>post<span class="token punctuation">.</span>idwhere tag<span class="token punctuation">.</span>tag<span class="token operator">=</span><span class="token string">'mysql'</span><span class="token punctuation">;</span></code></pre><p>同样的，我们可以用以下查询来代替：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">select</span> <span class="token operator">*</span> from tag where tag<span class="token operator">=</span><span class="token string">'mysql'</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> from tag_post where tag_id<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> from post where id <span class="token function">in</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span><span class="token number">456</span><span class="token punctuation">,</span><span class="token number">567</span><span class="token punctuation">,</span><span class="token number">9989</span><span class="token punctuation">,</span><span class="token number">8909</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>看似后者查询步骤更多了，原本一个方法查询就能出结果，现在直接变成三个。但是这样做的好处是：</p><p><strong>1、单表查询更利于后续的维护。</strong></p><p>在实际开发场景中，在代码初步开发阶段（如果摊上一个不太靠谱的产品），业务发生变动，某张表的结构发生变动，很可能整个join查询都变得不可用，复杂的关联查询，在修改时，基本等于推倒重来。</p><p>但是如果我们使用了单表查询，拆成上诉例子中的三个步骤，我们可能只需要修改其中的一个步骤即可，比较利于维护。</p><p><strong>2、代码可复用性高</strong></p><p>这个不用多说，join联表的SQL，基本不太可能被复用，但是拆分后的单表查询，比如上面例子中，我查询出tab数据，任何地方组装需要tab数据，我都不需要再次做相关查询，直接使用。</p><p><strong>3、效率问题</strong></p><p>join联表查询，小表驱动大表，通过索引字段进行关联。如果表记录比较少的话，效率还是OK的，有时效率超过单表查询。但是如果数据量上去，多表查询是笛卡尔乘积方式，需要检索的数据是几何倍上升的。另外多表查询索引设计上也考验开发者的功底，索引设计不合理，大数据量下的多表查询，很可能把数据库拖垮。</p><p>相比而言，拆分成单表查询+代码上组装，业务逻辑更清晰，优化更方便，单个表的索引设计上也更简单。用多几行代码，多几次数据库查询换取这些优点，还是很值得的。</p><p><strong>4、减少冗余字段的查询</strong></p><p>在很多业务中，我们可能对某条记录只需要查询一次，此时如何使用关联查询，则不可避免的需要重复地访问一部分数据，从而可能会加剧网络和内存的消耗。</p><p><strong>5、缓存利用率更高</strong></p><p>比如上面查询中的tag是不常变动的数据，缓存下来，每次查询就可以跳过第一条查询语句。而关联查询，任何一张表的数据变动都会引起缓存结果的失效，缓存利用率不会很高。</p><p><strong>6、其他</strong></p><p>数据库资源比较宝贵，很多系统的瓶颈就在数据库上，很多复杂的逻辑我们在Service做，不在数据库处理会更好。</p><p>在后续数据量上去，需要分库分表时，Join查询更不利于分库分表，目前MySQL的分布式中间件，跨库join表现不良。</p><p>单表查询+代码上组装相当于解耦，现在开发中，我们常常使用各种ORM框架，不知道你的联查orm给你搞成了什么样,你是很难直接优化。</p><p>以上理由，强烈推荐在今后的开发中，尽可能的使用单表查询+代码上组装的方式。使用Stream lambda + mybatis plus + lombok， 酸爽！</p><h2 id="单表-VS-联表"><a href="#单表-VS-联表" class="headerlink" title="单表 VS 联表"></a>单表 VS 联表</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9lUVB5QmZmWWJ1Y3RHNEZsMDBNVkhpY2djVGRHeUhjbm1xN3FQMWN6Q0JPVUJiZGdSS3BlbWliaWFMOGQ2VWcxQnFIQWJ5clpFYnVCU1d6Z2NITVdabkdCZy82NDA?x-oss-process=image/format,png" alt="img"> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9lUVB5QmZmWWJ1Y3RHNEZsMDBNVkhpY2djVGRHeUhjbm1heGljRGJqekk3N0hOZUNRTm5MVDZRb3pJQzFpY3ZYTjFHN0xjeXNQZFpRNlVPbEJqU3pha09kUS82NDA?x-oss-process=image/format,png" alt="img"></p><p>基本就这些了，你的看法呢？</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客资源站收集</title>
      <link href="2021/02/17/good-blogs/"/>
      <url>2021/02/17/good-blogs/</url>
      
        <content type="html"><![CDATA[<h1 id="Github收集"><a href="#Github收集" class="headerlink" title="Github收集"></a>Github收集</h1><p><a href="https://github.com/iamshuaidi/algo-basic">https://github.com/iamshuaidi/algo-basic</a></p><p>这个Github将会分享数据结构，算法，计算机基础，我的学习经验等文章，无论你是要应付面试，特别是校招，还是想提升自己的<strong>内功</strong>，我想，我的这些文章都会对你有所帮助，这些文章基本都是获得各大博客平台一直好评</p><h2 id="免费编程练习"><a href="#免费编程练习" class="headerlink" title="免费编程练习"></a>免费编程练习</h2><p><a href="https://chinese.freecodecamp.org/learn/">https://chinese.freecodecamp.org/learn/</a></p><h2 id="WebGL教程"><a href="#WebGL教程" class="headerlink" title="WebGL教程"></a>WebGL教程</h2><p><a href="http://www.webgl3d.cn/WebGL/">http://www.webgl3d.cn/WebGL/</a></p><p>Three教程</p><p><a href="http://www.webgl3d.cn/Three.js/">http://www.webgl3d.cn/Three.js/</a></p><h2 id="Node学习"><a href="#Node学习" class="headerlink" title="Node学习"></a>Node学习</h2><p><a href="http://nqdeng.github.io/7-days-nodejs/#1">http://nqdeng.github.io/7-days-nodejs/#1</a></p><h2 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h2><p>饥人谷前端学习指南 <a href="https://www.zhihu.com/column/study-fe">https://www.zhihu.com/column/study-fe</a></p><p> Postbird博客 <a href="http://www.ptbird.cn/list.html">http://www.ptbird.cn/list.html</a></p><p>javascript的内存管理 <a href="https://mp.weixin.qq.com/s/aNm6Fp-E1TJX0Mzb_amjVA">https://mp.weixin.qq.com/s/aNm6Fp-E1TJX0Mzb_amjVA</a></p><p>Abp Vnext Pro 的 Vue 实现版本  <a href="https://mp.weixin.qq.com/s/MtoTzaJYFVcZA5keeyABqQ">https://mp.weixin.qq.com/s/MtoTzaJYFVcZA5keeyABqQ</a></p><p>2021年Node.js开发人员学习路线图  <a href="https://mp.weixin.qq.com/s/oDQNwvXNgnaLYgWZAUM0NQ">https://mp.weixin.qq.com/s/oDQNwvXNgnaLYgWZAUM0NQ</a></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>一个不错的博客  算法 leet code  <a href="https://www.cxyxiaowu.com/">https://www.cxyxiaowu.com/</a></p><h2 id="net"><a href="#net" class="headerlink" title=".net"></a>.net</h2><p>使用 Tye 辅助开发 dotnet 应用程序 <a href="https://mp.weixin.qq.com/s/I_dT4tBIrq4edGZOxe5qtA">https://mp.weixin.qq.com/s/I_dT4tBIrq4edGZOxe5qtA</a></p><p>C# 手把手教你爬取优酷电影信息-进阶 <a href="https://mp.weixin.qq.com/s/AvBzqPHr6ADIl6alEkqICQ">https://mp.weixin.qq.com/s/AvBzqPHr6ADIl6alEkqICQ</a></p><h2 id="软件设计模式和架构"><a href="#软件设计模式和架构" class="headerlink" title="软件设计模式和架构"></a>软件设计模式和架构</h2><p>几种常见的软件架构模式总结 <a href="https://mp.weixin.qq.com/s/PBRRpAcNB82sCzQvholRJA">https://mp.weixin.qq.com/s/PBRRpAcNB82sCzQvholRJA</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoCAD开发</title>
      <link href="2021/02/17/autocad-c/c-autocad-01/"/>
      <url>2021/02/17/autocad-c/c-autocad-01/</url>
      
        <content type="html"><![CDATA[<h1 id="c-AutoCAD开发"><a href="#c-AutoCAD开发" class="headerlink" title="c# AutoCAD开发"></a>c# AutoCAD开发</h1><h1 id="第二章-AutoCAD-创建实体-C-基本概念"><a href="#第二章-AutoCAD-创建实体-C-基本概念" class="headerlink" title="第二章 AutoCAD 创建实体 C#基本概念"></a>第二章 AutoCAD 创建实体 C#基本概念</h1><p>AutoCAD的常用命名空间</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210227102402285.png" alt="image-20210227102402285"></p><p>新建项目</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210227102533248.png" alt="image-20210227102533248"></p><p>注册方法</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210227102707034.png" alt="image-20210227102707034"></p><p>定义</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210227103116149.png" alt="image-20210227103116149"></p>]]></content>
      
      
      <categories>
          
          <category> AutoCAD开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoCAD开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoCAD开发</title>
      <link href="2021/02/17/autocad-c/c-autocad-00/"/>
      <url>2021/02/17/autocad-c/c-autocad-00/</url>
      
        <content type="html"><![CDATA[<h1 id="c-AutoCAD开发"><a href="#c-AutoCAD开发" class="headerlink" title="c# AutoCAD开发"></a>c# AutoCAD开发</h1><h1 id="第一章-AutoCAD-C-开发基础"><a href="#第一章-AutoCAD-C-开发基础" class="headerlink" title="第一章 AutoCAD C#开发基础"></a>第一章 AutoCAD C#开发基础</h1><h2 id="AutoCAD二次开发语言"><a href="#AutoCAD二次开发语言" class="headerlink" title="AutoCAD二次开发语言"></a>AutoCAD二次开发语言</h2><p>1.ObjectARX：优点：功能强大，编程效率高。缺点：必须掌握VC++</p><p>2.Lisp,VBA  优点：简单易上手，缺点：对于程序开发，很难</p><p>3.c# 结合了ObjectARX功能强大，效率高，以及简单易学</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226232629971.png" alt="image-20210226232629971"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226232718389.png" alt="image-20210226232718389"></p><h2 id="项目中添加cad引用"><a href="#项目中添加cad引用" class="headerlink" title="项目中添加cad引用"></a>项目中添加cad引用</h2><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226232851361.png" alt="image-20210226232851361"></p><p>引用之后修改属性</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226232919860.png" alt="image-20210226232919860"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226233032206.png" alt="image-20210226233032206"></p><p>程序集引入以及命名空间</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226233432913.png" alt="image-20210226233432913"></p><p>调用方法 标注</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226233554713.png" alt="image-20210226233554713"></p><p>AUTOCAD  netload  dll引用，可以命令行输入命令</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226233834674.png" alt="image-20210226233834674"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226234328640.png" alt="image-20210226234328640"></p>]]></content>
      
      
      <categories>
          
          <category> AutoCAD开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoCAD开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 前言</title>
      <link href="2021/02/17/c-10/c-10th-00/"/>
      <url>2021/02/17/c-10/c-10th-00/</url>
      
        <content type="html"><![CDATA[<h1 id="c-是专门用于-net-的语言"><a href="#c-是专门用于-net-的语言" class="headerlink" title="c# 是专门用于 .net 的语言"></a>c# 是专门用于 .net 的语言</h1><p>web 页面<br>WPF<br>REST WEB服务<br>分布式应用程序的组件<br>数据库访问组件<br>桌面应用程序<br>UWP</p><h1 id="net-core-重要性"><a href="#net-core-重要性" class="headerlink" title=".net core 重要性"></a>.net core 重要性</h1><p>.net framework<br><a href="http://asp.net/">asp.net</a> web forms ？ MVC<br>WIN form /UWP<br>EF / LINQ</p><h1 id="NET-CORE"><a href="#NET-CORE" class="headerlink" title=".NET CORE"></a>.NET CORE</h1><p>开源<br>包较小，更快的创新<br>支持多个平台<br>可以编译为本地代码<br>Xamarin</p><h1 id="C-重要性"><a href="#C-重要性" class="headerlink" title="C# 重要性"></a>C# 重要性</h1><p>设计思想来源于C++ 、java、Pascal<br>面向对象的通用编程语言<br>给予组件的变成语言，支持属性、时间、特性和构建程序集<br>函数数编程理念<br>增加了泛型、语言集成查询linq、lambda表达式、动态特性、更简单的异步编程</p><h1 id="c-6-新特性"><a href="#c-6-新特性" class="headerlink" title="c#6 新特性"></a>c#6 新特性</h1><h2 id="静态using声明："><a href="#静态using声明：" class="headerlink" title="静态using声明："></a>静态using声明：</h2><p>静态的声明允许调用静态方式时不适用类名</p><blockquote><p>using static sysytem.console； Writeline(&quot;hello world&quot;) ​</p></blockquote><h2 id="表达式体方法"><a href="#表达式体方法" class="headerlink" title="表达式体方法:"></a>表达式体方法:</h2><p>表达式方法只包括一个可以用lambda语法编写的语句</p><blockquote><p>public bool isSquare（Rectangle rect）=&gt;rect.Height == rect.Width;</p></blockquote><h2 id="表达式体属性："><a href="#表达式体属性：" class="headerlink" title="表达式体属性："></a>表达式体属性：</h2><p>与表达式方法类似，只有get存取器的单行属性可以用lamabda语法编写</p><blockquote><p>public string FullName =&gt; FirstName +&quot;&quot;+ LastName;</p></blockquote><h2 id="自动实现的属性初始化器"><a href="#自动实现的属性初始化器" class="headerlink" title="自动实现的属性初始化器:"></a>自动实现的属性初始化器:</h2><p>自动实现的属性可以用属性初始化器来初始化</p><blockquote><p>public class Person{ public int Age{get;set;}=42; ​}</p></blockquote><h2 id="只读的自动属性"><a href="#只读的自动属性" class="headerlink" title="只读的自动属性"></a>只读的自动属性</h2><blockquote><p>public BookId {get;} </p></blockquote><h2 id="ameof-运算符："><a href="#ameof-运算符：" class="headerlink" title="ameof 运算符："></a>ameof 运算符：</h2><p>使用此运算符，可以访问字段名、属性名、方法名、类型名</p><h2 id="空值传播运算符"><a href="#空值传播运算符" class="headerlink" title="空值传播运算符"></a>空值传播运算符</h2><blockquote><p>int? age =p?.Age; handler?.Invoke(source,e)</p></blockquote><h2 id="字符串插值-占位符可以直接是表达式"><a href="#字符串插值-占位符可以直接是表达式" class="headerlink" title="字符串插值: 占位符可以直接是表达式"></a>字符串插值: 占位符可以直接是表达式</h2><blockquote><p>public override ToString() =&gt; $&quot;{Title} {Publisher}&quot;</p></blockquote><h2 id="字典初始化器"><a href="#字典初始化器" class="headerlink" title="字典初始化器"></a>字典初始化器</h2><blockquote><p>var dict = new Dictionary&lt;int,string&gt;(){<br>    2 =”three”,<br>  3=”seven”<br> ​}</p></blockquote><h2 id="异常过滤器"><a href="#异常过滤器" class="headerlink" title="异常过滤器"></a>异常过滤器</h2><h2 id="Catch-中的await"><a href="#Catch-中的await" class="headerlink" title="Catch 中的await"></a>Catch 中的await</h2><blockquote><p>try{ // }Catch(MyException ex){ await new<br>MessageDialog().showAsync(ex.Message); ​}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
