<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c# 高级编程(10th) 第十章 字符串和正则表达式</title>
      <link href="2021/02/18/c/c-10th-10/"/>
      <url>2021/02/18/c/c-10th-10/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第十章-字符串和正则表达式"><a href="#c-语言-第十章-字符串和正则表达式" class="headerlink" title="c#语言 第十章 字符串和正则表达式"></a>c#语言 第十章 字符串和正则表达式</h1><p>10.1 System.String类</p><p>10.1.1构建字符串</p><p>10.1.2 StringBuilder成员</p><p>10.2字符串格式</p><p>10.2.1字符串插值</p><p>10.2.2日期事件和数字格式</p><p>10.2.3自定义字符串格式</p><p>10.3正则表达式</p><p>10.3.1正则表达式概述</p><p>10.3.2RegularExpressionsPlayaround示例</p><p>10.3.3显示结果</p><p>10.3.4匹配、组合捕获</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> 字符串和正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第九章 运算符和强制类型转换</title>
      <link href="2021/02/18/c/c-10th-09/"/>
      <url>2021/02/18/c/c-10th-09/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第九章-委托、lambda表达式和事件"><a href="#c-语言-第九章-委托、lambda表达式和事件" class="headerlink" title="c#语言 第九章 委托、lambda表达式和事件"></a>c#语言 第九章 委托、lambda表达式和事件</h1><p>9.1引用方法</p><p>9.2委托</p><p>9.2.1声明委托</p><p>9.2.2使用委托</p><p>9.2.3简单的委托示例</p><p>9.2.4action<T>和Func<T>委托</p><p>9.2.5BubbleSorter示例</p><p>9.2.6 多播委托</p><p>9.2.7匿名方法</p><p>9.3lambda表达式</p><p>9.3.1参数</p><p>9.3.2多行代码</p><p>9.3.3闭包</p><p>9.4事件</p><p>9.4.1事件发布程序</p><p>9.4.2事件侦听器</p><p>9.4.3弱事件</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> 运算符和强制类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第七章 数组和元祖</title>
      <link href="2021/02/18/c/c-10th-07/"/>
      <url>2021/02/18/c/c-10th-07/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第七章-数组和元祖"><a href="#c-语言-第七章-数组和元祖" class="headerlink" title="c#语言 第七章 数组和元祖"></a>c#语言 第七章 数组和元祖</h1><h2 id="7-1-同一类型Array和不同类型Tuple的多个对象"><a href="#7-1-同一类型Array和不同类型Tuple的多个对象" class="headerlink" title="7.1 同一类型Array和不同类型Tuple的多个对象"></a>7.1 同一类型Array和不同类型Tuple的多个对象</h2><p>​        对于同一个类型的多个对象，我们可以使用集合和数组。</p><p>​        C#用特殊的记号声明、初始化和使用数组。Array类在后台发挥作用，它为数组中元素的排序和过滤提供了几个方法。使用枚举器，就可以迭代数组中的所有元素。</p><p>​        对于不同类型的多个对象，可以使用Tuple（元组）类型。</p><h2 id="7-2简单数组"><a href="#7-2简单数组" class="headerlink" title="7.2简单数组"></a>7.2简单数组</h2><p>​        数组是一种数据结构，可以包含统一类型的多个元素。</p><h3 id="7-2-1数组的声明"><a href="#7-2-1数组的声明" class="headerlink" title="7.2.1数组的声明"></a>7.2.1数组的声明</h3><p>​        在声明数组时，应先定义元素的类型，其后是一对空方括号，后面是变量名</p><h3 id="7-2-2数组的初始化"><a href="#7-2-2数组的初始化" class="headerlink" title="7.2.2数组的初始化"></a>7.2.2数组的初始化</h3><p>​        在声明了数组之后，我们需要为数组的元素分配内存。因为数组时引用类型，所以我们必须用new来给它分配堆上的内存。使用new运算符，制定数组中元素的类型和数量来初始化数组的变量</p><blockquote><p>int[] myArray ;//声明数组</p><p>myArray = new int [4]；//分配内存</p><p>int[] myArray = new int [4]{1,2,3,4};</p><p>//如果我们在声明时使用初始化器为数组赋值，那就可以不必指定数组的大小，因为编译器会自动统计元素的个数</p><p>int[] myArray = new int []{1,2,3,4};</p><p>int[] myArray = {1,2,3,4}; //简化写法</p></blockquote><p><strong>如果你不知道数组应包含多少个元素个数，那你应该用集合而不是数组。</strong></p><h3 id="7-2-3访问数组元素"><a href="#7-2-3访问数组元素" class="headerlink" title="7.2.3访问数组元素"></a>7.2.3访问数组元素</h3><p>​        访问数组元素的下标都是从0开始，0代表第一个数组元素。</p><p><img src="https://img-blog.csdnimg.cn/2020050810080638.png" alt="img"></p><blockquote><p>int[] myArray = new int[]{1,2,3,4};</p><p>int v1 = myArray[0];</p><p>myArray[2]=5;</p></blockquote><h3 id="7-2-4使用引用类型"><a href="#7-2-4使用引用类型" class="headerlink" title="7.2.4使用引用类型"></a>7.2.4使用引用类型</h3><p>​        数组不仅可以声明值类型的元素，还可以声明引用类型的元素，而且往往使用引用类型的元素还挺常见。</p><p>​        要注意的是，使用引用类型如类类型，那你需要为该类型里面的每个元素分配内存，都要初始化值。</p><blockquote><p>public class Person<br>{<br>   public string name;<br>   public int age;</p><p>   public void GETAge()<br>   {<br>       DO…..<br>   }<br>}</p><p>public class M<br>{<br>   // 使用类的实例作为数组元素<br>   Person[] myPerson= new Person[2];</p><pre class=" language-c#"><code class="language-c#">// 每次初始化都是初始化这个对象myPerson[0] = new Person&#123; name = "马云"，age = 55&#125;;myPerson[1] = new Person&#123; name = "totoro"，age = 18&#125;;</code></pre><p>}</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200508100700528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RPVE9MT0c=,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="7-3多维数组"><a href="#7-3多维数组" class="headerlink" title="7.3多维数组"></a>7.3多维数组</h2><p>  <strong>声明数组后，就不能修改其阶数了</strong></p><blockquote><p>int[,] arr2 = new int[1, 2];<br>int[,,] arr3 = new int[2,2,2] {<br>                                {<br>                                    {1,2 },   //0,0,0 - 0,0,1<br>                                    {3,4 }    //0,1,0 - 0,1,1<br>                                },<br>                                {<br>                                    {5,6 },   //1,0,0 - 1,0,1<br>                                    {7,8 }    //1,1,0 - 1,1,1<br>                                }<br>                               };</p><p>Console.WriteLine(arr3[0, 0, 0]);  // 输出1<br>Console.WriteLine(arr3[0, 1, 0]);  // 输出3</p></blockquote><h2 id="7-4锯齿数组"><a href="#7-4锯齿数组" class="headerlink" title="7.4锯齿数组"></a>7.4锯齿数组</h2><p><img src="https://img-blog.csdnimg.cn/20200508104822207.png" alt="img"></p><blockquote><p>{<br>    // 声明一个3维的锯齿数组，最外维包有2个2维<br>    int[][][] arr = new int[2][][];</p><pre class=" language-c#"><code class="language-c#">// 表示最外围的第一个二维数组，该2为数组包含3个一维数组arr[0] = new int[3][]; // 表示中间的第一个一维数组，该一维数组包含2个元素arr[0][0] = new int[3] &#123; 1,2,3&#125;;arr[0][1] = new int[5] &#123; 4,5,6,7,8&#125;;arr[0][2] = new int[2] &#123; 9,10&#125;; // 验证，输出7Console.WriteLine(arr[0][1][3]);     </code></pre><p>}</p></blockquote><h2 id="7-5Array类"><a href="#7-5Array类" class="headerlink" title="7.5Array类"></a>7.5Array类</h2><p>​        上面声明数组都是通过Array类来实现的，就是说使用[]就是使用Array类的表示法。c#语法，会创建一个派生自抽象类基类Array类的新类。</p><p>​        Length属性和foreach语句迭代数组，其实是使用了Array类中的GetEnumerator()方法。</p><p>​        <strong>如果数组中包含的元素个数超过了整数范围，就可以使用LongLength属性获得元素个数。</strong></p><h3 id="7-5-1创建数组"><a href="#7-5-1创建数组" class="headerlink" title="7.5.1创建数组"></a>7.5.1创建数组</h3><p>​        Array类是一个抽象类，所以不能用构造函数来创建数组。</p><p>​        除了我们常规类如上面的[]创建数组,还有一种方法可以创建数组，那就是使用静态方法CreateInstance( )创建数组。如果你开始不知道数组的类型，那这方法就显得非常有用了。</p><p>​        <strong>CreateInstance()方法有许多重载版本，可以创建多维数组和不基于0的数组。</strong></p><blockquote><p>int[] lengths = { 2, 3 };<br>int[] lowerBounds = { 1, 10 };</p><p>// lengths 表示你要创建一个2*3维的数组，不能创建锯齿数组<br>// lowerBounds表示自定义每个维度的初始下标，默认是0开始，这里最外围自定义最小是1，最里维是从10开始<br>Array arr = Array.CreateInstance(typeof(string), lengths, lowerBounds);</p><p>// 给这个2维数组赋值<br>arr.SetValue(“A”, 1, 10); // 就相当于[0,0]<br>arr.SetValue(“B”, 1, 11);<br>arr.SetValue(“C”, 1, 12);<br>arr.SetValue(“D”, 2, 10); // 就相当于[1,0]<br>arr.SetValue(“E”, 2, 11);<br>arr.SetValue(“F”, 2, 12); // 就相当于[1,2]</p><p>// 对于Array类型的我们不能直接输出Console.Write(arr[1][11])，需要通过遍历数组<br>System.Collections.IEnumerator arr1  = arr.GetEnumerator();</p><p>// arr1.Rank得到数组的维度，这里arr1.Rank - 1得到1，即0-1<br>// arr1.GetLength(1),表示第二维上有几个元素<br>// arr1.MoveNext()表示是否存在元素<br>while (arr1.MoveNext())<br>{<br>   // 存在就输出该元素值<br>   Console.Write(“\t{0}”, arr1.Current);<br>}</p></blockquote><h3 id="7-5-2复制数组"><a href="#7-5-2复制数组" class="headerlink" title="7.5.2复制数组"></a>7.5.2复制数组</h3><p>​        因为数组是引用类型，所以将一个数组变量赋予另一个数组的变量，就会得到两个引用同一数组的变量。就是在栈上有两个引用的值都是一个堆上的某个地址。而复制数组，会使数组实现ICloneable接口。这个接口定义的Clone( )方法会创建数组的浅表副本。如：</p><blockquote><p>{<br>    int[] arr = {1,2,3，4,5};</p><pre><code>// 实现浅表复制（只动栈），对于引用类型复制引用而不动到对象，对于值类型直接复制值int[] arr1 = (int[])arr.Clone(); // 还有一种是复制堆对象数据 int[] arr2 = new int[3]; Array.Copy(arr, arr2, arr2.Length);</code></pre><p>}</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200508144252355.png" alt="img">    </p><p>​        如果元素是值类型，就会赋值所有值</p><p><img src="https://img-blog.csdnimg.cn/20200508144212691.png" alt="img"></p><p><strong>除了Clone()方法之外，还可以使用Array.Copy()方法创建浅表副本。但clone和copy的一个重要区别：</strong></p><p>​    clone会创建一个新数组</p><p>​    copy方法必须传递阶数相同且有足够元素的已有数组</p><h3 id="7-5-3排序"><a href="#7-5-3排序" class="headerlink" title="7.5.3排序"></a>7.5.3排序</h3><p>​        Array使用Quicksort算法对数组中的元素进行排序。Sort方法需要数组中元素实现IComparable接口。例如简单类型 string和int32实现IComparable接口，所以可以对包含这些类型的元素排序</p><blockquote><p>{<br>    int[] arr = { 5, 2, 1,4,3 };<br>    string[] brr = { “H”, “U”, “A”, “N”, “Z” };</p><pre><code>// 无论数字还是字符串都从小到大输出（对字符串判断首字母）Array.Sort(arr);Array.Sort(brr);</code></pre><p>}</p></blockquote><p>​        对于我们自定义的类类型数组也是可以排序的，但是一定要注意，使用自定义类做排序，那么这个自定义类一定要是实现Icomparable&lt;自定义类名&gt; 这个接口的</p><blockquote><p>public  class Class1: IComparable<Class1><br>{<br>     // 姓<br>     public string FirstName { get; set; }</p><pre><code>// 名public string LastName &#123; get; set; &#125; // 别忘了重写Tostring(),这样你才能狗输出字符串内容public override string ToString() =&gt; $&quot;&#123;FirstName&#125; &#123;LastName&#125;&quot;; // 也前往别忘了要实现接口public int CompareTo(Class1 other)&#123;    if (other == null) throw new ArgumentNullException(&quot;other&quot;);     // 比较 姓 先,不一致默认返回1，一致默认返回0    int result = FirstName .CompareTo(other.FirstName );    if (result == 0)    &#123;        result = LastName.CompareTo(other.LastName);    &#125;    return result;&#125;</code></pre><p>}</p><p>public class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        Class1[] arr = new Class1[]<br>        {<br>            new Class1 { FirstName=”马”, LastName=”云” },<br>            new Class1 { FirstName=”马”, LastName=”化腾” },<br>            new Class1 { FirstName=”李”, LastName=”庆国” },<br>            new Class1 { FirstName=”董”, LastName=”明珠” },<br>            new Class1 { FirstName=”宗”, LastName=”庆后” }<br>        }</p><pre><code>    // 进行排序，会触发CompareTo    Array.Sort(arr);     // 输出结果    foreach (var a in arr)    &#123;        Console.WriteLine(a);    &#125;    &#125;</code></pre><p>}</p></blockquote><h2 id="7-6数组作为参数"><a href="#7-6数组作为参数" class="headerlink" title="7.6数组作为参数"></a>7.6数组作为参数</h2><h3 id="7-6-1数组协变"><a href="#7-6-1数组协变" class="headerlink" title="7.6.1数组协变"></a>7.6.1数组协变</h3><p>​        数组支持协变，表示数组可以声明为基类，其派生类型的元素可以赋予数组元素。我们可以把自定义的Class1类数组赋值给object数组，因为Class1派生自object，这就是数组协变的表示，数组协变只能用于引用类型，不能用于值类型！！！如：</p><blockquote><p>// 接着上面代码<br>public class Program<br>{<br>    public static void DispalyArray(object[] data)<br>    {<br>        DO……<br>    }</p><pre><code>DispalyArray(arr);</code></pre><p>}</p></blockquote><h3 id="7-6-2ArraySegment"><a href="#7-6-2ArraySegment" class="headerlink" title="7.6.2ArraySegment"></a>7.6.2ArraySegment<T></h3><p>​        结构ArraySegment<T>表示数组的一个部分。如果需要使用不同的方法处理某个大型数组的不同部分，那么可以把相应的数组部分传到各个方法中。具体的使用如下：</p><blockquote><p>public class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        int[] ar1 = { 1, 4, 5, 11, 13, 18 };<br>        int[] ar2 = { 3, 4, 5, 18, 21, 27, 33 };</p><pre><code>    // 我们可以将一个数组或者多个数组的部分传给某个函数做处理    var segments = new ArraySegment&lt;int&gt;[2]    &#123;        new ArraySegment&lt;int&gt;(ar1, 0, 3),        new ArraySegment&lt;int&gt;(ar2, 3, 3)    &#125;     SumOfSegments(segments);&#125; static void SumOfSegments(ArraySegment&lt;int&gt;[] segments)&#123;    foreach (var segment in segments)    &#123;        for (int i = segment.Offset; i &lt; segment.Offset + segment.Count; i++)        &#123;            Console.WriteLine(segment.Array[i]);        &#125;    &#125;&#125;</code></pre><p>}</p></blockquote><p>​        来了来了，动脑的地方来了，数组段不复制原数组的元素，但是原数组可以通过ArraySegment<T>访问。如果数组段中的元素改变了，这些变化就会反映到原数组中。如：</p><blockquote><p>// 接着上面的代码，我们改一下：<br>{<br>        static void SumOfSegments(ArraySegment<int>[] segments)<br>        {<br>            foreach (var segment in segments)<br>            {<br>                for (int i = segment.Offset; i &lt; segment.Offset + segment.Count; i++)<br>                {<br>                    // 改一下这里，改一下数组的值<br>                    segment.Array[i] = 998 ;<br>                }</p><pre><code>        &#125;            &#125;     // 在最后    foreach (var a in ar1)    &#123;        Console.WriteLine(a);    &#125;</code></pre><p>}</p></blockquote><p>​        </p><h2 id="7-7枚举-foreach"><a href="#7-7枚举-foreach" class="headerlink" title="7.7枚举 foreach"></a>7.7枚举 foreach</h2><h3 id="7-7-1IEnumrtator接口"><a href="#7-7-1IEnumrtator接口" class="headerlink" title="7.7.1IEnumrtator接口"></a>7.7.1IEnumrtator接口</h3><p>​        在上面谈Array类的时候，代码中我们有用到这么一个方法——GetEnumerator( )，数组或集合都有实现带GetEnumerator()方法的IEumerator接口。调用了foreach方法的客户端和集合之间的关系显示如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200509104613177.png" alt="img"></p><p>​    IEumerator定义了current属性，来返回光标所在的元素，改接口的MoveNext( )方法移动到集合的下一个元素上，如果有这个元素，就返回true，否则返回false。</p><p>​    这个接口的泛型版本IEnumerator<T>派生自IDispossable,因此定义了Dispose()方法，来清理给枚举器分配的资源。</p><h3 id="7-7-2foreach语句"><a href="#7-7-2foreach语句" class="headerlink" title="7.7.2foreach语句"></a>7.7.2foreach语句</h3><p>​        foreach语句的实现并不真的需要在集合类中实现这个接口，它只需要通过一个名为GetEnumerator( )的方法，它返回实现了IEumerator接口就足够了</p><h3 id="7-7-3yield语句"><a href="#7-7-3yield语句" class="headerlink" title="7.7.3yield语句"></a>7.7.3yield语句</h3><p>​        c#2.0添加了yield语句，以便于创建枚举器。</p><p>​        yield return 语句返回集合的一个元素，并移动到下一个元素上，yield break可停止迭代。</p><blockquote><p>using System;</p><p>using System.Collections;</p><p>namespace Wrox.ProCSarp.Arrays{</p><p>​    public class HelloCollection{</p><p>​        public IEnumerator<string>  GetEnumerator(){</p><p>​            yield return “Hello”,</p><p>​            yield return “world”,</p><p>​        }</p><p>​    }</p><p>}</p></blockquote><p>​        迭代集合的不同方式</p><p>​        用yield return返回枚举器</p><h2 id="7-8元祖"><a href="#7-8元祖" class="headerlink" title="7.8元祖"></a>7.8元祖</h2><p>​        来讲讲元组吧，前面一直在说数组(同类型)，元组就是支持不同类型的元素。</p><p>​        元组的使用和数组不同，数组是new创建的，元组不是，且元组一直都是作为方法的类型。例如Tuple<T1>包含一个元素，Tuple&lt;T1,T2&gt;包含两个元素，以此类推。元组用静态的Create( )方法创建。Create( )方法的泛型参数定义了要实例化的元组类型。如：</p><blockquote><p> public class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        int[] a = { 1, 2, 3, 4, 5 };<br>        string b = “HeeloWorld!”;</p><pre><code>    var result = TT(a,b);&#125; // 通过Item取对应的类型值foreach (var i in result.Item1)&#123;    Console.WriteLine(i);&#125; // 元组可接纳不同类型的参数，返回不同类型的结果static Tuple&lt;int[], string&gt; SumOfSegments(int[] a,string b)&#123;    // Tuple.Create将计算结果打包成元组返回去    return Tuple.Create(a, b);&#125;</code></pre><p>}</p></blockquote><h2 id="7-9结构比较"><a href="#7-9结构比较" class="headerlink" title="7.9结构比较"></a>7.9结构比较</h2>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> 数组和元祖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第八章 运算符和强制类型转换</title>
      <link href="2021/02/18/c/c-10th-08/"/>
      <url>2021/02/18/c/c-10th-08/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第八章-运算符和强制类型转换"><a href="#c-语言-第八章-运算符和强制类型转换" class="headerlink" title="c#语言 第八章 运算符和强制类型转换"></a>c#语言 第八章 运算符和强制类型转换</h1><p>8.1运算符和类型转换</p><p>8.2运算符</p><p>8.2.1运算符的简化操作</p><p>条件运算符</p><p>checked和unchecked运算符</p><p>is运算符</p><p>as运算符</p><p>sizefof运算符</p><p>typeof运算符</p><p>namefo运算符</p><p>index运算符</p><p>可控类型和运算符</p><p>空合并运算符</p><p>空值传播运算符</p><p>8.2.2运算符的优先级和关联性</p><p>8.3类型的安全性</p><p>8.3.1类型转换</p><p>隐式转换</p><p>显示转换</p><p>8.3.2装箱和拆箱</p><p>8.4比较对象的相等性</p><p>8.4.1比较引用类型的相等性</p><p>8.4.2比较值类型的相等性</p><p>8.5运算符重载</p><p>8.5.1运算符的工作方式</p><p>8.5.2运算符重载的示例</p><p>8.5.3比较运算符的重载</p><p>8.5.4可以重载的运算符</p><p>8.6实现自定义的额索引运算符</p><p>8.7实现用户定义的类型强制转换</p><p>8.7.1实现用户定义的类型强制转换</p><p>类之间的强制转换</p><p>基类和派生类之间的类型强制转换</p><p>装箱和拆箱类型强制转换</p><p>8.7.2多重类型强制转换</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> 运算符和强制类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第六章 泛型</title>
      <link href="2021/02/18/c/c-10th-06/"/>
      <url>2021/02/18/c/c-10th-06/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第六章-泛型"><a href="#c-语言-第六章-泛型" class="headerlink" title="c#语言 第六章 泛型"></a>c#语言 第六章 泛型</h1><h2 id="6-1泛型概述"><a href="#6-1泛型概述" class="headerlink" title="6.1泛型概述"></a>6.1泛型概述</h2><p>​        有了泛型就可以创建独立于被包含类型的类和方法，不必给不同的类型编写功能相同的许多方法或类，只创建一个方法和类即可</p><p>​        另一个减少代码的选项是使用object类，但使用派生自object类的类型进行传递不是类型安全的</p><p>​        泛型使用泛型类型，根据需要用特定的类型替换泛型类型，保证了类型安全性</p><h3 id="6-1-1-性能"><a href="#6-1-1-性能" class="headerlink" title="6.1.1 性能"></a>6.1.1 性能</h3><p>​        对值类型使用非泛型集合类，则在把值类型转换为引用类型和把引用类型转换为值类型时，需要进行装箱和拆箱操作。操作很容易，但是性能损失比较大，遍历许多项时尤其如此。</p><p>​        使用List<T>定义泛型为int时，就不需要再进行装箱和拆箱操作。</p><h3 id="6-1-2类型安全"><a href="#6-1-2类型安全" class="headerlink" title="6.1.2类型安全"></a>6.1.2类型安全</h3><p>​        泛型类List<T>中，泛型类型T定义了允许使用过的类型，有了List<int> 的定义，就只能把证书类型添加到集合中。</p><h3 id="6-1-3二进制代码的重用"><a href="#6-1-3二进制代码的重用" class="headerlink" title="#6.1.3二进制代码的重用"></a>#6.1.3二进制代码的重用</h3><p>​        泛型允许更好的重用二进制代码，泛型类可以定义一次，并且可以用许多不同的类型实例化。</p><h3 id="6-1-4代码的扩展"><a href="#6-1-4代码的扩展" class="headerlink" title="6.1.4代码的扩展"></a>6.1.4代码的扩展</h3><p>​        JIT编译器会把泛型类型编译为本地代码时，会给每个值类型创建一个新类</p><h3 id="6-1-5命名约定"><a href="#6-1-5命名约定" class="headerlink" title="6.1.5命名约定"></a>6.1.5命名约定</h3><p>​        泛型类型的命名名称用字母T作为前缀</p><p>​        如果没有特需要求，泛型类型允许用任意类代替</p><p>​        如果泛型类型有特殊要求，（必须实现一个借口）或使用多个泛型类型，就应给泛型类型使用描述性的名称</p><h2 id="6-2创建泛型类"><a href="#6-2创建泛型类" class="headerlink" title="6.2创建泛型类"></a>6.2创建泛型类</h2><p>​    每个处理兑现类型的类都可以有泛型的实现方式，另外，如果类使用了层次结构，泛型就非常有助于消除类型强制转换操作</p><h2 id="6-3泛型类的功能"><a href="#6-3泛型类的功能" class="headerlink" title="6.3泛型类的功能"></a>6.3泛型类的功能</h2><h3 id="6-3-1默认值"><a href="#6-3-1默认值" class="headerlink" title="6.3.1默认值"></a>6.3.1默认值</h3><p>​    不能把null赋值非泛型类型，因为泛型类型也可以实例化为值类型，而null只能用于引用;</p><p>​    使用default关键字，将null值赋予引用类型，将0赋予值类型</p><h3 id="6-3-2约束"><a href="#6-3-2约束" class="headerlink" title="6.3.2约束"></a>6.3.2约束</h3><p>​    如果泛型需要调用泛型类型中的方法，就必须添加约束</p><p>​    泛型支持的几种约束</p><p>​        where T:struct  必须是值类型</p><p>​        where T:class 必须是引用类型</p><p>​        where T:IFoo 必须是实现接口IFoo</p><p>​        where T:Foo 必须是派生自Foo</p><p>​        where T:new() 构造函数约束，指定T必须有一个默认构造函数</p><p>​        where T1:T2  类型T1派生自泛型类型T2</p><h3 id="6-3-3-继承"><a href="#6-3-3-继承" class="headerlink" title="6.3.3 继承"></a>6.3.3 继承</h3><p>​        泛型类可以实现泛型接口，也可以派生自一个类，泛型类可以派生自泛型类</p><p>​        要求必须重复接口的泛型类型，或者必须制定基类的类型</p><p>​        派生类可以是泛型类型或非泛型类型</p><h3 id="6-3-4静态成员"><a href="#6-3-4静态成员" class="headerlink" title="6.3.4静态成员"></a>6.3.4静态成员</h3><h2 id="6-4泛型接口"><a href="#6-4泛型接口" class="headerlink" title="6.4泛型接口"></a>6.4泛型接口</h2><p>6.4.1协变和抗变</p><p>.net 4之前泛型接口是不变的，。net4通过协变和抗变为泛型接口和泛型委托添加了一个重要的扩展。</p><p>协变和抗变指对参数和返回值的类型进行转换</p><p>6.4.2泛型接口的协变</p><p>​        如果泛型类型用out关键字标注，泛型接口是协变得。这也意味着返回类型只能是T</p><p>6.4.3泛型接口的抗变</p><p>​        如果泛型类型用in关键字标注，泛型接口是抗变的。这也意味着输入只能是T</p><h2 id="6-5泛型结构"><a href="#6-5泛型结构" class="headerlink" title="6.5泛型结构"></a>6.5泛型结构</h2><p>Nullable<T>  =&gt;Nullable<int> =&gt; int?</p><blockquote><p>int y1 = x1??0; </p></blockquote><h2 id="6-6泛型方法"><a href="#6-6泛型方法" class="headerlink" title="6.6泛型方法"></a>6.6泛型方法</h2><p>6.6.1泛型方法示例</p><p>6.6.2带约束的泛型方法</p><p>6.6.3带委托的泛型方法</p><p>6.6.4泛型方法规范</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第五章 托管和非托管的资源</title>
      <link href="2021/02/18/c/c-10th-05/"/>
      <url>2021/02/18/c/c-10th-05/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第五章-托管和非托管的资源"><a href="#c-语言-第五章-托管和非托管的资源" class="headerlink" title="c#语言 第五章 托管和非托管的资源"></a>c#语言 第五章 托管和非托管的资源</h1><h2 id="5-1资源"><a href="#5-1资源" class="headerlink" title="5.1资源"></a>5.1资源</h2><p>使用托管和非托管的资源—存储在托管或本机堆中的对象，尽管垃圾收集齐释放存储在托管堆中的托管对象，但不释放本机堆中的对象，必须由开发人员自己释放</p><p>什么是大小对象堆？</p><p>什么数据类型存储在堆栈上是非常有益的？</p><p>垃圾收集器处理托管的资源，那么非托管的资源呢？</p><h2 id="5-2后台内存管理"><a href="#5-2后台内存管理" class="headerlink" title="5.2后台内存管理"></a>5.2后台内存管理</h2><h3 id="5-2-1值类型数据"><a href="#5-2-1值类型数据" class="headerlink" title="5.2.1值类型数据"></a>5.2.1值类型数据</h3><p>虚拟内存：执行代码、代码加载的所有DLL、以及程序运行时使用的所有变量</p><p>栈–值类型数据</p><p>​    块作用域或结构作用域：生存期嵌套</p><p>​    编译器在内部确保先放在内存中的那个变量后删除</p><h3 id="5-2-2引用数据类型"><a href="#5-2-2引用数据类型" class="headerlink" title="5.2.2引用数据类型"></a>5.2.2引用数据类型</h3><p>​    所有引用类型，托管堆</p><p>首先创建对象时，分配堆上的内存以存储对象（真正的对象），然后把变量的值设置为分配给新对象的内存地址</p><p>把一个引用变量的值赋予两一个相同类型的变量，就有两个变量引用内存中的同一对象了；当一个引用变量超出作用域时，它会从栈中删除，但是引用对象的数据让保留在堆中</p><p>只有到程序停止，或垃圾回收器删除为止。只有数据不再被任何变量引用时，它才会被删除</p><h3 id="5-2-3-垃圾回收-System-GC-Collect"><a href="#5-2-3-垃圾回收-System-GC-Collect" class="headerlink" title="5.2.3 垃圾回收  System.GC.Collect()"></a>5.2.3 垃圾回收  System.GC.Collect()</h3><p>​    在垃圾回收器运行时，它会从堆中删除不再引用的所有对象</p><p>​    只要释放了能释放的所有对象，就会把其它对象移动回堆的端部，再次形成一个连续的内存块</p><p>​    垃圾回收器的这个压缩操作是托管的堆与非托管的堆的区别所在，使用托管的堆，就只需要读取指针的值即可，而不需要遍历地址的链表，来查找一个地方放置新数据</p><p>​    大对象堆：在.net 下，较大对象有自己的托管堆，使用大于85000个字节的对象时，就会放在这个特殊的堆上</p><h2 id="5-3强引用-和弱引用"><a href="#5-3强引用-和弱引用" class="headerlink" title="5.3强引用 和弱引用"></a>5.3强引用 和弱引用</h2><p>​    垃圾回收器不能回收仍在引用的对象的内存 —-这是一个强引用</p><p>​    弱引用WeakPeference：允许创建和使用对象，但垃圾回收器碰巧在运行，就会回收对象并释放内存，由于潜在的bug和性能问题，一般不这么做</p><h2 id="5-4处理非托管的资源"><a href="#5-4处理非托管的资源" class="headerlink" title="5.4处理非托管的资源"></a>5.4处理非托管的资源</h2><p>​    垃圾回收器不知道如何释放非托管的资源，例如：文件句柄、网络连接、和数据库连接</p><p>​    定义一个类时，可以使用两种机制来自动释放非托管的资源</p><p>​            声明一个析构函数（终结器），作为类的一个成员</p><p>​            在类中实现System.IDispossable接口</p><h3 id="5-4-1析构函数或终结器finalizer"><a href="#5-4-1析构函数或终结器finalizer" class="headerlink" title="5.4.1析构函数或终结器finalizer"></a>5.4.1析构函数或终结器finalizer</h3><p>​    c#编译器在编译析构函数时，会隐式的把析构函数的代码编译为等价于重写Finalize（）方法的代码，从而确保执行父类的Finalize（）方法</p><p>缺点：</p><p>​    无法确定c#对象的析构函数何时执行，所以不能再析构函数中放置需要在某一时刻运行的代码</p><p>​    c#析构函数的实现会延迟对象最终从内存中删除的时间</p><p>5.4.2IDispossable接口</p><pre><code> 在c#中，推荐使用System.IDispossable接口代替析构函数，接口定义了一种模式（具有语言级的支持）该模式为释放非托管资源提供了确定的机制，并避免产生析构函数固有的与垃圾回收器相关的问题。</code></pre><p>​    IDispossable接口声明了一个Dispose()方法，不带参数，返回void。显示的释放有对象直接使用的所有非托管资源</p><blockquote><p>ResourceGobbler theInstance =null;</p><p>try{</p><p>​    theInstance = new ResourceGobbler ()</p><p> }</p><p>finally{</p><p>theInstance ?.Dispose()</p><p>}</p></blockquote><p>​    </p><h3 id="5-4-3using语句"><a href="#5-4-3using语句" class="headerlink" title="5.4.3using语句"></a>5.4.3using语句</h3><p>​    使用try/finally，即使处理过程中出现异常，也可以确保总是在调用Dispose方法释放了资源，但是每个都需要这样重复度的结构；</p><p>​        c#提供另一种语法using，实现IDispossable接口的对象在超出作用域时，自动调用Dipose方法；</p><blockquote><p>using(var    theInstance = new ResourceGobbler ()){</p><p>//do something()</p><p>}</p></blockquote><h3 id="5-4-4-实现IDispossable接口和析构函数"><a href="#5-4-4-实现IDispossable接口和析构函数" class="headerlink" title="5.4.4 实现IDispossable接口和析构函数"></a>5.4.4 实现IDispossable接口和析构函数</h3><p>总结资源释放的两种方式：</p><p>​        利用运行库强制执行的析构函数，但它的执行是不确定的，而且由于垃圾回收的工作方式，会给运行库增加不可接受的系统开销</p><p>​        IDispossable接口提供了一种机制，允许类的用户控制释放资源的时间，但需要确保调用Dispose()方法</p><p>双重实现，创建终结器，实现IDispossabe结构，同时把析构函数作为一种安全机制，以防没有调用Dispose方法</p><h3 id="5-4-5IDispossable和终结器的规则"><a href="#5-4-5IDispossable和终结器的规则" class="headerlink" title="5.4.5IDispossable和终结器的规则"></a>5.4.5IDispossable和终结器的规则</h3><p>​    如果类定义实现了IDispossable的成员，该类也应该实现IDispossable</p><p>​    实现IDispossable并不以为也应该实现一个终结器，终结器会带来额外的开销</p><p>​    如果实现了终结器，也应该实现IDispossable接口，这样可以早些释放资源，不必等GC回收</p><p>​    如果使用的一个对象实现了IDispossable接口，就不在需要对象时调用Dispose方法。如果在方法中使用这个对象，using语句比较方便。如果对象时类的一个成员，就让类也实现IDispossable</p><h2 id="5-5不安全的代码"><a href="#5-5不安全的代码" class="headerlink" title="5.5不安全的代码"></a>5.5不安全的代码</h2><p>​    由于性能问题，要在外部的DLL中访问一个函数，该函数需要把一个指针当做参数来传递（WindowsAPI）,本节将讨论c#直接访问内存的内容的功能</p><h3 id="5-5-1用指针直接访问内存"><a href="#5-5-1用指针直接访问内存" class="headerlink" title="5.5.1用指针直接访问内存"></a>5.5.1用指针直接访问内存</h3><p>​    指针是一个以与引用相同的方式存储地址的变量；其区别是c#不允许直接访问在引用变量中包含的地址。</p><p>​    使用指针，就可以访问实际内存地址，执行新类型的操作</p><p>使用指针的两个原因：</p><p>​        向后兼容性：调用windowsAPI函数，这些函数都是用c++或c#语言编写的，通常要求把指针作为其参数，</p><p>​        性能：在一些情况下，速度是最重要的，而指针可以提供最优性能，</p><p>这种地接别的访问也是有代价的</p><p>​        指针使用起来比较困难，需要非常高的变成技巧和很强的能力</p><pre><code>     很容易重写其他变量，导致栈溢出，访问某些没有存储变量的内存区域，甚至重写.net运行库，使程序崩溃</code></pre><p>​        另外，如果使用指针，就必须授予代码运行库的代码访问安全机制的最高级别</p><p>强烈建议轻易不要使用指针，不仅难以编写，还无法通过CLR施加的内存类型和安全检查</p><h4 id="用unsafe编写不安全的代码"><a href="#用unsafe编写不安全的代码" class="headerlink" title="用unsafe编写不安全的代码"></a>用unsafe编写不安全的代码</h4><p>​    任何方法都可以标记为unsafe，还允许把指针作为参数，也可以把整个类或结构标记为unsafe，假定所有的成员都是不安全的</p><p>​    也可以把方法中的一块代码标记为unsafe；不能把局部变量本身标记为unsafe</p><h4 id="指针的语法"><a href="#指针的语法" class="headerlink" title="指针的语法 *"></a>指针的语法 *</h4><p>指针可以声明为任意一种值类型，也可以声明为一个结构</p><p>int* pWidth,pHeight;</p><p>&amp;表示取地址</p><p>*表示获取地址的内容</p><h4 id="将指针强制转换为整数类型"><a href="#将指针强制转换为整数类型" class="headerlink" title="将指针强制转换为整数类型"></a>将指针强制转换为整数类型</h4><h4 id="指针类型之间的强制转换"><a href="#指针类型之间的强制转换" class="headerlink" title="指针类型之间的强制转换"></a>指针类型之间的强制转换</h4><h4 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a>void指针</h4><h4 id="指针算术的运算"><a href="#指针算术的运算" class="headerlink" title="指针算术的运算"></a>指针算术的运算</h4><h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><h4 id="结构指针，指针成员访问运算符"><a href="#结构指针，指针成员访问运算符" class="headerlink" title="结构指针，指针成员访问运算符"></a>结构指针，指针成员访问运算符</h4><h4 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h4><h3 id="5-5-2指针实例-：PointerPlayground"><a href="#5-5-2指针实例-：PointerPlayground" class="headerlink" title="5.5.2指针实例  ：PointerPlayground"></a>5.5.2指针实例  ：PointerPlayground</h3><h3 id="5-5-3使用指针优化性能"><a href="#5-5-3使用指针优化性能" class="headerlink" title="5.5.3使用指针优化性能"></a>5.5.3使用指针优化性能</h3><p>创建一个基于栈的数组</p><p>QuickArray示例</p><h2 id="5-6平台调用"><a href="#5-6平台调用" class="headerlink" title="5.6平台调用"></a>5.6平台调用</h2>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> 托管 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="2021/02/18/rabbitmq/rabbitmq/"/>
      <url>2021/02/18/rabbitmq/rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-RabbitMQ简介"><a href="#第一章-RabbitMQ简介" class="headerlink" title="第一章 RabbitMQ简介"></a>第一章 RabbitMQ简介</h1><h2 id="1-1-什么是消息中间件"><a href="#1-1-什么是消息中间件" class="headerlink" title="1.1 什么是消息中间件"></a>1.1 什么是消息中间件</h2><p> 　　消息是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串、Json等，也可以很复杂，比如内嵌对象。</p><p> 　　消息队列中间件是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。</p><p>　　一般有两种传递模式：点对点模式和发布/订阅模式。点对点模式是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息，队列的存在使得消息的异步传输称为可能。发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者从主题中订阅想消息。主题使得消息订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布/订阅模式在消息的一对多广播时采用。</p><p>　　比较流行的消息中间件有：RabbitMQ、Kafka、ActiveMQ、RocketMQ等。</p><p>　　消息中间件适用于需要可靠的数据传送的分布式环境。采用消息中间件的系统中，不同的对象之间通过传递消息来激活对方的事件，已完成相应的操作。发送者将消息发送给消息服务器，消息服务器将消息存放在若干队列中，在合适的时候，再将消息转发给接收者。</p><h2 id="1-2-消息中间件的作用"><a href="#1-2-消息中间件的作用" class="headerlink" title="1.2 消息中间件的作用"></a>1.2 消息中间件的作用</h2><p>　　解耦：在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束即可。</p><p>　　冗余（存储）：有些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。</p><p> 　　扩展性：因为消息中间件解耦了应用程序的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。</p><p>　　削峰：在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发方访压力，不会因为突发的超负荷请求而完全奔溃。</p><p>　　可恢复性：当系统一部分组件失效时，不会影响到整个系统，消息中间件降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。</p><p>　　顺序保证：在大多数情景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。</p><p>　　缓冲：在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制和优化数据流经过系统的速度。</p><p>　　异步通信：在很多时候应用不想在不需要立即处理消息。消息中间件提供了异步处理机制，允许应用把一些消息放入消息中间件中，但不立即处理它，在之后需要的时候再慢慢处理。</p><h2 id="1-3-RabbitMQ的起源"><a href="#1-3-RabbitMQ的起源" class="headerlink" title="1.3 RabbitMQ的起源"></a>1.3 RabbitMQ的起源</h2><p>　　RabbitMQ是采用Erlang语言实现的AMQP（Advanced Message Queuing Protocol，高级消息队列协议）的消息 中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p><h2 id="1-4-RabbitMQ的安装及简单实用"><a href="#1-4-RabbitMQ的安装及简单实用" class="headerlink" title="1.4 RabbitMQ的安装及简单实用"></a>1.4 RabbitMQ的安装及简单实用</h2><p>　　本示例演示在ubuntu18.04.3中安装和使用rabbitMQ</p><blockquote><p>sudo apt-get update -y<br>sudo apt-get install erlang-nox rabbitmq-server -y<br>sudo rabbitmq-server start<br>sudo rabbitmq-server stop<br>sudo rabbitmq-server restart<br>sudo rabbitmqctl status</p><p>添加用户并且赋予权限</p><p>sudo rabbitmqctl add_user admin admin<br>sudo rabbitmqctl set_user_tags admin administrator<br>sudo rabbitmqctl  set_permissions -p / admin ‘.<em>‘ ‘.</em>‘ ‘.*’<br>sudo rabbitmq-plugins enable rabbitmq_management</p><p>sudo rabbitmqctl change_password admin ‘admin’</p></blockquote><h1 id="第二章-RabbitMQ-入门"><a href="#第二章-RabbitMQ-入门" class="headerlink" title="第二章 RabbitMQ 入门"></a>第二章 RabbitMQ 入门</h1><h2 id="2-1-相关概念介绍"><a href="#2-1-相关概念介绍" class="headerlink" title="2.1 相关概念介绍"></a>2.1 相关概念介绍</h2><p>　　RabbitMQ整体上市一个是生产者与消费者模型。主要负责接收、存储和转发消息。</p><p>　　RabbitMQ的整体模型架构如下图所示：</p><p>　　<img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200116100133957-524774026.png" alt="img"></p><h2 id="2-1-1-生产者和消费者"><a href="#2-1-1-生产者和消费者" class="headerlink" title="2.1.1 生产者和消费者"></a>2.1.1 生产者和消费者</h2><p>　　Producer：生产者，就是投递消息的一方。消息一般可以包含2个部分：消息体和标签（Label）。消息体也可以称之为payload，在实际应用中，消息体一般是一个带有业务逻辑结构的数据，比如一个JSON字符串。</p><p>　　Consumer：消费者，就算是接收消息的一方。</p><p>　　Broker：消息中间件的服务节点。</p><p>　　对于RabbitMQ来说，一个RabbitMQ Broker可以简单地看作一个RabbitMQ服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个RabbitMQ Broker看作一台RabbitMQ服务器。</p><p>　　下图展示了生产者将消息存入RabbitMQ Broker，以及消费者从Broker中消费数据的整个流程。</p><p>　　<img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200116101001502-1945693905.png" alt="img"></p><p> 2.1.2 队列</p><p>Queue：队列，是RabbitMQ的内部对象，用于存储消息。</p><p><img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200117113432130-466580577.png" alt="img"></p><p> RabbitMQ中消息都只能存储在队列中。U盾讴歌消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p><p><img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200117114049922-590796568.png" alt="img"></p><p> RabbitMQ不支持队列层面的广播消息，如果需要广播消息，需要在其上进行二次开发，处理逻辑会变得异常复杂，同时也不建议这么做。</p><p>2.1.3 交换器、路由件、绑定</p><p>Exchange：交换器。生产者将消息发送到Exchange（交换器，通常也可以用大写的“X”来表示）。由交换器将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃。</p><p><img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200117114708911-1388748529.png" alt="img"></p><p> RoutingKey：路右键。生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个Routing Key需要与交换器类型和绑定建（BindingKey）联合使用才能最终生效。</p><p>在交换器类型和绑定建（BindingKey）固定的情况下，生产者可以发送消息给交换器时，通过指定RoutingKey来决定消息流向哪里。</p><p>备注：本文转载于<a href="https://www.cnblogs.com/yuzhou133/p/12197311.html">https://www.cnblogs.com/yuzhou133/p/12197311.html</a></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第四章 继承</title>
      <link href="2021/02/17/c/c-10th-04/"/>
      <url>2021/02/17/c/c-10th-04/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第四章-继承"><a href="#c-语言-第四章-继承" class="headerlink" title="c#语言 第四章 继承"></a>c#语言 第四章 继承</h1><h2 id="4-1继承"><a href="#4-1继承" class="headerlink" title="4.1继承"></a>4.1继承</h2><p>面向对象的三个重要概念：继承、封装、多态</p><h2 id="4-2继承的类型"><a href="#4-2继承的类型" class="headerlink" title="4.2继承的类型"></a>4.2继承的类型</h2><p>面向对象（Object-Oriented,OO）术语，c#的继承</p><p>单重继承：c#</p><p>多重继承：一个类可以派生自多个类，c#不支持</p><p>多层继承：B派生自A，C派生自B，c#支持</p><p>接口继承：c#允许接口多继承</p><h3 id="4-2-1-多重继承-c"><a href="#4-2-1-多重继承-c" class="headerlink" title="4.2.1 多重继承 c++"></a>4.2.1 多重继承 c++</h3><p>多重继承会给生成的代码增加复杂性，还会带来一些开销。c#决定不支持多重继承。</p><p>c#允许派生自多个接口，一个类型可以实现多个接口。System.Object 是一个公共的基类，每个c#类（除了Object类之外）都有一个基类，还可以有人以多个基接口</p><h3 id="4-2-2-结构和类"><a href="#4-2-2-结构和类" class="headerlink" title="4.2.2 结构和类"></a>4.2.2 结构和类</h3><p>使用结构的一个限制是结构不支持继承，但每个结构都派生自system.ValueType . 但接口可以实现接口</p><h2 id="4-3实现继承-class-A：B"><a href="#4-3实现继承-class-A：B" class="headerlink" title="4.3实现继承 class A：B{}"></a>4.3实现继承 class A：B{}</h2><p>如果类和接口都用于派生，则类总是必须放在接口的前面</p><p>结构只能实现接口继承</p><p>类定义中更没有指定基类，c#编译器就假定 System.Object是基类</p><h3 id="4-3-1虚方法"><a href="#4-3-1虚方法" class="headerlink" title="4.3.1虚方法"></a>4.3.1虚方法</h3><p>  virtual </p><p>​    把一个基类方法声明为virtual，就可以在任何派生类中重写该方法</p><p>​    也可以把属性声明为virtual</p><p>​    成员字段和静态函数不能声明为virtual，因为这个概念只对类中实例函数成员有意义</p><p>override 显示声明重写</p><h3 id="4-3-2-多态性"><a href="#4-3-2-多态性" class="headerlink" title="4.3.2 多态性"></a>4.3.2 多态性</h3><p>多态性，动态地定义调用的方法，而不是在编译期间定义</p><h3 id="4-3-3隐藏方法"><a href="#4-3-3隐藏方法" class="headerlink" title="4.3.3隐藏方法"></a>4.3.3隐藏方法</h3><p>如果签名相同的方法在基类和派生类中都进行了声明，但该方法没有分别声明为virtual和override，派生类方法就会隐藏基类方法</p><p>用new关键词隐藏方法，避免出现编译器警告</p><h3 id="4-3-4调用基类版本方法base-fn"><a href="#4-3-4调用基类版本方法base-fn" class="headerlink" title="4.3.4调用基类版本方法base.fn()"></a>4.3.4调用基类版本方法base.fn()</h3><h3 id="4-3-5抽象类和抽象方法"><a href="#4-3-5抽象类和抽象方法" class="headerlink" title="4.3.5抽象类和抽象方法"></a>4.3.5抽象类和抽象方法</h3><p>abstract 抽象类不能实例化，抽象法法不能直接实现，必须在非抽象类的派生类中重写； 如果类包含抽象方法，则该类也是抽象的，也必须声明为抽象的</p><h3 id="4-3-6密封类和密封方法sealed"><a href="#4-3-6密封类和密封方法sealed" class="headerlink" title="4.3.6密封类和密封方法sealed"></a>4.3.6密封类和密封方法sealed</h3><p>对于密封类，编译器知道不能派生类</p><p>string是密封的</p><h3 id="4-3-7派生类的构造函数"><a href="#4-3-7派生类的构造函数" class="headerlink" title="4.3.7派生类的构造函数"></a>4.3.7派生类的构造函数</h3><p>​        创建派生类实例时，会有多个构造函数起作用个，要实例化类的构造函数本身不能初始化类，还必须调用其基类中的构造函数，通过层级结构进行构造</p><p>​        如果派生类没必要定义新的构造函数，仍可以提供一个构造函数，条用基构造函数base()</p><h2 id="4-4修饰符"><a href="#4-4修饰符" class="headerlink" title="4.4修饰符"></a>4.4修饰符</h2><p>4.4.1访问修饰符</p><p>逻辑访问修饰符  public protected private</p><p>物理访问修饰符 internal</p><p>不能把类型定义为protected、private或 protected internal，因为这些修饰符对包含在命名空间中的类型没有意义，这些只能用于成员。但可以修饰嵌套的类型，类型也具有成员的状态</p><p>如果有嵌套的类型，内部的类型总是可以访问外部类型的所有成员</p><p>4.4.2其他修饰符</p><p>new static virtual abstract override sealed  extern</p><h2 id="4-5接口"><a href="#4-5接口" class="headerlink" title="4.5接口"></a>4.5接口</h2><p>Microsoft 预定义的一个几口System.IDisposable的完整定义，包含一个方法Dispose（），该方法由类实现，用于清理代码</p><p>声明接口在于发生和声明抽象类完全相同，但不允许提供接口中任何成员的实现方式，一般情况下，接口只能包含方法、属性、索引器、和事件的声明</p><p>抽象类： 可以有实现代码或没有实现代码的抽象成员，</p><p>接口：不能有任何实现代码，纯粹抽象的；所以接口不需要abstract关键字</p><p>接口不能有构造函数，也不能有字段，不能声明为virtual</p><p>4.5.1定义和实现接口</p><p>从接口中派生独立于从类中派生</p><p>4.5.2派生的接口</p><h2 id="4-6-is-和as-运算符"><a href="#4-6-is-和as-运算符" class="headerlink" title="4.6 is 和as 运算符"></a>4.6 is 和as 运算符</h2><p>as返回对象的引用，如果对象不是所要求的的类型，则返回null</p><p>is运算符，判读是否满足，true则继续进行强制转换</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第三章 对象和类型</title>
      <link href="2021/02/17/c/c-10th-03/"/>
      <url>2021/02/17/c/c-10th-03/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第三章-对象和类型"><a href="#c-语言-第三章-对象和类型" class="headerlink" title="c#语言 第三章 对象和类型"></a>c#语言 第三章 对象和类型</h1><h2 id="3-2-类和结构的区别"><a href="#3-2-类和结构的区别" class="headerlink" title="3.2 类和结构的区别"></a>3.2 类和结构的区别</h2><p>​    类和结构实际上都是常见对象的模板</p><p>​    类是引用类型</p><p>​    结构是值类型</p><p>​    较小的数据类型使用结构可以提高性能</p><p>​    类和结构都用new来声明实例</p><h2 id="3-3-类"><a href="#3-3-类" class="headerlink" title="3.3 类"></a>3.3 类</h2><p>类包含成员。成员可以是静态成员或实例成员，static静态成员属于类；实例成员属于对象</p><p>成员：字段、常量、方法、属性、构造函数、索引器、运算符、事件、析构函数、类型</p><h3 id="3-3-1字段"><a href="#3-3-1字段" class="headerlink" title="3.3.1字段"></a>3.3.1字段</h3><p>​       const 常量 公开 public</p><p>​      最好把字段声明为private</p><h3 id="2-3-2属性"><a href="#2-3-2属性" class="headerlink" title="2.3.2属性"></a>2.3.2属性</h3><p> 一个方法或一对方法，看起来是一个字段</p><h4 id="自动实现的属性："><a href="#自动实现的属性：" class="headerlink" title="自动实现的属性："></a>自动实现的属性：</h4><p>​    set；get；访问器没有任何逻辑，属性会自动实现后备成员变量</p><p>​    属性初始化器来初始化 public int Age {get;set;}=42;</p><h4 id="属性的访问修饰符"><a href="#属性的访问修饰符" class="headerlink" title="属性的访问修饰符"></a>属性的访问修饰符</h4><p>​    public get private set</p><h3 id="3-3-3方法"><a href="#3-3-3方法" class="headerlink" title="3.3.3方法"></a>3.3.3方法</h3><p>非数据成员</p><p>​      正式的c#术语区分函数和方法，在c#术语中，函数成员不仅包含方法，也包含类或结构的一些非数据成员，如索引器、运算符、构造函数、析构函数等，还有属性，这些事非数据成员</p><p>数据成员</p><p>​    字段、常量、事件才是数据成员</p><h4 id="方法的声明"><a href="#方法的声明" class="headerlink" title="方法的声明"></a>方法的声明</h4><p>​    表达式体方法：  =&gt; 区分操作符左边的声明和右边的实现代码</p><p>​    调用方法</p><h4 id="方法的重载："><a href="#方法的重载：" class="headerlink" title="方法的重载："></a>方法的重载：</h4><p>​    方法名相同，但是参数的数量和/或数据类型不同</p><h4 id="命名的参数："><a href="#命名的参数：" class="headerlink" title="命名的参数："></a>命名的参数：</h4><p>​    任何方法都可以使用命名的参数调用，编译器会去掉变量名</p><p>这种方式更改变量的顺序，编译器会重新安排，获得正确的顺序</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>​    一个或多个，可选参数置后</p><h4 id="个数可变的参数-params关键字"><a href="#个数可变的参数-params关键字" class="headerlink" title="个数可变的参数 params关键字"></a>个数可变的参数 params关键字</h4><p>​    如果params关键字与方法签名定义的多个参数一起使用，params只能使用一次，且必须是最后一个参数</p><h3 id="3-3-4构造函数"><a href="#3-3-4构造函数" class="headerlink" title="3.3.4构造函数"></a>3.3.4构造函数</h3><p>​    如果没有构造函数，编译器会默认生成一个默认的构造函数（引用类型为空引用，数值类型为0，bool为false）</p><p>构造函数的重载遵循与其他方法相同的规则 ；</p><p>​    构造函数的重载遵循与其他方法相同的</p><p>​    如果提供了带参数的构造函数，编译器就不会自动提供默认的构造函数</p><p>​    可以把构造函数定义为private或者protected，这样不相关的类就不能访问他们</p><p><strong>没有公有或受保护的构造函数的用法</strong></p><p>​    类仅仅是静态成员或属性的容器，永远不会实例化，static修饰类，只能包含静态成员，不能实例化</p><p>​    希望仅通过条用个某个静态成员函数来实例化（对象实例化的类工厂方法）（单例模式的实现）</p><h4 id="从构造函数中调用其他构造函数"><a href="#从构造函数中调用其他构造函数" class="headerlink" title="从构造函数中调用其他构造函数"></a>从构造函数中调用其他构造函数</h4><p>​    this关键字仅条用参数最匹配的那个构造函数</p><p>​    c#构造函数初始化器可以包含对同一个类的另一个构造函数的调用，也可以对直接基类的构造函数的调用应使用base代替this关键字，初始化器不能有多个调用</p><h4 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h4><p>​    无参数的静态构造函数</p><p>​        不能带任何参数，一个类只有一个静态构造函数</p><h4 id="只读成员-readonly"><a href="#只读成员-readonly" class="headerlink" title="只读成员 readonly"></a>只读成员 readonly</h4><h4 id="只读字段-readonly"><a href="#只读字段-readonly" class="headerlink" title="只读字段 readonly"></a>只读字段 readonly</h4><h4 id="只读readonly与const的区别"><a href="#只读readonly与const的区别" class="headerlink" title="只读readonly与const的区别"></a>只读readonly与const的区别</h4><p>​        const 编译器通过值取代了使用它的变量，编译器知道它的值</p><p>​        readonly在运行期间通过构造函数制定，与常量字段相反，只读字段可以是实例成员，使用只读字段作为类成员时，需要把static修饰符分配给该字段</p><p>只读字段，不能在构造函数外部赋值</p><p>只读属性{get}</p><p>​    自动实现的只读属性</p><p>​    只读属性也可以在构造函数中初始化</p><p>表达式体属性</p><blockquote><p>public string FullName =&gt; $”{FirstName} {LastName}”;</p></blockquote><p>不可变的类型</p><p>​        例如String，，任何改变总会返回一个新的字符串</p><h2 id="3-4匿名类型"><a href="#3-4匿名类型" class="headerlink" title="3.4匿名类型"></a>3.4匿名类型</h2><h2 id="3-5结构-struct"><a href="#3-5结构-struct" class="headerlink" title="3.5结构 struct"></a>3.5结构 struct</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>​    数据小 提升性能</p><p>​    值类型</p><p>​    不支持继承</p><p>​    分配内存非常快，销毁也快</p><p>​    互相赋予时，会复制一份，有性能损失</p><p>​    当把结构作为参数传递时，应把它作为ref参数传递---避免性能损失，只传递地址；被调用的方法可以改变结构的值</p><h3 id="结构和继承"><a href="#结构和继承" class="headerlink" title="结构和继承"></a>结构和继承</h3><p>​    不能从一个结构中继承</p><p>​    例外： 结构最终派生于类System.Object ,因此可以访问System.Object 的方法</p><p>​    结构 &lt;= System.ValueType&lt;= System.Object</p><h3 id="结构的构造函数"><a href="#结构的构造函数" class="headerlink" title="结构的构造函数"></a>结构的构造函数</h3><h2 id="3-6按值和按引用传递参数"><a href="#3-6按值和按引用传递参数" class="headerlink" title="3.6按值和按引用传递参数"></a>3.6按值和按引用传递参数</h2><h3 id="ref参数-gt-可以通过引用传递结构"><a href="#ref参数-gt-可以通过引用传递结构" class="headerlink" title="ref参数 -&gt;可以通过引用传递结构"></a>ref参数 -&gt;可以通过引用传递结构</h3><p>out参数 -&gt;</p><p>​    如果一个方法返回多个值，可能类型还不同</p><h2 id="3-7可空类型-int-x2-null"><a href="#3-7可空类型-int-x2-null" class="headerlink" title="3.7可空类型  int? x2=null;"></a>3.7可空类型  int? x2=null;</h2><h2 id="3-8枚举-enum"><a href="#3-8枚举-enum" class="headerlink" title="3.8枚举 enum"></a>3.8枚举 enum</h2><p>​    默认enum的类型是int</p><p>​    使用强制类型转换可以把数字改为枚举值，把枚举改为数字</p><p>​    Flags</p><h2 id="3-9-部分类-partial"><a href="#3-9-部分类-partial" class="headerlink" title="3.9 部分类 partial"></a>3.9 部分类 partial</h2><p>​    可以把类分开放在两个文件中</p><p>声明类和结构，返回信息都是类成员</p><p>元组类型</p><h2 id="3-10-扩展方法"><a href="#3-10-扩展方法" class="headerlink" title="3.10 扩展方法"></a>3.10 扩展方法</h2><p>扩展</p><p>​    继承给对象添加功能的好方法</p><p>​    扩展方法是给对象添加功能的另一个选项，在不能使用继承时，可以使用这个选项（例如类是密封的）</p><p>扩展方法是静态方法，是类的一部分，但实际上没有放在类的源代码中</p><p>使用this关键字和第一个参数来扩展字符串，这个关键字定义了要扩展的类型</p><blockquote><p>public static class StringExtension{ public static int<br>GetWordCount(this string s)=&gt; s.Split().Length; ​} ​</p></blockquote><p>好处：</p><p>​    可以使用实例方法的语法，而不是从代码中直接调用静态方法</p><p>​    该方法的实现可以用另一个类取代，而不需要更改代码</p><p>编译器如何找到某个类型的扩展方法？</p><p>​    this关键字必须匹配类型的扩展方法</p><p>​    而且需要打开定义扩展方法的静态类所在名称空间</p><p>​    如果类型还定义了同名的实例方法，扩展方法就永远不会使用</p><p>​    类中已有的实例方法都优先</p><p>Object类，其他类型都从该类派生而来</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> 对象和类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第二章 核心C#</title>
      <link href="2021/02/17/c/c-10th-02/"/>
      <url>2021/02/17/c/c-10th-02/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-2-核心c"><a href="#c-语言-2-核心c" class="headerlink" title="c#语言 2 核心c#"></a>c#语言 2 核心c#</h1><h2 id="2-3变量"><a href="#2-3变量" class="headerlink" title="2.3变量"></a>2.3变量</h2><p>c# 区分大小写</p><h3 id="2-3-1初始化变量"><a href="#2-3-1初始化变量" class="headerlink" title="2.3.1初始化变量"></a>2.3.1初始化变量</h3><p>​    c#编译器需要用某个初始值对变量进行初始化，之后才能在操作中引用变量；c#中有两个方法可确保变量使用前进行了初始化</p><p>​        变量是类或结构中的字段，如果没有显示初始化，则创建这些变量时，其默认值就是0</p><p>​        方法的局部变量必须在代码中显示初始化，变量初始化之前就使用了其值，编译器就会标记错误</p><h3 id="2-3-2类型推断"><a href="#2-3-2类型推断" class="headerlink" title="2.3.2类型推断"></a>2.3.2类型推断</h3><p>​    变量必须初始化，编译器推断类型的依据</p><p>​    初始化器不能为空</p><p>​    初始化器必须放在表达式中</p><p>​    不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象</p><h3 id="2-3-3变量的作用域"><a href="#2-3-3变量的作用域" class="headerlink" title="2.3.3变量的作用域"></a>2.3.3变量的作用域</h3><p>定义或规则</p><p>​    只要类在某个作用域内，其字段也在该作用域内</p><p>​    局部变量存在于表示声明该变量的块语句或方法结束的右花括号之前的作用域内</p><p>​    在 for whild 或类似语句中声明的局部变量存在于该循环体内</p><h4 id="局部变量的作用域冲突"><a href="#局部变量的作用域冲突" class="headerlink" title="局部变量的作用域冲突"></a>局部变量的作用域冲突</h4><h4 id="字段和局部变量的作用域冲突"><a href="#字段和局部变量的作用域冲突" class="headerlink" title="字段和局部变量的作用域冲突"></a>字段和局部变量的作用域冲突</h4><blockquote><p>class program{ static int j=20; static void Main(){ int<br>j=30;WriteLine(j); WriteLine(program.j) } ​}</p></blockquote><h3 id="2-3-4常量"><a href="#2-3-4常量" class="headerlink" title="2.3.4常量"></a>2.3.4常量</h3><p>特点</p><p>​    常量声明时必须初始化，指定其值后，就不能再改写了、</p><p>​    常量的值必须在编译时用于计算，因此不能用从变量中提取的值来初始化常亮</p><p>​    常量总是隐式静态的</p><p>好处</p><p>​    易于读取的名称</p><p>​    是程序更易于修改</p><p>​    更容易避免程序出现错误</p><h2 id="2-4预定义数据类型"><a href="#2-4预定义数据类型" class="headerlink" title="2.4预定义数据类型"></a>2.4预定义数据类型</h2><h3 id="2-4-1-值类型和引用类型"><a href="#2-4-1-值类型和引用类型" class="headerlink" title="2.4.1 值类型和引用类型"></a>2.4.1 值类型和引用类型</h3><p>堆栈</p><p>​    值类型存储在堆栈中stack</p><p>​    引用各类型存储在托管堆中 managed heap</p><p>bool 和long等都是值类型，值类型的赋予是通过值复制的</p><p>大多数更复杂的c#数据类型，包括自己声明的类，都是引用类型</p><p>​    CLR实现一种精细的算法，来跟踪哪些引用变量是可以访问的，哪些不能访问，CLR会定期删除不能访问的对象，把占用的内存返回给操作系统，垃圾回收器</p><p>​    如果要把自己的类型定义为值类型，就应把它声明为一个结构</p><h3 id="2-4-2-net-类型"><a href="#2-4-2-net-类型" class="headerlink" title="2.4.2 .net 类型"></a>2.4.2 .net 类型</h3><p>​    15个预定义类型，13个值类型，两个引用类型string 和 object</p><h3 id="2-4-3预定义的值类型"><a href="#2-4-3预定义的值类型" class="headerlink" title="2.4.3预定义的值类型"></a>2.4.3预定义的值类型</h3><p>整型 sbyte 8 short 16 int32 long64</p><p>浮点类型 float32位单精度浮点，double 64位双精度浮点 15/16</p><p>decimal类型 128位高精度十进制数表示法<br>（decimal类型不是基本类型，计算时有性能损失）(高精度计算)</p><blockquote><p>decimal d =12.30M;</p></blockquote><p>bool类型</p><p>字符类型 char 表示一个16位的Unicode字符</p><p>​    转义字符\</p><h3 id="2-4-4预定义的引用类型"><a href="#2-4-4预定义的引用类型" class="headerlink" title="2.4.4预定义的引用类型"></a>2.4.4预定义的引用类型</h3><h4 id="object-类型"><a href="#object-类型" class="headerlink" title="object 类型"></a>object 类型</h4><p>​     可以使用object引用来绑定任何特定子类型的对象;如值类型装箱，再移动到堆中，object引用也可以用于反射，此时必须有代码来处理类型未知的对象</p><p>​    object类型实现了许多一般用途的基本方法，包括Equals(),GetHashCode(),GetType()和ToString()用户定义的类型需要使用一种面向对象技术---重写</p><h4 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h4><p>​    字符串不可修改，修改会产生新的string对象</p><p>​    @的使用，看做所有字符保持原来的含义</p><p>​    字符串插值功能 $</p><h2 id="2-5程序流控制"><a href="#2-5程序流控制" class="headerlink" title="2.5程序流控制"></a>2.5程序流控制</h2><p>if</p><p>for</p><p>while</p><p>do while</p><p>foreach 不能改变集合中各项的值</p><p>跳转语句</p><p>goto语句<br>不能跳转像for循环这样的代码块中，也不能跳出类的范围，不能退出try<br>catch后面的finally</p><p>break语句</p><p>switch 中退出某个语句</p><p>也可用于for foreach whild do...while</p><p>continue语句 只能退出循环的当前迭代</p><p>return 语句 退出类的方法</p><h2 id="2-6-枚举"><a href="#2-6-枚举" class="headerlink" title="2.6 枚举"></a>2.6 枚举</h2><h3 id="枚举是用户定义的整数类型"><a href="#枚举是用户定义的整数类型" class="headerlink" title="枚举是用户定义的整数类型"></a>枚举是用户定义的整数类型</h3><p>优势</p><p>​    代码易于维护，有助于确保给变量制定合法的期望的值</p><p>​    枚举使代码更清晰，允许描述性的蒙城表示整数值，而不是含义模糊的数</p><p>​    更易于输入</p><p>​    枚举真正强大之处，在于实例化为派生自积累system.enum的结构，不会造成性能损失</p><h2 id="2-7名称空间"><a href="#2-7名称空间" class="headerlink" title="2.7名称空间"></a>2.7名称空间</h2><p>using语句</p><h3 id="2-7-2名称空间的别名"><a href="#2-7-2名称空间的别名" class="headerlink" title="2.7.2名称空间的别名"></a>2.7.2名称空间的别名</h3><h2 id="2-8main方法"><a href="#2-8main方法" class="headerlink" title="2.8main方法"></a>2.8main方法</h2><h2 id="2-9使用注释"><a href="#2-9使用注释" class="headerlink" title="2.9使用注释"></a>2.9使用注释</h2><h2 id="2-10-c-预处理指令"><a href="#2-10-c-预处理指令" class="headerlink" title="2.10 c#预处理指令"></a>2.10 c#预处理指令</h2><p>#define 和#undef</p><p>#if #elif #else #endif</p><p>#warning 和#ERROR</p><p>#region 和 #endregion</p><p>#LINE</p><p>#pragma</p><h2 id="2-11c-编程准则"><a href="#2-11c-编程准则" class="headerlink" title="2.11c#编程准则"></a>2.11c#编程准则</h2><h3 id="标识符的规则"><a href="#标识符的规则" class="headerlink" title="标识符的规则"></a>标识符的规则</h3><p>​    尽管可以包含数字字符，但他们必须以字母或下划线开头</p><p>​    不能把c#关键字用作标识符</p><p>用法约定</p><p>命名约定</p><p>​    名称的大小写 Pascal camel</p><p>​    名称的风格统一</p><p>​    名称和关键字</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello MyBlog</title>
      <link href="2021/02/17/hello-myblog/"/>
      <url>2021/02/17/hello-myblog/</url>
      
        <content type="html"><![CDATA[<h2 id="使用github-page-和hexo搭建第一个网站"><a href="#使用github-page-和hexo搭建第一个网站" class="headerlink" title="使用github page 和hexo搭建第一个网站"></a>使用github page 和hexo搭建第一个网站</h2><p><a href="https://www.zhihu.com/question/22197688">https://www.zhihu.com/question/22197688</a></p><h2 id="博客美化-博客主题之hexo-theme-matery的介绍"><a href="#博客美化-博客主题之hexo-theme-matery的介绍" class="headerlink" title="博客美化 博客主题之hexo-theme-matery的介绍"></a>博客美化 博客主题之hexo-theme-matery的介绍</h2><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#alipay">https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#alipay</a></p><h3 id="hexo扩展学习"><a href="#hexo扩展学习" class="headerlink" title="hexo扩展学习"></a>hexo扩展学习</h3><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p><a href="https://hexo.io/themes/index.html">https://hexo.io/themes/index.html</a></p><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><h3 id="window下pandoc的如何使用-文档类型转换"><a href="#window下pandoc的如何使用-文档类型转换" class="headerlink" title="window下pandoc的如何使用 文档类型转换"></a>window下pandoc的如何使用 文档类型转换</h3><p><a href="https://www.jianshu.com/p/f4a9ceb68088">https://www.jianshu.com/p/f4a9ceb68088</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
            <tag> github gage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第一章 .net 应用程序体系结构</title>
      <link href="2021/02/17/c/c-10th-01/"/>
      <url>2021/02/17/c/c-10th-01/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第一章-net-应用程序体系结构"><a href="#c-语言-第一章-net-应用程序体系结构" class="headerlink" title="c#语言 第一章 .net 应用程序体系结构"></a>c#语言 第一章 .net 应用程序体系结构</h1><h2 id="1-2-回顾net-历史"><a href="#1-2-回顾net-历史" class="headerlink" title="1.2.回顾net 历史"></a>1.2.回顾net 历史</h2><h3 id="net-版本"><a href="#net-版本" class="headerlink" title=".net 版本"></a>.net 版本</h3><p>​    CLR(Common Language Runtime) 公共语言运行库</p><p>​    c#</p><p>​    Visual Studio</p><h3 id="1-2-1c-1-0-新语言"><a href="#1-2-1c-1-0-新语言" class="headerlink" title="1.2.1c#1.0 新语言"></a>1.2.1c#1.0 新语言</h3><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><p>​        面向对象编程语言，具备继承，封装和多态性等特性</p><p>​        也提供了基于组件的变成改造，如委托和事件</p><h4 id="CLR"><a href="#CLR" class="headerlink" title="CLR"></a>CLR</h4><p>​     .net 编程语言都使用的运行库，类似java虚拟机</p><p>​     中间语言Intermediate Language IL代码，编译器生成IL代码，当程序运行时，JIT编译器会从IL代码生成本地代码</p><p>​     GC垃圾回收</p><p>​     调试器扩展</p><p>​     线程实用工具</p><p>​    CLR还负责线程的处理，C#中创建托管的线程不一定来自底层操作系统，线程的虚拟化和管理有CLR负责</p><h3 id="1-2-2带有泛型的c-2-和-net-2"><a href="#1-2-2带有泛型的c-2-和-net-2" class="headerlink" title="1.2.2带有泛型的c#2 和.net 2"></a>1.2.2带有泛型的c#2 和.net 2</h3><h3 id="1-2-3-net-3-0-WPF"><a href="#1-2-3-net-3-0-WPF" class="headerlink" title="1.2.3 .net 3.0 WPF"></a>1.2.3 .net 3.0 WPF</h3><p>​    WPF 矢量图形控件</p><p>​     WCF 通用通信</p><h3 id="1-2-4-c-LINQ-EF"><a href="#1-2-4-c-LINQ-EF" class="headerlink" title="1.2.4 c##  LINQ   EF"></a>1.2.4 c##  LINQ   EF</h3><h3 id="1-2-5-c-4-dynamic-TPL-任务并行库"><a href="#1-2-5-c-4-dynamic-TPL-任务并行库" class="headerlink" title="1.2.5  c# 4 dynamic TPL(任务并行库)"></a>1.2.5  c# 4 dynamic TPL(任务并行库)</h3><p>​    使用Task 和 Parallel 类抽象出线程</p><h3 id="1-2-6c-5-异步编程-async-和await"><a href="#1-2-6c-5-异步编程-async-和await" class="headerlink" title="1.2.6c#5 异步编程  async 和await"></a>1.2.6c#5 异步编程  async 和await</h3><h3 id="1-2-7-c-6-新的编译器引擎-Roslyn"><a href="#1-2-7-c-6-新的编译器引擎-Roslyn" class="headerlink" title="1.2.7 c#6 新的编译器引擎 Roslyn"></a>1.2.7 c#6 新的编译器引擎 Roslyn</h3><h4 id="1-3-2-net-core-1-0-CORE-CLI"><a href="#1-3-2-net-core-1-0-CORE-CLI" class="headerlink" title="1.3.2 .net core 1.0   CORE CLI"></a>1.3.2 .net core 1.0   CORE CLI</h4><p>特性：</p><p>​    开源</p><p>​    模块化的方式设计</p><p>​    可以很快更新</p><p>程序集 assembly：编译好的，面向.net framework的代码逻辑单元</p><p>​        私有程序集</p><p>​        共享程序集（Global Assembly Cache）</p><h3 id="1-3-5-公共语言运行库"><a href="#1-3-5-公共语言运行库" class="headerlink" title="1.3.5 公共语言运行库"></a>1.3.5 公共语言运行库</h3><p>​       编译器将源代码编译为Microsoft中间语言(Intermediate Language, IL)生成IL代码，当程序运行时，JIT编译器会从IL代码生成本地代码</p><p>​       CLR还负责线程的处理，C#中创建托管的线程不一定来自底层操作系统，线程的虚拟化和管理有CLR负责</p><h3 id="1-3-7windows运行库-windows-runtime"><a href="#1-3-7windows运行库-windows-runtime" class="headerlink" title="1.3.7windows运行库 windows runtime"></a>1.3.7windows运行库 windows runtime</h3><h2 id="net-2015"><a href="#net-2015" class="headerlink" title=".net 2015"></a>.net 2015</h2><h3 id="1-5-net-4-6编译"><a href="#1-5-net-4-6编译" class="headerlink" title="1.5.net 4.6编译"></a>1.5.net 4.6编译</h3><p>​    c# 命令行编译器（csc.exe）: csc HelloWorld.cs -&gt; 中间语言代码</p><p>​    DASM中间语言反汇编程序 （ildasm.exe）</p><p>.net core cli编译</p><p>​    repl学习 ： dotnet repl</p><h2 id="1-7应用程序类型与技术"><a href="#1-7应用程序类型与技术" class="headerlink" title="1.7应用程序类型与技术"></a>1.7应用程序类型与技术</h2><h3 id="1-7-1数据访问"><a href="#1-7-1数据访问" class="headerlink" title="1.7.1数据访问"></a>1.7.1数据访问</h3><pre><code>Database FirstModel First</code></pre><p>CodeFirst:<br>   代码优先有一定意味着数据库不能事先存在；数据库可以动态创建，属性和流利的API可以以编程方式定义映射</p><h3 id="1-7-2桌面应用程序"><a href="#1-7-2桌面应用程序" class="headerlink" title="1.7.2桌面应用程序"></a>1.7.2桌面应用程序</h3><p>WF WPF</p><h3 id="1-7-3-UWP"><a href="#1-7-3-UWP" class="headerlink" title="1.7.3 UWP"></a>1.7.3 UWP</h3><h3 id="1-7-4soap服务和WCF"><a href="#1-7-4soap服务和WCF" class="headerlink" title="1.7.4soap服务和WCF"></a>1.7.4soap服务和WCF</h3><h3 id="1-7-5WEB服务-WEB-API-基于REST"><a href="#1-7-5WEB服务-WEB-API-基于REST" class="headerlink" title="1.7.5WEB服务 WEB API 基于REST"></a>1.7.5WEB服务 WEB API 基于REST</h3><h3 id="1-7-6WebHooks-和SignalR-基于-webSocket"><a href="#1-7-6WebHooks-和SignalR-基于-webSocket" class="headerlink" title="1.7.6WebHooks 和SignalR 基于 webSocket"></a>1.7.6WebHooks 和SignalR 基于 webSocket</h3><h3 id="1-7-7windows服务"><a href="#1-7-7windows服务" class="headerlink" title="1.7.7windows服务"></a>1.7.7windows服务</h3><pre><code>world wide web服务 可以监听客户端的web请求</code></pre><h3 id="Microsoft-Azure服务"><a href="#Microsoft-Azure服务" class="headerlink" title="Microsoft Azure服务"></a>Microsoft Azure服务</h3><p>​    SaaS IaaS PaaS</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> .net 应用程序体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客资源站收集</title>
      <link href="2021/02/17/good-blogs/"/>
      <url>2021/02/17/good-blogs/</url>
      
        <content type="html"><![CDATA[<h1 id="一个不错的博客-算法-leet-code"><a href="#一个不错的博客-算法-leet-code" class="headerlink" title="一个不错的博客  算法 leet code"></a>一个不错的博客  算法 leet code</h1><p><a href="https://www.cxyxiaowu.com/">https://www.cxyxiaowu.com/</a></p><h1 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h1><p><a href="http://www.ptbird.cn/list.html">http://www.ptbird.cn/list.html</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 前言</title>
      <link href="2021/02/17/c/c-10th/"/>
      <url>2021/02/17/c/c-10th/</url>
      
        <content type="html"><![CDATA[<h1 id="c-是专门用于-net-的语言"><a href="#c-是专门用于-net-的语言" class="headerlink" title="c# 是专门用于 .net 的语言"></a>c# 是专门用于 .net 的语言</h1><p>web 页面<br>WPF<br>REST WEB服务<br>分布式应用程序的组件<br>数据库访问组件<br>桌面应用程序<br>UWP</p><h1 id="net-core-重要性"><a href="#net-core-重要性" class="headerlink" title=".net core 重要性"></a>.net core 重要性</h1><p>.net framework<br><a href="http://asp.net/">asp.net</a> web forms ？ MVC<br>WIN form /UWP<br>EF / LINQ</p><h1 id="NET-CORE"><a href="#NET-CORE" class="headerlink" title=".NET CORE"></a>.NET CORE</h1><p>开源<br>包较小，更快的创新<br>支持多个平台<br>可以编译为本地代码<br>Xamarin</p><h1 id="C-重要性"><a href="#C-重要性" class="headerlink" title="C# 重要性"></a>C# 重要性</h1><p>设计思想来源于C++ 、java、Pascal<br>面向对象的通用编程语言<br>给予组件的变成语言，支持属性、时间、特性和构建程序集<br>函数数编程理念<br>增加了泛型、语言集成查询linq、lambda表达式、动态特性、更简单的异步编程</p><h1 id="c-6-新特性"><a href="#c-6-新特性" class="headerlink" title="c#6 新特性"></a>c#6 新特性</h1><h2 id="静态using声明："><a href="#静态using声明：" class="headerlink" title="静态using声明："></a>静态using声明：</h2><p>静态的声明允许调用静态方式时不适用类名</p><blockquote><p>using static sysytem.console； Writeline(&quot;hello world&quot;) ​</p></blockquote><h2 id="表达式体方法"><a href="#表达式体方法" class="headerlink" title="表达式体方法:"></a>表达式体方法:</h2><p>表达式方法只包括一个可以用lambda语法编写的语句</p><blockquote><p>public bool isSquare（Rectangle rect）=&gt;rect.Height == rect.Width;</p></blockquote><h2 id="表达式体属性："><a href="#表达式体属性：" class="headerlink" title="表达式体属性："></a>表达式体属性：</h2><p>与表达式方法类似，只有get存取器的单行属性可以用lamabda语法编写</p><blockquote><p>public string FullName =&gt; FirstName +&quot;&quot;+ LastName;</p></blockquote><h2 id="自动实现的属性初始化器"><a href="#自动实现的属性初始化器" class="headerlink" title="自动实现的属性初始化器:"></a>自动实现的属性初始化器:</h2><p>自动实现的属性可以用属性初始化器来初始化</p><blockquote><p>public class Person{ public int Age{get;set;}=42; ​}</p></blockquote><h2 id="只读的自动属性"><a href="#只读的自动属性" class="headerlink" title="只读的自动属性"></a>只读的自动属性</h2><blockquote><p>public BookId {get;} </p></blockquote><h2 id="ameof-运算符："><a href="#ameof-运算符：" class="headerlink" title="ameof 运算符："></a>ameof 运算符：</h2><p>使用此运算符，可以访问字段名、属性名、方法名、类型名</p><h2 id="空值传播运算符"><a href="#空值传播运算符" class="headerlink" title="空值传播运算符"></a>空值传播运算符</h2><blockquote><p>int? age =p?.Age; handler?.Invoke(source,e)</p></blockquote><h2 id="字符串插值-占位符可以直接是表达式"><a href="#字符串插值-占位符可以直接是表达式" class="headerlink" title="字符串插值: 占位符可以直接是表达式"></a>字符串插值: 占位符可以直接是表达式</h2><blockquote><p>public override ToString() =&gt; $&quot;{Title} {Publisher}&quot;</p></blockquote><h2 id="字典初始化器"><a href="#字典初始化器" class="headerlink" title="字典初始化器"></a>字典初始化器</h2><blockquote><p>var dict = new Dictionary&lt;int,string&gt;(){<br>    2 =”three”,<br>  3=”seven”<br> ​}</p></blockquote><h2 id="异常过滤器"><a href="#异常过滤器" class="headerlink" title="异常过滤器"></a>异常过滤器</h2><h2 id="Catch-中的await"><a href="#Catch-中的await" class="headerlink" title="Catch 中的await"></a>Catch 中的await</h2><blockquote><p>try{ // }Catch(MyException ex){ await new<br>MessageDialog().showAsync(ex.Message); ​}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
