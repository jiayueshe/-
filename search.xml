<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c# 高级编程(10th) 第十一章 集合</title>
      <link href="2021/02/23/c/c-10th-11/"/>
      <url>2021/02/23/c/c-10th-11/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第十一章-集合"><a href="#c-语言-第十一章-集合" class="headerlink" title="c#语言 第十一章 集合"></a>c#语言 第十一章 集合</h1><h2 id="1-集合接口和类型"><a href="#1-集合接口和类型" class="headerlink" title="1.集合接口和类型"></a>1.集合接口和类型</h2><table><thead><tr><th>接口</th><th>说明</th></tr></thead><tbody><tr><td>IEnumerable<T></td><td>如果foreach语句用于集合,就需要IEnumerable接口.这个借口定义了方法GetEnumerator(),他返回一个实现了IEnumerator接口的枚举</td></tr><tr><td>ICollection<T></td><td>ICollection<T>接口有泛型集合类实现.使用这个借口可以获得集合中的元素个数(Count属性),把集合复制到数组中(CopyTo()方法),还可以从集合中添加和删除元素(Add(),Remove(),Clear())</td></tr><tr><td>List<T></td><td>IList<T>接口用于可通过位置访问其中的元素列表,这个接口定义了一个 索引器,可以在集合的指定位置插入或删除 mount些项(Insert()和Remove()方法).IList<T>接口派生自ICollection<T>接口</td></tr><tr><td>ISet<T></td><td>ISet<T>接口是.NET4中新增的.实现这个接口的集允许合并不同的集.获得两个集的交集,检查两个集合是否重叠.ISet<T>接口派生自ICollection<T>接口</td></tr><tr><td>IDictionary&lt;TKey,TValue&gt;</td><td>IDictionary&lt;TKey,TValue&gt;接口由包含键和值的泛型集合类 实现.使用这个接口可以访问所有的键和值,使用键类型的索引器可以访问某些项,还可以添加或删除某些项</td></tr><tr><td>ILookup&lt;TKey,TValue&gt;</td><td>ILookup&lt;TKey,TValue&gt;接口类似于IDictionary&lt;TKey,TValue&gt;接口,实现该接口的集合有键和值,且可以通过一个键包含多个值</td></tr><tr><td>IComparer<T></td><td>接口ICommparer<T>由比较器实现,通过Comparer()方法给集合中的元素排序</td></tr><tr><td>IEqualityComparer<T></td><td>接口IEqualityComparer<T>由一个比较器实现,该比较器可用于字典中的键.使用这个接口,可以对对象进行相等性比较.在.NET中,这个接口也由数组和元组实现</td></tr><tr><td>IProducerConsumerColllection<T></td><td>IProducerConsumerCollection<T>接口是.NET4中新增的,它支持新的线程安全的集合类</td></tr><tr><td>IReadOnlyList<T>、 IReadOnlyDictionary<T>、 IReadOnlyCollection<T></td><td>初始化后不能修改的集合，只能检索对象，不能添加和删除.</td></tr></tbody></table><h2 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h2><blockquote><pre><code>[Serializable]  public class Racer : IComparable&lt;Racer&gt;, IFormattable  &#123;    public int Id &#123; get; private set; &#125;    public string FirstName &#123; get; set; &#125;    public string LastName &#123; get; set; &#125;    public string Country &#123; get; set; &#125;    public int Wins &#123; get; set; &#125;    public Racer(int id, string firstName, string lastName, string country)      : this(id, firstName, lastName, country, wins: 0)    &#123;    &#125;    public Racer(int id, string firstName, string lastName, string country, int wins)    &#123;      this.Id = id;      this.FirstName = firstName;      this.LastName = lastName;      this.Country = country;      this.Wins = wins;    &#125;    public override string ToString()    &#123;      return String.Format(&quot;&#123;0&#125; &#123;1&#125;&quot;, FirstName, LastName);    &#125;    public string ToString(string format, IFormatProvider formatProvider)    &#123;      if (format == null) format = &quot;N&quot;;      switch (format.ToUpper())      &#123;        case null:        case &quot;N&quot;: // name          return ToString();        case &quot;F&quot;: // first name          return FirstName;        case &quot;L&quot;: // last name          return LastName;        case &quot;W&quot;: // Wins          return String.Format(&quot;&#123;0&#125;, Wins: &#123;1&#125;&quot;, ToString(), Wins);        case &quot;C&quot;: // Country          return String.Format(&quot;&#123;0&#125;, Country: &#123;1&#125;&quot;, ToString(), Country);        case &quot;A&quot;: // All          return String.Format(&quot;&#123;0&#125;, &#123;1&#125; Wins: &#123;2&#125;&quot;, ToString(), Country, Wins);        default:          throw new FormatException(String.Format(formatProvider,                &quot;Format &#123;0&#125; is not supported&quot;, format));      &#125;    &#125;    public string ToString(string format)    &#123;      return ToString(format, null);    &#125;    public int CompareTo(Racer other)    &#123;      if (other == null) return -1;      int compare = string.Compare(this.LastName, other.LastName);      if (compare == 0)        return string.Compare(this.FirstName, other.FirstName);      return compare;    &#125;  &#125;</code></pre></blockquote><p>​        使用默认的构造函数创建一个空列表，元素添加到列表后，列表容量会扩大到可接纳4个元素。<br>​        如果添加了第5个元素，列表大小会重新设置为8个元素。每次都会将列表的容量重新设置为原来的2倍.</p><blockquote><pre><code>var intList=new List&lt;int&gt;();</code></pre></blockquote><p>​        如果列表的容量变了，整个集合就要重新分配到新的内存块中，我们可以在初始化时设置它的容量：</p><blockquote><pre><code>List&lt;int&gt; intList=new List&lt;int&gt;(10);</code></pre></blockquote><p>如果列表的个数超过10个，可以设置容量Capacity：</p><blockquote><pre><code>intList.Capacity = 20;</code></pre></blockquote><p>如果列表的元素已经添加完了，列表会存在多余的容量空间。可以使用TrimExcess方法去除不要的容量:</p><blockquote><pre><code>intList.TrimExcess();</code></pre></blockquote><h3 id="a-集合初始值设定项"><a href="#a-集合初始值设定项" class="headerlink" title="a.集合初始值设定项"></a>a.集合初始值设定项</h3><p>使用初始化构造器初始化设定项</p><blockquote><pre><code>int[] arr = &#123; 1, 2, 3 &#125;;var intList = new List&lt;int&gt;(arr) ;</code></pre></blockquote><p>括号中初始化</p><pre><code>var intList = new List&lt;int&gt;() &#123; 4, 5 &#125;;</code></pre><h3 id="b-添加元素"><a href="#b-添加元素" class="headerlink" title="b.添加元素"></a>b.添加元素</h3><pre><code>intList.Add(5);</code></pre><h3 id="添加数组"><a href="#添加数组" class="headerlink" title="添加数组"></a>添加数组</h3><pre><code>intList.AddRange(new int[] &#123; 3, 5 &#125;);</code></pre><h3 id="c-插入元素"><a href="#c-插入元素" class="headerlink" title="c.插入元素"></a>c.插入元素</h3><pre><code>intList.Insert(3, 4);</code></pre><h3 id="d-访问元素"><a href="#d-访问元素" class="headerlink" title="d.访问元素"></a>d.访问元素</h3><p>使用索引获取：</p><pre><code>var value = intList[3];</code></pre><p>循环遍历：</p><pre><code>foreach (var item in intList)&#123;     var res = item;&#125;</code></pre><p>forEach方法：</p><pre><code>class List&lt;T&gt; : IList&lt;T&gt;&#123;    private T[] items;    public void forEach(Action&lt;T&gt; action)    &#123;        if (action == null) throw new ArgumentNullException(&quot;action&quot;);        foreach (var item in items)        &#123;            action(item);        &#125;    &#125;&#125;</code></pre><p>然后我们可以这样调用：</p><pre><code>intList.ForEach(m =&gt; Console.WriteLine(m));</code></pre><h3 id="e-删除元素"><a href="#e-删除元素" class="headerlink" title="e.删除元素"></a>e.删除元素</h3><p>按索引删除,比较快</p><pre><code>intList.RemoveAt(3);</code></pre><p>按元素值删除</p><pre><code>intList.Remove(4);</code></pre><h3 id="f-搜索"><a href="#f-搜索" class="headerlink" title="f.搜索"></a>f.搜索</h3><p>在集合中搜索元素。可以查找索引和元素。</p><p>FindIndex通过匹配元素值，获得索引：</p><pre><code>intList.FindIndex(m =&gt; m==4);</code></pre><p>FindIndex方法参数Predicate<T>传入匹配的表达式，返回匹配的元素索引值,Predicate<T>委托表示定义一组条件并确定指定对象是否符合这些条件的方法</p><pre><code>intList.Find(m =&gt; m == 4);intList.FindAll(m =&gt; m &gt; 2);</code></pre><p>Find返回了匹配条件的元素值，FindAll返回了匹配条件的所有元素</p><h3 id="g-排序"><a href="#g-排序" class="headerlink" title="g.排序"></a>g.排序</h3><p>列表使用Sort方法进行元素排序</p><pre><code>intList.Sort();intList.Sort((m, n) =&gt; m);</code></pre><p>Sort(Comparison<T> comparison)方法参数中的委托Comparison含有2个参数,方法将这2个元素进行比较，然后返回绝对值,如果返回-1的，元素需要排前面，返回1的元素需要排后面.</p><p>Sort(IComparer<T> comparer)方法参数中是一个比较接口，接口实现Comparer方法</p><pre><code>public enum CompareType  &#123;    FirstName,    LastName,    Country,    Wins  &#125;  public class RacerComparer : IComparer&lt;Racer&gt;  &#123;    private CompareType compareType;    public RacerComparer(CompareType compareType)    &#123;      this.compareType = compareType;    &#125;    public int Compare(Racer x, Racer y)    &#123;      if (x == null &amp;&amp; y == null) return 0;      if (x == null) return -1;      if (y == null) return 1;      int result;      switch (compareType)      &#123;        case CompareType.FirstName:          return string.Compare(x.FirstName, y.FirstName);        case CompareType.LastName:          return string.Compare(x.LastName, y.LastName);        case CompareType.Country:          result = string.Compare(x.Country, y.Country);          if (result == 0)            return string.Compare(x.LastName, y.LastName);          else            return result;        case CompareType.Wins:          return x.Wins.CompareTo(y.Wins);        default:          throw new ArgumentException(&quot;Invalid Compare Type&quot;);      &#125;    &#125;  &#125;</code></pre><h3 id="h-类型转换"><a href="#h-类型转换" class="headerlink" title="h.类型转换"></a>h.类型转换</h3><p> Converter委托</p><pre><code>public delegate TOutput Converter&lt;in TInput, out TOutput&gt;(TInput input);ConvertAll可以将一种类型的集合转换为另一种类型的集合。intList.ConvertAll(m =&gt; m.ToString());</code></pre><h6 id="只读集合"><a href="#只读集合" class="headerlink" title="只读集合"></a>只读集合</h6><p>创建集合后，它们是只读的。</p><h2 id="3-队列"><a href="#3-队列" class="headerlink" title="3.队列"></a>3.队列</h2><p>代表了一个<strong>先进先出</strong>的对象集合。当您需要对各项进行先进先出的访问时，则使用队列。当您在列表中添加一项，称为<strong>入队</strong>，当您从列表中移除一项时，称为<strong>出队</strong>。</p><p>添加队列元素时加上lock,因为多线程可以同时访问，所以对队列进行锁定访问。</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523112249101-324688636.png" alt="img"></p><pre><code>using System;using System.Collections;namespace CollectionsApplication&#123;   class Program   &#123;      static void Main(string[] args)      &#123;         Queue q = new Queue();         q.Enqueue(&#39;A&#39;);         q.Enqueue(&#39;M&#39;);         q.Enqueue(&#39;G&#39;);         q.Enqueue(&#39;W&#39;);                  Console.WriteLine(&quot;Current queue: &quot;);         foreach (char c in q)            Console.Write(c + &quot; &quot;);         Console.WriteLine();         q.Enqueue(&#39;V&#39;);         q.Enqueue(&#39;H&#39;);         Console.WriteLine(&quot;Current queue: &quot;);                  foreach (char c in q)            Console.Write(c + &quot; &quot;);         Console.WriteLine();         Console.WriteLine(&quot;Removing some values &quot;);         char ch = (char)q.Dequeue();         Console.WriteLine(&quot;The removed value: &#123;0&#125;&quot;, ch);         ch = (char)q.Dequeue();         Console.WriteLine(&quot;The removed value: &#123;0&#125;&quot;, ch);         Console.ReadKey();      &#125;   &#125;&#125;</code></pre><p>当上面的代码被编译和执行时，它会产生下列结果：</p><pre><code>Current queue: A M G W Current queue: A M G W V H Removing valuesThe removed value: AThe removed value: M</code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>class Program    &#123;        static void Main()        &#123;            var dm = new DocumentManager();            ProcessDocuments.Start(dm);            // Create documents and add them to the DocumentManager            for (int i = 0; i &lt; 1000; i++)            &#123;                Document doc = new Document(&quot;Doc &quot; + i.ToString(), &quot;content&quot;);                dm.AddDocument(doc);                Console.WriteLine(&quot;Added document &#123;0&#125;&quot;, doc.Title);                Thread.Sleep(new Random().Next(20));            &#125;        &#125;    &#125;</code></pre><p>Program</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>public class ProcessDocuments  &#123;    public static void Start(DocumentManager dm)    &#123;      Task.Factory.StartNew(new ProcessDocuments(dm).Run);    &#125;    protected ProcessDocuments(DocumentManager dm)    &#123;      if (dm == null)        throw new ArgumentNullException(&quot;dm&quot;);      documentManager = dm;    &#125;    private DocumentManager documentManager;    protected void Run()    &#123;      while (true)      &#123;        if (documentManager.IsDocumentAvailable)        &#123;          Document doc = documentManager.GetDocument();          Console.WriteLine(&quot;Processing document &#123;0&#125;&quot;, doc.Title);        &#125;        Thread.Sleep(new Random().Next(20));      &#125;    &#125;  &#125;</code></pre><p>ProcessDocuments</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>public class DocumentManager  &#123;    private readonly Queue&lt;Document&gt; documentQueue = new Queue&lt;Document&gt;();    public void AddDocument(Document doc)    &#123;      lock (this)      &#123;        documentQueue.Enqueue(doc);      &#125;    &#125;    public Document GetDocument()    &#123;      Document doc = null;      lock (this)      &#123;        doc = documentQueue.Dequeue();      &#125;      return doc;    &#125;    public bool IsDocumentAvailable    &#123;      get      &#123;        return documentQueue.Count &gt; 0;      &#125;    &#125;  &#125;</code></pre><p>DocumentManager</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>public class Document  &#123;    public string Title &#123; get; private set; &#125;    public string Content &#123; get; private set; &#125;    public Document(string title, string content)    &#123;      this.Title = title;      this.Content = content;    &#125;  &#125;</code></pre><h2 id="4-栈"><a href="#4-栈" class="headerlink" title="4.栈"></a>4.栈</h2><p>代表了一个<strong>后进先出</strong>的对象集合。当您需要对各项进行后进先出的访问时，则使用堆栈。当您在列表中添加一项，称为<strong>推入</strong>元素，当您从列表中移除一项时，称为<strong>弹出</strong>元素。</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523134233945-207787536.png" alt="img"></p><pre><code>class Program    &#123;        static void Main()        &#123;            var alphabet = new Stack&lt;char&gt;();            alphabet.Push(&#39;A&#39;);            alphabet.Push(&#39;B&#39;);            alphabet.Push(&#39;C&#39;);            Console.Write(&quot;First iteration: &quot;);            foreach (char item in alphabet)            &#123;                Console.Write(item);            &#125;            Console.WriteLine();            Console.Write(&quot;Second iteration: &quot;);            while (alphabet.Count &gt; 0)            &#123;                Console.Write(alphabet.Pop());            &#125;            Console.WriteLine();        &#125;    &#125;</code></pre><h2 id="5-链表"><a href="#5-链表" class="headerlink" title="5.链表"></a>5.链表</h2><p>LinkedList<T>是一个双向链表，其元素指向它前面和后面的元素，这样通过移动下一个元素就可以正向遍历整个链表。通过移动到前一个元素可以反向遍历这个链表</p><p>链表的优点是，如果将元素插入列表的中间位置，使用链表会很快，在插入一个元素时，只需要修改上一个元素的Next引用和下一个元素的Previous引用，使他们引用所插入的元素。</p><pre><code>public class Document  &#123;    public string Title &#123; get; private set; &#125;    public string Content &#123; get; private set; &#125;    public byte Priority &#123; get; private set; &#125;    public Document(string title, string content, byte priority)    &#123;      this.Title = title;      this.Content = content;      this.Priority = priority;    &#125;  &#125;</code></pre><pre><code>public class PriorityDocumentManager  &#123;    private readonly LinkedList&lt;Document&gt; documentList;    // priorities 0.9    private readonly List&lt;LinkedListNode&lt;Document&gt;&gt; priorityNodes;    public PriorityDocumentManager()    &#123;      documentList = new LinkedList&lt;Document&gt;();      priorityNodes = new List&lt;LinkedListNode&lt;Document&gt;&gt;(10);      for (int i = 0; i &lt; 10; i++)      &#123;        priorityNodes.Add(new LinkedListNode&lt;Document&gt;(null));      &#125;    &#125;    public void AddDocument(Document d)    &#123;      Contract.Requires&lt;ArgumentNullException&gt;(d != null, &quot;argument d must not be null&quot;);      //  if (d == null) throw new ArgumentNullException(&quot;d&quot;);      AddDocumentToPriorityNode(d, d.Priority);    &#125;    private void AddDocumentToPriorityNode(Document doc, int priority)    &#123;      Contract.Requires&lt;ArgumentException&gt;(priority &gt;= 0 &amp;&amp; priority &lt; 10, &quot;priority value must be between 0 and 9&quot;);      //if (priority &gt; 9 || priority &lt; 0)      //    throw new ArgumentException(&quot;Priority must be between 0 and 9&quot;);      if (priorityNodes[priority].Value == null)      &#123;        --priority;        if (priority &gt;= 0)        &#123;          // check for the next lower priority          AddDocumentToPriorityNode(doc, priority);        &#125;        else // now no priority node exists with the same priority or lower        // add the new document to the end        &#123;          documentList.AddLast(doc);          priorityNodes[doc.Priority] = documentList.Last;        &#125;        return;      &#125;      else // a priority node exists      &#123;        LinkedListNode&lt;Document&gt; prioNode = priorityNodes[priority];        if (priority == doc.Priority)        // priority node with the same priority exists        &#123;          documentList.AddAfter(prioNode, doc);          // set the priority node to the last document with the same priority          priorityNodes[doc.Priority] = prioNode.Next;        &#125;        else // only priority node with a lower priority exists        &#123;          // get the first node of the lower priority          LinkedListNode&lt;Document&gt; firstPrioNode = prioNode;          while (firstPrioNode.Previous != null &amp;&amp;             firstPrioNode.Previous.Value.Priority == prioNode.Value.Priority)          &#123;            firstPrioNode = prioNode.Previous;            prioNode = firstPrioNode;          &#125;          documentList.AddBefore(firstPrioNode, doc);          // set the priority node to the new value          priorityNodes[doc.Priority] = firstPrioNode.Previous;        &#125;      &#125;    &#125;    public void DisplayAllNodes()    &#123;      foreach (Document doc in documentList)      &#123;        Console.WriteLine(&quot;priority: &#123;0&#125;, title &#123;1&#125;&quot;, doc.Priority, doc.Title);      &#125;    &#125;    // returns the document with the highest priority    // (that&#39;s first in the linked list)    public Document GetDocument()    &#123;      Document doc = documentList.First.Value;      documentList.RemoveFirst();      return doc;    &#125;  &#125;</code></pre><pre><code> class Program  &#123;    static void Main()    &#123;        PriorityDocumentManager pdm = new PriorityDocumentManager();        pdm.AddDocument(new Document(&quot;one&quot;, &quot;Sample&quot;, 8));        pdm.AddDocument(new Document(&quot;two&quot;, &quot;Sample&quot;, 3));        pdm.AddDocument(new Document(&quot;three&quot;, &quot;Sample&quot;, 4));        pdm.AddDocument(new Document(&quot;four&quot;, &quot;Sample&quot;, 8));        pdm.AddDocument(new Document(&quot;five&quot;, &quot;Sample&quot;, 1));        pdm.AddDocument(new Document(&quot;six&quot;, &quot;Sample&quot;, 9));        pdm.AddDocument(new Document(&quot;seven&quot;, &quot;Sample&quot;, 1));        pdm.AddDocument(new Document(&quot;eight&quot;, &quot;Sample&quot;, 1));        pdm.DisplayAllNodes();    &#125;  &#125;</code></pre><h2 id="6-有序列表"><a href="#6-有序列表" class="headerlink" title="6.有序列表"></a>6.有序列表</h2><p>SortedList基于键对集合进行排序.</p><pre><code>class Program  &#123;    static void Main()    &#123;      var books = new SortedList&lt;string, string&gt;();      books.Add(&quot;sty&quot;, &quot;&quot;);      books.Add(&quot;abc&quot;, &quot;&quot;);      books.Add(&quot;123&quot;, &quot;&quot;);      foreach (var item in books.Keys)      &#123;          Console.WriteLine(item);      &#125;    &#125;  &#125;</code></pre><h2 id="7-字典"><a href="#7-字典" class="headerlink" title="7.字典"></a>7.字典</h2><p>字典：用于在名称/值对中存储信息，字典的名称即键不能重复.</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523142813132-1598220317.png" alt="img"></p><p>HashTable和Dictionary</p><p>1.HashTable大数据量插入数据时需要花费比Dictionary大的多的时间。</p><p>2.for方式遍历HashTable和Dictionary速度最快。</p><p>3.在foreach方式遍历时Dictionary遍历速度更快。</p><p>4.HashTable在取值时需要进行类型转换,Dictionary不用做类型转换。</p><p>在单线程的时候使用Dictionary更好一些，多线程的时候使用HashTable更好。</p><p>有序字典SortedList和SortedDictionary</p><p><strong>SortedDictionary</strong> 泛型类是检索运算复杂度为 O(log n) 的二叉搜索树，其中 n 是字典中的元素数。就这一点而言，它与 <a href="http://blog.csdn.net/nma_123456/article/details/7298343">SortedList</a> 泛型类相似。这两个类具有相似的对象模型，并且都具有 O(log n) 的检索运算复杂度。这两个类的区别在于内存的使用以及插入和移除元素的速度：</p><ul><li><strong>SortedList</strong> 使用的内存比 <strong>SortedDictionary</strong> 少。</li><li><strong>SortedDictionary</strong> 可对未排序的数据执行更快的插入和移除操作：它的时间复杂度为 O(log n)，而<strong>SortedList</strong> 为 O(n)。</li><li>如果使用排序数据一次性填充列表，则 <strong>SortedList</strong> 比 <strong>SortedDictionary</strong> 快。</li><li></li></ul><h2 id="8-集"><a href="#8-集" class="headerlink" title="8.集"></a>8.集</h2><p>包含不重复元素的集合，叫“集”。.NET包含2个集。HashSet<T>和SortedSet<T>，它们继承ISet;SortedSet是一个有序集.</p><p>ISet提供了Add方法,如果HashSet中存在这个元素，再次使用Add方法不会抛出异常，返回bool值是否添加</p><blockquote><p>var companyTeams = new HashSet<string>() { “Ferrari”, “McLaren”, “Mercedes” };<br>var traditionalTeams = new HashSet<string>() { “Ferrari”, “McLaren” };<br>var privateTeams = new HashSet<string>() { “Red Bull”, “Lotus”, “Toro Rosso”, “Force India”, “Sauber” };</p><p>if (privateTeams.Add(“Williams”))<br>    Console.WriteLine(“Williams added”);<br>if (!companyTeams.Add(“McLaren”))<br>    Console.WriteLine(“McLaren was already in this set”);</p></blockquote><pre><code>IsSubsetOf方法判断了traditionalTeams集合是否companyTeams的子集IsSupersetOf方法判断了companyTeams集合是否traditionalTeams的超集(包含它拥有的所有元素，并且多余它的元素)</code></pre><pre><code>var companyTeams = new HashSet&lt;string&gt;() &#123; &quot;Ferrari&quot;, &quot;McLaren&quot;, &quot;Mercedes&quot; &#125;;var traditionalTeams = new HashSet&lt;string&gt;() &#123; &quot;Ferrari&quot;, &quot;McLaren&quot; &#125;;var privateTeams = new HashSet&lt;string&gt;() &#123; &quot;Red Bull&quot;, &quot;Lotus&quot;, &quot;Toro Rosso&quot;, &quot;Force India&quot;, &quot;Sauber&quot; &#125;;if (traditionalTeams.IsSubsetOf(companyTeams))&#123;  Console.WriteLine(&quot;traditionalTeams is subset of companyTeams&quot;);&#125;if (companyTeams.IsSupersetOf(traditionalTeams))&#123;   Console.WriteLine(&quot;companyTeams is a superset of traditionalTeams&quot;);&#125;SortedSet的UnionWith方法可以修改这个集合，并且包含传入的集合var allTeams = new SortedSet&lt;string&gt;(companyTeams);allTeams.UnionWith(privateTeams);allTeams.UnionWith(traditionalTeams);</code></pre><h2 id="9-可视察的集合"><a href="#9-可视察的集合" class="headerlink" title="9.可视察的集合"></a>9.可视察的集合</h2><p>如果需要记录集合何时添加和删除元素的信息，可以使用ObservableCollection<T>,这个本身是为WPF定制的。</p><p>ObservableCollection<T>类用于创建自定义集合，在内部使用List<T>类,重写虚方法RemoveItem和SetItem()方法触发CollectionChanged事件。</p><pre><code>class Program  &#123;    static void Main()    &#123;      var data = new ObservableCollection&lt;string&gt;();      data.CollectionChanged += Data_CollectionChanged;      data.Add(&quot;One&quot;);      data.Add(&quot;Two&quot;);      data.Insert(1, &quot;Three&quot;);      data.Remove(&quot;One&quot;);    &#125;    static void Data_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)    &#123;      Console.WriteLine(&quot;action: &#123;0&#125;&quot;, e.Action.ToString());      if (e.OldItems != null)      &#123;        Console.WriteLine(&quot;starting index for old item(s): &#123;0&#125;&quot;, e.OldStartingIndex);        Console.WriteLine(&quot;old item(s):&quot;);        foreach (var item in e.OldItems)        &#123;          Console.WriteLine(item);        &#125;      &#125;      if (e.NewItems != null)      &#123;        Console.WriteLine(&quot;starting index for new item(s): &#123;0&#125;&quot;, e.NewStartingIndex);        Console.WriteLine(&quot;new item(s): &quot;);        foreach (var item in e.NewItems)        &#123;          Console.WriteLine(item);        &#125;      &#125;      Console.WriteLine();    &#125;  &#125;</code></pre><p>Data_CollectionChanged方法接收了NotifyCollectionChangedEventArgs，包含了集合的变化信息，Action属性给出了是否添加或删除一项的信息，对于删除的项，会设置OldItems属性，列出删除的项</p><p>对于添加的项，会设置NewItems属性，列出添加的项。</p><pre><code>action: Addstarting index for new item(s): 0new item(s):Oneaction: Addstarting index for new item(s): 1new item(s):Twoaction: Addstarting index for new item(s): 1new item(s):Threeaction: Removestarting index for old item(s): 0old item(s):One</code></pre><h2 id="10-位数组"><a href="#10-位数组" class="headerlink" title="10.位数组"></a>10.位数组</h2><h3 id="BitArray类的方法和属性"><a href="#BitArray类的方法和属性" class="headerlink" title="BitArray类的方法和属性"></a>BitArray类的方法和属性</h3><p>下表列出了一些BitArray类的常用属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Count</td><td>获取包含在BitArray元素的数量</td></tr><tr><td>IsReadOnly</td><td>获取一个值，指示BitArray是否是只读</td></tr><tr><td>Item</td><td>获取或设置在所述BitArray的特定位置的比特的值</td></tr><tr><td>Length</td><td>获取或设置在BitArray元素的数量</td></tr></tbody></table><p>下表列出了一些BitArray类的常用方法：</p><table><thead><tr><th>S.N</th><th>方法名称及用途</th></tr></thead><tbody><tr><td>1</td><td><strong>public BitArray And( BitArray value );</strong>  执行对指定BitArray的相应元素在当前BitArray元素的按位与运算</td></tr><tr><td>2</td><td><strong>public bool Get( int index );</strong>  获取在所述BitArray的特定位置的比特的值</td></tr><tr><td>3</td><td><strong>public BitArray Not();</strong> 反转当前BitArray所有的位值，使设置为true的元素被更改为false，并设置为false元素更改为true</td></tr><tr><td>4</td><td><strong>public BitArray Or( BitArray value );</strong>  在执行对指定BitArray的相应元素在当前BitArray的元素的按位或操作</td></tr><tr><td>5</td><td><strong>public void Set( int index, bool value );</strong>  设置在所述BitArray为指定值的特定位置的比特值</td></tr><tr><td>6</td><td><strong>public void SetAll( bool value );</strong>  设置在BitArray所有位设置为指定值</td></tr><tr><td>7</td><td><strong>public BitArray Xor( BitArray value );</strong>  执行关于对在指定BitArray的相应元素中的当前BitArray的元素按位异或运算</td></tr></tbody></table><p>当需要存储位，但不知道事先比特数就使用它。您可以通过使用一个整数索引，它从零开始访问BitArray集合中的项。</p><pre><code>using System;using System.Collections;namespace CollectionsApplication&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //creating two  bit arrays of size 8            BitArray ba1 = new BitArray(8);            BitArray ba2 = new BitArray(8);            byte[] a = &#123; 60 &#125;;            byte[] b = &#123; 13 &#125;;                        //storing the values 60, and 13 into the bit arrays            ba1 = new BitArray(a);            ba2 = new BitArray(b);            //content of ba1            Console.WriteLine(&quot;Bit array ba1: 60&quot;);            for (int i = 0; i &lt; ba1.Count; i++)            &#123;                Console.Write(&quot;&#123;0, -6&#125; &quot;, ba1[i]);            &#125;            Console.WriteLine();                        //content of ba2            Console.WriteLine(&quot;Bit array ba2: 13&quot;);            for (int i = 0; i &lt; ba2.Count; i++)            &#123;                Console.Write(&quot;&#123;0, -6&#125; &quot;, ba2[i]);            &#125;            Console.WriteLine();                                   BitArray ba3 = new BitArray(8);            ba3 = ba1.And(ba2);            //content of ba3            Console.WriteLine(&quot;Bit array ba3 after AND operation: 12&quot;);            for (int i = 0; i &lt; ba3.Count; i++)            &#123;                Console.Write(&quot;&#123;0, -6&#125; &quot;, ba3[i]);            &#125;            Console.WriteLine();            ba3 = ba1.Or(ba2);            //content of ba3            Console.WriteLine(&quot;Bit array ba3 after OR operation: 61&quot;);            for (int i = 0; i &lt; ba3.Count; i++)            &#123;                Console.Write(&quot;&#123;0, -6&#125; &quot;, ba3[i]);            &#125;            Console.WriteLine();                        Console.ReadKey();        &#125;    &#125;&#125;</code></pre><p>让我们编译和运行上面的程序，这将产生以下结果：</p><pre><code>Bit array ba1: 60 False False True True True True False False Bit array ba2: 13True False True True False False False False Bit array ba3 after AND operation: 12False False True True False False False False Bit array ba3 after OR operation: 61True False True True False False False False </code></pre><h6 id="BitVector32"><a href="#BitVector32" class="headerlink" title="BitVector32"></a><a href="http://www.cnblogs.com/kingdom_0/articles/2024941.html">BitVector32</a></h6><p>提供了一个简单结构，该结构以32位内存存储布尔和小数值</p><p>对于内部使用的布尔值和小整数，BitVector32 比 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.bitarray.aspx">BitArray</a> 更有效。 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.bitarray.aspx">BitArray</a> 可以按需要无限地扩大，但它有内存和性能方面的系统开销，这是类实例所要求的。 相比之下，BitVector32 只使用 32 位。</p><p>BitVector32 结构可以设置成包含小整数的若干节或包含布尔值的若干位标志，但不能同时包含两者。<a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.section.aspx">BitVector32.Section</a> 是 BitVector32 中的窗口，且由最小数量的连续位构成，连续位可以包含 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.createsection.aspx">CreateSection</a> 中指定的最大值。 例如，带有最大值 1 的节只由一个位构成，而带有最大值 5 的节由三个位构成。 可以创建带有最大值 1 的 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.section.aspx">BitVector32.Section</a> 作为布尔值，从而使您能够在同一 BitVector32 中存储整数和布尔值。</p><p>BitVector32 既可以设置为节，也可以设置为位标志，分别有成员可以应用于这两种情形。 例如，<a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.item.aspx">BitVector32.Item</a> 属性是作为节设置的 BitVector32 的索引器，而 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.item.aspx">BitVector32.Item</a> 属性是作为位标志设置的BitVector32 的索引器。 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.createmask.aspx">CreateMask</a> 创建一系列屏蔽，这些屏蔽可用于访问作为位标志设置的 BitVector32 中的单个位。</p><p>在作为节设置的 BitVector32 上使用屏蔽可能会导致意外的结果</p><pre><code>using System;using System.Collections.Specialized;public class SamplesBitVector32  &#123;   public static void Main()  &#123;      // Creates and initializes a BitVector32 with all bit flags set to FALSE.      BitVector32 myBV = new BitVector32( 0 );      // Creates masks to isolate each of the first five bit flags.      int myBit1 = BitVector32.CreateMask();      int myBit2 = BitVector32.CreateMask( myBit1 );      int myBit3 = BitVector32.CreateMask( myBit2 );      int myBit4 = BitVector32.CreateMask( myBit3 );      int myBit5 = BitVector32.CreateMask( myBit4 );      // Sets the alternating bits to TRUE.      Console.WriteLine( &quot;Setting alternating bits to TRUE:&quot; );      Console.WriteLine( &quot;   Initial:         &#123;0&#125;&quot;, myBV.ToString() );      myBV[myBit1] = true;      Console.WriteLine( &quot;   myBit1 = TRUE:   &#123;0&#125;&quot;, myBV.ToString() );      myBV[myBit3] = true;      Console.WriteLine( &quot;   myBit3 = TRUE:   &#123;0&#125;&quot;, myBV.ToString() );      myBV[myBit5] = true;      Console.WriteLine( &quot;   myBit5 = TRUE:   &#123;0&#125;&quot;, myBV.ToString() );   &#125;&#125;/*This code produces the following output.Setting alternating bits to TRUE:   Initial:         BitVector32&#123;00000000000000000000000000000000&#125;   myBit1 = TRUE:   BitVector32&#123;00000000000000000000000000000001&#125;   myBit3 = TRUE:   BitVector32&#123;00000000000000000000000000000101&#125;   myBit5 = TRUE:   BitVector32&#123;00000000000000000000000000010101&#125;*/BitVector用作节集合using System;using System.Collections.Specialized;public class SamplesBitVector32  &#123;   public static void Main()  &#123;      // Creates and initializes a BitVector32.      BitVector32 myBV = new BitVector32( 0 );      // Creates four sections in the BitVector32 with maximum values 6, 3, 1, and 15.      // mySect3, which uses exactly one bit, can also be used as a bit flag.      BitVector32.Section mySect1 = BitVector32.CreateSection( 6 );      BitVector32.Section mySect2 = BitVector32.CreateSection( 3, mySect1 );      BitVector32.Section mySect3 = BitVector32.CreateSection( 1, mySect2 );      BitVector32.Section mySect4 = BitVector32.CreateSection( 15, mySect3 );      // Displays the values of the sections.      Console.WriteLine( &quot;Initial values:&quot; );      Console.WriteLine( &quot;\tmySect1: &#123;0&#125;&quot;, myBV[mySect1] );      Console.WriteLine( &quot;\tmySect2: &#123;0&#125;&quot;, myBV[mySect2] );      Console.WriteLine( &quot;\tmySect3: &#123;0&#125;&quot;, myBV[mySect3] );      Console.WriteLine( &quot;\tmySect4: &#123;0&#125;&quot;, myBV[mySect4] );      // Sets each section to a new value and displays the value of the BitVector32 at each step.      Console.WriteLine( &quot;Changing the values of each section:&quot; );      Console.WriteLine( &quot;\tInitial:    \t&#123;0&#125;&quot;, myBV.ToString() );      myBV[mySect1] = 5;      Console.WriteLine( &quot;\tmySect1 = 5:\t&#123;0&#125;&quot;, myBV.ToString() );      myBV[mySect2] = 3;      Console.WriteLine( &quot;\tmySect2 = 3:\t&#123;0&#125;&quot;, myBV.ToString() );      myBV[mySect3] = 1;      Console.WriteLine( &quot;\tmySect3 = 1:\t&#123;0&#125;&quot;, myBV.ToString() );      myBV[mySect4] = 9;      Console.WriteLine( &quot;\tmySect4 = 9:\t&#123;0&#125;&quot;, myBV.ToString() );      // Displays the values of the sections.      Console.WriteLine( &quot;New values:&quot; );      Console.WriteLine( &quot;\tmySect1: &#123;0&#125;&quot;, myBV[mySect1] );      Console.WriteLine( &quot;\tmySect2: &#123;0&#125;&quot;, myBV[mySect2] );      Console.WriteLine( &quot;\tmySect3: &#123;0&#125;&quot;, myBV[mySect3] );      Console.WriteLine( &quot;\tmySect4: &#123;0&#125;&quot;, myBV[mySect4] );   &#125;&#125;</code></pre><h2 id="11-不变的集合"><a href="#11-不变的集合" class="headerlink" title="11.不变的集合"></a>11.不变的集合</h2><p><strong>Net提供的不可变集合</strong></p><pre><code>ImmutableStack&lt;int&gt; a1 = ImmutableStack&lt;int&gt;.Empty;ImmutableStack&lt;int&gt; a2 = a1.Push(10);ImmutableStack&lt;int&gt; a3 = a2.Push(20);ImmutableStack&lt;int&gt; a4 = a3.Push(30);ImmutableStack&lt;int&gt; iv3 = a4.Pop(); </code></pre><p>使用Net不可变列表集合有一点要注意的是，当我们Push值时要重新赋值给原变量才正确，因为push后会生成一个新对象，原a1只是旧值：</p><pre><code>ImmutableStack&lt;int&gt; a1 = ImmutableStack&lt;int&gt;.Empty;a1.Push(10); //不正确，a1仍是空值值，push会生成新的栈。a1 = a1.Push(10); //需要将新栈重新赋值给a1</code></pre><p><strong>NET提供的常用数据结构</strong></p><p>1.ImmutableStack<br>2.ImmutableQueue<br>3.ImmutableList<br>4.ImmutableHashSet<br>5.ImmutableSortedSet<br>6.ImmutableDictionary&lt;K, V&gt;<br>7.ImmutableSortedDictionary&lt;K, V&gt;</p><p><strong>不可变优点</strong></p><p>1.集合共享安全，从不被改变<br>2.访问集合时，不需要锁集合（线程安全）<br>3.修改集合不担心旧集合被改变<br>4.书写更简洁，函数式风格。 var list = ImmutableList.Empty.Add(10).Add(20).Add(30);<br>5.保证数据完整性，安全性</p><p><strong>不可变对象缺点</strong></p><p>不可变本身的优点即是缺点，当每次对象/集合操作都会返回个新值。而旧值依旧会保留一段时间，这会使内存有极大开销，也会给GC造成回收负担，性能也比可变集合差的多。</p><h2 id="12-并发集合"><a href="#12-并发集合" class="headerlink" title="12.并发集合"></a>12.并发集合</h2><p>线程安全的集合可防止多个线程以相互冲突的方式访问集合</p><p>.NET 的System.Collections.Concurrent提供了几个安全的类和功能：</p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd267312.aspx">BlockingCollection</a></td><td>为实现 <a href="https://msdn.microsoft.com/zh-cn/library/dd287147.aspx">IProducerConsumerCollection</a> 的线程安全集合提供阻塞和限制功能。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd381779.aspx">ConcurrentBag</a></td><td>表示对象的线程安全的无序集合。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd287191.aspx">ConcurrentDictionary</a></td><td>表示可由多个线程同时访问的键/值对的线程安全集合。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd267265.aspx">ConcurrentQueue</a></td><td>表示线程安全的先进先出 (FIFO) 集合。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd267331.aspx">ConcurrentStack</a></td><td>表示线程安全的后进先出 (LIFO) 集合。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd394988.aspx">OrderablePartitioner</a></td><td>表示将可排序数据源拆分为多个分区的特定方式。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/system.collections.concurrent.partitioner.aspx">Partitioner</a></td><td>为数组、列表和可枚举对象提供常见的分区策略。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd381768.aspx">Partitioner</a></td><td>表示将数据源拆分为多个分区的特定方式。</td></tr></tbody></table><h3 id="1-创建管道"><a href="#1-创建管道" class="headerlink" title="1)创建管道"></a>1)创建管道</h3><p>将这些并发集合类用于管道,一个任务向一个集合类写入一些内容，同时另一个任务从该集合中读取内容</p><p>示例中多个任务形成一个管道.<br>第一个管道，<br>第1阶段的任务读取文件名，添加到队列，这个任务运行同时，<br>第2阶段的任务已经开始从队列中读取文件名并加载它们的程序,结果被写入另一个队列。<br>第3阶段同时启动，读取并处理第2个队列的内容，结果被写入一个字典。</p><p>第3阶段完成，并且内容已被最终处理，字典得到完整结果时，下一阶段才开始。<br>第4阶段从字典中读取内容，转换数据，然后写入队列中<br>第5阶段在项中添加颜色信息，然后把它们添加到另一个队列中，最后一个阶段显示信息。<br>第4到第6阶段也可以并发运行.</p><pre><code>class Program  &#123;    static void Main(string[] args)    &#123;      StartPipeline();      Console.ReadLine();    &#125;    private static async void StartPipeline()    &#123;      var fileNames = new BlockingCollection&lt;string&gt;();      var lines = new BlockingCollection&lt;string&gt;();      var words = new ConcurrentDictionary&lt;string, int&gt;();      var items = new BlockingCollection&lt;Info&gt;();      var coloredItems = new BlockingCollection&lt;Info&gt;();      Task t1 = PipelineStages.ReadFilenamesAsync(@&quot;../../..&quot;, fileNames);      ConsoleHelper.WriteLine(&quot;started stage 1&quot;);      Task t2 = PipelineStages.LoadContentAsync(fileNames, lines);      ConsoleHelper.WriteLine(&quot;started stage 2&quot;);      Task t3 = PipelineStages.ProcessContentAsync(lines, words);      await Task.WhenAll(t1, t2, t3);      ConsoleHelper.WriteLine(&quot;stages 1, 2, 3 completed&quot;);      Task t4 = PipelineStages.TransferContentAsync(words, items);      Task t5 = PipelineStages.AddColorAsync(items, coloredItems);      Task t6 = PipelineStages.ShowContentAsync(coloredItems);      ConsoleHelper.WriteLine(&quot;stages 4, 5, 6 started&quot;);      await Task.WhenAll(t4, t5, t6);      ConsoleHelper.WriteLine(&quot;all stages finished&quot;);    &#125;  &#125;</code></pre><pre><code>public class ConsoleHelper  &#123;    private static object syncOutput = new object();    public static void WriteLine(string message)    &#123;      lock (syncOutput)      &#123;        Console.WriteLine(message);      &#125;    &#125;    public static void WriteLine(string message, string color)    &#123;      lock (syncOutput)      &#123;        Console.ForegroundColor = (ConsoleColor)Enum.Parse(typeof(ConsoleColor), color);        Console.WriteLine(message);        Console.ResetColor();      &#125;    &#125;  &#125;</code></pre><pre><code>public static class PipelineStages  &#123;    public static Task ReadFilenamesAsync(string path, BlockingCollection&lt;string&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (string filename in Directory.EnumerateFiles(path, &quot;*.cs&quot;, SearchOption.AllDirectories))          &#123;            output.Add(filename);            ConsoleHelper.WriteLine(string.Format(&quot;stage 1: added &#123;0&#125;&quot;, filename));          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static async Task LoadContentAsync(BlockingCollection&lt;string&gt; input, BlockingCollection&lt;string&gt; output)    &#123;      foreach (var filename in input.GetConsumingEnumerable())      &#123;        using (FileStream stream = File.OpenRead(filename))        &#123;          var reader = new StreamReader(stream);          string line = null;          while ((line = await reader.ReadLineAsync()) != null)          &#123;            output.Add(line);            ConsoleHelper.WriteLine(string.Format(&quot;stage 2: added &#123;0&#125;&quot;, line));          &#125;        &#125;      &#125;      output.CompleteAdding();    &#125;    public static Task ProcessContentAsync(BlockingCollection&lt;string&gt; input, ConcurrentDictionary&lt;string, int&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var line in input.GetConsumingEnumerable())          &#123;            string[] words = line.Split(&#39; &#39;, &#39;;&#39;, &#39;\t&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;:&#39;, &#39;,&#39;, &#39;&quot;&#39;);            foreach (var word in words.Where(w =&gt; !string.IsNullOrEmpty(w)))            &#123;              output.AddOrIncrementValue(word);              ConsoleHelper.WriteLine(string.Format(&quot;stage 3: added &#123;0&#125;&quot;, word));            &#125;          &#125;        &#125;);    &#125;    public static Task TransferContentAsync(ConcurrentDictionary&lt;string, int&gt; input, BlockingCollection&lt;Info&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var word in input.Keys)          &#123;            int value;            if (input.TryGetValue(word, out value))            &#123;              var info = new Info &#123; Word = word, Count = value &#125;;              output.Add(info);              ConsoleHelper.WriteLine(string.Format(&quot;stage 4: added &#123;0&#125;&quot;, info));            &#125;          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static Task AddColorAsync(BlockingCollection&lt;Info&gt; input, BlockingCollection&lt;Info&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var item in input.GetConsumingEnumerable())          &#123;            if (item.Count &gt; 40)            &#123;              item.Color = &quot;Red&quot;;            &#125;            else if (item.Count &gt; 20)            &#123;              item.Color = &quot;Yellow&quot;;            &#125;            else            &#123;              item.Color = &quot;Green&quot;;            &#125;            output.Add(item);            ConsoleHelper.WriteLine(string.Format(&quot;stage 5: added color &#123;1&#125; to &#123;0&#125;&quot;, item, item.Color));          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static Task ShowContentAsync(BlockingCollection&lt;Info&gt; input)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var item in input.GetConsumingEnumerable())          &#123;            ConsoleHelper.WriteLine(string.Format(&quot;stage 6: &#123;0&#125;&quot;, item), item.Color);          &#125;        &#125;);    &#125;  &#125;</code></pre><p>2)使用<a href="https://msdn.microsoft.com/zh-cn/library/dd267312.aspx">BlockingCollection</a></p><p>第1阶段的ReadFilenamesAsync方法，实现了迭代目录文件名。在完成文件名添加后调用output.CompleteAdding();用以通知所有读取器不再等待集合中任何额外的项.如果没有调用的话，循环中读取器会添加等待更多的项.</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>public static Task ReadFilenamesAsync(string path, BlockingCollection&lt;string&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (string filename in Directory.EnumerateFiles(path, &quot;*.cs&quot;, SearchOption.AllDirectories))          &#123;            output.Add(filename);            ConsoleHelper.WriteLine(string.Format(&quot;stage 1: added &#123;0&#125;&quot;, filename));          &#125;          output.CompleteAdding();        &#125;);    &#125;</code></pre><p>ReadFilenamesAsync </p><p>下一阶段读取文件并将器内容添加到另一个集合中，由LoadContentAsync方法完成，该方法使用了输入集合传递的文件名，打开文件，把文件中的所有行添加到输出的集合中。在循环中用输入阻塞集合调用GetConsumingEnumerable()方法，以迭代各项，不使用也是可以的，但是值会迭代当前状态的集合。不会迭代以后添加的项。</p><p>如果在填充集合的同时，使用读取器读取集合，则需要使用GetConsumingEnumerable()方法获取阻塞集合的枚举器，而不是直接迭代集合</p><pre><code>public static async Task LoadContentAsync(BlockingCollection&lt;string&gt; input, BlockingCollection&lt;string&gt; output)    &#123;      foreach (var filename in input.GetConsumingEnumerable())      &#123;        using (FileStream stream = File.OpenRead(filename))        &#123;          var reader = new StreamReader(stream);          string line = null;          while ((line = await reader.ReadLineAsync()) != null)          &#123;            output.Add(line);            ConsoleHelper.WriteLine(string.Format(&quot;stage 2: added &#123;0&#125;&quot;, line));          &#125;        &#125;      &#125;      output.CompleteAdding();    &#125;</code></pre><p>3)使用<a href="https://msdn.microsoft.com/zh-cn/library/dd287191.aspx">ConcurrentDictionary</a></p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523162236413-845354975.png" alt="img"></p><pre><code>public static Task ProcessContentAsync(BlockingCollection&lt;string&gt; input, ConcurrentDictionary&lt;string, int&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var line in input.GetConsumingEnumerable())          &#123;            string[] words = line.Split(&#39; &#39;, &#39;;&#39;, &#39;\t&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;:&#39;, &#39;,&#39;, &#39;&quot;&#39;);            foreach (var word in words.Where(w =&gt; !string.IsNullOrEmpty(w)))            &#123;              output.AddOrIncrementValue(word);              ConsoleHelper.WriteLine(string.Format(&quot;stage 3: added &#123;0&#125;&quot;, word));            &#125;          &#125;        &#125;);    &#125;</code></pre><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523162311476-1014974724.png" alt="img"></p><pre><code>public static class ConcurrentDictionaryExtension  &#123;    public static void AddOrIncrementValue(this ConcurrentDictionary&lt;string, int&gt; dict, string key)    &#123;      bool success = false;      while (!success)      &#123;        int value;        if (dict.TryGetValue(key, out value))        &#123;          if (dict.TryUpdate(key, value + 1, value))          &#123;            success = true;          &#125;        &#125;        else        &#123;          if (dict.TryAdd(key, 1))          &#123;            success = true;          &#125;        &#125;      &#125;    &#125;  &#125;</code></pre><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523162341117-33389163.png" alt="img"></p><p>在完成第3个阶段后，第4到6阶段也可以并行运行，TransferContentAsync从字典中获取数据，进行类型转换，输出到BlockingCollection<string>中</p><pre><code>public static Task ProcessContentAsync(BlockingCollection&lt;string&gt; input, ConcurrentDictionary&lt;string, int&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var line in input.GetConsumingEnumerable())          &#123;            string[] words = line.Split(&#39; &#39;, &#39;;&#39;, &#39;\t&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;:&#39;, &#39;,&#39;, &#39;&quot;&#39;);            foreach (var word in words.Where(w =&gt; !string.IsNullOrEmpty(w)))            &#123;              output.AddOrIncrementValue(word);              ConsoleHelper.WriteLine(string.Format(&quot;stage 3: added &#123;0&#125;&quot;, word));            &#125;          &#125;        &#125;);    &#125;    public static Task TransferContentAsync(ConcurrentDictionary&lt;string, int&gt; input, BlockingCollection&lt;Info&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var word in input.Keys)          &#123;            int value;            if (input.TryGetValue(word, out value))            &#123;              var info = new Info &#123; Word = word, Count = value &#125;;              output.Add(info);              ConsoleHelper.WriteLine(string.Format(&quot;stage 4: added &#123;0&#125;&quot;, info));            &#125;          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static Task AddColorAsync(BlockingCollection&lt;Info&gt; input, BlockingCollection&lt;Info&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var item in input.GetConsumingEnumerable())          &#123;            if (item.Count &gt; 40)            &#123;              item.Color = &quot;Red&quot;;            &#125;            else if (item.Count &gt; 20)            &#123;              item.Color = &quot;Yellow&quot;;            &#125;            else            &#123;              item.Color = &quot;Green&quot;;            &#125;            output.Add(item);            ConsoleHelper.WriteLine(string.Format(&quot;stage 5: added color &#123;1&#125; to &#123;0&#125;&quot;, item, item.Color));          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static Task ShowContentAsync(BlockingCollection&lt;Info&gt; input)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var item in input.GetConsumingEnumerable())          &#123;            ConsoleHelper.WriteLine(string.Format(&quot;stage 6: &#123;0&#125;&quot;, item), item.Color);          &#125;        &#125;);    &#125;</code></pre><h2 id="13-性能"><a href="#13-性能" class="headerlink" title="13.性能"></a>13.性能</h2><p>集合的方法常常有性能提示，给出大写O记录操作时间。</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523162826570-2112606748.png" alt="img"></p><p>O(1)表示无论集合中有多少数据项，这个操作需要的时间都不变。<br>O(n)表示对于集合执行一个操作需要的事件在最坏情况时是N.<br>O(log n)表示操作需要的时间随集合中元素的增加而增加</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523163051320-952892312.png" alt="img"></p><h3 id="非泛型类集合"><a href="#非泛型类集合" class="headerlink" title="非泛型类集合"></a>非泛型类集合</h3><p>泛型集合类是在.NET2.0的时候出来的,也就是说在1.0的时候是没有这么方便的东西的。现在基本上我们已经不使用这些集合类了，除非在做一些和老代码保持兼容的工作的时候。来看看1.0时代的.NET程序员们都有哪些集合类可以用。</p><p>ArraryList后来被List<T>替代。</p><p>HashTable 后来被Dictionary&lt;TKey,TValue&gt;替代。<br>Queue 后来被Queue<T>替代。<br>SortedList 后来被SortedList<T>替代。<br>Stack 后来被Stack<T>替代。</p><h3 id="线程安全的集合类"><a href="#线程安全的集合类" class="headerlink" title="线程安全的集合类"></a>线程安全的集合类</h3><p>ConcurrentQueue 线程安全版本的Queue<br>ConcurrentStack线程安全版本的Stack<br>ConcurrentBag线程安全的对象集合<br>ConcurrentDictionary线程安全的Dictionary<br>BlockingCollection</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第十章 字符串和正则表达式</title>
      <link href="2021/02/20/c/c-10th-10/"/>
      <url>2021/02/20/c/c-10th-10/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第十章-字符串和正则表达式"><a href="#c-语言-第十章-字符串和正则表达式" class="headerlink" title="c#语言 第十章 字符串和正则表达式"></a>c#语言 第十章 字符串和正则表达式</h1><p>10.1 System.String类</p><p>​        System.String是一个类，专门用于存储字符串，允许对字符串进行许多操作。C#提供了关键字string和相关的语法，以便使用这个类更轻松。</p><blockquote><pre><code>你可以通过运算符重载连接字符串string message1 = &quot;hello&quot;;message1 += &quot; world&quot;;Console.WriteLine(message1);</code></pre></blockquote><blockquote><pre><code>C#还允许通过使用类似索引器的语法来提取字符串中的指定字符：string message1 = &quot;hello&quot;;char char1 = message1[0];Console.WriteLine(char1);</code></pre></blockquote><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Compare</td><td>比较字符串的内容，考虑区域设置之间的某些字符的等价性。</td></tr><tr><td>CompareOrdinal</td><td>比较字符串的内容，但不考虑区域设置。</td></tr><tr><td>Concat</td><td>将不同的字符串实例合并成一个字符串实例。</td></tr><tr><td>CopyTo</td><td>将指定序号，指定长度的字符拷贝到另外一个新建的数组中。</td></tr><tr><td>Format</td><td>根据指定的格式格式化一个含有多种数值的字符串。</td></tr><tr><td>IndexOf</td><td>定位某个字符或者子串在字符串中首次出现的位置。</td></tr><tr><td>IndexOfAny</td><td>定位一组字符中任意一个字符在字符串中首次出现的位置。</td></tr><tr><td>Insert</td><td>在指定位置插入另外一个字符串。</td></tr><tr><td>Join</td><td>按照要求将一个字符串数组合并成一个字符串实例。</td></tr><tr><td>LastIndexOf</td><td>跟IndexOf一样，但返回最后一次出现的位置。</td></tr><tr><td>LastIndexOfAny</td><td>跟IndexOfAny一样，但返回最后一次出现的位置。</td></tr><tr><td>PadLeft</td><td>如果字符串不够指定位数，则在其左侧按给定字符补全位数。</td></tr><tr><td>PadRight</td><td>如果字符串不够指定位数，则在其右侧按给定字符补全位数。</td></tr><tr><td>Replace</td><td>将指定字符或者子串替换成另外一个字符或者子串。</td></tr><tr><td>Split</td><td>根据指定字符分隔成若干子串。</td></tr><tr><td>Substring</td><td>根据指定位置和长度获取一个子串。</td></tr><tr><td>ToLower</td><td>转成小写。</td></tr><tr><td>ToUpper</td><td>转成大写。</td></tr><tr><td>Trim</td><td>移除字符串开头与结尾的空格。</td></tr></tbody></table><p>10.1.1构建字符串</p><p>​        String类存在一个问题：重复修改给定的字符串，效率会很低，它实际上是一个不可变的数据类型，一旦对字符串对象进行了初始化，该字符串对象就不能改变了</p><blockquote><pre><code>string message1 = &quot;hello&quot;;message1 = &quot;hello world&quot;;</code></pre></blockquote><p>​        表面上message1修改了字符串的内容，实际上是创建了一个新的字符串hello world然后将其指向meesage1，原来的hello字符串就没有变量引用它，下一次垃圾收集器清理时就会删除它</p><p>10.1.2 StringBuilder成员</p><p>​        实例化StringBuilder时有很多重载可以选择，其中就有提供一个字符串和给定容量</p><blockquote><pre><code>StringBuilder strb1 = new StringBuilder(&quot;hello&quot;);StringBuilder strb2 = new StringBuilder(100);</code></pre></blockquote><p>​        还可以随时显示地设置容量，当字符串长度超出时，就会抛出异常：</p><blockquote><pre><code>StringBuilder strb = new StringBuilder(&quot;1个字符&quot;);strb.Capacity = 1;</code></pre></blockquote><p>​        StringBuilder类上可以进行的处理仅限于替换和追加或删除字符串中的文本。StringBuilder转换为string的唯一方法就是使用ToString()方法。StringBuilder类基本上应在处理多个字符串时使用。</p><p>10.2字符串格式</p><p><strong>格式字符串</strong></p><p>例子：</p><pre><code>Console.WriteLine(&quot;张三有存款：&#123;0,10:C&#125;&quot;,1000);Console.WriteLine(&quot;李四有存款：&#123;0,10:C&#125;&quot;, 800);Console.WriteLine(&quot;赵六有存款：&#123;0,10:C&#125;&quot;, 20000);</code></pre><p>运行以上代码，结果如下：</p><p>​        解释一下{0,10:C}的作用，其中{0}是占位符，逗号后的数字是表示该项字符串要占用的字符宽度，冒号后面的字母是格式说明符。在使用格式说明符时，会检查占位符替换内容的类型是否实现IFormattable接口，如果没有则调用对象的ToString()方法。</p><p>​        在自定义类中实现IFormattable</p><blockquote><pre><code>1 class Program2 &#123;3     static void Main(string[] args)4     &#123;5         Person p = new Person();6         p.FirstName = &quot;zhang&quot;;7         p.SecondName = &quot;san&quot;;8         Console.WriteLine(&quot;无格式说明符：&#123;0&#125;&quot;, p);9         Console.WriteLine(&quot;格式说明符C：&#123;0:C&#125;&quot;, p);10         Console.WriteLine(&quot;格式说明符A：&#123;0:A&#125;&quot;, p);11     &#125;12 13 &#125;14 public class Person : IFormattable15 &#123;16     public string FirstName &#123; get; set; &#125;17     public string SecondName &#123; get; set; &#125;18     public string ToString(string format, IFormatProvider formatProvider)19     &#123;20         //当没有传入格式说明符时，直接调用ToString()21         if (format == null)22         &#123;23             return ToString();24         &#125;25         //C表示返回中国格式名字  A表示返回美国格式名字26         switch (format.ToUpper())27         &#123;28             case &quot;C&quot;:29                 return FirstName + SecondName;30             case &quot;A&quot;:31                 return SecondName + FirstName;32             default:33                 return ToString();34         &#125;35     &#125;36 &#125;</code></pre></blockquote><p>10.2.1字符串插值</p><p>10.2.2日期事件和数字格式</p><p>10.2.3自定义字符串格式</p><p>10.3正则表达式</p><p>​        .NET正则表达式引擎用于兼容Perl 5 的正则表达式</p><p>10.3.1正则表达式概述</p><p>​        正则表达式是一种专门用于字符串处理的语言</p><p>10.3.2RegularExpressionsPlayaround示例</p><blockquote><pre><code>MatchCollection match = Regex.Matches(&quot;happy hapy hay&quot;, &quot;ha.+?y&quot;);foreach (Match item in match)&#123;    Console.WriteLine(&quot;&#123;0&#125;位置，匹配到&#123;1&#125;&quot;, item.Index, item.Value);&#125;Console.ReadKey();</code></pre></blockquote><p>10.3.3显示结果</p><p>10.3.4匹配、组合捕获</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串和正则表达式 </tag>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第九章 运算符和强制类型转换</title>
      <link href="2021/02/20/c/c-10th-09/"/>
      <url>2021/02/20/c/c-10th-09/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第九章-委托、lambda表达式和事件"><a href="#c-语言-第九章-委托、lambda表达式和事件" class="headerlink" title="c#语言 第九章 委托、lambda表达式和事件"></a>c#语言 第九章 委托、lambda表达式和事件</h1><p>9.1引用方法</p><p>​        委托是寻址方法的.NET版本。委托是类型安全的类，它定义了返回类型和参数的类型。委托不仅包含对方法的引用，也可以包含对多个方法的引用。</p><p>​        Lambda表达式与委托直接相关。当参数是委托类型时，就可以使用lambda表达式实现委托引用的方法。</p><p>9.2委托</p><p>​        当要把方法传递给其它方法时，需要使用委托。委托是一种特殊类型的对象，其特殊之处在于，我们以前定义的所有对象都包含数据，而委托包含的只是一个或多个方法的地址。</p><p>9.2.1声明委托</p><p>​    委托使用关键字 delegate 进行定义。</p><p>例子：</p><p>​    定义一个返回类型为void参数为一个int的名为IntMethodInvoker的委托</p><blockquote><p>delegate void IntMethodInvoker(int x);</p></blockquote><p>​    因为定义委托基本上就是定义一个新类，所以可以在定义类的任何相同地方定义委托。可以在委托定义上应用常见的访问修饰符：public、private、protected等。</p><p>9.2.2使用委托</p><p>9.2.3简单的委托示例</p><blockquote><p>delegate int CalculateMethodInvoker(int x, int y);<br>class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        CalculateMethodInvoker calculateMethodInvoker = CalculateMethodHelper.Sum;<br>        int x = 100, y = 200;<br>        Console.WriteLine(“x,y相加：{0}”, Calculate(calculateMethodInvoker, x, y));<br>        calculateMethodInvoker = CalculateMethodHelper.Multiply;<br>        Console.WriteLine(“x,y相乘：{0}”, Calculate(calculateMethodInvoker, x, y));<br>        Console.ReadKey();<br>    }<br>    public static int Calculate(CalculateMethodInvoker calculateMethodInvoker, int x, int y)<br>    {<br>        return calculateMethodInvoker(x, y);<br>    }<br>}<br>public class CalculateMethodHelper<br>{<br>    public static int Sum(int x, int y)<br>    {<br>        return x + y;<br>    }<br>    public static int Multiply(int x, int y)<br>    {<br>        return x * y;<br>    }<br>}</p></blockquote><p>​        为了减少输入量，只需要委托实例，就可以只传递地址的名称。这称为委托推断。</p><p>9.2.4action<T>和Func<T>委托</p><p>​        除了为每个参数和返回类型定义一个新的委托类型外，还可以使用Action<T>和Func<T>委托。</p><p>​        泛型Action<T>委托表示引用一个void返回类型的方法，没有泛型参数的Action类可调用没有参数的方法。</p><p>​        泛型Func<T>委托表示引用一个有返回值的方法</p><p>9.2.5BubbleSorter示例</p><p>9.2.6 多播委托</p><p>​        委托也可以包含多个方法。这种委托成为多播委托。如果调用多播委托，就可以按顺序连续调用多个方法。为此，委托的签名就必须返回void；否则，就只能得到委托调用的最后一个方法的结果。多播委托识别运算符“-”、“+”、“-=”、“+=”以从委托中增加或删除方法调用。</p><blockquote><p>class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        Action&lt;int, int&gt; calFunc = CalculateMethodHelper.Sum;<br>        calFunc += CalculateMethodHelper.Multiply;<br>        int x = 100, y = 200;<br>        Calculate(calFunc, x, y);<br>        Console.ReadKey();<br>    }<br>    public static void Calculate(Action&lt;int, int&gt; calculateMethodInvoker, int x, int y)<br>    {<br>        Console.WriteLine(“运行结果：”);<br>        calculateMethodInvoker(x, y);<br>    }<br>}<br>public class CalculateMethodHelper<br>{<br>    public static void Sum(int x, int y)<br>    {<br>        Console.WriteLine(“x,y相加：{0}”, x + y);<br>    }<br>    public static void Multiply(int x, int y)<br>    {<br>        Console.WriteLine(“x,y相乘：{0}”, x * y);<br>    }<br>}</p></blockquote><p>​        如果通过委托调用的其中一个方法抛出异常，整个迭代就会停止。解决的方法是，使用Delegate类中定义的GetInvocationList()方法获取Delegate对象数组，再使用循环遍历执行，在过程中捕获异常，来继续下一次迭代。</p><p>9.2.7匿名方法</p><p>匿名方法是用作委托的参数的一段代码。</p><blockquote><pre><code>Action&lt;int, int&gt; calFunc = delegate (int i, int j)&#123;    Console.WriteLine(&quot;x,y相加：&#123;0&#125;&quot;, i + j);&#125;;</code></pre></blockquote><p>在匿名方法中不可使用跳转语句（break、goto或continue），在匿名方法内部不能访问不安全代码，不能访问在匿名方法外部使用的ref和out参数。</p><p>9.3lambda表达式</p><p>自C#3.0开始，可以使用新的语法把实现代码赋予委托，只要有委托参数类型的地方，就可以使用lambda表达式。</p><blockquote><pre><code>Action&lt;int, int&gt; calFunc = (i, j) =&gt;&#123;    Console.WriteLine(&quot;x,y相加：&#123;0&#125;&quot;, i + j);&#125;;</code></pre></blockquote><p>9.3.1参数</p><p>lambda表达式有几种定义参数的方式。如果只有一个参数，只写出参数名就足够了。如果除一个参数以外，需要圆括号把参数名括起来。</p><blockquote><p>Action<int> one = i =&gt;<br>{<br>    //方法内容<br>};<br>Action&lt;int, int&gt; two = (i, j) =&gt;<br>{<br>    //方法内容<br>};</p></blockquote><p>9.3.2多行代码</p><p>如果lambda表示只有一条语句，在方法块内就不需要花括号和return语句，因为编译器会隐式添加return</p><blockquote><pre><code>Func&lt;int&gt; lambdaOne = () =&gt; 0;</code></pre></blockquote><p>如果实现代码超过一行，就需要使用return语句显式返回</p><blockquote><p>Func<int> lambdaOne = () =&gt;<br>{<br>    int i = 0;<br>    i++;<br>    ++i;<br>    return i;<br>};</p></blockquote><p>9.3.3闭包</p><p>通过lambda表达式可以访问lambda表达式块外部的变量。这称为闭包。</p><blockquote><p>int param = 10;<br>Action<int> lambdaSecond = (i) =&gt;<br>{<br>    Console.WriteLine(i + param);<br>};<br>lambdaSecond(3);<br>Console.ReadKey();</p></blockquote><p>9.4事件</p><p>事件基于委托，为委托提供了一种发布/订阅机制。</p><blockquote><p>class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        AlarmClock alarmClock = new AlarmClock();<br>        Student zsStudent = new Student(“张三”);<br>        alarmClock.ItsGetUpClockEvent += zsStudent.ItsGetUpClock;<br>        alarmClock.ItsGetUpClock();<br>        Student lsStudent = new Student(“李四”);<br>        WeakEventManager&lt;AlarmClock, EventArgs&gt;.AddHandler(alarmClock, “ItsGetUpClockEvent”, lsStudent.ItsGetUpClock);//弱事件<br>        alarmClock.ItsGetUpClock();<br>        Console.ReadKey();<br>    }</p><p>}<br>//事件发布类<br>public class AlarmClock<br>{<br>    public event EventHandler<EventArgs> ItsGetUpClockEvent;<br>    public void ItsGetUpClock()<br>    {<br>        Console.WriteLine(“时间到，起床了！”);<br>        ItsGetUpClockEvent?.Invoke(this, new EventArgs());<br>    }<br>}<br>//事件侦听类<br>public class Student<br>{<br>    public string Name { get; set; }<br>    public Student(string name)<br>    {<br>        this.Name = name;<br>    }<br>    public void ItsGetUpClock(object sender, EventArgs e)<br>    {<br>        Console.WriteLine(“{0}关掉闹钟，起床了。”,Name);<br>    }<br>}</p></blockquote><p>9.4.1事件发布程序</p><p>9.4.2事件侦听器</p><p>9.4.3弱事件</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运算符和强制类型转换 </tag>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第八章 运算符和强制类型转换</title>
      <link href="2021/02/20/c/c-10th-08/"/>
      <url>2021/02/20/c/c-10th-08/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第八章-运算符和强制类型转换"><a href="#c-语言-第八章-运算符和强制类型转换" class="headerlink" title="c#语言 第八章 运算符和强制类型转换"></a>c#语言 第八章 运算符和强制类型转换</h1><h2 id="本章要点："><a href="#本章要点：" class="headerlink" title="本章要点："></a>本章要点：</h2><p>​    c#中的运算符</p><p>​    使用c#6的新运算符nameof和控制传播</p><p>​    隐式和显示转换</p><p>​    使用装箱技术把值类型转换为引用类型</p><p>​    比较值类型和引用类型</p><p>​    重载标准的运算符以支持自定义类型</p><p>​    实现索引运算符</p><p>​    通过类型强制转换在引用类型之间的转换</p><h2 id="8-1运算符和类型转换"><a href="#8-1运算符和类型转换" class="headerlink" title="8.1运算符和类型转换"></a>8.1运算符和类型转换</h2><h2 id="8-2运算符"><a href="#8-2运算符" class="headerlink" title="8.2运算符"></a>8.2运算符</h2><table><thead><tr><th>类别</th><th>运算符</th></tr></thead><tbody><tr><td>算术运算符</td><td>+ - * / %</td></tr><tr><td>逻辑运算符</td><td>&amp; | ^ ~ &amp;&amp; || !</td></tr><tr><td>字符串连接运算符</td><td>+</td></tr><tr><td>增量和减量运算符</td><td>++ –</td></tr><tr><td>移位运算符</td><td>&lt;&lt; &gt;&gt;</td></tr><tr><td>比较运算符</td><td>== != &lt; &gt; &lt;= &gt;=</td></tr><tr><td>赋值运算符</td><td>= += -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=</td></tr><tr><td>成员访问运算符（用于对象和结构）</td><td>.</td></tr><tr><td>索引运算符（用于数组和索引器）</td><td>[]</td></tr><tr><td>类型转换运算符</td><td>()</td></tr><tr><td>条件运算符（三元运算符）</td><td>?:</td></tr><tr><td>委托连接和删除运算符</td><td>+ -</td></tr><tr><td>对象创建运算符</td><td>new</td></tr><tr><td>类型信息运算符</td><td>sizeof is typeof as</td></tr><tr><td>溢出异常控制运算符</td><td>checked unchecked</td></tr><tr><td>间接寻址运算符</td><td>[]</td></tr><tr><td>名称空间别名限定符</td><td>::</td></tr><tr><td>空合并运算符</td><td>??</td></tr></tbody></table><p>​        有4个运算符（sizeof()、*、-&gt;和&amp;）只能用于不安全的代码（这些代码忽略了c#的类型安全性检查），这些不安全的代码见第五章细节</p><p>​        c#中很少用到指针，因此很少用到间接寻址运算符（-&gt;）。</p><h3 id="8-2-1运算符的简化操作"><a href="#8-2-1运算符的简化操作" class="headerlink" title="8.2.1运算符的简化操作"></a>8.2.1运算符的简化操作</h3><p>​        x+=y等同于x=x+y，赋值运算符中（+= -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=）都是相同的模式。</p><p>​        当x++和++x单独一行时等同于x=x+1。当他们用于较长的表达式内部时，运算符放在前面（++x）会在计算表达式之前增加x。</p><blockquote><p>int x = 0,y=0;</p><p>x++;</p><p>++y;</p><p>if (x==y)</p><p>{</p><p>   Console.WriteLine(“单独一行++在前在后结果一样”);</p><p>}</p><p>if (++x==2)</p><p>{</p><p>   Console.WriteLine(“++在前提前计算”);</p><p>}</p><p>if (y++==2)</p><p>{</p><pre class=" language-c#"><code class="language-c#">Console.WriteLine("++在后没有提前计算");</code></pre><p>}</p></blockquote><h4 id="（1）条件运算符"><a href="#（1）条件运算符" class="headerlink" title="（1）条件运算符"></a>（1）<strong>条件运算符</strong></h4><p>​        条件运算符（?:）也称单元运算符，是if…else的简化形式。它判断一个条件真假来返回对应的值（为真返回:之前的值，为假返回:之后的值）。</p><blockquote><pre><code>int x = 0;string str = x == 0 ? &quot;x等于0&quot; : &quot;x不等于0&quot;;Console.WriteLine(str)</code></pre></blockquote><h4 id="（2）checked运算符和unchecked运算符"><a href="#（2）checked运算符和unchecked运算符" class="headerlink" title="（2）checked运算符和unchecked运算符"></a>（2）<strong>checked运算符和unchecked运算符</strong></h4><p>​        C#提供checked运算符和unchecked运算符，来对一个代码块进行标记，是否执行溢出检查。</p><blockquote><pre><code>byte x = 255;x++;Console.WriteLine(x);</code></pre></blockquote><p>​        运行以上代码，结果如下：</p><p> <img src="https://images2015.cnblogs.com/blog/682781/201703/682781-20170327225436358-244304394.png" alt="img"></p><p>​        这是因为，C#默认使用unchecked运算符不对溢出执行检查，这会导致数据丢失（byte不能超过255，溢出的位会丢失，所以结果为0）。</p><p>​        如果要防止溢出导致的数据丢失，可以使用checked运算符对代码块进行标记。</p><blockquote><p>byte x = 255;</p><p>checked</p><p>{</p><p>   x++;</p><p>}</p><p>Console.WriteLine(x);</p></blockquote><p>​    运行以上代码，结果如下：</p><p> <img src="https://images2015.cnblogs.com/blog/682781/201703/682781-20170327225448951-1311569589.png" alt="img"></p><p>​    程序会抛出异常，这个时候我们就能捕捉异常，来防止溢出丢失数据。</p><h4 id="（3）is运算符"><a href="#（3）is运算符" class="headerlink" title="（3）is运算符"></a><strong>（3）is运算符</strong></h4><p>​        Is运算符检查对象是否与特定类型兼容（是该类型或者派生自该类型）。</p><blockquote><p>int x = 0;</p><p>if (x is object)</p><p>{</p><p>   Console.WriteLine(“x是object类型或派生自object的类型”);</p><p>}</p></blockquote><h4 id="（4）as运算符"><a href="#（4）as运算符" class="headerlink" title="（4）as运算符"></a>（4）<strong>as运算符</strong></h4><p>​        as运算符用于执行引用类型的显式类型转换。如果要转换的类型与指定的类型兼容，转换就会成功；如果不兼容，as运算符就会返回null。</p><blockquote><p>object obj1 = “字符串”;</p><p>object obj2 = 0;</p><p>string str1 = obj1 as string;</p><p>string str2 = obj2 as string;</p><p>Console.WriteLine(“obj1 as string转换结果：” + str1);</p><p>Console.WriteLine(“obj2 as string转换结果：” + str2);</p></blockquote><p>​        运行以上代码，结果如下：</p><p> <img src="https://images2015.cnblogs.com/blog/682781/201703/682781-20170327225525951-930522724.png" alt="img"></p><p>​        as运算符允许在一步中执行安全的类型转换，不需要先使用is运算符测试类型，再执行转换。</p><h4 id="（5）sizeof运算符"><a href="#（5）sizeof运算符" class="headerlink" title="（5）sizeof运算符"></a>（5）<strong>sizeof运算符</strong></h4><p>​        使用sizeof运算符可以确定栈中值类型的长度（单位是字节）：</p><blockquote><pre><code>Console.WriteLine(sizeof(int));//4</code></pre></blockquote><h4 id="（6）typeof运算符"><a href="#（6）typeof运算符" class="headerlink" title="（6）typeof运算符"></a>（6）<strong>typeof运算符</strong></h4><p>​        typeof运算符返回一个表示特定类型的System.Type对象。例如，typeof(string)返回表示System.String类型的Type类型。在使用反射技术动态地查找对象的信息时，这个运算符很有用。</p><h4 id="7-nameof运算符"><a href="#7-nameof运算符" class="headerlink" title="(7)nameof运算符"></a>(7)nameof运算符</h4><p>​        nameof是新的c#6运算符，该运算符接受一个符号、属性或方法，并返回其名称</p><h4 id="8-index运算符"><a href="#8-index运算符" class="headerlink" title="(8)index运算符[]"></a>(8)index运算符[]</h4><blockquote><p>int x = arr[2];</p></blockquote><h4 id="9-可空类型和运算符"><a href="#9-可空类型和运算符" class="headerlink" title="(9)可空类型和运算符"></a>(9)可空类型和运算符</h4><p>如果在程序中使用可空类型，就必须考虑null值与各种运算符一起使用时的影响。</p><blockquote><pre><code>int? x = null;int? y = x + 1;//null</code></pre></blockquote><h4 id="10-空合并运算符"><a href="#10-空合并运算符" class="headerlink" title="(10)空合并运算符"></a>(10)<strong>空合并运算符</strong></h4><p>​        空合并运算符（??）提供了一种快捷方式，可以在处理可空类型和引用类型时表示null可能的值。</p><p>例子：</p><blockquote><p>int? x = null;</p><p>int y;</p><p>y = x ?? 0;</p><p>Console.WriteLine(y);</p></blockquote><h4 id="11-空值传播运算符"><a href="#11-空值传播运算符" class="headerlink" title="(11)空值传播运算符"></a>(11)空值传播运算符</h4><blockquote><p>public void ShowPerson(Person p){</p><p>​    string firstName = p?.FirstName;</p><p>}</p></blockquote><h3 id="8-2-2运算符的优先级和关联性"><a href="#8-2-2运算符的优先级和关联性" class="headerlink" title="8.2.2运算符的优先级和关联性"></a>8.2.2运算符的优先级和关联性</h3><p>优先级由上到下依次递减</p><table><thead><tr><th>组</th><th>运算符</th></tr></thead><tbody><tr><td>初级运算符</td><td>() . [] x++ x– new typeof sizeof checked unchecked</td></tr><tr><td>一元运算符</td><td>+ - ! ~ ++x –x 和数据类型强制转换</td></tr><tr><td>乘除运算符</td><td>* / %</td></tr><tr><td>加减运算符</td><td>+ -</td></tr><tr><td>移位运算符</td><td>&lt;&lt; &gt;&gt;</td></tr><tr><td>关系运算符</td><td>&lt; &gt; &gt;= &lt;= is as</td></tr><tr><td>比较运算符</td><td>== !=</td></tr><tr><td>按位AND运算符</td><td>&amp;</td></tr><tr><td>按位XOR运算符</td><td>^</td></tr><tr><td>按位OR运算符</td><td>|</td></tr><tr><td>布尔AND运算符</td><td>&amp;&amp;</td></tr><tr><td>布尔OR运算符</td><td>||</td></tr><tr><td>条件运算符</td><td>?:</td></tr><tr><td>赋值运算符</td><td>= += -= *= /= %= &amp;= |= ^= &lt;&lt;== &gt;&gt;= &gt;&gt;&gt;=</td></tr></tbody></table><p>​        除了运算符优先级外，对于二元运算符，需要注意运算符是从左到右还是从右到左计算，除了少数运算符外，所有的运算符都是做关联的。例如</p><blockquote><p>x+y+z  就等于 （x+y）+z</p></blockquote><p>​        <strong>关联性的重要例外就是赋值运算符，他们是右关联的</strong>。例如</p><blockquote><p>x=y=z=3  从右向左赋值，所以x、y、z的值都是3</p></blockquote><p>​        <strong>一个重要的，可能误导的有关联运算符是条件运算符</strong></p><blockquote><p>a?b:c?d:e   </p><p>等于</p><p>a=b:(c?d:e)</p></blockquote><p>​        在复杂的表达式中，应避免利用运算符优先级来生成正确的结果，使用圆括号制定运算符的执行顺序，可以是代码更整洁，避免出现潜在的冲突。</p><h2 id="8-3类型的安全性"><a href="#8-3类型的安全性" class="headerlink" title="8.3类型的安全性"></a>8.3类型的安全性</h2><p>​        c#也支持不同引用类型之间的转换，在与其他类型相互转换时还允许定义所创建的数据类型的行为方式，</p><h3 id="8-3-1类型转换"><a href="#8-3-1类型转换" class="headerlink" title="8.3.1类型转换"></a>8.3.1类型转换</h3><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>​        只要保证值不会发生任何变化，类型转换就可以自动（隐式）进行。当值的数量级不受影响，而精度可能受到影响时，也可以进行隐式转换，因为编译器认为这是可以接受的错误。</p><h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><p>​        当无法保证值不会发生任何变化时，就需要使用显式转换，否则编译器会报错。</p><p>例子：</p><p>​        long类型无法隐式的转换为int，但我们可以显式地进行转换</p><blockquote><pre><code>long lon = 1;int i = (int)lon;</code></pre></blockquote><p>​        显式转换是一种比较危险的操作，因为有可能造成溢出，这样导致结果与正确值不同。在进行隐式转换时，应使用checked运算符进行检查。</p><h3 id="8-3-2装箱和拆箱"><a href="#8-3-2装箱和拆箱" class="headerlink" title="8.3.2装箱和拆箱"></a>8.3.2装箱和拆箱</h3><p>​    装箱用于描述一个值类型转换为引用类型</p><blockquote><pre><code>int i = 100;object obj = i;</code></pre></blockquote><p>​    拆箱用于描述相反的过程，其中以前装箱的值类型强制转换回值类型</p><blockquote><pre><code>int i = 100;object obj = i;int _i = (int)obj;</code></pre></blockquote><h2 id="8-4比较对象的相等性"><a href="#8-4比较对象的相等性" class="headerlink" title="8.4比较对象的相等性"></a>8.4比较对象的相等性</h2><p>​        对象相等的机制有所不同，这取决于比较的是引用类型（类的实例）还是值类型（基本数据类型、结构或枚举的实例）</p><h3 id="8-4-1比较引用类型的相等性"><a href="#8-4-1比较引用类型的相等性" class="headerlink" title="8.4.1比较引用类型的相等性"></a>8.4.1比较引用类型的相等性</h3><p>（1）<strong>ReferenceEquals()方法</strong></p><p>​        ReferenceEquals()是一个静态方法，测试两个引用是否引用类的同一个实例，特别是两个引用是否包含内存中的相同地址。最为静态方法，它不可重写。</p><blockquote><p>Person p1, p2;</p><p>p1 = new Person();</p><p>p2 = new Person();</p><p>bool b1 = ReferenceEquals(null, null);</p><p>bool b2 = ReferenceEquals(null, p1);</p><p>bool b3 = ReferenceEquals(p1, p2);</p><p>Console.WriteLine(“ReferenceEquals(null, null) 的结果：{0}”, b1);</p><p>Console.WriteLine(“ReferenceEquals(null, p1) 的结果：{0}”, b2);</p><p>Console.WriteLine(“ReferenceEquals(p1, p2) 的结果：{0}”, b3);</p></blockquote><p>（2）<strong>虚拟的Equals()方法</strong></p><p>​        Equals()方法是虚拟方法，所以可以在自己的类中重写，从而按值来比较对象。</p><p>（3）<strong>静态的Equals()方法</strong></p><p>Equals()静态版本与其虚拟实例版本的作用相同，其区别是静态版本带有两个参数，并对它们进行相等性比较。</p><p>（4）<strong>比较运算符==</strong></p><p>​    最好将比较运算符看作严格的值比较和严格的引用比较之间的中间选项</p><h3 id="8-4-2比较值类型的相等性"><a href="#8-4-2比较值类型的相等性" class="headerlink" title="8.4.2比较值类型的相等性"></a>8.4.2比较值类型的相等性</h3><p>​        在比较值类型的相等性时，采用与引用类型相同的规则：ReferenceEquals()用于比较引用，Equals()用于比较值，比较运算符可以看作一个中间选项。但最大的区别是值类型需要进行装箱，才能把它们转换为引用类型，进而才能对它们执行方法。</p><p>​        在System.ValueType类中重载了实例方法Equals()，以便对值类型进行合适的相等性测试。</p><h2 id="8-5运算符重载"><a href="#8-5运算符重载" class="headerlink" title="8.5运算符重载"></a>8.5运算符重载</h2><p>​        如果要对自定义的类使用运算符，就必须告诉编译器相关的运算符在这个类的上下文中的含义，此时就需要使用运算符重载。</p><p>​        C#要求所有的运算符重载都声明为public和static，这表示它们与它们的类相关联而不是特定实例。重载运算符需要使用operator关键字。编译器处理运算符重载和处理方法重载是一样的。C#要求成对的重载比较运算符，且必须返回布尔值。</p><blockquote><p>public static decimal operator +(Person lhs, Person rhs)</p><p>{</p><pre><code>return lhs.Money + rhs.Money;</code></pre><p>}</p></blockquote><h3 id="8-5-1运算符的工作方式"><a href="#8-5-1运算符的工作方式" class="headerlink" title="8.5.1运算符的工作方式"></a>8.5.1运算符的工作方式</h3><p>​        它们会根据参数类型查找最匹配的运算符重载。</p><h3 id="8-5-2运算符重载的示例"><a href="#8-5-2运算符重载的示例" class="headerlink" title="8.5.2运算符重载的示例"></a>8.5.2运算符重载的示例</h3><h3 id="8-5-3比较运算符的重载"><a href="#8-5-3比较运算符的重载" class="headerlink" title="8.5.3比较运算符的重载"></a>8.5.3比较运算符的重载</h3><h3 id="8-5-4可以重载的运算符"><a href="#8-5-4可以重载的运算符" class="headerlink" title="8.5.4可以重载的运算符"></a>8.5.4可以重载的运算符</h3><table><thead><tr><th>类别</th><th>运算符</th><th>限制</th></tr></thead><tbody><tr><td>算术二元运算符</td><td>+、*、/、-、%</td><td>无</td></tr><tr><td>算术一元运算符</td><td>+、-、++、–</td><td>无</td></tr><tr><td>按位二元运算符</td><td>&amp;、|、^、&lt;&lt;、&gt;&gt;</td><td>无</td></tr><tr><td>按位一元运算符</td><td>!、~、true、false</td><td>true和false运算符必须成对重载</td></tr><tr><td>比较运算符</td><td>==、!=、&gt;=、&lt;、&lt;=、&gt;</td><td>比较运算符必须成对重载</td></tr><tr><td>赋值运算符</td><td>+=、-=、*=、/=、&gt;&gt;=、&lt;&lt;=、%=、&amp;=、|=、^=</td><td>不能显式地重载这些运算符，在重写单个运算符（如+、-等）时，它们会被隐式地重写</td></tr><tr><td>索引运算符</td><td>[]</td><td>不能直接重载索引运算符。索引器成员类型允许在类和结构上支持索引运算符。</td></tr><tr><td>数据类型强制转换运算符</td><td>()</td><td>不能直接重载类型强制运算符。用户定义的类型强制转换允许定义定制的类型强制转换。</td></tr></tbody></table><p>8.6实现自定义的索引运算符</p><p>​    可以给自定义类创建一个索引器，索引器看起来非常类似于属性，因为它也包含get和set访问器。指定索引器要使用this关键字，this关键字后面的括号指定索引使用的类型。数组体用int类型的索引器，所以这里使用int类型直接把信息传递给包含的数组people。</p><blockquote><p>public Person this[int index]{</p><p>​    get{return _people[index];}</p><p>​    set{_people[index]=value;}</p><p>}</p></blockquote><p>​        对于索引器，不能仅定义int类型作为索引类型。任何类型都是有效的。例如：</p><blockquote><p>public IEnumerable<Person> this[DateTime birthday]{</p><p>​    get{ return _people.where(p=&gt;p.Birthday ==birthday);}</p><p>}</p></blockquote><p>8.7实现用户定义的类型强制转换</p><p>​        C#允许定义自己的数据类型（结构和类），这意味着需要某些工具支持在自定义的数据类型之间进行类型转换。方法是把类型强制转换运算符定义为相关类的成员运算符，类型强制装换运算符必须标记为隐式或显式，以说明希望如何使用它。我们应遵守与预定义的类型强制转换相同的规则，如果知道无论在元变量中存储什么值，类型强制转换总是安全的，就可以把它定义为隐式强制转换。然而，如果某些数值可能会出错，如丢失数据或抛出异常，就应把数据类型转换定义为显式强制转换。</p><p>例子：</p><p>显式关键字explicit，隐式关键字implicit</p><blockquote><p>class Program</p><p>{</p><pre><code>static void Main(string[] args)&#123;    Water water = new Water(100);        Ice ice = (Ice)water;//Water显示转换为Ice        Water water2 = ice;//Ice隐式转换为Water        Console.ReadKey();&#125;</code></pre><p>}</p><p>public class Water</p><p>{</p><pre><code>public int Volume &#123; get; set; &#125;public Water(int volume)&#123;    this.Volume = volume;&#125;public static explicit operator Ice(Water lhs)&#123;    return new Ice(lhs.Volume+1);&#125;</code></pre><p>}</p><p>public class Ice</p><p>{</p><pre><code>public int Volume &#123; get; set; &#125;public Ice(int volume)&#123;    this.Volume = volume;&#125;public static implicit operator Water(Ice lhs)&#123;    return new Water(lhs.Volume-1);&#125;</code></pre><p>}</p></blockquote><p>​    定义不同结构或类的实例之间的类型强制转换时完全合法的，但有两个限制：</p><ul><li>如果某个类派生自另一个类，就不能定义这两个类之间的类型强制转换（这些类型的类型转换已经存在）。</li><li>类型强制转换必须在源数据类型或目标数据类型的内部定义。</li></ul><p>​     C#要求把类型强制转换的定义放置在源类（或结构）或目标类（或结构）的内部。它的副作用是不能定义两个类之间的类型强制转换，除非至少可以编辑其中一个类的源代码。这是因为，这样可以防止第三方把类型转换引入类中。</p><p>8.7.1实现用户定义的类型强制转换</p><p>类之间的强制转换</p><p>基类和派生类之间的类型强制转换</p><p>装箱和拆箱类型强制转换</p><p>8.7.2多重类型强制转换</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运算符和强制类型转换 </tag>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第七章 数组和元祖</title>
      <link href="2021/02/19/c/c-10th-07/"/>
      <url>2021/02/19/c/c-10th-07/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第七章-数组和元祖"><a href="#c-语言-第七章-数组和元祖" class="headerlink" title="c#语言 第七章 数组和元祖"></a>c#语言 第七章 数组和元祖</h1><h2 id="7-1-同一类型Array和不同类型Tuple的多个对象"><a href="#7-1-同一类型Array和不同类型Tuple的多个对象" class="headerlink" title="7.1 同一类型Array和不同类型Tuple的多个对象"></a>7.1 同一类型Array和不同类型Tuple的多个对象</h2><p>​        对于同一个类型的多个对象，我们可以使用集合和数组。</p><p>​        C#用特殊的记号声明、初始化和使用数组。Array类在后台发挥作用，它为数组中元素的排序和过滤提供了几个方法。使用枚举器，就可以迭代数组中的所有元素。</p><p>​        对于不同类型的多个对象，可以使用Tuple（元组）类型。</p><h2 id="7-2简单数组"><a href="#7-2简单数组" class="headerlink" title="7.2简单数组"></a>7.2简单数组</h2><p>​        数组是一种数据结构，可以包含统一类型的多个元素。</p><h3 id="7-2-1数组的声明"><a href="#7-2-1数组的声明" class="headerlink" title="7.2.1数组的声明"></a>7.2.1数组的声明</h3><p>​        在声明数组时，应先定义元素的类型，其后是一对空方括号，后面是变量名</p><h3 id="7-2-2数组的初始化"><a href="#7-2-2数组的初始化" class="headerlink" title="7.2.2数组的初始化"></a>7.2.2数组的初始化</h3><p>​        在声明了数组之后，我们需要为数组的元素分配内存。因为数组时引用类型，所以我们必须用new来给它分配堆上的内存。使用new运算符，制定数组中元素的类型和数量来初始化数组的变量</p><blockquote><p>int[] myArray ;//声明数组</p><p>myArray = new int [4]；//分配内存</p><p>int[] myArray = new int [4]{1,2,3,4};</p><p>//如果我们在声明时使用初始化器为数组赋值，那就可以不必指定数组的大小，因为编译器会自动统计元素的个数</p><p>int[] myArray = new int []{1,2,3,4};</p><p>int[] myArray = {1,2,3,4}; //简化写法</p></blockquote><p><strong>如果你不知道数组应包含多少个元素个数，那你应该用集合而不是数组。</strong></p><h3 id="7-2-3访问数组元素"><a href="#7-2-3访问数组元素" class="headerlink" title="7.2.3访问数组元素"></a>7.2.3访问数组元素</h3><p>​        访问数组元素的下标都是从0开始，0代表第一个数组元素。</p><p><img src="https://img-blog.csdnimg.cn/2020050810080638.png" alt="img"></p><blockquote><p>int[] myArray = new int[]{1,2,3,4};</p><p>int v1 = myArray[0];</p><p>myArray[2]=5;</p></blockquote><h3 id="7-2-4使用引用类型"><a href="#7-2-4使用引用类型" class="headerlink" title="7.2.4使用引用类型"></a>7.2.4使用引用类型</h3><p>​        数组不仅可以声明值类型的元素，还可以声明引用类型的元素，而且往往使用引用类型的元素还挺常见。</p><p>​        要注意的是，使用引用类型如类类型，那你需要为该类型里面的每个元素分配内存，都要初始化值。</p><blockquote><p>public class Person<br>{<br>   public string name;<br>   public int age;</p><p>   public void GETAge()<br>   {<br>       DO…..<br>   }<br>}</p><p>public class M<br>{<br>   // 使用类的实例作为数组元素<br>   Person[] myPerson= new Person[2];</p><pre class=" language-c#"><code class="language-c#">// 每次初始化都是初始化这个对象myPerson[0] = new Person&#123; name = "马云"，age = 55&#125;;myPerson[1] = new Person&#123; name = "totoro"，age = 18&#125;;</code></pre><p>}</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200508100700528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RPVE9MT0c=,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="7-3多维数组"><a href="#7-3多维数组" class="headerlink" title="7.3多维数组"></a>7.3多维数组</h2><p>  <strong>声明数组后，就不能修改其阶数了</strong></p><blockquote><p>int[,] arr2 = new int[1, 2];<br>int[,,] arr3 = new int[2,2,2] {<br>                                {<br>                                    {1,2 },   //0,0,0 - 0,0,1<br>                                    {3,4 }    //0,1,0 - 0,1,1<br>                                },<br>                                {<br>                                    {5,6 },   //1,0,0 - 1,0,1<br>                                    {7,8 }    //1,1,0 - 1,1,1<br>                                }<br>                               };</p><p>Console.WriteLine(arr3[0, 0, 0]);  // 输出1<br>Console.WriteLine(arr3[0, 1, 0]);  // 输出3</p></blockquote><h2 id="7-4锯齿数组"><a href="#7-4锯齿数组" class="headerlink" title="7.4锯齿数组"></a>7.4锯齿数组</h2><p><img src="https://img-blog.csdnimg.cn/20200508104822207.png" alt="img"></p><blockquote><p>{<br>    // 声明一个3维的锯齿数组，最外维包有2个2维<br>    int[][][] arr = new int[2][][];</p><pre class=" language-c#"><code class="language-c#">// 表示最外围的第一个二维数组，该2为数组包含3个一维数组arr[0] = new int[3][]; // 表示中间的第一个一维数组，该一维数组包含2个元素arr[0][0] = new int[3] &#123; 1,2,3&#125;;arr[0][1] = new int[5] &#123; 4,5,6,7,8&#125;;arr[0][2] = new int[2] &#123; 9,10&#125;; // 验证，输出7Console.WriteLine(arr[0][1][3]);     </code></pre><p>}</p></blockquote><h2 id="7-5Array类"><a href="#7-5Array类" class="headerlink" title="7.5Array类"></a>7.5Array类</h2><p>​        上面声明数组都是通过Array类来实现的，就是说使用[]就是使用Array类的表示法。c#语法，会创建一个派生自抽象类基类Array类的新类。</p><p>​        Length属性和foreach语句迭代数组，其实是使用了Array类中的GetEnumerator()方法。</p><p>​        <strong>如果数组中包含的元素个数超过了整数范围，就可以使用LongLength属性获得元素个数。</strong></p><h3 id="7-5-1创建数组"><a href="#7-5-1创建数组" class="headerlink" title="7.5.1创建数组"></a>7.5.1创建数组</h3><p>​        Array类是一个抽象类，所以不能用构造函数来创建数组。</p><p>​        除了我们常规类如上面的[]创建数组,还有一种方法可以创建数组，那就是使用静态方法CreateInstance( )创建数组。如果你开始不知道数组的类型，那这方法就显得非常有用了。</p><p>​        <strong>CreateInstance()方法有许多重载版本，可以创建多维数组和不基于0的数组。</strong></p><blockquote><p>int[] lengths = { 2, 3 };<br>int[] lowerBounds = { 1, 10 };</p><p>// lengths 表示你要创建一个2*3维的数组，不能创建锯齿数组<br>// lowerBounds表示自定义每个维度的初始下标，默认是0开始，这里最外围自定义最小是1，最里维是从10开始<br>Array arr = Array.CreateInstance(typeof(string), lengths, lowerBounds);</p><p>// 给这个2维数组赋值<br>arr.SetValue(“A”, 1, 10); // 就相当于[0,0]<br>arr.SetValue(“B”, 1, 11);<br>arr.SetValue(“C”, 1, 12);<br>arr.SetValue(“D”, 2, 10); // 就相当于[1,0]<br>arr.SetValue(“E”, 2, 11);<br>arr.SetValue(“F”, 2, 12); // 就相当于[1,2]</p><p>// 对于Array类型的我们不能直接输出Console.Write(arr[1][11])，需要通过遍历数组<br>System.Collections.IEnumerator arr1  = arr.GetEnumerator();</p><p>// arr1.Rank得到数组的维度，这里arr1.Rank - 1得到1，即0-1<br>// arr1.GetLength(1),表示第二维上有几个元素<br>// arr1.MoveNext()表示是否存在元素<br>while (arr1.MoveNext())<br>{<br>   // 存在就输出该元素值<br>   Console.Write(“\t{0}”, arr1.Current);<br>}</p></blockquote><h3 id="7-5-2复制数组"><a href="#7-5-2复制数组" class="headerlink" title="7.5.2复制数组"></a>7.5.2复制数组</h3><p>​        因为数组是引用类型，所以将一个数组变量赋予另一个数组的变量，就会得到两个引用同一数组的变量。就是在栈上有两个引用的值都是一个堆上的某个地址。而复制数组，会使数组实现ICloneable接口。这个接口定义的Clone( )方法会创建数组的浅表副本。如：</p><blockquote><p>{<br>    int[] arr = {1,2,3，4,5};</p><pre><code>// 实现浅表复制（只动栈），对于引用类型复制引用而不动到对象，对于值类型直接复制值int[] arr1 = (int[])arr.Clone(); // 还有一种是复制堆对象数据 int[] arr2 = new int[3]; Array.Copy(arr, arr2, arr2.Length);</code></pre><p>}</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200508144252355.png" alt="img">    </p><p>​        如果元素是值类型，就会赋值所有值</p><p><img src="https://img-blog.csdnimg.cn/20200508144212691.png" alt="img"></p><p><strong>除了Clone()方法之外，还可以使用Array.Copy()方法创建浅表副本。但clone和copy的一个重要区别：</strong></p><p>​    clone会创建一个新数组</p><p>​    copy方法必须传递阶数相同且有足够元素的已有数组</p><h3 id="7-5-3排序"><a href="#7-5-3排序" class="headerlink" title="7.5.3排序"></a>7.5.3排序</h3><p>​        Array使用Quicksort算法对数组中的元素进行排序。Sort方法需要数组中元素实现IComparable接口。例如简单类型 string和int32实现IComparable接口，所以可以对包含这些类型的元素排序</p><blockquote><p>{<br>    int[] arr = { 5, 2, 1,4,3 };<br>    string[] brr = { “H”, “U”, “A”, “N”, “Z” };</p><pre><code>// 无论数字还是字符串都从小到大输出（对字符串判断首字母）Array.Sort(arr);Array.Sort(brr);</code></pre><p>}</p></blockquote><p>​        对于我们自定义的类类型数组也是可以排序的，但是一定要注意，使用自定义类做排序，那么这个自定义类一定要是实现Icomparable&lt;自定义类名&gt; 这个接口的</p><blockquote><p>public  class Class1: IComparable<Class1><br>{<br>     // 姓<br>     public string FirstName { get; set; }</p><pre><code>// 名public string LastName &#123; get; set; &#125; // 别忘了重写Tostring(),这样你才能狗输出字符串内容public override string ToString() =&gt; $&quot;&#123;FirstName&#125; &#123;LastName&#125;&quot;; // 也前往别忘了要实现接口public int CompareTo(Class1 other)&#123;    if (other == null) throw new ArgumentNullException(&quot;other&quot;);     // 比较 姓 先,不一致默认返回1，一致默认返回0    int result = FirstName .CompareTo(other.FirstName );    if (result == 0)    &#123;        result = LastName.CompareTo(other.LastName);    &#125;    return result;&#125;</code></pre><p>}</p><p>public class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        Class1[] arr = new Class1[]<br>        {<br>            new Class1 { FirstName=”马”, LastName=”云” },<br>            new Class1 { FirstName=”马”, LastName=”化腾” },<br>            new Class1 { FirstName=”李”, LastName=”庆国” },<br>            new Class1 { FirstName=”董”, LastName=”明珠” },<br>            new Class1 { FirstName=”宗”, LastName=”庆后” }<br>        }</p><pre><code>    // 进行排序，会触发CompareTo    Array.Sort(arr);         // 输出结果    foreach (var a in arr)    &#123;        Console.WriteLine(a);    &#125;    &#125;</code></pre><p>}</p></blockquote><h2 id="7-6数组作为参数"><a href="#7-6数组作为参数" class="headerlink" title="7.6数组作为参数"></a>7.6数组作为参数</h2><h3 id="7-6-1数组协变"><a href="#7-6-1数组协变" class="headerlink" title="7.6.1数组协变"></a>7.6.1数组协变</h3><p>​        数组支持协变，表示数组可以声明为基类，其派生类型的元素可以赋予数组元素。我们可以把自定义的Class1类数组赋值给object数组，因为Class1派生自object，这就是数组协变的表示，数组协变只能用于引用类型，不能用于值类型！！！如：</p><blockquote><p>// 接着上面代码<br>public class Program<br>{<br>    public static void DispalyArray(object[] data)<br>    {<br>        DO……<br>    }</p><pre><code>DispalyArray(arr);</code></pre><p>}</p></blockquote><h3 id="7-6-2ArraySegment"><a href="#7-6-2ArraySegment" class="headerlink" title="7.6.2ArraySegment"></a>7.6.2ArraySegment<T></h3><p>​        结构ArraySegment<T>表示数组的一个部分。如果需要使用不同的方法处理某个大型数组的不同部分，那么可以把相应的数组部分传到各个方法中。具体的使用如下：</p><blockquote><p>public class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        int[] ar1 = { 1, 4, 5, 11, 13, 18 };<br>        int[] ar2 = { 3, 4, 5, 18, 21, 27, 33 };</p><pre><code>    // 我们可以将一个数组或者多个数组的部分传给某个函数做处理    var segments = new ArraySegment&lt;int&gt;[2]    &#123;        new ArraySegment&lt;int&gt;(ar1, 0, 3),        new ArraySegment&lt;int&gt;(ar2, 3, 3)    &#125;         SumOfSegments(segments);&#125; static void SumOfSegments(ArraySegment&lt;int&gt;[] segments)&#123;    foreach (var segment in segments)    &#123;        for (int i = segment.Offset; i &lt; segment.Offset + segment.Count; i++)        &#123;            Console.WriteLine(segment.Array[i]);        &#125;    &#125;&#125;</code></pre><p>}</p></blockquote><p>​        来了来了，动脑的地方来了，数组段不复制原数组的元素，但是原数组可以通过ArraySegment<T>访问。如果数组段中的元素改变了，这些变化就会反映到原数组中。如：</p><blockquote><p>// 接着上面的代码，我们改一下：<br>{<br>        static void SumOfSegments(ArraySegment<int>[] segments)<br>        {<br>            foreach (var segment in segments)<br>            {<br>                for (int i = segment.Offset; i &lt; segment.Offset + segment.Count; i++)<br>                {<br>                    // 改一下这里，改一下数组的值<br>                    segment.Array[i] = 998 ;<br>                }</p><pre><code>        &#125;                &#125;         // 在最后    foreach (var a in ar1)    &#123;        Console.WriteLine(a);    &#125;</code></pre><p>}</p></blockquote><p>​        </p><h2 id="7-7枚举-foreach"><a href="#7-7枚举-foreach" class="headerlink" title="7.7枚举 foreach"></a>7.7枚举 foreach</h2><h3 id="7-7-1IEnumrtator接口"><a href="#7-7-1IEnumrtator接口" class="headerlink" title="7.7.1IEnumrtator接口"></a>7.7.1IEnumrtator接口</h3><p>​        在上面谈Array类的时候，代码中我们有用到这么一个方法——GetEnumerator( )，数组或集合都有实现带GetEnumerator()方法的IEumerator接口。调用了foreach方法的客户端和集合之间的关系显示如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200509104613177.png" alt="img"></p><p>​    IEumerator定义了current属性，来返回光标所在的元素，改接口的MoveNext( )方法移动到集合的下一个元素上，如果有这个元素，就返回true，否则返回false。</p><p>​    这个接口的泛型版本IEnumerator<T>派生自IDispossable,因此定义了Dispose()方法，来清理给枚举器分配的资源。</p><h3 id="7-7-2foreach语句"><a href="#7-7-2foreach语句" class="headerlink" title="7.7.2foreach语句"></a>7.7.2foreach语句</h3><p>​        foreach语句的实现并不真的需要在集合类中实现这个接口，它只需要通过一个名为GetEnumerator( )的方法，它返回实现了IEumerator接口就足够了</p><h3 id="7-7-3yield语句"><a href="#7-7-3yield语句" class="headerlink" title="7.7.3yield语句"></a>7.7.3yield语句</h3><p>​        c#2.0添加了yield语句，以便于创建枚举器。</p><p>​        yield return 语句返回集合的一个元素，并移动到下一个元素上，yield break可停止迭代。</p><blockquote><p>using System;</p><p>using System.Collections;</p><p>namespace Wrox.ProCSarp.Arrays{</p><p>​    public class HelloCollection{</p><p>​        public IEnumerator<string>  GetEnumerator(){</p><p>​            yield return “Hello”,</p><p>​            yield return “world”,</p><p>​        }</p><p>​    }</p><p>}</p></blockquote><p>​        迭代集合的不同方式</p><p>​        用yield return返回枚举器</p><h2 id="7-8元祖"><a href="#7-8元祖" class="headerlink" title="7.8元祖"></a>7.8元祖</h2><p>​        来讲讲元组吧，前面一直在说数组(同类型)，元组就是支持不同类型的元素。</p><p>​        元组的使用和数组不同，数组是new创建的，元组不是，且元组一直都是作为方法的类型。例如Tuple<T1>包含一个元素，Tuple&lt;T1,T2&gt;包含两个元素，以此类推。元组用静态的Create( )方法创建。Create( )方法的泛型参数定义了要实例化的元组类型。如：</p><blockquote><p> public class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        int[] a = { 1, 2, 3, 4, 5 };<br>        string b = “HeeloWorld!”;</p><pre><code>    var result = TT(a,b);&#125; // 通过Item取对应的类型值foreach (var i in result.Item1)&#123;    Console.WriteLine(i);&#125; // 元组可接纳不同类型的参数，返回不同类型的结果static Tuple&lt;int[], string&gt; SumOfSegments(int[] a,string b)&#123;    // Tuple.Create将计算结果打包成元组返回去    return Tuple.Create(a, b);&#125;</code></pre><p>}</p></blockquote><h2 id="7-9结构比较"><a href="#7-9结构比较" class="headerlink" title="7.9结构比较"></a>7.9结构比较</h2>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组和元祖 </tag>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第六章 泛型</title>
      <link href="2021/02/18/c/c-10th-06/"/>
      <url>2021/02/18/c/c-10th-06/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第六章-泛型"><a href="#c-语言-第六章-泛型" class="headerlink" title="c#语言 第六章 泛型"></a>c#语言 第六章 泛型</h1><h2 id="6-1泛型概述"><a href="#6-1泛型概述" class="headerlink" title="6.1泛型概述"></a>6.1泛型概述</h2><p>​        有了泛型就可以创建独立于被包含类型的类和方法，不必给不同的类型编写功能相同的许多方法或类，只创建一个方法和类即可</p><p>​        另一个减少代码的选项是使用object类，但使用派生自object类的类型进行传递不是类型安全的</p><p>​        泛型使用泛型类型，根据需要用特定的类型替换泛型类型，保证了类型安全性</p><h3 id="6-1-1-性能"><a href="#6-1-1-性能" class="headerlink" title="6.1.1 性能"></a>6.1.1 性能</h3><p>​        对值类型使用非泛型集合类，则在把值类型转换为引用类型和把引用类型转换为值类型时，需要进行装箱和拆箱操作。操作很容易，但是性能损失比较大，遍历许多项时尤其如此。</p><p>​        使用List<T>定义泛型为int时，就不需要再进行装箱和拆箱操作。</p><h3 id="6-1-2类型安全"><a href="#6-1-2类型安全" class="headerlink" title="6.1.2类型安全"></a>6.1.2类型安全</h3><p>​        泛型类List<T>中，泛型类型T定义了允许使用过的类型，有了List<int> 的定义，就只能把证书类型添加到集合中。</p><h3 id="6-1-3二进制代码的重用"><a href="#6-1-3二进制代码的重用" class="headerlink" title="#6.1.3二进制代码的重用"></a>#6.1.3二进制代码的重用</h3><p>​        泛型允许更好的重用二进制代码，泛型类可以定义一次，并且可以用许多不同的类型实例化。</p><h3 id="6-1-4代码的扩展"><a href="#6-1-4代码的扩展" class="headerlink" title="6.1.4代码的扩展"></a>6.1.4代码的扩展</h3><p>​        JIT编译器会把泛型类型编译为本地代码时，会给每个值类型创建一个新类</p><h3 id="6-1-5命名约定"><a href="#6-1-5命名约定" class="headerlink" title="6.1.5命名约定"></a>6.1.5命名约定</h3><p>​        泛型类型的命名名称用字母T作为前缀</p><p>​        如果没有特需要求，泛型类型允许用任意类代替</p><p>​        如果泛型类型有特殊要求，（必须实现一个借口）或使用多个泛型类型，就应给泛型类型使用描述性的名称</p><h2 id="6-2创建泛型类"><a href="#6-2创建泛型类" class="headerlink" title="6.2创建泛型类"></a>6.2创建泛型类</h2><p>​    每个处理兑现类型的类都可以有泛型的实现方式，另外，如果类使用了层次结构，泛型就非常有助于消除类型强制转换操作</p><h2 id="6-3泛型类的功能"><a href="#6-3泛型类的功能" class="headerlink" title="6.3泛型类的功能"></a>6.3泛型类的功能</h2><h3 id="6-3-1默认值"><a href="#6-3-1默认值" class="headerlink" title="6.3.1默认值"></a>6.3.1默认值</h3><p>​    不能把null赋值非泛型类型，因为泛型类型也可以实例化为值类型，而null只能用于引用;</p><p>​    使用default关键字，将null值赋予引用类型，将0赋予值类型</p><h3 id="6-3-2约束"><a href="#6-3-2约束" class="headerlink" title="6.3.2约束"></a>6.3.2约束</h3><p>​    如果泛型需要调用泛型类型中的方法，就必须添加约束</p><p>​    泛型支持的几种约束</p><p>​        where T:struct  必须是值类型</p><p>​        where T:class 必须是引用类型</p><p>​        where T:IFoo 必须是实现接口IFoo</p><p>​        where T:Foo 必须是派生自Foo</p><p>​        where T:new() 构造函数约束，指定T必须有一个默认构造函数</p><p>​        where T1:T2  类型T1派生自泛型类型T2</p><h3 id="6-3-3-继承"><a href="#6-3-3-继承" class="headerlink" title="6.3.3 继承"></a>6.3.3 继承</h3><p>​        泛型类可以实现泛型接口，也可以派生自一个类，泛型类可以派生自泛型类</p><p>​        要求必须重复接口的泛型类型，或者必须制定基类的类型</p><p>​        派生类可以是泛型类型或非泛型类型</p><h3 id="6-3-4静态成员"><a href="#6-3-4静态成员" class="headerlink" title="6.3.4静态成员"></a>6.3.4静态成员</h3><h2 id="6-4泛型接口"><a href="#6-4泛型接口" class="headerlink" title="6.4泛型接口"></a>6.4泛型接口</h2><p>6.4.1协变和抗变</p><p>.net 4之前泛型接口是不变的，。net4通过协变和抗变为泛型接口和泛型委托添加了一个重要的扩展。</p><p>协变和抗变指对参数和返回值的类型进行转换</p><p>6.4.2泛型接口的协变</p><p>​        如果泛型类型用out关键字标注，泛型接口是协变得。这也意味着返回类型只能是T</p><p>6.4.3泛型接口的抗变</p><p>​        如果泛型类型用in关键字标注，泛型接口是抗变的。这也意味着输入只能是T</p><h2 id="6-5泛型结构"><a href="#6-5泛型结构" class="headerlink" title="6.5泛型结构"></a>6.5泛型结构</h2><p>Nullable<T>  =&gt;Nullable<int> =&gt; int?</p><blockquote><p>int y1 = x1??0; </p></blockquote><h2 id="6-6泛型方法"><a href="#6-6泛型方法" class="headerlink" title="6.6泛型方法"></a>6.6泛型方法</h2><p>6.6.1泛型方法示例</p><p>6.6.2带约束的泛型方法</p><p>6.6.3带委托的泛型方法</p><p>6.6.4泛型方法规范</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第五章 托管和非托管的资源</title>
      <link href="2021/02/18/c/c-10th-05/"/>
      <url>2021/02/18/c/c-10th-05/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第五章-托管和非托管的资源"><a href="#c-语言-第五章-托管和非托管的资源" class="headerlink" title="c#语言 第五章 托管和非托管的资源"></a>c#语言 第五章 托管和非托管的资源</h1><h2 id="5-1资源"><a href="#5-1资源" class="headerlink" title="5.1资源"></a>5.1资源</h2><p>使用托管和非托管的资源—存储在托管或本机堆中的对象，尽管垃圾收集齐释放存储在托管堆中的托管对象，但不释放本机堆中的对象，必须由开发人员自己释放</p><p>什么是大小对象堆？</p><p>什么数据类型存储在堆栈上是非常有益的？</p><p>垃圾收集器处理托管的资源，那么非托管的资源呢？</p><h2 id="5-2后台内存管理"><a href="#5-2后台内存管理" class="headerlink" title="5.2后台内存管理"></a>5.2后台内存管理</h2><h3 id="5-2-1值类型数据"><a href="#5-2-1值类型数据" class="headerlink" title="5.2.1值类型数据"></a>5.2.1值类型数据</h3><p>虚拟内存：执行代码、代码加载的所有DLL、以及程序运行时使用的所有变量</p><p>栈–值类型数据</p><p>​    块作用域或结构作用域：生存期嵌套</p><p>​    编译器在内部确保先放在内存中的那个变量后删除</p><h3 id="5-2-2引用数据类型"><a href="#5-2-2引用数据类型" class="headerlink" title="5.2.2引用数据类型"></a>5.2.2引用数据类型</h3><p>​    所有引用类型，托管堆</p><p>首先创建对象时，分配堆上的内存以存储对象（真正的对象），然后把变量的值设置为分配给新对象的内存地址</p><p>把一个引用变量的值赋予两一个相同类型的变量，就有两个变量引用内存中的同一对象了；当一个引用变量超出作用域时，它会从栈中删除，但是引用对象的数据让保留在堆中</p><p>只有到程序停止，或垃圾回收器删除为止。只有数据不再被任何变量引用时，它才会被删除</p><h3 id="5-2-3-垃圾回收-System-GC-Collect"><a href="#5-2-3-垃圾回收-System-GC-Collect" class="headerlink" title="5.2.3 垃圾回收  System.GC.Collect()"></a>5.2.3 垃圾回收  System.GC.Collect()</h3><p>​    在垃圾回收器运行时，它会从堆中删除不再引用的所有对象</p><p>​    只要释放了能释放的所有对象，就会把其它对象移动回堆的端部，再次形成一个连续的内存块</p><p>​    垃圾回收器的这个压缩操作是托管的堆与非托管的堆的区别所在，使用托管的堆，就只需要读取指针的值即可，而不需要遍历地址的链表，来查找一个地方放置新数据</p><p>​    大对象堆：在.net 下，较大对象有自己的托管堆，使用大于85000个字节的对象时，就会放在这个特殊的堆上</p><h2 id="5-3强引用-和弱引用"><a href="#5-3强引用-和弱引用" class="headerlink" title="5.3强引用 和弱引用"></a>5.3强引用 和弱引用</h2><p>​    垃圾回收器不能回收仍在引用的对象的内存 —-这是一个强引用</p><p>​    弱引用WeakPeference：允许创建和使用对象，但垃圾回收器碰巧在运行，就会回收对象并释放内存，由于潜在的bug和性能问题，一般不这么做</p><h2 id="5-4处理非托管的资源"><a href="#5-4处理非托管的资源" class="headerlink" title="5.4处理非托管的资源"></a>5.4处理非托管的资源</h2><p>​    垃圾回收器不知道如何释放非托管的资源，例如：文件句柄、网络连接、和数据库连接</p><p>​    定义一个类时，可以使用两种机制来自动释放非托管的资源</p><p>​            声明一个析构函数（终结器），作为类的一个成员</p><p>​            在类中实现System.IDispossable接口</p><h3 id="5-4-1析构函数或终结器finalizer"><a href="#5-4-1析构函数或终结器finalizer" class="headerlink" title="5.4.1析构函数或终结器finalizer"></a>5.4.1析构函数或终结器finalizer</h3><p>​    c#编译器在编译析构函数时，会隐式的把析构函数的代码编译为等价于重写Finalize（）方法的代码，从而确保执行父类的Finalize（）方法</p><p>缺点：</p><p>​    无法确定c#对象的析构函数何时执行，所以不能再析构函数中放置需要在某一时刻运行的代码</p><p>​    c#析构函数的实现会延迟对象最终从内存中删除的时间</p><p>5.4.2IDispossable接口</p><pre><code> 在c#中，推荐使用System.IDispossable接口代替析构函数，接口定义了一种模式（具有语言级的支持）该模式为释放非托管资源提供了确定的机制，并避免产生析构函数固有的与垃圾回收器相关的问题。</code></pre><p>​    IDispossable接口声明了一个Dispose()方法，不带参数，返回void。显示的释放有对象直接使用的所有非托管资源</p><blockquote><p>ResourceGobbler theInstance =null;</p><p>try{</p><p>​    theInstance = new ResourceGobbler ()</p><p> }</p><p>finally{</p><p>theInstance ?.Dispose()</p><p>}</p></blockquote><p>​    </p><h3 id="5-4-3using语句"><a href="#5-4-3using语句" class="headerlink" title="5.4.3using语句"></a>5.4.3using语句</h3><p>​    使用try/finally，即使处理过程中出现异常，也可以确保总是在调用Dispose方法释放了资源，但是每个都需要这样重复度的结构；</p><p>​        c#提供另一种语法using，实现IDispossable接口的对象在超出作用域时，自动调用Dipose方法；</p><blockquote><p>using(var    theInstance = new ResourceGobbler ()){</p><p>//do something()</p><p>}</p></blockquote><h3 id="5-4-4-实现IDispossable接口和析构函数"><a href="#5-4-4-实现IDispossable接口和析构函数" class="headerlink" title="5.4.4 实现IDispossable接口和析构函数"></a>5.4.4 实现IDispossable接口和析构函数</h3><p>总结资源释放的两种方式：</p><p>​        利用运行库强制执行的析构函数，但它的执行是不确定的，而且由于垃圾回收的工作方式，会给运行库增加不可接受的系统开销</p><p>​        IDispossable接口提供了一种机制，允许类的用户控制释放资源的时间，但需要确保调用Dispose()方法</p><p>双重实现，创建终结器，实现IDispossabe结构，同时把析构函数作为一种安全机制，以防没有调用Dispose方法</p><h3 id="5-4-5IDispossable和终结器的规则"><a href="#5-4-5IDispossable和终结器的规则" class="headerlink" title="5.4.5IDispossable和终结器的规则"></a>5.4.5IDispossable和终结器的规则</h3><p>​    如果类定义实现了IDispossable的成员，该类也应该实现IDispossable</p><p>​    实现IDispossable并不以为也应该实现一个终结器，终结器会带来额外的开销</p><p>​    如果实现了终结器，也应该实现IDispossable接口，这样可以早些释放资源，不必等GC回收</p><p>​    如果使用的一个对象实现了IDispossable接口，就不在需要对象时调用Dispose方法。如果在方法中使用这个对象，using语句比较方便。如果对象时类的一个成员，就让类也实现IDispossable</p><h2 id="5-5不安全的代码"><a href="#5-5不安全的代码" class="headerlink" title="5.5不安全的代码"></a>5.5不安全的代码</h2><p>​    由于性能问题，要在外部的DLL中访问一个函数，该函数需要把一个指针当做参数来传递（WindowsAPI）,本节将讨论c#直接访问内存的内容的功能</p><h3 id="5-5-1用指针直接访问内存"><a href="#5-5-1用指针直接访问内存" class="headerlink" title="5.5.1用指针直接访问内存"></a>5.5.1用指针直接访问内存</h3><p>​    指针是一个以与引用相同的方式存储地址的变量；其区别是c#不允许直接访问在引用变量中包含的地址。</p><p>​    使用指针，就可以访问实际内存地址，执行新类型的操作</p><p>使用指针的两个原因：</p><p>​        向后兼容性：调用windowsAPI函数，这些函数都是用c++或c#语言编写的，通常要求把指针作为其参数，</p><p>​        性能：在一些情况下，速度是最重要的，而指针可以提供最优性能，</p><p>这种地接别的访问也是有代价的</p><p>​        指针使用起来比较困难，需要非常高的变成技巧和很强的能力</p><pre><code>     很容易重写其他变量，导致栈溢出，访问某些没有存储变量的内存区域，甚至重写.net运行库，使程序崩溃</code></pre><p>​        另外，如果使用指针，就必须授予代码运行库的代码访问安全机制的最高级别</p><p>强烈建议轻易不要使用指针，不仅难以编写，还无法通过CLR施加的内存类型和安全检查</p><h4 id="用unsafe编写不安全的代码"><a href="#用unsafe编写不安全的代码" class="headerlink" title="用unsafe编写不安全的代码"></a>用unsafe编写不安全的代码</h4><p>​    任何方法都可以标记为unsafe，还允许把指针作为参数，也可以把整个类或结构标记为unsafe，假定所有的成员都是不安全的</p><p>​    也可以把方法中的一块代码标记为unsafe；不能把局部变量本身标记为unsafe</p><h4 id="指针的语法"><a href="#指针的语法" class="headerlink" title="指针的语法 *"></a>指针的语法 *</h4><p>指针可以声明为任意一种值类型，也可以声明为一个结构</p><p>int* pWidth,pHeight;</p><p>&amp;表示取地址</p><p>*表示获取地址的内容</p><h4 id="将指针强制转换为整数类型"><a href="#将指针强制转换为整数类型" class="headerlink" title="将指针强制转换为整数类型"></a>将指针强制转换为整数类型</h4><h4 id="指针类型之间的强制转换"><a href="#指针类型之间的强制转换" class="headerlink" title="指针类型之间的强制转换"></a>指针类型之间的强制转换</h4><h4 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a>void指针</h4><h4 id="指针算术的运算"><a href="#指针算术的运算" class="headerlink" title="指针算术的运算"></a>指针算术的运算</h4><h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><h4 id="结构指针，指针成员访问运算符"><a href="#结构指针，指针成员访问运算符" class="headerlink" title="结构指针，指针成员访问运算符"></a>结构指针，指针成员访问运算符</h4><h4 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h4><h3 id="5-5-2指针实例-：PointerPlayground"><a href="#5-5-2指针实例-：PointerPlayground" class="headerlink" title="5.5.2指针实例  ：PointerPlayground"></a>5.5.2指针实例  ：PointerPlayground</h3><h3 id="5-5-3使用指针优化性能"><a href="#5-5-3使用指针优化性能" class="headerlink" title="5.5.3使用指针优化性能"></a>5.5.3使用指针优化性能</h3><p>创建一个基于栈的数组</p><p>QuickArray示例</p><h2 id="5-6平台调用"><a href="#5-6平台调用" class="headerlink" title="5.6平台调用"></a>5.6平台调用</h2>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 托管 </tag>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="2021/02/18/rabbitmq/rabbitmq/"/>
      <url>2021/02/18/rabbitmq/rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-RabbitMQ简介"><a href="#第一章-RabbitMQ简介" class="headerlink" title="第一章 RabbitMQ简介"></a>第一章 RabbitMQ简介</h1><h2 id="1-1-什么是消息中间件"><a href="#1-1-什么是消息中间件" class="headerlink" title="1.1 什么是消息中间件"></a>1.1 什么是消息中间件</h2><p> 　　消息是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串、Json等，也可以很复杂，比如内嵌对象。</p><p> 　　消息队列中间件是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。</p><p>　　一般有两种传递模式：点对点模式和发布/订阅模式。点对点模式是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息，队列的存在使得消息的异步传输称为可能。发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者从主题中订阅想消息。主题使得消息订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布/订阅模式在消息的一对多广播时采用。</p><p>　　比较流行的消息中间件有：RabbitMQ、Kafka、ActiveMQ、RocketMQ等。</p><p>　　消息中间件适用于需要可靠的数据传送的分布式环境。采用消息中间件的系统中，不同的对象之间通过传递消息来激活对方的事件，已完成相应的操作。发送者将消息发送给消息服务器，消息服务器将消息存放在若干队列中，在合适的时候，再将消息转发给接收者。</p><h2 id="1-2-消息中间件的作用"><a href="#1-2-消息中间件的作用" class="headerlink" title="1.2 消息中间件的作用"></a>1.2 消息中间件的作用</h2><p>　　解耦：在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束即可。</p><p>　　冗余（存储）：有些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。</p><p> 　　扩展性：因为消息中间件解耦了应用程序的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。</p><p>　　削峰：在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发方访压力，不会因为突发的超负荷请求而完全奔溃。</p><p>　　可恢复性：当系统一部分组件失效时，不会影响到整个系统，消息中间件降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。</p><p>　　顺序保证：在大多数情景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。</p><p>　　缓冲：在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制和优化数据流经过系统的速度。</p><p>　　异步通信：在很多时候应用不想在不需要立即处理消息。消息中间件提供了异步处理机制，允许应用把一些消息放入消息中间件中，但不立即处理它，在之后需要的时候再慢慢处理。</p><h2 id="1-3-RabbitMQ的起源"><a href="#1-3-RabbitMQ的起源" class="headerlink" title="1.3 RabbitMQ的起源"></a>1.3 RabbitMQ的起源</h2><p>　　RabbitMQ是采用Erlang语言实现的AMQP（Advanced Message Queuing Protocol，高级消息队列协议）的消息 中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p><h2 id="1-4-RabbitMQ的安装及简单实用"><a href="#1-4-RabbitMQ的安装及简单实用" class="headerlink" title="1.4 RabbitMQ的安装及简单实用"></a>1.4 RabbitMQ的安装及简单实用</h2><p>　　本示例演示在ubuntu18.04.3中安装和使用rabbitMQ</p><blockquote><p>sudo apt-get update -y<br>sudo apt-get install erlang-nox rabbitmq-server -y<br>sudo rabbitmq-server start<br>sudo rabbitmq-server stop<br>sudo rabbitmq-server restart<br>sudo rabbitmqctl status</p><p>添加用户并且赋予权限</p><p>sudo rabbitmqctl add_user admin admin<br>sudo rabbitmqctl set_user_tags admin administrator<br>sudo rabbitmqctl  set_permissions -p / admin ‘.<em>‘ ‘.</em>‘ ‘.*’<br>sudo rabbitmq-plugins enable rabbitmq_management</p><p>sudo rabbitmqctl change_password admin ‘admin’</p></blockquote><h1 id="第二章-RabbitMQ-入门"><a href="#第二章-RabbitMQ-入门" class="headerlink" title="第二章 RabbitMQ 入门"></a>第二章 RabbitMQ 入门</h1><h2 id="2-1-相关概念介绍"><a href="#2-1-相关概念介绍" class="headerlink" title="2.1 相关概念介绍"></a>2.1 相关概念介绍</h2><p>　　RabbitMQ整体上市一个是生产者与消费者模型。主要负责接收、存储和转发消息。</p><p>　　RabbitMQ的整体模型架构如下图所示：</p><p>　　<img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200116100133957-524774026.png" alt="img"></p><h2 id="2-1-1-生产者和消费者"><a href="#2-1-1-生产者和消费者" class="headerlink" title="2.1.1 生产者和消费者"></a>2.1.1 生产者和消费者</h2><p>　　Producer：生产者，就是投递消息的一方。消息一般可以包含2个部分：消息体和标签（Label）。消息体也可以称之为payload，在实际应用中，消息体一般是一个带有业务逻辑结构的数据，比如一个JSON字符串。</p><p>　　Consumer：消费者，就算是接收消息的一方。</p><p>　　Broker：消息中间件的服务节点。</p><p>　　对于RabbitMQ来说，一个RabbitMQ Broker可以简单地看作一个RabbitMQ服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个RabbitMQ Broker看作一台RabbitMQ服务器。</p><p>　　下图展示了生产者将消息存入RabbitMQ Broker，以及消费者从Broker中消费数据的整个流程。</p><p>　　<img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200116101001502-1945693905.png" alt="img"></p><p> 2.1.2 队列</p><p>Queue：队列，是RabbitMQ的内部对象，用于存储消息。</p><p><img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200117113432130-466580577.png" alt="img"></p><p> RabbitMQ中消息都只能存储在队列中。U盾讴歌消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p><p><img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200117114049922-590796568.png" alt="img"></p><p> RabbitMQ不支持队列层面的广播消息，如果需要广播消息，需要在其上进行二次开发，处理逻辑会变得异常复杂，同时也不建议这么做。</p><p>2.1.3 交换器、路由件、绑定</p><p>Exchange：交换器。生产者将消息发送到Exchange（交换器，通常也可以用大写的“X”来表示）。由交换器将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃。</p><p><img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200117114708911-1388748529.png" alt="img"></p><p> RoutingKey：路右键。生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个Routing Key需要与交换器类型和绑定建（BindingKey）联合使用才能最终生效。</p><p>在交换器类型和绑定建（BindingKey）固定的情况下，生产者可以发送消息给交换器时，通过指定RoutingKey来决定消息流向哪里。</p><p>备注：本文转载于<a href="https://www.cnblogs.com/yuzhou133/p/12197311.html">https://www.cnblogs.com/yuzhou133/p/12197311.html</a></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第四章 继承</title>
      <link href="2021/02/17/c/c-10th-04/"/>
      <url>2021/02/17/c/c-10th-04/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第四章-继承"><a href="#c-语言-第四章-继承" class="headerlink" title="c#语言 第四章 继承"></a>c#语言 第四章 继承</h1><h2 id="4-1继承"><a href="#4-1继承" class="headerlink" title="4.1继承"></a>4.1继承</h2><p>面向对象的三个重要概念：继承、封装、多态</p><h2 id="4-2继承的类型"><a href="#4-2继承的类型" class="headerlink" title="4.2继承的类型"></a>4.2继承的类型</h2><p>面向对象（Object-Oriented,OO）术语，c#的继承</p><p>单重继承：c#</p><p>多重继承：一个类可以派生自多个类，c#不支持</p><p>多层继承：B派生自A，C派生自B，c#支持</p><p>接口继承：c#允许接口多继承</p><h3 id="4-2-1-多重继承-c"><a href="#4-2-1-多重继承-c" class="headerlink" title="4.2.1 多重继承 c++"></a>4.2.1 多重继承 c++</h3><p>多重继承会给生成的代码增加复杂性，还会带来一些开销。c#决定不支持多重继承。</p><p>c#允许派生自多个接口，一个类型可以实现多个接口。System.Object 是一个公共的基类，每个c#类（除了Object类之外）都有一个基类，还可以有人以多个基接口</p><h3 id="4-2-2-结构和类"><a href="#4-2-2-结构和类" class="headerlink" title="4.2.2 结构和类"></a>4.2.2 结构和类</h3><p>使用结构的一个限制是结构不支持继承，但每个结构都派生自system.ValueType . 但接口可以实现接口</p><h2 id="4-3实现继承-class-A：B"><a href="#4-3实现继承-class-A：B" class="headerlink" title="4.3实现继承 class A：B{}"></a>4.3实现继承 class A：B{}</h2><p>如果类和接口都用于派生，则类总是必须放在接口的前面</p><p>结构只能实现接口继承</p><p>类定义中更没有指定基类，c#编译器就假定 System.Object是基类</p><h3 id="4-3-1虚方法"><a href="#4-3-1虚方法" class="headerlink" title="4.3.1虚方法"></a>4.3.1虚方法</h3><p>  virtual </p><p>​    把一个基类方法声明为virtual，就可以在任何派生类中重写该方法</p><p>​    也可以把属性声明为virtual</p><p>​    成员字段和静态函数不能声明为virtual，因为这个概念只对类中实例函数成员有意义</p><p>override 显示声明重写</p><h3 id="4-3-2-多态性"><a href="#4-3-2-多态性" class="headerlink" title="4.3.2 多态性"></a>4.3.2 多态性</h3><p>多态性，动态地定义调用的方法，而不是在编译期间定义</p><h3 id="4-3-3隐藏方法"><a href="#4-3-3隐藏方法" class="headerlink" title="4.3.3隐藏方法"></a>4.3.3隐藏方法</h3><p>如果签名相同的方法在基类和派生类中都进行了声明，但该方法没有分别声明为virtual和override，派生类方法就会隐藏基类方法</p><p>用new关键词隐藏方法，避免出现编译器警告</p><h3 id="4-3-4调用基类版本方法base-fn"><a href="#4-3-4调用基类版本方法base-fn" class="headerlink" title="4.3.4调用基类版本方法base.fn()"></a>4.3.4调用基类版本方法base.fn()</h3><h3 id="4-3-5抽象类和抽象方法"><a href="#4-3-5抽象类和抽象方法" class="headerlink" title="4.3.5抽象类和抽象方法"></a>4.3.5抽象类和抽象方法</h3><p>abstract 抽象类不能实例化，抽象法法不能直接实现，必须在非抽象类的派生类中重写； 如果类包含抽象方法，则该类也是抽象的，也必须声明为抽象的</p><h3 id="4-3-6密封类和密封方法sealed"><a href="#4-3-6密封类和密封方法sealed" class="headerlink" title="4.3.6密封类和密封方法sealed"></a>4.3.6密封类和密封方法sealed</h3><p>对于密封类，编译器知道不能派生类</p><p>string是密封的</p><h3 id="4-3-7派生类的构造函数"><a href="#4-3-7派生类的构造函数" class="headerlink" title="4.3.7派生类的构造函数"></a>4.3.7派生类的构造函数</h3><p>​        创建派生类实例时，会有多个构造函数起作用个，要实例化类的构造函数本身不能初始化类，还必须调用其基类中的构造函数，通过层级结构进行构造</p><p>​        如果派生类没必要定义新的构造函数，仍可以提供一个构造函数，条用基构造函数base()</p><h2 id="4-4修饰符"><a href="#4-4修饰符" class="headerlink" title="4.4修饰符"></a>4.4修饰符</h2><p>4.4.1访问修饰符</p><p>逻辑访问修饰符  public protected private</p><p>物理访问修饰符 internal</p><p>不能把类型定义为protected、private或 protected internal，因为这些修饰符对包含在命名空间中的类型没有意义，这些只能用于成员。但可以修饰嵌套的类型，类型也具有成员的状态</p><p>如果有嵌套的类型，内部的类型总是可以访问外部类型的所有成员</p><p>4.4.2其他修饰符</p><p>new static virtual abstract override sealed  extern</p><h2 id="4-5接口"><a href="#4-5接口" class="headerlink" title="4.5接口"></a>4.5接口</h2><p>Microsoft 预定义的一个几口System.IDisposable的完整定义，包含一个方法Dispose（），该方法由类实现，用于清理代码</p><p>声明接口在于发生和声明抽象类完全相同，但不允许提供接口中任何成员的实现方式，一般情况下，接口只能包含方法、属性、索引器、和事件的声明</p><p>抽象类： 可以有实现代码或没有实现代码的抽象成员，</p><p>接口：不能有任何实现代码，纯粹抽象的；所以接口不需要abstract关键字</p><p>接口不能有构造函数，也不能有字段，不能声明为virtual</p><p>4.5.1定义和实现接口</p><p>从接口中派生独立于从类中派生</p><p>4.5.2派生的接口</p><h2 id="4-6-is-和as-运算符"><a href="#4-6-is-和as-运算符" class="headerlink" title="4.6 is 和as 运算符"></a>4.6 is 和as 运算符</h2><p>as返回对象的引用，如果对象不是所要求的的类型，则返回null</p><p>is运算符，判读是否满足，true则继续进行强制转换</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第三章 对象和类型</title>
      <link href="2021/02/17/c/c-10th-03/"/>
      <url>2021/02/17/c/c-10th-03/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第三章-对象和类型"><a href="#c-语言-第三章-对象和类型" class="headerlink" title="c#语言 第三章 对象和类型"></a>c#语言 第三章 对象和类型</h1><h2 id="3-2-类和结构的区别"><a href="#3-2-类和结构的区别" class="headerlink" title="3.2 类和结构的区别"></a>3.2 类和结构的区别</h2><p>​    类和结构实际上都是常见对象的模板</p><p>​    类是引用类型</p><p>​    结构是值类型</p><p>​    较小的数据类型使用结构可以提高性能</p><p>​    类和结构都用new来声明实例</p><h2 id="3-3-类"><a href="#3-3-类" class="headerlink" title="3.3 类"></a>3.3 类</h2><p>类包含成员。成员可以是静态成员或实例成员，static静态成员属于类；实例成员属于对象</p><p>成员：字段、常量、方法、属性、构造函数、索引器、运算符、事件、析构函数、类型</p><h3 id="3-3-1字段"><a href="#3-3-1字段" class="headerlink" title="3.3.1字段"></a>3.3.1字段</h3><p>​       const 常量 公开 public</p><p>​      最好把字段声明为private</p><h3 id="2-3-2属性"><a href="#2-3-2属性" class="headerlink" title="2.3.2属性"></a>2.3.2属性</h3><p> 一个方法或一对方法，看起来是一个字段</p><h4 id="自动实现的属性："><a href="#自动实现的属性：" class="headerlink" title="自动实现的属性："></a>自动实现的属性：</h4><p>​    set；get；访问器没有任何逻辑，属性会自动实现后备成员变量</p><p>​    属性初始化器来初始化 public int Age {get;set;}=42;</p><h4 id="属性的访问修饰符"><a href="#属性的访问修饰符" class="headerlink" title="属性的访问修饰符"></a>属性的访问修饰符</h4><p>​    public get private set</p><h3 id="3-3-3方法"><a href="#3-3-3方法" class="headerlink" title="3.3.3方法"></a>3.3.3方法</h3><p>非数据成员</p><p>​      正式的c#术语区分函数和方法，在c#术语中，函数成员不仅包含方法，也包含类或结构的一些非数据成员，如索引器、运算符、构造函数、析构函数等，还有属性，这些事非数据成员</p><p>数据成员</p><p>​    字段、常量、事件才是数据成员</p><h4 id="方法的声明"><a href="#方法的声明" class="headerlink" title="方法的声明"></a>方法的声明</h4><p>​    表达式体方法：  =&gt; 区分操作符左边的声明和右边的实现代码</p><p>​    调用方法</p><h4 id="方法的重载："><a href="#方法的重载：" class="headerlink" title="方法的重载："></a>方法的重载：</h4><p>​    方法名相同，但是参数的数量和/或数据类型不同</p><h4 id="命名的参数："><a href="#命名的参数：" class="headerlink" title="命名的参数："></a>命名的参数：</h4><p>​    任何方法都可以使用命名的参数调用，编译器会去掉变量名</p><p>这种方式更改变量的顺序，编译器会重新安排，获得正确的顺序</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>​    一个或多个，可选参数置后</p><h4 id="个数可变的参数-params关键字"><a href="#个数可变的参数-params关键字" class="headerlink" title="个数可变的参数 params关键字"></a>个数可变的参数 params关键字</h4><p>​    如果params关键字与方法签名定义的多个参数一起使用，params只能使用一次，且必须是最后一个参数</p><h3 id="3-3-4构造函数"><a href="#3-3-4构造函数" class="headerlink" title="3.3.4构造函数"></a>3.3.4构造函数</h3><p>​    如果没有构造函数，编译器会默认生成一个默认的构造函数（引用类型为空引用，数值类型为0，bool为false）</p><p>构造函数的重载遵循与其他方法相同的规则 ；</p><p>​    构造函数的重载遵循与其他方法相同的</p><p>​    如果提供了带参数的构造函数，编译器就不会自动提供默认的构造函数</p><p>​    可以把构造函数定义为private或者protected，这样不相关的类就不能访问他们</p><p><strong>没有公有或受保护的构造函数的用法</strong></p><p>​    类仅仅是静态成员或属性的容器，永远不会实例化，static修饰类，只能包含静态成员，不能实例化</p><p>​    希望仅通过条用个某个静态成员函数来实例化（对象实例化的类工厂方法）（单例模式的实现）</p><h4 id="从构造函数中调用其他构造函数"><a href="#从构造函数中调用其他构造函数" class="headerlink" title="从构造函数中调用其他构造函数"></a>从构造函数中调用其他构造函数</h4><p>​    this关键字仅条用参数最匹配的那个构造函数</p><p>​    c#构造函数初始化器可以包含对同一个类的另一个构造函数的调用，也可以对直接基类的构造函数的调用应使用base代替this关键字，初始化器不能有多个调用</p><h4 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h4><p>​    无参数的静态构造函数</p><p>​        不能带任何参数，一个类只有一个静态构造函数</p><h4 id="只读成员-readonly"><a href="#只读成员-readonly" class="headerlink" title="只读成员 readonly"></a>只读成员 readonly</h4><h4 id="只读字段-readonly"><a href="#只读字段-readonly" class="headerlink" title="只读字段 readonly"></a>只读字段 readonly</h4><h4 id="只读readonly与const的区别"><a href="#只读readonly与const的区别" class="headerlink" title="只读readonly与const的区别"></a>只读readonly与const的区别</h4><p>​        const 编译器通过值取代了使用它的变量，编译器知道它的值</p><p>​        readonly在运行期间通过构造函数制定，与常量字段相反，只读字段可以是实例成员，使用只读字段作为类成员时，需要把static修饰符分配给该字段</p><p>只读字段，不能在构造函数外部赋值</p><p>只读属性{get}</p><p>​    自动实现的只读属性</p><p>​    只读属性也可以在构造函数中初始化</p><p>表达式体属性</p><blockquote><p>public string FullName =&gt; $”{FirstName} {LastName}”;</p></blockquote><p>不可变的类型</p><p>​        例如String，，任何改变总会返回一个新的字符串</p><h2 id="3-4匿名类型"><a href="#3-4匿名类型" class="headerlink" title="3.4匿名类型"></a>3.4匿名类型</h2><h2 id="3-5结构-struct"><a href="#3-5结构-struct" class="headerlink" title="3.5结构 struct"></a>3.5结构 struct</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>​    数据小 提升性能</p><p>​    值类型</p><p>​    不支持继承</p><p>​    分配内存非常快，销毁也快</p><p>​    互相赋予时，会复制一份，有性能损失</p><p>​    当把结构作为参数传递时，应把它作为ref参数传递---避免性能损失，只传递地址；被调用的方法可以改变结构的值</p><h3 id="结构和继承"><a href="#结构和继承" class="headerlink" title="结构和继承"></a>结构和继承</h3><p>​    不能从一个结构中继承</p><p>​    例外： 结构最终派生于类System.Object ,因此可以访问System.Object 的方法</p><p>​    结构 &lt;= System.ValueType&lt;= System.Object</p><h3 id="结构的构造函数"><a href="#结构的构造函数" class="headerlink" title="结构的构造函数"></a>结构的构造函数</h3><h2 id="3-6按值和按引用传递参数"><a href="#3-6按值和按引用传递参数" class="headerlink" title="3.6按值和按引用传递参数"></a>3.6按值和按引用传递参数</h2><h3 id="ref参数-gt-可以通过引用传递结构"><a href="#ref参数-gt-可以通过引用传递结构" class="headerlink" title="ref参数 -&gt;可以通过引用传递结构"></a>ref参数 -&gt;可以通过引用传递结构</h3><p>out参数 -&gt;</p><p>​    如果一个方法返回多个值，可能类型还不同</p><h2 id="3-7可空类型-int-x2-null"><a href="#3-7可空类型-int-x2-null" class="headerlink" title="3.7可空类型  int? x2=null;"></a>3.7可空类型  int? x2=null;</h2><h2 id="3-8枚举-enum"><a href="#3-8枚举-enum" class="headerlink" title="3.8枚举 enum"></a>3.8枚举 enum</h2><p>​    默认enum的类型是int</p><p>​    使用强制类型转换可以把数字改为枚举值，把枚举改为数字</p><p>​    Flags</p><h2 id="3-9-部分类-partial"><a href="#3-9-部分类-partial" class="headerlink" title="3.9 部分类 partial"></a>3.9 部分类 partial</h2><p>​    可以把类分开放在两个文件中</p><p>声明类和结构，返回信息都是类成员</p><p>元组类型</p><h2 id="3-10-扩展方法"><a href="#3-10-扩展方法" class="headerlink" title="3.10 扩展方法"></a>3.10 扩展方法</h2><p>扩展</p><p>​    继承给对象添加功能的好方法</p><p>​    扩展方法是给对象添加功能的另一个选项，在不能使用继承时，可以使用这个选项（例如类是密封的）</p><p>扩展方法是静态方法，是类的一部分，但实际上没有放在类的源代码中</p><p>使用this关键字和第一个参数来扩展字符串，这个关键字定义了要扩展的类型</p><blockquote><p>public static class StringExtension{ public static int<br>GetWordCount(this string s)=&gt; s.Split().Length; ​} ​</p></blockquote><p>好处：</p><p>​    可以使用实例方法的语法，而不是从代码中直接调用静态方法</p><p>​    该方法的实现可以用另一个类取代，而不需要更改代码</p><p>编译器如何找到某个类型的扩展方法？</p><p>​    this关键字必须匹配类型的扩展方法</p><p>​    而且需要打开定义扩展方法的静态类所在名称空间</p><p>​    如果类型还定义了同名的实例方法，扩展方法就永远不会使用</p><p>​    类中已有的实例方法都优先</p><p>Object类，其他类型都从该类派生而来</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象和类型 </tag>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第二章 核心C#</title>
      <link href="2021/02/17/c/c-10th-02/"/>
      <url>2021/02/17/c/c-10th-02/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-2-核心c"><a href="#c-语言-2-核心c" class="headerlink" title="c#语言 2 核心c#"></a>c#语言 2 核心c#</h1><h2 id="2-3变量"><a href="#2-3变量" class="headerlink" title="2.3变量"></a>2.3变量</h2><p>c# 区分大小写</p><h3 id="2-3-1初始化变量"><a href="#2-3-1初始化变量" class="headerlink" title="2.3.1初始化变量"></a>2.3.1初始化变量</h3><p>​    c#编译器需要用某个初始值对变量进行初始化，之后才能在操作中引用变量；c#中有两个方法可确保变量使用前进行了初始化</p><p>​        变量是类或结构中的字段，如果没有显示初始化，则创建这些变量时，其默认值就是0</p><p>​        方法的局部变量必须在代码中显示初始化，变量初始化之前就使用了其值，编译器就会标记错误</p><h3 id="2-3-2类型推断"><a href="#2-3-2类型推断" class="headerlink" title="2.3.2类型推断"></a>2.3.2类型推断</h3><p>​    变量必须初始化，编译器推断类型的依据</p><p>​    初始化器不能为空</p><p>​    初始化器必须放在表达式中</p><p>​    不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象</p><h3 id="2-3-3变量的作用域"><a href="#2-3-3变量的作用域" class="headerlink" title="2.3.3变量的作用域"></a>2.3.3变量的作用域</h3><p>定义或规则</p><p>​    只要类在某个作用域内，其字段也在该作用域内</p><p>​    局部变量存在于表示声明该变量的块语句或方法结束的右花括号之前的作用域内</p><p>​    在 for whild 或类似语句中声明的局部变量存在于该循环体内</p><h4 id="局部变量的作用域冲突"><a href="#局部变量的作用域冲突" class="headerlink" title="局部变量的作用域冲突"></a>局部变量的作用域冲突</h4><h4 id="字段和局部变量的作用域冲突"><a href="#字段和局部变量的作用域冲突" class="headerlink" title="字段和局部变量的作用域冲突"></a>字段和局部变量的作用域冲突</h4><blockquote><p>class program{ static int j=20; static void Main(){ int<br>j=30;WriteLine(j); WriteLine(program.j) } ​}</p></blockquote><h3 id="2-3-4常量"><a href="#2-3-4常量" class="headerlink" title="2.3.4常量"></a>2.3.4常量</h3><p>特点</p><p>​    常量声明时必须初始化，指定其值后，就不能再改写了、</p><p>​    常量的值必须在编译时用于计算，因此不能用从变量中提取的值来初始化常亮</p><p>​    常量总是隐式静态的</p><p>好处</p><p>​    易于读取的名称</p><p>​    是程序更易于修改</p><p>​    更容易避免程序出现错误</p><h2 id="2-4预定义数据类型"><a href="#2-4预定义数据类型" class="headerlink" title="2.4预定义数据类型"></a>2.4预定义数据类型</h2><h3 id="2-4-1-值类型和引用类型"><a href="#2-4-1-值类型和引用类型" class="headerlink" title="2.4.1 值类型和引用类型"></a>2.4.1 值类型和引用类型</h3><p>堆栈</p><p>​    值类型存储在堆栈中stack</p><p>​    引用各类型存储在托管堆中 managed heap</p><p>bool 和long等都是值类型，值类型的赋予是通过值复制的</p><p>大多数更复杂的c#数据类型，包括自己声明的类，都是引用类型</p><p>​    CLR实现一种精细的算法，来跟踪哪些引用变量是可以访问的，哪些不能访问，CLR会定期删除不能访问的对象，把占用的内存返回给操作系统，垃圾回收器</p><p>​    如果要把自己的类型定义为值类型，就应把它声明为一个结构</p><h3 id="2-4-2-net-类型"><a href="#2-4-2-net-类型" class="headerlink" title="2.4.2 .net 类型"></a>2.4.2 .net 类型</h3><p>​    15个预定义类型，13个值类型，两个引用类型string 和 object</p><h3 id="2-4-3预定义的值类型"><a href="#2-4-3预定义的值类型" class="headerlink" title="2.4.3预定义的值类型"></a>2.4.3预定义的值类型</h3><p>整型 sbyte 8 short 16 int32 long64</p><p>浮点类型 float32位单精度浮点，double 64位双精度浮点 15/16</p><p>decimal类型 128位高精度十进制数表示法<br>（decimal类型不是基本类型，计算时有性能损失）(高精度计算)</p><blockquote><p>decimal d =12.30M;</p></blockquote><p>bool类型</p><p>字符类型 char 表示一个16位的Unicode字符</p><p>​    转义字符\</p><h3 id="2-4-4预定义的引用类型"><a href="#2-4-4预定义的引用类型" class="headerlink" title="2.4.4预定义的引用类型"></a>2.4.4预定义的引用类型</h3><h4 id="object-类型"><a href="#object-类型" class="headerlink" title="object 类型"></a>object 类型</h4><p>​     可以使用object引用来绑定任何特定子类型的对象;如值类型装箱，再移动到堆中，object引用也可以用于反射，此时必须有代码来处理类型未知的对象</p><p>​    object类型实现了许多一般用途的基本方法，包括Equals(),GetHashCode(),GetType()和ToString()用户定义的类型需要使用一种面向对象技术---重写</p><h4 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h4><p>​    字符串不可修改，修改会产生新的string对象</p><p>​    @的使用，看做所有字符保持原来的含义</p><p>​    字符串插值功能 $</p><h2 id="2-5程序流控制"><a href="#2-5程序流控制" class="headerlink" title="2.5程序流控制"></a>2.5程序流控制</h2><p>if</p><p>for</p><p>while</p><p>do while</p><p>foreach 不能改变集合中各项的值</p><p>跳转语句</p><p>goto语句<br>不能跳转像for循环这样的代码块中，也不能跳出类的范围，不能退出try<br>catch后面的finally</p><p>break语句</p><p>switch 中退出某个语句</p><p>也可用于for foreach whild do...while</p><p>continue语句 只能退出循环的当前迭代</p><p>return 语句 退出类的方法</p><h2 id="2-6-枚举"><a href="#2-6-枚举" class="headerlink" title="2.6 枚举"></a>2.6 枚举</h2><h3 id="枚举是用户定义的整数类型"><a href="#枚举是用户定义的整数类型" class="headerlink" title="枚举是用户定义的整数类型"></a>枚举是用户定义的整数类型</h3><p>优势</p><p>​    代码易于维护，有助于确保给变量制定合法的期望的值</p><p>​    枚举使代码更清晰，允许描述性的蒙城表示整数值，而不是含义模糊的数</p><p>​    更易于输入</p><p>​    枚举真正强大之处，在于实例化为派生自积累system.enum的结构，不会造成性能损失</p><h2 id="2-7名称空间"><a href="#2-7名称空间" class="headerlink" title="2.7名称空间"></a>2.7名称空间</h2><p>using语句</p><h3 id="2-7-2名称空间的别名"><a href="#2-7-2名称空间的别名" class="headerlink" title="2.7.2名称空间的别名"></a>2.7.2名称空间的别名</h3><h2 id="2-8main方法"><a href="#2-8main方法" class="headerlink" title="2.8main方法"></a>2.8main方法</h2><h2 id="2-9使用注释"><a href="#2-9使用注释" class="headerlink" title="2.9使用注释"></a>2.9使用注释</h2><h2 id="2-10-c-预处理指令"><a href="#2-10-c-预处理指令" class="headerlink" title="2.10 c#预处理指令"></a>2.10 c#预处理指令</h2><p>#define 和#undef</p><p>#if #elif #else #endif</p><p>#warning 和#ERROR</p><p>#region 和 #endregion</p><p>#LINE</p><p>#pragma</p><h2 id="2-11c-编程准则"><a href="#2-11c-编程准则" class="headerlink" title="2.11c#编程准则"></a>2.11c#编程准则</h2><h3 id="标识符的规则"><a href="#标识符的规则" class="headerlink" title="标识符的规则"></a>标识符的规则</h3><p>​    尽管可以包含数字字符，但他们必须以字母或下划线开头</p><p>​    不能把c#关键字用作标识符</p><p>用法约定</p><p>命名约定</p><p>​    名称的大小写 Pascal camel</p><p>​    名称的风格统一</p><p>​    名称和关键字</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客资源站收集</title>
      <link href="2021/02/17/good-blogs/"/>
      <url>2021/02/17/good-blogs/</url>
      
        <content type="html"><![CDATA[<h1 id="一个不错的博客-算法-leet-code"><a href="#一个不错的博客-算法-leet-code" class="headerlink" title="一个不错的博客  算法 leet code"></a>一个不错的博客  算法 leet code</h1><p><a href="https://www.cxyxiaowu.com/">https://www.cxyxiaowu.com/</a></p><h1 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h1><p><a href="http://www.ptbird.cn/list.html">http://www.ptbird.cn/list.html</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第一章 .net 应用程序体系结构</title>
      <link href="2021/02/17/c/c-10th-01/"/>
      <url>2021/02/17/c/c-10th-01/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第一章-net-应用程序体系结构"><a href="#c-语言-第一章-net-应用程序体系结构" class="headerlink" title="c#语言 第一章 .net 应用程序体系结构"></a>c#语言 第一章 .net 应用程序体系结构</h1><h2 id="1-2-回顾net-历史"><a href="#1-2-回顾net-历史" class="headerlink" title="1.2.回顾net 历史"></a>1.2.回顾net 历史</h2><h3 id="net-版本"><a href="#net-版本" class="headerlink" title=".net 版本"></a>.net 版本</h3><p>​    CLR(Common Language Runtime) 公共语言运行库</p><p>​    c#</p><p>​    Visual Studio</p><h3 id="1-2-1c-1-0-新语言"><a href="#1-2-1c-1-0-新语言" class="headerlink" title="1.2.1c#1.0 新语言"></a>1.2.1c#1.0 新语言</h3><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><p>​        面向对象编程语言，具备继承，封装和多态性等特性</p><p>​        也提供了基于组件的变成改造，如委托和事件</p><h4 id="CLR"><a href="#CLR" class="headerlink" title="CLR"></a>CLR</h4><p>​     .net 编程语言都使用的运行库，类似java虚拟机</p><p>​     中间语言Intermediate Language IL代码，编译器生成IL代码，当程序运行时，JIT编译器会从IL代码生成本地代码</p><p>​     GC垃圾回收</p><p>​     调试器扩展</p><p>​     线程实用工具</p><p>​    CLR还负责线程的处理，C#中创建托管的线程不一定来自底层操作系统，线程的虚拟化和管理有CLR负责</p><h3 id="1-2-2带有泛型的c-2-和-net-2"><a href="#1-2-2带有泛型的c-2-和-net-2" class="headerlink" title="1.2.2带有泛型的c#2 和.net 2"></a>1.2.2带有泛型的c#2 和.net 2</h3><h3 id="1-2-3-net-3-0-WPF"><a href="#1-2-3-net-3-0-WPF" class="headerlink" title="1.2.3 .net 3.0 WPF"></a>1.2.3 .net 3.0 WPF</h3><p>​    WPF 矢量图形控件</p><p>​     WCF 通用通信</p><h3 id="1-2-4-c-LINQ-EF"><a href="#1-2-4-c-LINQ-EF" class="headerlink" title="1.2.4 c##  LINQ   EF"></a>1.2.4 c##  LINQ   EF</h3><h3 id="1-2-5-c-4-dynamic-TPL-任务并行库"><a href="#1-2-5-c-4-dynamic-TPL-任务并行库" class="headerlink" title="1.2.5  c# 4 dynamic TPL(任务并行库)"></a>1.2.5  c# 4 dynamic TPL(任务并行库)</h3><p>​    使用Task 和 Parallel 类抽象出线程</p><h3 id="1-2-6c-5-异步编程-async-和await"><a href="#1-2-6c-5-异步编程-async-和await" class="headerlink" title="1.2.6c#5 异步编程  async 和await"></a>1.2.6c#5 异步编程  async 和await</h3><h3 id="1-2-7-c-6-新的编译器引擎-Roslyn"><a href="#1-2-7-c-6-新的编译器引擎-Roslyn" class="headerlink" title="1.2.7 c#6 新的编译器引擎 Roslyn"></a>1.2.7 c#6 新的编译器引擎 Roslyn</h3><h4 id="1-3-2-net-core-1-0-CORE-CLI"><a href="#1-3-2-net-core-1-0-CORE-CLI" class="headerlink" title="1.3.2 .net core 1.0   CORE CLI"></a>1.3.2 .net core 1.0   CORE CLI</h4><p>特性：</p><p>​    开源</p><p>​    模块化的方式设计</p><p>​    可以很快更新</p><p>程序集 assembly：编译好的，面向.net framework的代码逻辑单元</p><p>​        私有程序集</p><p>​        共享程序集（Global Assembly Cache）</p><h3 id="1-3-5-公共语言运行库"><a href="#1-3-5-公共语言运行库" class="headerlink" title="1.3.5 公共语言运行库"></a>1.3.5 公共语言运行库</h3><p>​       编译器将源代码编译为Microsoft中间语言(Intermediate Language, IL)生成IL代码，当程序运行时，JIT编译器会从IL代码生成本地代码</p><p>​       CLR还负责线程的处理，C#中创建托管的线程不一定来自底层操作系统，线程的虚拟化和管理有CLR负责</p><h3 id="1-3-7windows运行库-windows-runtime"><a href="#1-3-7windows运行库-windows-runtime" class="headerlink" title="1.3.7windows运行库 windows runtime"></a>1.3.7windows运行库 windows runtime</h3><h2 id="net-2015"><a href="#net-2015" class="headerlink" title=".net 2015"></a>.net 2015</h2><h3 id="1-5-net-4-6编译"><a href="#1-5-net-4-6编译" class="headerlink" title="1.5.net 4.6编译"></a>1.5.net 4.6编译</h3><p>​    c# 命令行编译器（csc.exe）: csc HelloWorld.cs -&gt; 中间语言代码</p><p>​    DASM中间语言反汇编程序 （ildasm.exe）</p><p>.net core cli编译</p><p>​    repl学习 ： dotnet repl</p><h2 id="1-7应用程序类型与技术"><a href="#1-7应用程序类型与技术" class="headerlink" title="1.7应用程序类型与技术"></a>1.7应用程序类型与技术</h2><h3 id="1-7-1数据访问"><a href="#1-7-1数据访问" class="headerlink" title="1.7.1数据访问"></a>1.7.1数据访问</h3><pre><code>Database FirstModel First</code></pre><p>CodeFirst:<br>   代码优先有一定意味着数据库不能事先存在；数据库可以动态创建，属性和流利的API可以以编程方式定义映射</p><h3 id="1-7-2桌面应用程序"><a href="#1-7-2桌面应用程序" class="headerlink" title="1.7.2桌面应用程序"></a>1.7.2桌面应用程序</h3><p>WF WPF</p><h3 id="1-7-3-UWP"><a href="#1-7-3-UWP" class="headerlink" title="1.7.3 UWP"></a>1.7.3 UWP</h3><h3 id="1-7-4soap服务和WCF"><a href="#1-7-4soap服务和WCF" class="headerlink" title="1.7.4soap服务和WCF"></a>1.7.4soap服务和WCF</h3><h3 id="1-7-5WEB服务-WEB-API-基于REST"><a href="#1-7-5WEB服务-WEB-API-基于REST" class="headerlink" title="1.7.5WEB服务 WEB API 基于REST"></a>1.7.5WEB服务 WEB API 基于REST</h3><h3 id="1-7-6WebHooks-和SignalR-基于-webSocket"><a href="#1-7-6WebHooks-和SignalR-基于-webSocket" class="headerlink" title="1.7.6WebHooks 和SignalR 基于 webSocket"></a>1.7.6WebHooks 和SignalR 基于 webSocket</h3><h3 id="1-7-7windows服务"><a href="#1-7-7windows服务" class="headerlink" title="1.7.7windows服务"></a>1.7.7windows服务</h3><pre><code>world wide web服务 可以监听客户端的web请求</code></pre><h3 id="Microsoft-Azure服务"><a href="#Microsoft-Azure服务" class="headerlink" title="Microsoft Azure服务"></a>Microsoft Azure服务</h3><p>​    SaaS IaaS PaaS</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .net 应用程序体系结构 </tag>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello MyBlog</title>
      <link href="2021/02/17/hello-myblog/"/>
      <url>2021/02/17/hello-myblog/</url>
      
        <content type="html"><![CDATA[<h2 id="使用github-page-和hexo搭建第一个网站"><a href="#使用github-page-和hexo搭建第一个网站" class="headerlink" title="使用github page 和hexo搭建第一个网站"></a>使用github page 和hexo搭建第一个网站</h2><p><a href="https://www.zhihu.com/question/22197688">https://www.zhihu.com/question/22197688</a></p><h2 id="博客美化-博客主题之hexo-theme-matery的介绍"><a href="#博客美化-博客主题之hexo-theme-matery的介绍" class="headerlink" title="博客美化 博客主题之hexo-theme-matery的介绍"></a>博客美化 博客主题之hexo-theme-matery的介绍</h2><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#alipay">https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#alipay</a></p><h3 id="hexo扩展学习"><a href="#hexo扩展学习" class="headerlink" title="hexo扩展学习"></a>hexo扩展学习</h3><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p><a href="https://hexo.io/themes/index.html">https://hexo.io/themes/index.html</a></p><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><h3 id="window下pandoc的如何使用-文档类型转换"><a href="#window下pandoc的如何使用-文档类型转换" class="headerlink" title="window下pandoc的如何使用 文档类型转换"></a>window下pandoc的如何使用 文档类型转换</h3><p><a href="https://www.jianshu.com/p/f4a9ceb68088">https://www.jianshu.com/p/f4a9ceb68088</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
            <tag> github gage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 前言</title>
      <link href="2021/02/17/c/c-10th-00/"/>
      <url>2021/02/17/c/c-10th-00/</url>
      
        <content type="html"><![CDATA[<h1 id="c-是专门用于-net-的语言"><a href="#c-是专门用于-net-的语言" class="headerlink" title="c# 是专门用于 .net 的语言"></a>c# 是专门用于 .net 的语言</h1><p>web 页面<br>WPF<br>REST WEB服务<br>分布式应用程序的组件<br>数据库访问组件<br>桌面应用程序<br>UWP</p><h1 id="net-core-重要性"><a href="#net-core-重要性" class="headerlink" title=".net core 重要性"></a>.net core 重要性</h1><p>.net framework<br><a href="http://asp.net/">asp.net</a> web forms ？ MVC<br>WIN form /UWP<br>EF / LINQ</p><h1 id="NET-CORE"><a href="#NET-CORE" class="headerlink" title=".NET CORE"></a>.NET CORE</h1><p>开源<br>包较小，更快的创新<br>支持多个平台<br>可以编译为本地代码<br>Xamarin</p><h1 id="C-重要性"><a href="#C-重要性" class="headerlink" title="C# 重要性"></a>C# 重要性</h1><p>设计思想来源于C++ 、java、Pascal<br>面向对象的通用编程语言<br>给予组件的变成语言，支持属性、时间、特性和构建程序集<br>函数数编程理念<br>增加了泛型、语言集成查询linq、lambda表达式、动态特性、更简单的异步编程</p><h1 id="c-6-新特性"><a href="#c-6-新特性" class="headerlink" title="c#6 新特性"></a>c#6 新特性</h1><h2 id="静态using声明："><a href="#静态using声明：" class="headerlink" title="静态using声明："></a>静态using声明：</h2><p>静态的声明允许调用静态方式时不适用类名</p><blockquote><p>using static sysytem.console； Writeline(&quot;hello world&quot;) ​</p></blockquote><h2 id="表达式体方法"><a href="#表达式体方法" class="headerlink" title="表达式体方法:"></a>表达式体方法:</h2><p>表达式方法只包括一个可以用lambda语法编写的语句</p><blockquote><p>public bool isSquare（Rectangle rect）=&gt;rect.Height == rect.Width;</p></blockquote><h2 id="表达式体属性："><a href="#表达式体属性：" class="headerlink" title="表达式体属性："></a>表达式体属性：</h2><p>与表达式方法类似，只有get存取器的单行属性可以用lamabda语法编写</p><blockquote><p>public string FullName =&gt; FirstName +&quot;&quot;+ LastName;</p></blockquote><h2 id="自动实现的属性初始化器"><a href="#自动实现的属性初始化器" class="headerlink" title="自动实现的属性初始化器:"></a>自动实现的属性初始化器:</h2><p>自动实现的属性可以用属性初始化器来初始化</p><blockquote><p>public class Person{ public int Age{get;set;}=42; ​}</p></blockquote><h2 id="只读的自动属性"><a href="#只读的自动属性" class="headerlink" title="只读的自动属性"></a>只读的自动属性</h2><blockquote><p>public BookId {get;} </p></blockquote><h2 id="ameof-运算符："><a href="#ameof-运算符：" class="headerlink" title="ameof 运算符："></a>ameof 运算符：</h2><p>使用此运算符，可以访问字段名、属性名、方法名、类型名</p><h2 id="空值传播运算符"><a href="#空值传播运算符" class="headerlink" title="空值传播运算符"></a>空值传播运算符</h2><blockquote><p>int? age =p?.Age; handler?.Invoke(source,e)</p></blockquote><h2 id="字符串插值-占位符可以直接是表达式"><a href="#字符串插值-占位符可以直接是表达式" class="headerlink" title="字符串插值: 占位符可以直接是表达式"></a>字符串插值: 占位符可以直接是表达式</h2><blockquote><p>public override ToString() =&gt; $&quot;{Title} {Publisher}&quot;</p></blockquote><h2 id="字典初始化器"><a href="#字典初始化器" class="headerlink" title="字典初始化器"></a>字典初始化器</h2><blockquote><p>var dict = new Dictionary&lt;int,string&gt;(){<br>    2 =”three”,<br>  3=”seven”<br> ​}</p></blockquote><h2 id="异常过滤器"><a href="#异常过滤器" class="headerlink" title="异常过滤器"></a>异常过滤器</h2><h2 id="Catch-中的await"><a href="#Catch-中的await" class="headerlink" title="Catch 中的await"></a>Catch 中的await</h2><blockquote><p>try{ // }Catch(MyException ex){ await new<br>MessageDialog().showAsync(ex.Message); ​}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
