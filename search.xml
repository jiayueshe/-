<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>戏说面向对象程序设计Ｃ＃版</title>
      <link href="2021/03/06/ziliao/c/xi-shuo-mian-xiang-dui-xiang-cheng-xu-she-ji-c-ban/"/>
      <url>2021/03/06/ziliao/c/xi-shuo-mian-xiang-dui-xiang-cheng-xu-she-ji-c-ban/</url>
      
        <content type="html"><![CDATA[<h1 id="戏说面向对象程序设计C＃版"><a href="#戏说面向对象程序设计C＃版" class="headerlink" title="戏说面向对象程序设计Ｃ＃版"></a>戏说面向对象程序设计Ｃ＃版</h1><div class="row">    <embed src="./2021/03/06/ziliao/c/xi-shuo-mian-xiang-dui-xiang-cheng-xu-she-ji-c-ban/C#.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 戏说面向对象程序设计Ｃ＃版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法01</title>
      <link href="2021/03/04/kaikeba/suan-fa-00/"/>
      <url>2021/03/04/kaikeba/suan-fa-00/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构和算法01"><a href="#数据结构和算法01" class="headerlink" title="数据结构和算法01"></a>数据结构和算法01</h1><h1 id="（1）链表的基础知识"><a href="#（1）链表的基础知识" class="headerlink" title="**（1）链表的基础知识**"></a><strong>**（</strong>1<strong>）</strong>链表的基础知识**</h1><h2 id="链表的结构"><a href="#链表的结构" class="headerlink" title="链表的结构"></a><strong>链表的结构</strong></h2><p>节点</p><p>​        数据域</p><p>​        指针域：实现方式包括地址、下标（相对地址）、引用</p><p>链状结构</p><p>​        通过指针域的值形成了一个线性结构</p><h2 id="访问链表的时间复杂度"><a href="#访问链表的时间复杂度" class="headerlink" title="访问链表的时间复杂度"></a><strong>访问链表的时间复杂度</strong></h2><p>​    链表不适合快速的定位数据，适合动态的插入和删除的应用场景。</p><p>​    查找节点O(n)</p><p>​    插入节点O(1)</p><p>​    删除节点O(1) </p><h2 id="几种经典的链表实现方法"><a href="#几种经典的链表实现方法" class="headerlink" title="几种经典的链表实现方法"></a><strong>几种经典的链表实现方法</strong></h2><p>​    传统方法（节点+指针）</p><p>​    使用数组模拟</p><p>​        指针域和数据域分离</p><p>​        利用数组存放下标进行索引</p><h1 id="（2）-链表的典型应用场景"><a href="#（2）-链表的典型应用场景" class="headerlink" title="（2） 链表的典型应用场景"></a><strong>（</strong>2<strong>） 链表的典型应用场景</strong></h1><h2 id="操作系统内的动态内存分配"><a href="#操作系统内的动态内存分配" class="headerlink" title="操作系统内的动态内存分配"></a>操作系统内的动态内存分配</h2><p>​    LRU缓存淘汰算法</p><p>​    LRU = Least Recently Used（近期最少使用）</p><h2 id="缓存是一种高速的数据结构。"><a href="#缓存是一种高速的数据结构。" class="headerlink" title="缓存是一种高速的数据结构。"></a>缓存是一种高速的数据结构。</h2><p>​    设备间存在速度差异，可以通过将使用较多的数据存放在高速区域，而将使用较少的内容存放</p><p>​    在相对低速的区域的方式，来对系统进行优化。</p><p><strong>（</strong>3<strong>） 经典面试题</strong></p><p>141环形链表</p><pre><code>var hasCycle = function(head) &#123;    let slow = head;    let fast = head;    while (fast &amp;&amp; fast.next) &#123;        slow = slow.next;        fast = fast.next.next;        if (fast == slow) &#123;            return true;        &#125;    &#125;    return false;&#125;;</code></pre><p>141环形链表2 (判断环的起点)</p><p>快乐数</p><h4 id="剑指-Offer-24-反转链表-反转链表"><a href="#剑指-Offer-24-反转链表-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表  反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a>  反转链表</h4><pre><code>var reverseList = function(head) &#123;    if(!head) return null;    let pre = null,cur =head;    while(cur)&#123;        let next = cur.next;        cur.next = pre;        pre =cur;        cur =next;        //[cur.next,pre,cur] =[pre,cur,cur.next];    &#125;    return pre;&#125;;</code></pre><h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h4><p>242</p><p>241</p><p>202</p><p>206</p><p>92翻转链表</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于复杂人员排班系统的设计</title>
      <link href="2021/03/04/vue/fu-za-pai-ban-xi-tong-she-ji/"/>
      <url>2021/03/04/vue/fu-za-pai-ban-xi-tong-she-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="关于复杂人员排班系统的设计（前端实战）"><a href="#关于复杂人员排班系统的设计（前端实战）" class="headerlink" title="关于复杂人员排班系统的设计（前端实战）"></a>关于复杂人员排班系统的设计（前端实战）</h1><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p>1.实现工作日期，班次，机组的合理安排表格（班次可配置，日期根据每周日期安排）</p><p>2.实现人员排班调整的拖拉拽操作（借助框架）</p><p>3.适应平板和web端</p><p>4.模板</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210304171109789.png" alt="image-20210304171109789"></p><h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><p>界面布局：</p><p>​        班次多选shiftsTemp，病区单选（包含全部病区）wardName，选择后会渲染表格布局initTable</p><p>​        周次信息选择后会调整响应日期范围，changeWeek  库 date-fns参考说明 <a href="https://blog.csdn.net/weixin_39987434/article/details/104635987">https://blog.csdn.net/weixin_39987434/article/details/104635987</a></p><p>​       周次-&gt;对比星期几-&gt;计算日期范围</p><p>​        人数信息统计：根据查询条件显示返回的信息weekPatientCount，todayPatientCount</p><p>​        左侧患者列表，模糊查询，可拖拉至右侧表格</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>每个床位 一行数据；单元格有数据，可以拖动</p>]]></content>
      
      
      <categories>
          
          <category> 前端项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VUE项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化【进阶篇】</title>
      <link href="2021/03/03/ziliao/javascript/qian-duan-xing-neng-you-hua-jin-jie/"/>
      <url>2021/03/03/ziliao/javascript/qian-duan-xing-neng-you-hua-jin-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前端性能优化【进阶篇】"><a href="#前端性能优化【进阶篇】" class="headerlink" title="前端性能优化【进阶篇】"></a>前端性能优化【进阶篇】</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/pfCCZhlbMQSwnCkt8UaYpqrbzCiaNQ2CEH685vW53ibX4xia2IsNRuJ61khpkI2xDooaNyO2lNT9OoU4VUa3iazwLA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><blockquote><p>作者：前端学苑 公号 / 前端小贾 （本文来自作者投稿）</p></blockquote><blockquote><p>衡量网页的性能是一个比较琐碎的事情，因为没有某一个指标或数字可以直接告诉我们网页的性能怎样。优化的目的在于让页面加载的更快，对用户操作响应更及时，为用户带来更好的用户体验，对于开发者来说优化能够减少页面请求数，能够节省资源。</p></blockquote><p>简短的概括：</p><p>1､前端性能优化</p><p>2､前端性能监控</p><p>3､框架性能优化</p><p>正文从这里开始~~~</p><p>一、前端性能优化</p><p>1、从输入url到页面展现发生了什么？（万能面试题）</p><p>2、网络优化</p><p>3、浏览器优化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MXzNlnO3ib9Pxeun9OEYicdJiclWq5Tn0dD4YSLR3ic3bPoSuIUfoksbYibxWuC2VB7VuDNtkicpk5ibnrYnQ6oT6rooA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>详细如下：<img src="https://mmbiz.qpic.cn/mmbiz_png/OtuoacnwftRCRlcwbibSAicuNdvVcA9LmfpFZ6lrUMoBxW8826mJGRERSIuHiaJIbib3CqibatJiccRqMCXADTIoT0uQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></strong></p><hr><p><strong><em>\</em>从输入url到页面展现发生了什么？**</strong></p><p><strong><em>\</em>（万能面试题）**</strong></p><hr><p>1）浏览器的地址栏输入URL并按下回车；</p><p>2）DNS 解析：将域名解析成 IP 地址；</p><p>3）TCP 连接：TCP 三次握手；</p><p>4）发送 HTTP 请求；</p><p>5）服务器处理请求并返回 HTTP 报文；</p><p>6）浏览器解析渲染页面；</p><p>7）断开连接：TCP 四次挥手</p><p><strong>说完整个过程的几个关键点后我们再来展开的说一下。</strong></p><p>1、URL</p><p>我们常见的URL是这样的:<a href="http://www.baidu.com,这个域名由三部分组成：协议名、域名、端口号，这里端口是默认所以隐藏。最常见的的协议是HTTP协议，除此之外还有加密的HTTPS协议、FTP协议、FILe协议等等。如HTTP默认端口80，HTTPS默认端口443。说到这里可能有的面试官会问你同源策略，以及更深层次的跨域的问题。">http://www.baidu.com,这个域名由三部分组成：协议名、域名、端口号，这里端口是默认所以隐藏。最常见的的协议是HTTP协议，除此之外还有加密的HTTPS协议、FTP协议、FILe协议等等。如HTTP默认端口80，HTTPS默认端口443。说到这里可能有的面试官会问你同源策略，以及更深层次的跨域的问题。</a></p><p>2、DNS 解析 （ * 网络优化 ）</p><p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。</p><p><strong>1) IP 地址</strong></p><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式。</p><p><strong>2) 域名解析定义</strong></p><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。</p><p><strong>3) 浏览器如何通过域名去查询 URL 对应的 IP 呢？</strong></p><p>DNS域名解析分为递归查询和迭代查询两种方式，现一般为迭代查询。</p><p><strong>DNS 应用</strong></p><ol><li>CDN (Content Delivery Network) 就是利用DNS的重定向技术，DNS服务器会返回一个跟 用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</li></ol><ol start="2"><li>dns-prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。</li></ol><p><strong>OSI参考模型与TCP/IP四层模型</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/OtuoacnwftRCRlcwbibSAicuNdvVcA9Lmf7fJ23UTO25LfhvkONBS1KM7FzJBOm1EaRmWibsFEpeZIiaqwBDJkhTQw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>3、TCP 连接</p><p>客户端和服务端建立TCP连接需要三次握手。过程如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/OtuoacnwftRCRlcwbibSAicuNdvVcA9LmfB4FYBVZQAw5kI4PYVnrd88IMMxjQrU6Nhgr1Rcab6ChvcPl6lSu6UA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ol><li>客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</li></ol><ol start="2"><li>服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</li></ol><ol start="3"><li>客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</li></ol><p><strong>说明：</strong></p><p>ACK：确认标识，用于表示对数据包的成功接收。</p><p>SYN：同步标识，表示TCP连接已初始化。</p><p><strong>三次握手的目的：为了防止已经失效的连接请求报文段突然又传送到了服务器端，从而产生错误。</strong></p><p>4、发送HTTP请求 （ * 网络优化 ）</p><p>请求报文由请求行、请求头和请求体三部分组成。</p><p>1）请求行包含请求方法、url和协议版本。</p><p>2）请求头包含请求的附加信息，由键值对组成。如Host:github.com、User-Agent：””、Connection:keep-alive以及Cookie。</p><p>3）请求体主要是请求参数（Query String Parameters）。</p><p>注意：在发送HTTP请求的过程中，要先考虑浏览器缓存情况。缓存又分为强制缓存和协商缓存。</p><p>详细资料：<a href="http://mp.weixin.qq.com/s?__biz=MzI5MTUyMjk0Mw==&mid=2247485026&idx=1&sn=f9b76f0e03c8f74e43c16d6deb4354b2&chksm=ec0e1672db799f64cee594e50eb4b6be2f0e6a3271e95f0763864d6c9a2d340cdf9c182f8c0b&scene=21#wechat_redirect">一文读懂，关于 “ HTTP ” 那些事</a></p><p>5、服务器处理请求并返回 HTTP 报文</p><p>每台服务器上都会安装处理请求的应用——Web server。常见的web server产品有apache、nginx、IIS、Lighttpd等。</p><p>6、浏览器解析渲染页面 （ * 浏览器优化 ）</p><p><strong>浏览器渲染过程</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/OtuoacnwftRCRlcwbibSAicuNdvVcA9LmfEia9GK21bqdSZ9IP5GnYwTXVlUwA8gxOMmR4PPmpE7zftUKibtF4yPSw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>1）HTML解析，处理HTML标记并构建DOM树。</p><p>2）CSS解析，处理CSS标记并构建CSSOM树。</p><p>3）将DOM树和CSSOM合并称render tree(渲染树)。将每条css规则按照【从右至左】的方式在dom树上进行逆向匹配，然后生成具有样式规则描述的渲染树。</p><p>4）渲染树布局，计算每个节点的集合信息。包括repaint和reflow。</p><p>5）渲染树绘制，将每个节点绘制到屏幕上。</p><p><strong>重绘与重排（</strong>重排 又叫 回流<strong>）</strong></p><p>1）重排 (html改变) 一般是位置，大小，节点变化引起文档空间变化时发生的。</p><p>引起重排：</p><ul><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>页面一开始渲染的时候（这肯定避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ul><p>2）重绘（css改变）一般是颜色等不引起文档结构变化时发生的。</p><p>注：重绘不一定导致重排，但重排一定会导致重绘。</p><p>7、断开连接：TCP 四次挥手</p><p>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。</p><ol><li>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li></ol><ol start="2"><li>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li></ol><ol start="3"><li>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li></ol><ol start="4"><li>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li></ol><p><strong>TCP与UDP区别总结：</strong></p><p><strong>相同点：</strong>TCP和UDP都是网络层之上的，传输层协议，都能都能保护网络层的传输，双方的通信都需要开放端口，TCP和UDP中都存在复用和分用技术。</p><p><strong>不同点：</strong>TCP是可靠传输的，UDP是不可靠传输的。</p><p><strong>TCP VS UDP 对比：</strong></p><table><thead><tr><th>选项</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>可靠性</td><td>全双工可靠传输无差错，不丢失，不重复，且按序到达</td><td>尽最大努力交付</td></tr><tr><td>建立连接</td><td>需要建立连接</td><td>无需建立连接</td></tr><tr><td>数据发送模式</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>传输方式</td><td>点对点（不支持广播和多播）</td><td>一对一，一对多，多对一，多对多</td></tr><tr><td>首部开销</td><td>20字节</td><td>8字节</td></tr><tr><td>拥塞机制</td><td>有</td><td>无</td></tr><tr><td>流量控制</td><td>有</td><td>无</td></tr><tr><td>系统资源占用</td><td>对系统资源要求较多</td><td>对系统资源要求较少</td></tr><tr><td>实时性</td><td>相对UDP较低</td><td>较高，适用于对高速传输和实时性要求较高的通信或广播通信</td></tr><tr><td>确认重传机制</td><td>TCP提供超时重发，丢弃重复数据，检验数据，</td><td>无重传，只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地</td></tr></tbody></table><hr><p><strong><em>\</em>简单粗暴的优化策略**</strong></p><hr><p>1、⽂件加载的更少</p><ol><li><p>缓存，CDN  （详细资料：<a href="http://mp.weixin.qq.com/s?__biz=MzI5MTUyMjk0Mw==&mid=2247484933&idx=1&sn=19d6185b7ac2fda8f52a3b60e84a0607&chksm=ec0e1615db799f03db12947af64b8b7671d09d14dacc6b662ac25d92be0d4e7bf19ac140c550&scene=21#wechat_redirect">解析Web缓存及其最佳实践</a>）</p></li><li><p>图⽚优化</p></li><li><p>静态⽂件优化</p></li><li><p>浏览器优化</p></li><li><p>⽂件合并压缩等雅⻁军规常规操作</p></li></ol><p>2、代码执⾏的更少</p><p>1）节流防抖 （详细资料：<a href="http://mp.weixin.qq.com/s?__biz=MzI5MTUyMjk0Mw==&mid=2247485093&idx=1&sn=70864537b39b6c926ababf41f816e8d0&chksm=ec0e16b5db799fa341f333218598ef8f14197adad3f2e95decbbd46036e0da89e13bce0665f3&scene=21#wechat_redirect">彻底弄懂 “ 防抖 和 节流 ”</a>）</p><p>2）按需执⾏</p><p>3）回流重绘</p><p>4）框架优化（⽐如vue3的静态标记）</p><p>5）html、css、javascript</p><hr><p><strong>二、前端性能监控</strong></p><p>1、前端性能指标分析</p><p>2、关键性能指标统计</p><p>3、性能分析工具</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MXzNlnO3ib9Pxeun9OEYicdJiclWq5Tn0dD4YSLR3ic3bPoSuIUfoksbYibxWuC2VB7VuDNtkicpk5ibnrYnQ6oT6rooA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>详细如下：<img src="https://mmbiz.qpic.cn/mmbiz_png/OtuoacnwftRCRlcwbibSAicuNdvVcA9LmfpFZ6lrUMoBxW8826mJGRERSIuHiaJIbib3CqibatJiccRqMCXADTIoT0uQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></strong></p><hr><p><strong><em>\</em>前端性能指标分析**</strong></p><hr><p>以 <a href="https://www.google.com.hk/">https://www.google.com.hk</a> 为例，下图是使用Lighthouse（一个性能测评工具）捕获出的测评结果报告。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MpGQUHiaib4ib7IGiboflmhpibLq6UD9r8Y1FkrckDFlOayDdXd5lSkls1XrT04e5c6DTW2ExANczlIk1uAnr4F3hVw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>下图是使用Chrome浏览器的DevTools捕获出的加载性能结果报告。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MpGQUHiaib4ib7IGiboflmhpibLq6UD9r8Y1FV5rTNhQRCgdtCM8hhvtQHduZW6B2iao0EI8xTswicibOblgBVlXHEQF5g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>从上面这两张性能测评报告中，我们会发现报告通常会给出很多个 “关键时间点” 来表示性能数据，单独的某个“时间点”无法体现出网页的性能，只有将它们与自身的产品类型相结合，综合评估，才能判断出网页的性能到底怎样。而我们要做的，就是读懂报告中的各种专业术语，并分辨出哪些因素影响了网页的加载性能。</p><hr><p><strong><em>\</em>关键性能指标统计**</strong></p><hr><p><strong>FP、FCP、FMP与TTI</strong></p><p>从前面的评测报告中，我们会看到FP、FCP、FMP与TTI这几个字母很接近的术语，实际上他们的意思也非常接近，都表示浏览器在屏幕上渲染像素的时间点。</p><p>1）FP（全称“First Paint”，翻译为“首次绘制”） 是时间线上的第一个“时间点”，它代表浏览器第一次向屏幕传输像素的时间，也就是页面在屏幕上首次发生视觉变化的时间。</p><blockquote><p>注意：FP不包含默认背景绘制，但包含非默认的背景绘制。</p></blockquote><p>2）FCP（全称“First Contentful Paint”，翻译为“首次内容绘制”），顾名思义，它代表浏览器第一次向屏幕绘制 “内容”。</p><blockquote><p>注意：只有首次绘制文本、图片（包含背景图）、非白色的canvas或SVG时才被算作FCP。</p></blockquote><p>FP与FCP这两个指标之间的主要区别是：</p><p><strong>FP</strong>是当浏览器开始绘制内容到屏幕上的时候，只要在视觉上开始发生变化，无论是什么内容触发的视觉变化，在这一刻，这个时间点，叫做FP。</p><p><strong>FCP</strong>指的是浏览器首次绘制来自DOM的内容。例如：文本，图片，SVG，canvas元素等，这个时间点叫FCP。</p><p>3）FMP（全称“First Meaningful Paint”，翻译为“首次有效绘制”） 表示页面的“主要内容”开始出现在屏幕上的时间点。它是我们测量用户加载体验的主要指标。</p><blockquote><p>注意：FMP本质上是通过一个算法来猜测某个时间点可能是FMP，所以有时候不准。</p></blockquote><p><strong>说明：</strong></p><p>FMP 实现的三种方式：（需要扩展）</p><p>1､固定好dom的id，统计高度变化时间。</p><p>2､统计首屏dom的面积，计算占比 总结FMP。</p><p>3､dom变化趋势，来统计FMP。</p><p>计算占比 的思路 （需要扩展）</p><ul><li>元素权重：宽<em>⾼</em>权重(img,video要⽐普通dom⾼）；</li><li>进⼊⻚⾯开始记录，启⽤mutationobserver；</li><li>遍历domtree，根据可视区域⾯积，计算得分；</li><li>遍历⽗元素修正得分（⽗元素和⼦元素之和的最⼤值）；</li><li>平均值，过滤出⽬标元素；</li><li>是否img(video,canvas等；</li><li>合集求出FMP</li></ul><p>4）TTI（全称“Time to Interactive”，翻译为“可交互时间”） 表示网页第一次 完全达到可交互状态 的时间点。可交互状态指的是页面上的UI组件是可以交互的（可以响应按钮的点击或在文本框输入文字等），不仅如此，此时主线程已经达到“流畅”的程度，主线程的任务均不超过50毫秒。TTI很重要，因为TTI可以让我们了解我们的产品需要多久可以真正达到“可用”的状态。</p><p>图3给出了<strong>FP、FCP、FMP、TTI</strong>之间的比较。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MpGQUHiaib4ib7IGiboflmhpibLq6UD9r8Y1Fhp8Yhicldb66HPwJibC0Rsj0cFzTRaSxuyKfMecbjWZLiatDWePLh4wWQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><blockquote><p>W3C发布导航计时（Navigation Timing 2）的标准工作草案，该规范定义了一个统一的接口，存储和获取与网页导航和页面加载相关的高解析度的性能度量数据。</p><p>地址：<a href="https://www.w3.org/TR/navigation-timing-2/">https://www.w3.org/TR/navigation-timing-2/</a> </p></blockquote><p>如图：</p><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><hr><p><strong><em>\</em>性能分析工具**</strong></p><hr><p>1）谷歌开发者工具的“性能”选项进行分析：performance</p><p>详细资料：<a href="http://mp.weixin.qq.com/s?__biz=MzI5MTUyMjk0Mw==&mid=2247485181&idx=1&sn=9894db29fa89f155264a1de98d45b247&chksm=ec0e16eddb799ffbe13c480f244b5a8085a485390e3a5c6d042e982ee25c33ba2131c2474417&scene=21#wechat_redirect">性能优化篇 - Performance（工具 &amp; api）</a></p><p>2）谷歌的Lighthouse工具（国内网络环境）：基于 node（版本≥6）</p><p>安装：npm install -g lighthouse</p><p>运行使用：lighthouse <url> –view</url></p><p>例如：lighthouse <a href="https://www.baidu.com/">https://www.baidu.com/</a> –view</p><p>3）如果可以翻墙的话：可以在 Chorome 网上应用商店中安装 - 网页性能优化的扩展程序：Lighthouse、PageSpeed Insights ；</p><p>4）在线网页性能分析工具（推荐）</p><p><a href="https://tools.pingdom.com/">https://tools.pingdom.com/</a></p><p>Pingdom是一个免费的网站速度测试工作，不仅是看起来非常棒，而且尽可能多的呈现出你的网站的各方面信息。</p><p>5）使用 Chrome 原生 lazyload 属性进行图片懒加载</p><blockquote><p>chrome://flags/#enable-lazy-image-loading</p></blockquote><p>复制它到 Chrome 浏览器的地址栏，然后找到如下选项，将其设置为「Enabled」。</p><p><strong>例如：</strong><img src="/jiayueshe/jiayueshe.github/具体图片" alt lazyload="on"></p><p><strong>说明：</strong></p><p>auto 浏览器自行判断</p><p>on 开启懒加载</p><p>off 关闭懒加载</p><hr><p><strong>三、框架性能优化</strong></p><p>1、Vue性能优化</p><p>2、长列表优化 </p><p>3、用户体验优化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MXzNlnO3ib9Pxeun9OEYicdJiclWq5Tn0dD4YSLR3ic3bPoSuIUfoksbYibxWuC2VB7VuDNtkicpk5ibnrYnQ6oT6rooA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>详细如下：<img src="https://mmbiz.qpic.cn/mmbiz_png/OtuoacnwftRCRlcwbibSAicuNdvVcA9LmfpFZ6lrUMoBxW8826mJGRERSIuHiaJIbib3CqibatJiccRqMCXADTIoT0uQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></strong></p><hr><p><strong><em>\</em>Vue性能优化**</strong></p><hr><p>1、你都做过哪些Vue的性能优化？（ 统计后的结果 ）</p><p><strong>1）编码阶段</strong></p><ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher；</li><li>如果需要使用v-for给每项元素绑定事件时使用事件代理；</li><li>SPA 页面采用keep-alive缓存组件；</li><li>在更多的情况下，使用v-if替代v-show；</li><li>key保证唯一；</li><li>使用路由懒加载、异步组件；</li><li>防抖、节流；</li><li>第三方模块按需导入；</li><li>长列表滚动到可视区域动态加载；</li><li>图片懒加载；</li></ul><p><strong>2）用户体验：</strong></p><ul><li>骨架屏；</li><li>PWA；</li><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li></ul><p><strong>3）SEO优化</strong></p><ul><li>预渲染；</li><li>服务端渲染SSR；</li></ul><p><strong>4）打包优化</strong></p><ul><li>压缩代码；</li><li>Tree Shaking/Scope Hoisting；</li><li>使用cdn加载第三方模块；</li><li>多线程打包happypack；</li><li>splitChunks抽离公共文件；</li><li>sourceMap优化；</li></ul><p><strong>说明：</strong>优化是个大工程，会涉及很多方面，这里申请另开一个专栏<img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>2、vue1.X，vue2.X，vue3 框架分析性能 （ 还需要进一步学习 ）</p><p><strong>Vue1.x</strong> （特点：响应式）</p><p>没有vdom，完全的响应式，每个数据变化，都通过响应式通知机制来新建Watcher干活，项目规模变大后，过多的Watcher，会导致性能的瓶颈。</p><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p><strong>Vue2.x</strong> （特点：组件级响应式，组件内部vdom diff） </p><p>引入vdom，控制了颗粒度，组件层面走watcher通知， 组件内部走vdom做diff，既不会有太多watcher，也不会让vdom的规模过大，diff超过16ms，真是优秀。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/OtuoacnwftRdPL4VqJYTeMlGpI0Z2V9d2YU8ajygq0nnlWAZaXtejWob00DW9tsbh8kqRmoTZ3JnKMt9wfjA8g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>Vue3</strong> （特点：proxy做响应式：静态标记、按需更新） </p><p>先说结论，静态标记，<code>upadte</code>性能提升1.3<del>2倍，<code>ssr</code>提升2</del>3倍。</p><p>Vue3通过Proxy响应式+组件内部vdom+静态标记，把任务颗粒度控制的足够细致，所以也不太需要time-slice了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/OtuoacnwftRdPL4VqJYTeMlGpI0Z2V9dgria76w3ILrEFChaUmHPRXcibIXn8UA5fYSgudtfibl4uicxsibtEsBeQSw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><hr><p><strong><em>\</em>长列表优化**</strong></p><hr><p>1、vue-virtual-scroll-list优化长列表</p><p>虚拟列表的实现原理：只渲染可视区的 dom 节点，其余不可见的数据卷起来，只会渲染可视区域的 dom 节点，提高渲染性能及流畅性，优点是支持海量数据的渲染；</p><p>github地址：<a href="https://github.com/tangbc/vue-virtual-scroll-list">https://github.com/tangbc/vue-virtual-scroll-list</a></p><h2 id="2、Object-freeze优化长列表"><a href="#2、Object-freeze优化长列表" class="headerlink" title="2、Object.freeze优化长列表"></a>2、Object.freeze优化长列表</h2><p>Object.freeze()方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。</p><p>对于data()或vuex中冻结的对象，vue不会做getter和setter的转换。因此对于一个不变的、大数据量的数组或Object数据来说，使用Object.freeze()可以有效地提升性能。</p><hr><p><strong><em>\</em>用户体验优化**</strong></p><hr><p><strong>使用骨架屏</strong></p><p>骨架屏可以理解为是当数据还未加载进来前，页面的一个空白版本，一个简单的关键渲染路径。</p><p>一些项目，可能大部分数据都是从后端获取，网络请求是需要占用一定的时间的，所以用户一进来发现是空页面，所以这个时候可以使用骨架屏先加载一个轮廓，而不是让用户觉得这个页面挂了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/OtuoacnwftRmpicO7aMYibNKM1tQLB2A7yRFt5T6GZ4bkN72oRVsNRuNjombzowzwoYeeOCWF4KCmHRCFwVGsLJA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片"></p><p>可以看一下上面的示例图，第一个为骨架屏，第二个为菊花图，第三个为无优化，可以看到相比于传统的菊花图会在感官上觉得内容出现的流畅而不突兀，体验更加优良。</p><p>来源：<a href="https://mp.weixin.qq.com/s/PCmCS46GPc6tt1yb9goNFA">https://mp.weixin.qq.com/s/PCmCS46GPc6tt1yb9goNFA</a></p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>速度与激情之 Vite 初体验（最佳入门）</title>
      <link href="2021/03/03/ziliao/javascript/vite-ti-yan/"/>
      <url>2021/03/03/ziliao/javascript/vite-ti-yan/</url>
      
        <content type="html"><![CDATA[<p>大家最近学习 Vue3 学废了吗？尤雨溪尤大大马不停蹄地又给大家送来了专门为 Vue3 打造的开发利器 — Vite。你是否在开发过程中使用 Webpack 觉得不那么丝滑，是否等待启动编译可以喝好几口热水？本文将带领大家简单了解 Vite 的基本知识和作用，让我们更好的开启 Vue3 开发之旅~ 首先，学习 Vite 之前得至少有 2 部分的知识储备：1）掌握 ES Modules 特性 2）了解 Http2 标准，限于篇幅，这里就不过多赘述啦~</p><h2 id="一、问题来源"><a href="#一、问题来源" class="headerlink" title="一、问题来源"></a>一、问题来源</h2><h3 id="1-1-Webpack-槽点"><a href="#1-1-Webpack-槽点" class="headerlink" title="1.1 Webpack 槽点"></a>1.1 Webpack 槽点</h3><p>如果应用比较复杂，那么使用 Webpack 的开发过程就相对没有那么舒适。</p><pre><code>  - Webpack Dev Server 冷启动时间会比较长  - Webpack HMR 热更新的反应速度比较慢</code></pre><p><strong><img src="https://mmbiz.qpic.cn/mmbiz_jpg/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjxO68MtsrFIplBh3GtpG8Vk9iczYsN4iaJbNZdamHXibF1rUFdqvj6U1b9w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></strong></p><h3 id="1-2-回顾-Webpack-初衷"><a href="#1-2-回顾-Webpack-初衷" class="headerlink" title="1.2 回顾 Webpack 初衷"></a>1.2 回顾 Webpack 初衷</h3><p>【之前技术环境】我们使用 Webpack 打包应用代码，最后生成一个 bundle.js，主要有两个原因：</p><pre><code>  - 浏览器环境并不很好的来支持模块化  - 零散的模块文件会产生大量的 HTTP 请求</code></pre><h3 id="1-3-思考现在"><a href="#1-3-思考现在" class="headerlink" title="1.3 思考现在"></a>1.3 思考现在</h3><p>bundle 太大，要采用各种 Code Splitting，压缩代码，去除的插件，提取的第三方库，so tired~ 【当前技术环境】是否能解决 Webpack 当时的难点？thinking~~</p><h2 id="二、解决思路"><a href="#二、解决思路" class="headerlink" title="二、解决思路"></a>二、解决思路</h2><h3 id="2-1-ES-Module"><a href="#2-1-ES-Module" class="headerlink" title="2.1 ES Module"></a>2.1 ES Module</h3><ul><li>随着浏览器的对 ES 标准支持的逐渐完善，第一个问题已经慢慢不存在了。现阶段绝大多数浏览器都是支持 ES Modules 的。</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjxiaQ2jdztBW5sh45tU9wAJsAkNA15Zk8ia3eAXA46qFRFOqNFWspgSjIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>其最大的特点是在浏览器端使用 export import 的方式导入和导出模块，在 script 标签里写 <code>type=&quot;module&quot;</code> ，然后使用 ES Module。</p><pre><code>// 当 html 里嵌入 ES module 的 script 标签时候，浏览器会发起 http 请求，请求 http server 托管的 main.js ;// index.html&lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;// 使用 export 导出模块, import 导入模块：// main.js import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;./App.vue&#39;import &#39;./index.css&#39;createApp(App).mount(&#39;#app&#39;)</code></pre><p>直接访问 index.html，报错：<img src="https://mmbiz.qpic.cn/mmbiz_png/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjxXRe2963J6wwH63xgPEZ1EsokmSiaGBDLR754C6ySFjCPupxJJvnogqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">在浏览器里使用 ES module 是使用 http 请求拿到模块的，所以 file 协议的请求不允许。</p><h3 id="2-2-模块解析"><a href="#2-2-模块解析" class="headerlink" title="2.2 模块解析"></a>2.2 模块解析</h3><p>那我们就在本地起一个静态服务，再来打开一下 index.html 来看下<img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">报错：找不到模块 vue；原因：”/“, “./“, or “../“开头的 import 相对/绝对路径，才是合法的。</p><pre><code>import vue from &#39;vue&#39;</code></pre><p>也就是说浏览器中的 ESM 是获取不到导入的模块内容的。平时我们写代码，如果不是引用相对路径的模块，而是引用 <code>node_modules</code> 的模块，都是直接 <code>import xxx from &#39;xxx&#39;</code>，由 <code>Webpack</code> 等工具来帮我们处理 js 间的相互依赖关系，找这个模块的具体路径进行打包，但是浏览器不知道你项目里有 <code>node_modules</code>，它只能通过相对路径或者绝对路径去寻找模块。</p><p>那咋办？？？所以 <strong>Vite 的一个任务就是启动一个 web server 去代理这些模块，Vite 这里是借用了 koa 来启动了一个服务</strong></p><pre><code>export function createServer(config: ServerConfig): Server &#123;  // ...  const app = new Koa&lt;State, Context&gt;()  const server = resolveServer(config, app.callback())    // ...  const listen = server.listen.bind(server)  server.listen = (async (port: number, ...args: any[]) =&gt; &#123;    if (optimizeDeps.auto !== false) &#123;      await require(&#39;../optimizer&#39;).optimizeDeps(config)    &#125;    return listen(port, ...args)  &#125;) as any    server.once(&#39;listening&#39;, () =&gt; &#123;    context.port = (server.address() as AddressInfo).port  &#125;)    return server&#125;</code></pre><p>那这就引出了 <strong>Vite 的一个实现核心 - 拦截浏览器对模块的请求并返回处理后的结果</strong>我们来看下 Vite 是怎么处理的？</p><h3 id="2-3-module-前缀"><a href="#2-3-module-前缀" class="headerlink" title="2.3 /@module/前缀"></a>2.3 <code>/@module/</code>前缀</h3><p>通过工程下的 main.js 和开发环境下的实际加载的 main.js 对比，发现 main.js 内容发生了改变，由</p><pre><code>import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;./App.vue&#39;import &#39;./index.css&#39;createApp(App).mount(&#39;#app&#39;)</code></pre><p>变成了</p><pre><code>import &#123; createApp &#125; from &#39;/@modules/vue.js&#39;import App from &#39;/src/App.vue&#39;import &#39;/src/index.css?import&#39;createApp(App).mount(&#39;#app&#39;)</code></pre><p>为了解决 <code>import xxx from &#39;xxx&#39;</code> 报错的问题，Vite 对这种资源路径做了一个统一的处理，加一个<code>/@module/</code>前缀。我们在 <code>src/node/server/serverPluginModuleRewrite.ts</code> 源码这个 koa 中间件里可以看到 Vite 对 import 都做了一层处理，其过程如下：</p><ul><li>在 koa 中间件里获取请求 ctx.body</li><li>通过 <strong>es-module-lexer</strong> 解析资源 ast 拿到 import 的内容</li><li>判断 import 的资源是否是绝对路径，绝对视为 npm 模块</li><li><strong>rewriteImports</strong> 返回处理后的资源路径：”vue” =&gt; “/@modules/vue”</li></ul><p>**如何支持 <code>/@module/？</code>**在 <code>/src/node/server/serverPluginModuleResolve.ts</code> 里可以看到大概的处理逻辑是</p><ul><li>在 koa 中间件里获取请求 ctx.body</li><li>判断路径是否以 /@module/ 开头，如果是取出包名</li><li>去 node_module 里找到这个库，基于 package.json 返回对应的内容</li></ul><h3 id="2-4-文件编译"><a href="#2-4-文件编译" class="headerlink" title="2.4 文件编译"></a>2.4 文件编译</h3><p>上面我们提到的是对普通 js module 的处理，那对于其他文件，比如 <code>vue</code>、<code>css</code>、<code>ts</code>等是如何处理的呢？我们以 vue 文件为例来看一下，在 Webpack 里我们是使用的 vue-loader 对单文件组件进行编译，实际上 Vite 同样的是<strong>拦截了对模块的请求并执行了一个实时编译</strong>。通过工程下的 App.vue 和开发环境下的实际加载的 App.vue 对比，发现内容发生了改变 原本的 App.vue</p><pre><code>&lt;template&gt;  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;  &lt;HelloWorld msg=&quot;Hello Vue 3.0 + Vite&quot; /&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from &#39;./components/HelloWorld.vue&#39;export default &#123;  name: &#39;App&#39;,  components: &#123;    HelloWorld  &#125;&#125;&lt;/script&gt;&lt;style&gt;  body &#123;    background: #fff;  &#125;&lt;/style&gt;</code></pre><p>变成了</p><pre><code>import HelloWorld from &#39;/src/components/HelloWorld.vue&#39;const __script = &#123;    name: &#39;App&#39;,    components: &#123;        HelloWorld    &#125;&#125;import &quot;/src/App.vue?type=style&amp;index=0&quot;import &#123;render as __render&#125; from &quot;/src/App.vue?type=template&quot;__script.render = __render__script.__hmrId = &quot;/src/App.vue&quot;typeof __VUE_HMR_RUNTIME__ !== &#39;undefined&#39; &amp;&amp; __VUE_HMR_RUNTIME__.createRecord(__script.__hmrId, __script)__script.__file = &quot;/Users/liangxiaoying/myfile/wy-project/vite-demo/src/App.vue&quot;export default __script</code></pre><p>这样就把原本一个 <code>.vue</code> 的文件拆成了三个请求（分别对应 script、style 和 template） ，浏览器会先收到包含 script 逻辑的 App.vue 的响应，然后解析到 template 和 style 的路径后，会再次发起 HTTP 请求来请求对应的资源，此时 Vite 对其拦截并再次处理后返回相应的内容。</p><p>实际上在看到这个思路之后，对于其他的类型文件的处理几乎都是类似的逻辑，根据请求的不同文件类型，做出不同的编译处理。<strong>实际上 Vite 就是在按需加载的基础上通过拦截请求实现了实时按需编译</strong></p><h3 id="2-5-HTTP-2"><a href="#2-5-HTTP-2" class="headerlink" title="2.5 HTTP 2"></a>2.5 HTTP 2</h3><ul><li>零散模块文件在<strong>HTTP 1.x \</strong>确实会产生大量的 HTTP 请求，而大量的 HTTP 请求在浏览器端就会并发请求资源的问题；但是这些问题随着**HTTP 2**的出现，也就不复存在了。</li><li>why?</li></ul><p>HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8 个的 TCP 链接请求限制；HTTP 2 则可以使用<strong>多路复用</strong>，代替原来的序列和阻塞机制。所有请求都是通过一个 TCP 连接并发完成。<img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><h2 id="三、三大作用"><a href="#三、三大作用" class="headerlink" title="三、三大作用"></a>三、三大作用</h2><p>即 Vite 的 3 大核心功能：Static Server  + HMR + Compile</p><h3 id="3-1-快速的冷启动"><a href="#3-1-快速的冷启动" class="headerlink" title="3.1 快速的冷启动"></a>3.1 快速的冷启动</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjxU87KR9JVnFl9g26xmuroHsCsZUrECBLDgrhPMWZYusw1mSqjcArlEA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">社区：比如可以借助各种 cli ：vue-cli、create-react-app 等等</p><p>当我们对比使用 vue-cli-service serve 的时候，会有明显感觉。<strong>因为 Webpack Dev Server 在启动时，需要先 build—遍，而 build 的过程是需要耗费很多时间的。**</strong><img src="https://mmbiz.qpic.cn/mmbiz_png/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjx491micWSphF36pgeicUo6WUXpiaiajpYLia2dicibRxqdfqalWTaIZxnJF1GQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><strong>**而 Vite 则完全不同，当我们执行 Vite serve 时（\</strong>npm run dev**），内部直接启动了 Web Server，并不会先编译所有的代码文件。<strong>那仅仅是启动 Web Server，速度上自然就蹭蹭蹭的 up↑。那么及时请求的编译呢？关于支持 JSX， TSX，Typescript 编译到原生 JS —— Vite 引入了</strong>EsBuild**，是使用 Go 写的，直接编译为 Native 代码，性能要比 TSC 好二三十倍,所以就不用担心啦~ 当然也会用上缓存，具体这里暂时不扩展。<img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><h3 id="3-2-即时的热模块更新"><a href="#3-2-即时的热模块更新" class="headerlink" title="3.2 即时的热模块更新"></a>3.2 即时的热模块更新</h3><p>社区：Webpack HMR 等</p><p>热更新的时候，Vite 只需要立即编译当前所修改的文件即可，所以 响应速度非常快。<img src="https://mmbiz.qpic.cn/mmbiz_png/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjxQYDdeabfibbYbvMv9ofluF3UFfbdvSw7ccLtNHuh98yEict844tlohWQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">而 Webpack 修改某个文件过后，会自动以这个文件为入口重写 build—次，所有的涉及到的依赖也都会被加载一遍，所以反应速度会慢很多。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjxt1hEjAceHTNSF6nYUBT3pwCnSEhyZjuhIr6VaLuzmL7XZ1A4z1gM0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz_png/Tmczbd3NL02sfWXFEw0doMUvwAAPBVjxwc7elX8zqScUZKyICSdgJyOAEv6OFkj8jEeCvK79nrcz11m7nvuIfw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="3-3-真正的按需编译"><a href="#3-3-真正的按需编译" class="headerlink" title="3.3 真正的按需编译"></a>3.3 真正的按需编译</h3><p>社区：需要开发者自行在代码中引入其他插件 <code>impor(&#39;xx.js&#39;)</code> 实现 dynamic-import；如@babel/plugin-syntax-dynamic-import</p><p>但是像 Webpack 这类工具的做法是将所有模块提前编译、打包进 bundle 里，换句话说，不管模块是否会被执行，都要被编译和打包到 bundle 里。随着项目越来越大打包后的 bundle 也越来越大，打包的速度自然也就越来越慢。</p><p>Vite 利用现代浏览器原生支持 ESM 特性，省略了对模块的打包。</p><p>对于需要编译的文件，Vite 采用的是另外一种模式：即时编译。也就是说，只有具体去请求某个文件时才会编译这个文件。所以，这种「即时编译」的好处主要体现在：按需编译。</p><h2 id="四、核心思路"><a href="#四、核心思路" class="headerlink" title="四、核心思路"></a>四、核心思路</h2><h3 id="4-1-初始启动静态服务"><a href="#4-1-初始启动静态服务" class="headerlink" title="4.1 初始启动静态服务"></a>4.1 初始启动静态服务</h3><p>初始执行命令  npm run dev –&gt; 实际就是启动了 /src/node/server/index.ts 如上文提到启动了一个 koa server, 该文件还使用了 chokidar 库创建一个 watcher，来监听文件变动：</p><pre><code>export function createServer(config: ServerConfig): Server &#123;  // 启动静态 server：  const app = new Koa&lt;State, Context&gt;()  const server = resolveServer(config, app.callback())    ......    const listen = server.listen.bind(server)  server.listen = (async (port: number, ...args: any[]) =&gt; &#123;    ...  &#125;) as any      // 其中关键 1：使用 chokidar 对文件进行递归监听：监听到文件变动可对不同模块进行相应处理  const watcher = chokidar.watch(root, &#123;    ignored: [&#39;**/node_modules/**&#39;, &#39;**/.git/**&#39;],    ...  &#125;) as HMRWatcher    // 其中关键 2：执行各类插件  const resolvedPlugins = [    // rewrite and source map plugins take highest priority and should be run    // after all other middlewares have finished    sourceMapPlugin,    moduleRewritePlugin,    htmlRewritePlugin, // 处理 html 文件    // user plugins    ...toArray(configureServer),    envPlugin,    moduleResolvePlugin,    proxyPlugin,    clientPlugin, // 输出客户端执行代码    hmrPlugin, // 处理热模块更新    ...(transforms.length || Object.keys(vueCustomBlockTransforms).length      ? [          createServerTransformPlugin(            transforms,            vueCustomBlockTransforms,            resolver          )        ]      : []),    vuePlugin, // 处理单文件组件    cssPlugin, // 处理样式文件    enableEsbuild ? esbuildPlugin : null,    jsonPlugin,    assetPathPlugin,    webWorkerPlugin,    wasmPlugin,    serveStaticPlugin  ]  resolvedPlugins.forEach((m) =&gt; m &amp;&amp; m(context))&#125;</code></pre><h3 id="4-2-监听消息，拦截部分请求"><a href="#4-2-监听消息，拦截部分请求" class="headerlink" title="4.2 监听消息，拦截部分请求"></a>4.2 监听消息，拦截部分请求</h3><p>我们可以看到初始第一个请求如下：<img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">那么这个文件哪里来的？这就是经过 clientPlugin 【/src/node/server/serverPluginClient.ts】处理输出的：</p><pre><code>export const clientPublicPath = `/vite/client` // 当前的文件名称const legacyPublicPath = &#39;/vite/hmr&#39; // 历史版本的名称...export const clientPlugin: ServerPlugin = (&#123; app, config &#125;) =&gt; &#123; // clientCode 替换配置的信息，用于最后 body 输出： const clientCode = fs    .readFileSync(clientFilePath, &#39;utf-8&#39;)    .replace(`__MODE__`, JSON.stringify(config.mode || &#39;development&#39;))    ...app.use(async (ctx, next) =&gt; &#123;   // 请求路径是/vite/client,返回响应：200，响应文本是处理好的 clientCode    if (ctx.path === clientPublicPath) &#123;      // 设置 socket 配置信息      let socketPort: number | string = ctx.port      ...      if (config.hmr &amp;&amp; typeof config.hmr === &#39;object&#39;) &#123;        // hmr option 有最高优先级        ...      &#125;      ctx.type = &#39;js&#39;      ctx.status = 200      // 返回整合好的 body      ctx.body = clientCode.replace(`__HMR_PORT__`, JSON.stringify(socketPort))    &#125; else &#123;      if (ctx.path === legacyPublicPath) &#123; // 历史版本 /vite/hmr        console.error(&#39;xxxx&#39;)      &#125;      return next()    &#125;  &#125;) &#125;</code></pre><p>请求/vite/client 实际就是 /src/client/client.ts 文件，即返回 body = clientCode = client.ts 文件内容；那么它做啥了呢？？？使用 websoket 处理消息，快速编译，达到实时热更新：</p><pre><code>const socketProtocol =  __HMR_PROTOCOL__ || (location.protocol === &#39;https:&#39; ? &#39;wss&#39; : &#39;ws&#39;)const socketHost = `$&#123;__HMR_HOSTNAME__ || location.hostname&#125;:$&#123;__HMR_PORT__&#125;`// 启动 websocket 通信，可实时处理消息，实现 HMRconst socket = new WebSocket(`$&#123;socketProtocol&#125;://$&#123;socketHost&#125;`, &#39;vite-hmr&#39;)...</code></pre><p>监听消息：</p><pre><code>socket.addEventListener(&#39;message&#39;, async (&#123; data &#125;) =&gt; &#123;  const payload = JSON.parse(data) as HMRPayload | MultiUpdatePayload  handleMessage(payload)&#125;)</code></pre><p>处理消息：</p><pre><code>async function handleMessage(payload) &#123;    const &#123; path, changeSrcPath, timestamp &#125; = payload;    switch (payload.type) &#123;        case &#39;connected&#39;: // socket 连接成功            console.log(`[vite] connected.`);            break;        case &#39;vue-reload&#39;: // 组件重新加载            queueUpdate(import(`$&#123;path&#125;?t=$&#123;timestamp&#125;`)                .catch((err) =&gt; warnFailedFetch(err, path))                .then((m) =&gt; () =&gt; &#123;                __VUE_HMR_RUNTIME__.reload(path, m.default);                console.log(`[vite] $&#123;path&#125; reloaded.`);            &#125;));            break;        case &#39;vue-rerender&#39;: // 组件重新渲染            const templatePath = `$&#123;path&#125;?type=template`;            import(`$&#123;templatePath&#125;&amp;t=$&#123;timestamp&#125;`).then((m) =&gt; &#123;                __VUE_HMR_RUNTIME__.rerender(path, m.render);                console.log(`[vite] $&#123;path&#125; template updated.`);            &#125;);            break;        case &#39;style-update&#39;: // 样式更新            // check if this is referenced in html via &lt;link&gt;            const el = document.querySelector(`link[href*=&#39;$&#123;path&#125;&#39;]`);            if (el) &#123;                el.setAttribute(&#39;href&#39;, `$&#123;path&#125;$&#123;path.includes(&#39;?&#39;) ? &#39;&amp;&#39; : &#39;?&#39;&#125;t=$&#123;timestamp&#125;`);                break;            &#125;            // imported CSS            const importQuery = path.includes(&#39;?&#39;) ? &#39;&amp;import&#39; : &#39;?import&#39;;            await import(`$&#123;path&#125;$&#123;importQuery&#125;&amp;t=$&#123;timestamp&#125;`);            console.log(`[vite] $&#123;path&#125; updated.`);            break;        case &#39;style-remove&#39;: // 样式移除            removeStyle(payload.id);            break;        case &#39;js-update&#39;: // js 更新            queueUpdate(updateModule(path, changeSrcPath, timestamp));            break;        case &#39;custom&#39;: // 自定义更新            const cbs = customUpdateMap.get(payload.id);            if (cbs) &#123;                cbs.forEach((cb) =&gt; cb(payload.customData));            &#125;            break;        case &#39;full-reload&#39;: // 网页重刷新            if (path.endsWith(&#39;.html&#39;)) &#123;                ...            &#125; else &#123;                location.reload();            &#125;    &#125;&#125;</code></pre><p>咦？那设立了 message 监听，那 message 又是谁发出来的呢？</p><h3 id="4-3-不同插件，监听文件变化，返回消息"><a href="#4-3-不同插件，监听文件变化，返回消息" class="headerlink" title="4.3 不同插件，监听文件变化，返回消息"></a>4.3 不同插件，监听文件变化，返回消息</h3><p>例如：cssPlugin 【/src/node/server/serverPluginCss.ts】</p><pre><code>// 处理 css 文件，监听 css 文件变动export const cssPlugin: ServerPlugin = (&#123; root, app, watcher, resolver &#125;) =&gt; &#123;  // 输出 css 请求的响应模板  export function codegenCss(    id: string,    css: string,    modules?: Record&lt;string, string&gt;  ): string &#123;    let code =      `import &#123; updateStyle &#125; from &quot;$&#123;clientPublicPath&#125;&quot;\n` +      `const css = $&#123;JSON.stringify(css)&#125;\n` +      `updateStyle($&#123;JSON.stringify(id)&#125;, css)\n`    if (modules) &#123;      code += dataToEsm(modules, &#123; namedExports: true &#125;)    &#125; else &#123;      code += `export default css`    &#125;    return code  &#125;    app.use(async (ctx, next) =&gt; &#123;    await next()    // 处理 .css 的 imports    ...    const id = JSON.stringify(hash_sum(ctx.path))    if (isImportRequest(ctx)) &#123;      const &#123; css, modules &#125; = await processCss(root, ctx)      ctx.type = &#39;js&#39;      // 用`?import`去重写 css 文件为一个 js 模块,插入 style 标记，链接到实际原始 url      ctx.body = codegenCss(id, css, modules)    &#125;  &#125;)  watcher.on(&#39;change&#39;, (filePath) =&gt; &#123;    // 筛出 css 文件，更新 css 请求文件    if (文件更新) &#123;      watcher.send(&#123; // 发送消息        type: &#39;style-update&#39;,        path: publicPath,        changeSrcPath: publicPath,        timestamp: Date.now()      &#125;)    &#125;  &#125;)  &#125;</code></pre><h3 id="4-4-逻辑小结"><a href="#4-4-逻辑小结" class="headerlink" title="4.4 逻辑小结"></a>4.4 逻辑小结</h3><ul><li>将当前项目目录作为静态文件服务器的根目录</li><li>拦截部分文件请求</li><li>处理代码中 import node_modules 中的模块 b</li><li>处理 Vue 单文件组件（SFC)的编译</li><li>通过 WebSocket 实现 HMR</li></ul><h2 id="五、Snowpack-VS-Vite"><a href="#五、Snowpack-VS-Vite" class="headerlink" title="五、Snowpack VS Vite"></a>五、Snowpack VS Vite</h2><p><strong>同：</strong></p><ol><li>底层原理：Snowpack v2 和 Vite 均提供基于浏览器原生 ES 模块导入的开发服务器；</li><li>冷启动快速：在开发反馈速度方面，两个项目都具有相似的性能特征；</li><li>开箱即用：避免各种 Loader 和 Plugin 的配置。</li></ol><p>Vite 默认情况下支持更多的选择加入功能-例如 TypeScript transpilation、CSS import、CSS Modules 和 postcss 支持（需要单独安装所对应的编译器) 都是现成的，无需配置；snowpack 也是支持 JSX、TypeScript、React、Preact、CSS Modules 等构建，非默认；</p><ol><li>插件：支持很多自定义插件；Vite 关于这部分的官方文档还没有。</li></ol><p><strong>异：</strong></p><ol><li>演变：Snowpack 最初不提供 HMR 支持，但在 v2 添加了它，从而使两个项目的范围更加接近。Vite 最初就是参考了 snowpack v1; 双方在基于 ESM 的 HMR 上合作过，尝试建立统一的 api ESM-HMR API 规范， 但因为底层不同还是会略微不同；</li><li>使用：Vite 当前暂时只能给 Vue 3.x.使用+react 等部分模板, 对 vue 支持更棒👍；snowpack 没限制；</li><li>生产打包：Vite 用 rollup，打包体积更小（<strong>rollupInputOptions：定义 rollup 的插件功能</strong>）；snowpack 用 parcel/webpack；- 决定了开发者生产个性化配置的方案不一样；</li><li>偏向：Vue 支持是 Vite 中的一级功能。例如，Vite 提供了一个更细粒度的 HMR 与 Vue 的集成，并且对构建配置进行了微调，以生成最高效的 bundle；</li><li>文档完善性：</li></ol><ul><li>Vitejs 优点是尤雨溪出品，可能和 Vue3 生态更好的融合。缺点是文档不完善。目前 star 13.7k；</li><li>Snowpack 优点是更加成熟，有成熟的 v1 和已经发布正式版的 v2, 支持 react， Vue， preact， svelte 等各类应用，文档也更加完善。目前 star 14.4k。</li></ul><p><strong>so。。。如何选择？：</strong>=&gt; 选 Vite:</p><ol><li>喜欢用 Vue，那么 Vite 提供更好支持；</li><li>诉求是打包 bundle 体积小 ，那么 Vue 使用 rollup👌。</li></ol><p>=&gt; 选 Snowpack：</p><ol><li>不喜欢用 Vue,不用 vue-cli,喜欢 react 等；</li><li>大的 team 想要使用各类插件 plugin，想要清晰的文档📚等；</li><li>对 Webpack 比较用的惯，想要开发模式不要 bundle 打包，更快速👀。</li></ol><p>来源：<a href="https://mp.weixin.qq.com/s/nI9o0NyoAI7jjreoflk79A">https://mp.weixin.qq.com/s/nI9o0NyoAI7jjreoflk79A</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端拓展：如何开发一个 Chrome 插件？</title>
      <link href="2021/03/03/ziliao/javascript/es6-copy/"/>
      <url>2021/03/03/ziliao/javascript/es6-copy/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是浏览器插件？"><a href="#什么是浏览器插件？" class="headerlink" title="什么是浏览器插件？"></a>什么是浏览器插件？</h2><p>简单来说浏览器插件，是浏览器上的一种工具，可以提供一些浏览器没有的功能，帮你做一些有趣的事情。开发者可以根据自己的喜欢，去实现一些功能。插件基于Web技术（html、css、js）构建。</p><h2 id="举个栗子🌰"><a href="#举个栗子🌰" class="headerlink" title="举个栗子🌰"></a>举个栗子🌰</h2><h3 id="FeHelper-JSON插件"><a href="#FeHelper-JSON插件" class="headerlink" title="FeHelper.JSON插件"></a>FeHelper.JSON插件</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZM2nTDaNBJXLcTLWtnTlBFMpaSicMge4GL1LfPNNqIGCoz30XMVTEgPag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>功能：格式化JSON、编码转化、markdown、代码压缩等功能。</p><h3 id="二维码生成器"><a href="#二维码生成器" class="headerlink" title="二维码生成器"></a>二维码生成器</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMuGVqnszYxGr4wnLib08SqLsrZP6PgtYict4brzEAhl1u6lMmRALrkTnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>功能：可以根据当前浏览的网页地址，生成一个二维码。</p><h3 id="SwitchyOmega-Proxy"><a href="#SwitchyOmega-Proxy" class="headerlink" title="SwitchyOmega Proxy"></a>SwitchyOmega Proxy</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMG6Xia2PKgfNIaGTN4OibB6ZKsSZZia81RIul9QUu8aLmvibSOjPIHVs4xA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>功能：你懂的。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h3><p>Chrome 浏览器插件没有严格的文件结构约束，只需要保证文件夹根目录有 <strong>manifest.json</strong> 文件<strong>，</strong>该文件的内容会概括插件所需的资源、权限等等。</p><p>一个段简单的示例：</p><pre><code>&#123;    &quot;manifest_version&quot;: 2, // 必填    &quot;name&quot;: &quot;my-plugin&quot;, // 必填    &quot;version&quot;: &quot;0.1.0&quot; // 必填&#125;</code></pre><p>manifest_version：代表了manifest文件的版本，浏览器会根据这个值去指定该版本拥有的功能。</p><p>name：插件的名称。</p><p>version：插件版本。</p><p>将manifest.json文件放到一个文件夹内。</p><h3 id="chrome-extensions"><a href="#chrome-extensions" class="headerlink" title="chrome://extensions/"></a>chrome://extensions/</h3><p>在浏览器地址栏输入chrome://extensions/打开“拓展程序”页面。</p><p>注意：需要启用右上角的 “开发者模式” 才能加载已解压的插件文件：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMsD8eWf0NliaEuTHoBYF1icbMrRhyR4icIsV3olpxsBrpEqtUpicpBr7V8w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="加载已解压的插件"><a href="#加载已解压的插件" class="headerlink" title="加载已解压的插件"></a>加载已解压的插件</h3><p>启用之后点击加载已解压的拓展程序，选择刚刚我们放入了manifest.json的文件夹，之后你会看到：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMFlDibS50coOOYMdQDF3YBwJAiahbb8icfbIAHlAicc6pRvucusoxuCvVpg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>新增了一个我们刚刚添加的插件，而且浏览器右上角也会有我们的一个图标：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMvoVN3ia30vx92He9j8KMF9PMCjY0Y4kIn8k9VmpkiaicgluqsRrUAKqicQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>此时已经加载了一个插件了，但是这个插件除了占用浏览器的一个位置除外，没有任何作用。</p><p>如果没有设置插件图标，那么插件的第一个字符会成为插件的默认icon。</p><h3 id="让插件看起来更“插件”一点"><a href="#让插件看起来更“插件”一点" class="headerlink" title="让插件看起来更“插件”一点"></a>让插件看起来更“插件”一点</h3><p>为了让这个插件更“完善”一点，我们给它加一个icon和描述，并且点击出现一个popup页面，popup 页面一般用来承载临时性的交互，且生命周期很短：单击图标打开popup，焦点离开又立即关闭，可以通过default_popup字段来定义。</p><pre><code>&#123;  .....  &quot;description&quot;: &quot;这是一段描述&quot;,  // 插件管理页面的icon  &quot;icons&quot;: &#123;    &quot;84&quot;: &quot;./icon/ball.png&quot;  &#125;,  // 浏览器右上角的图标和内容  &quot;browser_action&quot;: &#123;    &quot;default_icon&quot;: &quot;./icon/ball.png&quot;,    &quot;default_title&quot;: &quot;我的插件&quot;,    &quot;default_popup&quot;: &quot;./html/popup.html&quot;  &#125;&#125;</code></pre><p>此时我们的目录结构也变成了这样：</p><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>给popup.html加上内容：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;my-plugin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p style=&quot;width: 200px;text-align:center;&quot;&gt;hello world!!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>之后，我们点击插件右下角的“刷新”按钮：</p><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>你会发现插件有了icon和描述：</p><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>并且右上角的icon也变了，点击一下，会弹出我们刚刚编写的popup.html页面：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZM2ybjHtPpicFjoEU8M75faAdzDS3zT0meA0zgMdu3zDicNe9GUTORv85A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>现在，我们一个“完整”的插件就已经做好了。</p><h2 id="manifest-json-配置介绍"><a href="#manifest-json-配置介绍" class="headerlink" title="manifest.json 配置介绍"></a>manifest.json 配置介绍</h2><h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><pre><code>&#123;    ...    &quot;background&quot;: &#123;        // 提供一个页面给background        &quot;page&quot;: &quot;./html/background.html&quot;        // 或者若干个js文件，后台会默认生成一个空白的html        &quot;scripts&quot;: [&quot;./js/background.js&quot;]    &#125;&#125;</code></pre><p>background配置项，为插件的后台常驻页面，生命周期随着浏览器的生命周期一样，浏览器一启动，后台页面就会开始运行，直到浏览器被关闭；或者在插件管理页面，将该插件禁用了，后台页面也会停止运行。</p><p>另外，background拥有的权限比较高，几乎可以调用所有的Chrome扩展API（除了devtools），同时拥有直接跨域的能力。</p><p>page:指定一个网页为后台页面。</p><p>scripts:指定若干个js文件，后台会自动生成一个html，并按顺序调用这些js文件。</p><p>注意：<strong>page</strong> 和 <strong>scripts</strong> 选项只能<strong>二选一</strong>，不然会报错。</p><p>配置好之后，属性插件，会出现一个背景页选项：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMWicHDJKtia4MjSA08GyJPKCYbGlMJsyRKZeqHbK9U2bShJ7NVGBeUqpg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>我使用的是一个background.js文件：</p><pre><code>function _back() &#123;  console.log(&#39;background.js&#39;)&#125;console.log(&#39;running...&#39;)</code></pre><p>点进去看看里面装的什么玩意：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMcgde1yRv2uhwEE8hClMtxzib9NhSPtOfyxJJ9ibmLuZSEXSeRVJlic5iaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>没错，是一个普通的后台页面，如果background.js和其他页面有通信，则可以在这里进行查看请求或者调试代码。</p><p>如果使用page选项，打开也是这个样子。</p><p>另外：由于background是一直在后台运行的，为了优化性能，可以增加一个配置:</p><pre><code>&#123;    ...    &quot;background&quot;: &#123;        ...        &quot;persistent&quot;: false    &#125;&#125;</code></pre><p>这样，插件就会在被需要时加载，在空闲时被关闭。比如安装、更新插件的时候，或者有其他页面与background通信的时候才会被加载。</p><h3 id="content-scripts"><a href="#content-scripts" class="headerlink" title="content-scripts"></a><strong>content-scripts</strong></h3><p>content-scripts能够在合适的时机（页面载入前、载入后、空闲时）注入脚本，允许内容脚本更改其JavaScript环境，而不与页面或其他内容脚本发生冲突。</p><p>例如，原页面有个按钮，并且给按钮添加了一个点击事件：</p><pre><code>&lt;html&gt;    &lt;button id=&quot;mybutton&quot;&gt;click me&lt;/button&gt;    &lt;script&gt;      var greeting = &quot;hello, &quot;;      var button = document.getElementById(&quot;mybutton&quot;);      button.person_name = &quot;Bob&quot;;      button.addEventListener(&quot;click&quot;, function() &#123;        alert(greeting + button.person_name + &quot;.&quot;);      &#125;, false);    &lt;/script&gt;  &lt;/html&gt;</code></pre><p>在content-scripts中，加入以下代码：</p><pre><code>var greeting = &quot;hola, &quot;;var button = document.getElementById(&quot;mybutton&quot;);button.person_name = &quot;Roberto&quot;;button.addEventListener(&quot;click&quot;, function() &#123;alert(greeting + button.person_name + &quot;.&quot;);&#125;, false);</code></pre><p>当页面运行之后，脚本内容也会在插件定义的时间运行，当页面点击按钮时，会出现两次弹窗。</p><p>content-scripts配置：</p><pre><code>&#123;    ...    &quot;content_scripts&quot;: [        &#123;          // 在匹配的URL中运行，&lt;all_urls&gt;表示所有的URL都会运行。          &quot;matches&quot;: [&quot;&lt;all_urls&gt;&quot;],          // 注入的js,会按顺序运行。          &quot;js&quot;: [&quot;./js/content.js&quot;],          // css引入需谨慎，因为可能会影响全局的样式,同样也能接收多个css文件，会按顺序插入到页面中          &quot;css&quot;: [&quot;./css/style.css&quot;],          // 代码注入的时机，可选值： &quot;document_start&quot;, &quot;document_end&quot;, or &quot;document_idle&quot;，最后一个表示页面空闲时，默认document_idle          &quot;run_at&quot;: &quot;document_start&quot;        &#125;,        &#123;          &quot;matches&quot;: [&quot;https://www.baidu.com/&quot;],          &quot;js&quot;: [&quot;./js/other.js&quot;],          &quot;run_at&quot;: &quot;document_start&quot;        &#125;      ],    ...&#125;</code></pre><p>content.js代码如下：</p><pre><code>console.log(&#39;hello, from content.js&#39;);</code></pre><p>other.js代码如下：</p><pre><code>console.log(&#39;hello, from other.js...&#39;)</code></pre><p>更新插件，当在 <a href="https://bytedance.feishu.cn/drive/home/%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%9A">https://bytedance.feishu.cn/drive/home/运行时：</a></p><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>因为【 <a href="https://bytedance.feishu.cn/drive/home/%E3%80%91%E5%8F%AA%E5%8C%B9%E9%85%8D%E5%88%B0%E4%BA%86">https://bytedance.feishu.cn/drive/home/】只匹配到了</a><all_urls>的规则，所以之后运行content.js</all_urls></p><p>当在<a href="https://www.baidu.com/%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%9A">https://www.baidu.com/运行时：</a></p><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>同时命中了2个规则，所以content.js和other.js都会运行，顺序也是正确的。</p><p>content-scripts 和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过inject-scripts来实现。content-scripts能够访问的Chrome API的权限也比较低，只能访问以下四个API：</p><ul><li>chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest)</li><li>chrome.i18n</li><li>chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage)</li><li>chrome.storage</li></ul><h3 id="Inject-scripts"><a href="#Inject-scripts" class="headerlink" title="Inject-scripts"></a>Inject-scripts</h3><p>inject-scripts 是通过DOM操作插入的JS代码，通常在content-scripts只能操作DOM，但是却无法访问页面的JS，借助content-scripts可以操作DOM的能力，往页面中插入JS文件，给页面提供调用插件API的能力，以及和background通信的能力。</p><p>在插入之前，需配置一下web可访问的资源，同时content-scripts的调用时机换成”document_end”或者”document_idle”，不然会无法获取DOM,导致插入失败。在manifest.json中添加以下内容：</p><pre><code>&#123;    ...    &quot;content_scripts&quot;: [        &#123;          &quot;matches&quot;: [&quot;&lt;all_urls&gt;&quot;],          &quot;js&quot;: [&quot;./js/content.js&quot;],          &quot;run_at&quot;: &quot;document_end&quot;        &#125;,        ...     ],    &quot;web_accessible_resources&quot;: [&quot;js/inject.js&quot;],    ...&#125;</code></pre><p>inject.js的内容如下：</p><pre><code>function mockApi () &#123;  console.log(&#39;this is from inject.js&#39;)&#125;</code></pre><p>content.js增加以下代码:</p><pre><code>(function () &#123;  let path = &#39;js/inject.js&#39;;  let script = document.createElement(&#39;script&#39;);  script.setAttribute(&#39;type&#39;, &#39;text/javascript&#39;);  // 注意，路径需用Chrome API 生成，这个方法可以获得插件的资源的真实路径。  // 类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js  script.src = chrome.extension.getURL(path);  script.onload = function () &#123;    // 在执行完代码之后移除script标签    this.parentNode.removeChild(this);  &#125;  document.body.appendChild(script);&#125;)();</code></pre><p>更新插件后，页面就可以访问inject.js的方法：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMUdtVGGetGOGTicuxaFUJ8fkr8NdVlcvias6qqHbzYgFQLbK9y7F7X6zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="permissions"><a href="#permissions" class="headerlink" title="permissions"></a>permissions</h3><p>插件后台有的操作需要配置相应的权限，例如本地存储、网络请求、通知等等，示例：</p><pre><code>&#123;    ...    &quot;permissions&quot;: [        &quot;contextMenus&quot;, // 右键菜单        &quot;tabs&quot;, // 标签        &quot;notifications&quot;, // 通知        &quot;webRequest&quot;, // web请求        &quot;webRequestBlocking&quot;,        &quot;storage&quot; // 插件本地存储    ],    ...&#125;</code></pre><h3 id="完整的manifest配置"><a href="#完整的manifest配置" class="headerlink" title="完整的manifest配置"></a>完整的manifest配置</h3><p>官方文档：<a href="https://developer.chrome.com/extensions/manifest">https://developer.chrome.com/extensions/manifest</a></p><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><h3 id="popup和background通信"><a href="#popup和background通信" class="headerlink" title="popup和background通信"></a>popup和background通信</h3><p>popup可以通过 chrome.extension.getBackgroundPage() API 直接获取到background的上下文，从而调用background的方法来通信：</p><pre><code>// popup.jsvar backend = chrome.extension.getBackgroundPage();backend.test(); // 访问bbackground的函数</code></pre><p>background可以通过chrome.extension.getViews({type:’popup’}) 获取到popup的上下文，前提是popup页面是打开的状态下。</p><pre><code>let views = chrome.extension.getViews(&#123;type:&#39;popup&#39;&#125;);let popup = nullif(views.length &gt; 0) &#123;    popup = views[0];    // 直接访问popup的函数    popup.test();&#125;</code></pre><p>这里需要注意一点：</p><p>在popup页面，你如果想编写js，请将js编写在一个文件里面，然后引入进来，不然会报错，这是因为Chrome的安全政策规定的：<a href="https://developer.chrome.com/extensions/contentSecurityPolicy">https://developer.chrome.com/extensions/contentSecurityPolicy</a></p><p>popup错误示范：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;   ...&lt;/head&gt;&lt;body&gt;    &lt;p style=&quot;width: 200px;text-align:center;&quot;&gt;hello world!!&lt;/p&gt;    &lt;script&gt;        // 不能直接在里面写    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>正确姿势：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    ...&lt;/head&gt;&lt;body&gt;    &lt;p style=&quot;width: 200px;text-align:center;&quot;&gt;hello world!!&lt;/p&gt;    &lt;script src=&quot;../js/popup.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="content-scripts和background通信"><a href="#content-scripts和background通信" class="headerlink" title="content-scripts和background通信"></a>content-scripts和background通信</h3><p>content-scripts可以通过 chrome.runtime.sendMessage(message) 给background发送消息：</p><pre><code>chrome.runtime.sendMessage(&#39;message content&#39;, (res) =&gt; &#123;    console.log(&#39;from background:&#39;, res)&#125;);</code></pre><p>background通过chrome.runtime.onMessage.addListener()监听content-scripts发送的消息：</p><pre><code>chrome.runtime.onMessage.addListener(function(message, sender, callback) &#123;   console.log(mesasge); // meesage content   callback &amp;&amp; callback(&#39;yes this from background&#39;)&#125;);</code></pre><p>background主动给content-scripts发消息，首先得查找要给哪个tab发消息，使用chrome.tabs.query 这个方法查找到tab，再使用chrome.tabs.sendMessage 方法给tab发消息：</p><pre><code>// &#123;active: true, currentWindow: true&#125; 表示查找当前屏幕下的active状态的tab;chrome.tabs.query(&#123;active: true, currentWindow: true&#125;, function (tabs) &#123;    chrome.tabs.sendMessage(tabs[0].id, &#39;message content&#39;, (res) =&gt; &#123;        console.log(&#39;from content:&#39;, res)    &#125;);&#125;);</code></pre><p>content-scripts通过chrome.runtime.onMessage.addListener 去监听事件：</p><pre><code>chrome.runtime.onMessage.addListener(function (message, sender, callback) &#123;    console.log(message, sender)    callback &amp;&amp; callback(&#39;yes this from content&#39;)&#125;);</code></pre><p>注意：</p><p>1.消息内容可以直接发送JSON格式的对象。</p><p>2.popup和content的通信方式与上面一样。</p><p>3.如果popup和background都监听了从content发来的消息，两者都能收到监听消息，但是callback只会触发一次，被谁触发取决与谁先发送。</p><h3 id="inject-scripts和content-scripts"><a href="#inject-scripts和content-scripts" class="headerlink" title="inject-scripts和content-scripts"></a>inject-scripts和content-scripts</h3><p>inject-scripts和content-scripts通信有两种方法：</p><p>1.window.postMessage发送，window.addEventListener接收</p><p>2.还有一种是自定义的DOM事件；</p><p>但是很少情况会是content-scripts去调inject-scripts，因为，可以，但是没必要….content-scripts完全可以自己处理一些API的事件监听，况且inject-scripts也只是content-scripts生成并插入到DOM里面的，所以在content-scripts眼里，inject-scripts就是个弟弟…</p><p>但是，很多用户触发的事件，需要通过inject-scripts告诉content-scripts，content-scripts再给background通信并且去做一些事情，然后再发消息告诉inject-scripts，从这个角度看：content-scripts就是一个inject-scripts的工具人！</p><p>（扯平了，完美。）</p><p>inject-scripts给content-scripts发消息：</p><pre><code>window.postMessage(&#123;&quot;test&quot;: &#39;你好！工具人！&#39;&#125;, &#39;*&#39;);</code></pre><p>content-scripts接收消息:</p><pre><code>window.addEventListener(&quot;message&quot;, function(message) &#123;    console.log(&#39;来了老弟！&#39;, message.data);&#125;, false);</code></pre><p>同样的，content-scripts给inject-scripts发消息是一样的。</p><h2 id="练练手：HTTP-Header-插件"><a href="#练练手：HTTP-Header-插件" class="headerlink" title="练练手：HTTP Header 插件"></a>练练手：HTTP Header 插件</h2><p>实现一个HTTP Header 插件，可以实现动态添加header，并且给网络请求自动加上header，header参数可以配置。</p><p>示例图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMUwzQm5LYOcPkML3jDXAFtMz1kMiaMBo1FVY59VribDA7XQS4QviczXqKQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="Background-功能设计"><a href="#Background-功能设计" class="headerlink" title="Background 功能设计"></a>Background 功能设计</h3><p>background复制存储、操作headers，对所有浏览器请求做一层拦截，并加上启用的headers。</p><p>注意：因为涉及到网络请求，所以需在manifest.json中添加权限：</p><pre><code>&#123;    ...    &quot;permissions&quot;: [        &quot;storage&quot;, // 本地存储        &quot;webRequest&quot;, // 网络请求        &quot;webRequestBlocking&quot;, // 网络请求 阻塞式        &quot;&lt;all_urls&gt;&quot; // 匹配的URL    ]    ...&#125;</code></pre><p>Background 功能伪代码:</p><pre><code>// headers数据结构, 附带默认值;(可以改为本地存储)。const headers = [    &#123;    key: &#39;Content-Type&#39;,    value: &#39;application/x-www-form-urlencoded&#39;,    enable: false,  &#125;,  &#123;    key: &#39;Test-Header&#39;,    value: &#39;按F进入坦克&#39;,    enable: true,  &#125;,];// 获取、新增、删除、启用禁用function getHeaders () &#123;    return headers;&#125;function addHeader (header) &#123;    headers.push(header);&#125;function deleteHeader (index) &#123;    headers.splice(index, 1);&#125;function toggleHeader(index) &#123;  headers[index].enable = !headers[index].enable;&#125;...// 请求拦截器// On install 在被安装的时候去初始化chrome.runtime.onInstalled.addListener(function()&#123;    // 添加事件      chrome.webRequest.onBeforeSendHeaders.addListener(requestHandle, &#123;        urls: [&quot;&lt;all_urls&gt;&quot;],// 拦截所有URL的请求    &#125;,[&quot;blocking&quot;, &quot;requestHeaders&quot;]); // 阻塞式    console.log(&#39;load&#39;);&#125;);// 添加headerfunction requestHandle(request) &#123;    let requestHeaders = request.requestHeaders;    // 添加headers    headers.forEach(item =&gt; &#123;        if (item.enable) &#123;            requestHeaders.push(&#123;                name: item.key,                value: item.value,            &#125;);        &#125;    &#125;);    return &#123;requestHeaders&#125;;&#125;</code></pre><h3 id="chrome-webRequest的生命周期："><a href="#chrome-webRequest的生命周期：" class="headerlink" title="chrome.webRequest的生命周期："></a>chrome.webRequest的生命周期：</h3><p><img src="/jiayueshe/jiayueshe.github/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>详细参考：<a href="https://developer.chrome.com/extensions/webRequest">https://developer.chrome.com/extensions/webRequest</a></p><h3 id="popup-页面设计"><a href="#popup-页面设计" class="headerlink" title="popup 页面设计"></a>popup 页面设计</h3><p>popup页面提供增加、删除、启用禁用功能接口，并且在每次打开popup页面的时候去background获取最新的header数据，展示在前台。</p><p>popup.js 功能伪代码：</p><pre><code>// popup页面被打开时，去后台获取最新headerwindow.onload = function () &#123;    let backend = chrome.extension.getBackgroundPage();    // 调用background方法，获得headers    let headers = backend.getHeaders();    // 渲染header    createElement(headers);&#125;// 增加按钮function addHeader() &#123;    let backend = chrome.extension.getBackgroundPage();    let key = document.querySelector(&#39;.key&#39;);    let value =  document.querySelector(&#39;.value&#39;);    let header = &#123;        key: key.value,        value: value.value,        enable: true      &#125;    // 调用background方法，新增headers    backend.addHeader(header);    createElement(header);&#125;// 启用禁用、删除功能function toggleHeader(index) &#123;  let backend = chrome.extension.getBackgroundPage();  backend.toggleHeader(index);&#125;function delHeader(index) &#123;  let backend = chrome.extension.getBackgroundPage();  backend.deleteHeader(index);&#125;</code></pre><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>打开popup,添加一个header:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMKMaeNzVubDDletfVm8LoJ3Vz9xN4T8AqVNJsLibS5LrOmZLEbCtNNbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>随便打开一个网页，打开控制台查看RequestHeaders:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicSorfbFEjFGUpjcE45e2ZMiawEIbcIZ7icYfdHh2Bzx81siaqVZPfWfZbellc22NHmwUnKfHf74dx5A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>很多权限、功能需要在manifest.json配置。</li><li>content-scripts、popup、background、inject-scripts拥有的权限不一样，通信方式也不一样，理解各个脚本的特点，组合使用。</li><li>开发调试可在后台背景页查看信息，popup、inject-scripts、content-scripts可直接审查元素调试。</li></ul><p>Chrome 插件还有很多功能这里没有详细介绍，例如devtools。感兴趣的同学可以查阅下面的参考文档。</p><p><a href="https://mp.weixin.qq.com/s/5jl8wshMNBbNopuWqUx_7Q">https://mp.weixin.qq.com/s/5jl8wshMNBbNopuWqUx_7Q</a></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/03/niuke/sql/sql-server-cha-xun-you-hua-fang-fa/"/>
      <url>2021/03/03/niuke/sql/sql-server-cha-xun-you-hua-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>SQL Server查询优化方法</p><p>查询速度慢的原因很多，常见如下几种</p><p>　　1、没有索引或者没有用到索引(这是查询慢最常见的问题，是程序设计的缺陷)<br>　　2、I/O吞吐量小，形成了瓶颈效应<br>　　3、没有创建计算列导致查询不优化<br>　　4、内存不足<br>　　5、网络速度慢<br>　　6、查询出的数据量过大（可以采用多次查询，其他的方法降低数据量）<br>　　7、锁或者死锁(这也是查询慢最常见的问题，是程序设计的缺陷)<br>　　8、sp_lock,sp_who,活动的用户查看,原因是读写竞争资源。<br>　　9、返回了不必要的行和列<br>　　10、查询语句不好，没有优化</p><p>可以通过如下方法来优化查询</p><p>　　1、把数据、日志、索引放到不同的I/O设备上，增加读取速度，以前可以将Tempdb应放在RAID0上，SQL2000不在支持。数据量（尺寸）越大，提高I/O越重要.<br>　　2、纵向、横向分割表，减少表的尺寸(sp_spaceuse)<br>　　3、升级硬件<br>　　4、根据查询条件,建立索引,优化索引、优化访问方式，限制结果集的数据量。注意填充因子要适当（最好是使用默认值0）。索引应该尽量小，使用字节数小的列建索引好（参照索引的创建）,不要对有限的几个值的字段建单一索引如性别字段<br>　　5、提高网速;<br>　　6、扩大服务器的内存。配置虚拟内存：虚拟内存大小应基于计算机上并发运行的服务进行配置。可考虑将虚拟内存大小设置为计算机中安装的物理内存的1.5倍。如果另外安装了全文检索功能，并打算运行Microsoft搜索服务以便执行全文索引和查询，可考虑：将虚拟内存大小配置为至少是计算机中安装的物理内存的3倍。将SQL Server max server memory服务器配置选项配置为物理内存的1.5倍（虚拟内存大小设置的一半）。<br>　　7、增加服务器CPU个数;但是必须明白并行处理串行处理更需要资源例如内存。使用并行还是串行程是MsSQL自动评估选择的。单个任务分解成多个任务，就可以在处理器上运行。例如耽搁查询的排序、连接、扫描和GROUPBY字句同时执行，SQLSERVER根据系统的负载情况决定最优的并行等级，复杂的需要消耗大量的CPU的查询最适合并行处理。但是更新操作UPDATE,INSERT，DELETE还不能并行处理。<br>　　8、如果是使用like进行查询的话，简单的使用index是不行的，但是全文索引耗空间。like’a%’使用索引like’%a’不使用索引用like’%a%’查询时，查询耗时和字段值总长度成正比,所以不能用CHAR类型，而是VARCHAR。对于字段的值很长的建全文索引。<br>　　9、DBServer和ApplicationServer分离，OLTP和OLAP分离<br>　　10、分布式分区视图可用于实现数据库服务器联合体。联合体是一组分开管理的服务器，但它们相互协作分担系统的处理负荷。这种通过分区数据形成数据库服务器联合体的机制能够扩大一组服务器，以支持大型的多层Web站点的处理需要。有关更多信息，参见设计联合数据库服务器。（参照SQL帮助文件’分区视图’）</p><p>　　　　a、在实现分区视图之前，必须先水平分区表<br>　　　　b、在创建成员表后，在每个成员服务器上定义一个分布式分区视图，并且每个视图具有相同的名称。这样，引用分布式分区视图名的查询可以在任何一个成员服务器上运行。系统操作如同每个成员服务器上都有一个原始表的复本一样，但其实每个服务器上只有一个成员表和一个分布式分区视图。数据的位置对应用程序是透明的。</p><p>　　11、重建索引DBCCREINDEX,DBCCINDEXDEFRAG,收缩数据和日志DBCCSHRINKDB,DBCCSHRINKFILE.设置自动收缩日志.对于大的数据库不要设置数据库自动增长，它会降低服务器的性能。在T-sql的写法上有很大的讲究，下面列出常见的要点：首先，DBMS处理查询计划的过程是这样的：<br>　　　　1、查询语句的词法、语法检查<br>　　　　2、将语句提交给DBMS的查询优化器<br>　　　　3、优化器做代数优化和存取路径的优化<br>　　　　4、由预编译模块生成查询规划<br>　　　　5、然后在合适的时间提交给系统处理执行<br>　　　　6、最后将执行结果返回给用户其次，看一下SQLSERVER的数据存放的结构：一个页面的大小为8K(8060)字节，8个页面为一个盘区，按照B树存放。<br>　　12、Commit和rollback的区别Rollback:回滚所有的事物。Commit:提交当前的事物.没有必要在动态SQL里写事物，如果要写请写在外面如：begintranexec(@s)committrans或者将动态SQL写成函数或者存储过程。<br>　　13、在查询Select语句中用Where字句限制返回的行数,避免表扫描,如果返回不必要的数据，浪费了服务器的I/O资源，加重了网络的负担降低性能。如果表很大，在表扫描的期间将表锁住，禁止其他的联接访问表,后果严重。<br>　　14、SQL的注释申明对执行没有任何影响<br>　　15、尽可能不使用光标，它占用大量的资源。如果需要row-by-row地执行，尽量采用非光标技术,如：在客户端循环，用临时表，Table变量，用子查询，用Case语句等等。游标可以按照它所支持的提取选项进行分类：只进必须按照从第一行到最后一行的顺序提取行。FETCHNEXT是唯一允许的提取操作,也是默认方式。可滚动性可以在游标中任何地方随机提取任意行。游标的技术在SQL2000下变得功能很强大，他的目的是支持循环。<br>　　有四个并发选项：<br>　　　　READ_ONLY：不允许通过游标定位更新(Update)，且在组成结果集的行中没有锁。<br>　　　　OPTIMISTICWITHvalueS:乐观并发控制是事务控制理论的一个标准部分。乐观并发控制用于这样的情形，即在打开游标及更新行的间隔中，只有很小的机会让第二个用户更新某一行。当某个游标以此选项打开时，没有锁控制其中的行，这将有助于最大化其处理能力。如果用户试图修改某一行，则此行的当前值会与最后一次提取此行时获取的值进行比较。如果任何值发生改变，则服务器就会知道其他人已更新了此行，并会返回一个错误。如果值是一样的，服务器就执行修改。选择这个并发选项OPTIMISTICWITHROWVERSIONING:此乐观并发控制选项基于行版本控制。使用行版本控制，其中的表必须具有某种版本标识符，服务器可用它来确定该行在读入游标后是否有所更改。<br>　　　　在SQLServer中，这个性能由timestamp数据类型提供，它是一个二进制数字，表示数据库中更改的相对顺序。每个数据库都有一个全局当前时间戳值：@@DBTS。每次以任何方式更改带有timestamp列的行时，SQLServer先在时间戳列中存储当前的@@DBTS值，然后增加@@DBTS的值。如果某个表具有timestamp列，则时间戳会被记到行级。服务器就可以比较某行的当前时间戳值和上次提取时所存储的时间戳值，从而确定该行是否已更新。服务器不必比较所有列的值，只需比较timestamp列即可。如果应用程序对没有timestamp列的表要求基于行版本控制的乐观并发，则游标默认为基于数值的乐观并发控制。<br>　　　　SCROLLLOCKS这个选项实现悲观并发控制。在悲观并发控制中，在把数据库的行读入游标结果集时，应用程序将试图锁定数据库行。在使用服务器游标时，将行读入游标时会在其上放置一个更新锁。如果在事务内打开游标，则该事务更新锁将一直保持到事务被提交或回滚；当提取下一行时，将除去游标锁。如果在事务外打开游标，则提取下一行时，锁就被丢弃。因此，每当用户需要完全的悲观并发控制时，游标都应在事务内打开。更新锁将阻止任何其它任务获取更新锁或排它锁，从而阻止其它任务更新该行。<br>　　　　然而，更新锁并不阻止共享锁，所以它不会阻止其它任务读取行，除非第二个任务也在要求带更新锁的读取。滚动锁根据在游标定义的SELECT语句中指定的锁提示，这些游标并发选项可以生成滚动锁。滚动锁在提取时在每行上获取，并保持到下次提取或者游标关闭，以先发生者为准。下次提取时，服务器为新提取中的行获取滚动锁，并释放上次提取中行的滚动锁。滚动锁独立于事务锁，并可以保持到一个提交或回滚操作之后。如果提交时关闭游标的选项为关，则COMMIT语句并不关闭任何打开的游标，而且滚动锁被保留到提交之后，以维护对所提取数据的隔离。所获取滚动锁的类型取决于游标并发选项和游标SELECT语句中的锁提示。<br>　　　　锁提示只读乐观数值乐观行版本控制锁定无提示未锁定未锁定未锁定更新NOLOCK未锁定未锁定未锁定未锁定HOLDLOCK共享共享共享更新UPDLOCK错误更新更新更新TABLOCKX错误未锁定未锁定更新其它未锁定未锁定未锁定更新<em>指定NOLOCK提示将使指定了该提示的表在游标内是只读的。<br>　　16、用Profiler来跟踪查询，得到查询所需的时间，找出SQL的问题所在;用索引优化器优化索引<br>　　17、注意UNion和UNionall的区别。UNIONall好<br>　　18、注意使用DISTINCT，在没有必要时不要用，它同UNION一样会使查询变慢。重复的记录在查询里是没有问题的<br>　　19、查询时不要返回不需要的行、列<br>　　20、用sp_configure’querygovernorcostlimit’或者SETQUERY_GOVERNOR_COST_LIMIT来限制查询消耗的资源。当评估查询消耗的资源超出限制时，服务器自动取消查询,在查询之前就扼杀掉。SETLOCKTIME设置锁的时间<br>　　21、用selecttop100/10Percent来限制用户返回的行数或者SETROWCOUNT来限制操作的行<br>　　22、在SQL2000以前，一般不要用如下的字句:”ISNULL”,”&lt;&gt;”,”!=”,”!&gt;”,”!&lt;”,”NOT”,”NOTEXISTS”,”NOTIN”,”NOTLIKE”,and”LIKE’%500’”，因为他们不走索引全是表扫描。也不要在WHere字句中的列名加函数，如Convert，substring等,如果必须用函数的时候，创建计算列再创建索引来替代.还可以变通写法：WHERESUBSTRING(firstname,1,1)=’m’改为WHEREfirstnamelike’m%’（索引扫描），一定要将函数和列名分开。并且索引不能建得太多和太大。NOTIN会多次扫描表，使用EXISTS、NOTEXISTS，IN,LEFTOUTERJOIN来替代，特别是左连接,而Exists比IN更快，最慢的是NOT操作.如果列的值含有空，以前它的索引不起作用，现在2000的优化器能够处理了。相同的是ISNULL，“NOT”,”NOTEXISTS”,”NOTIN”能优化她，而”&lt;&gt;”等还是不能优化，用不到索引。<br>　　23、使用QueryAnalyzer，查看SQL语句的查询计划和评估分析是否是优化的SQL。一般的20%的代码占据了80%的资源，我们优化的重点是这些慢的地方。<br>　　24、如果使用了IN或者OR等时发现查询没有走索引，使用显示申明指定索引：SELECT</em>FROMPersonMember(INDEX=IX_Title)WHEREprocessidIN(‘男’，‘女’)<br>　　25、将需要查询的结果预先计算好放在表中，查询的时候再SELECT。这在SQL7.0以前是最重要的手段。例如医院的住院费计算。<br>　　26、MIN()和MAX()能使用到合适的索引<br>　　27、数据库有一个原则是代码离数据越近越好，所以优先选择Default,依次为Rules,Triggers,Constraint（约束如外健主健CheckUNIQUE……,数据类型的最大长度等等都是约束）,Procedure.这样不仅维护工作小，编写程序质量高，并且执行的速度快。<br>　　28、如果要插入大的二进制值到Image列，使用存储过程，千万不要用内嵌INsert来插入(不知JAVA是否)。因为这样应用程序首先将二进制值转换成字符串（尺寸是它的两倍），服务器受到字符后又将他转换成二进制值.存储过程就没有这些动作:方法：Createprocedurep_insertasinsertintotable(Fimage)values(@image),在前台调用这个存储过程传入二进制参数，这样处理速度明显改善。<br>　　29、Between在某些时候比IN速度更快,Between能够更快地根据索引找到范围。用查询优化器可见到差别。select<em>fromchineseresumewheretitlein(‘男’,’女’)Select</em>fromchineseresumewherebetween’男’and’女’是一样的。由于in会在比较多次，所以有时会慢些。<br>　　30、在必要是对全局或者局部临时表创建索引，有时能够提高速度，但不是一定会这样，因为索引也耗费大量的资源。他的创建同是实际表一样。<br>　　31、不要建没有作用的事物例如产生报表时，浪费资源。只有在必要使用事物时使用它。<br>　　32、用OR的字句可以分解成多个查询，并且通过UNION连接多个查询。他们的速度只同是否使用索引有关,如果查询需要用到联合索引，用UNIONall执行的效率更高.多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。<br>　　33、尽量少用视图，它的效率低。对视图操作比直接对表操作慢,可以用storedprocedure来代替她。特别的是不要用视图嵌套,嵌套视图增加了寻找原始资料的难度。我们看视图的本质：它是存放在服务器上的被优化好了的已经产生了查询规划的SQL。对单个表检索数据时，不要使用指向多个表的视图，直接从表检索或者仅仅包含这个表的视图上读，否则增加了不必要的开销,查询受到干扰.为了加快视图的查询，MsSQL增加了视图索引的功能。<br>　　34、没有必要时不要用DISTINCT和ORDERBY，这些动作可以改在客户端执行。它们增加了额外的开销。这同UNION和UNIONALL一样的道理。SELECTtop20ad.companyname,comid,position,ad.referenceid,worklocation,convert(varchar(10),ad.postDate,120)aspostDate1,workyear,degreedescriptionFROMjobcn_query.dbo.COMPANYAD_queryadwherereferenceIDin(‘JCNAD00329667’,’JCNAD132168’,’JCNAD00337748’,’JCNAD00338345’,’JCNAD00333138’,’JCNAD00303570’,’JCNAD00303569’,’JCNAD00303568’,’JCNAD00306698’,’JCNAD00231935’,’JCNAD00231933’,’JCNAD00254567’,’JCNAD00254585’,’JCNAD00254608’,’JCNAD00254607’,’JCNAD00258524’,’JCNAD00332133’,’JCNAD00268618’,’JCNAD00279196’,’JCNAD00268613’)orderbypostdatedesc<br>　　35、在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数<br>　　36、当用SELECTINTO时，它会锁住系统表(sysobjects，sysindexes等等)，阻塞其他的连接的存取。创建临时表时用显示申明语句，而不是selectINTO.droptablet_lxhbegintranselect<em>intot_lxhfromchineseresumewherename=’XYZ’–commit在另一个连接中SELECT</em>fromsysobjects可以看到SELECTINTO会锁住系统表，Createtable也会锁系统表(不管是临时表还是系统表)。所以千万不要在事物内使用它！！！这样的话如果是经常要用的临时表请使用实表，或者临时表变量。<br>　　37、一般在GROUPBY个HAVING字句之前就能剔除多余的行，所以尽量不要用它们来做剔除行的工作。他们的执行顺序应该如下最优：select的Where字句选择所有合适的行，GroupBy用来分组个统计行，Having字句用来剔除多余的分组。这样GroupBy个Having的开销小，查询快.对于大的数据行进行分组和Having十分消耗资源。如果GroupBY的目的不包括计算，只是分组，那么用Distinct更快<br>　　38、一次更新多条记录比分多次更新每次一条快,就是说批处理好<br>　　39、少用临时表，尽量用结果集和Table类性的变量来代替它,Table类型的变量比临时表好<br>　　40、在SQL2000下，计算字段是可以索引的，需要满足的条件如下：<br>　　　　a、计算字段的表达是确定的<br>　　　　b、不能用在TEXT,Ntext，Image数据类型<br>　　　　c、必须配制如下选项ANSI_NULLS=ON,ANSI_PADDINGS=ON,…….<br>　　41、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL,可以使用临时存储过程，该过程（临时表）被放在Tempdb中。以前由于SQLSERVER对复杂的数学计算不支持，所以不得不将这个工作放在其他的层上而增加网络的开销。SQL2000支持UDFs,现在支持复杂的数学计算，函数的返回值不要太大，这样的开销很大。用户自定义函数象光标一样执行的消耗大量的资源，如果返回大的结果采用存储过程<br>　　42、不要在一句话里再三的使用相同的函数，浪费资源,将结果放在变量里再调用更快<br>　　43、SELECTCOUNT(*)的效率教低，尽量变通他的写法，而EXISTS快.同时请注意区别：selectcount(Fieldofnull)fromTable和selectcount(FieldofNOTnull)fromTable的返回值是不同的。<br>　　44、当服务器的内存够多时，配制线程数量=最大连接数+5，这样能发挥最大的效率；否则使用配制线程数量&lt;最大连接数启用SQLSERVER的线程池来解决,如果还是数量=最大连接数+5，严重的损害服务器的性能。<br>　　45、按照一定的次序来访问你的表。如果你先锁住表A，再锁住表B，那么在所有的存储过程中都要按照这个顺序来锁定它们。如果你（不经意的）某个存储过程中先锁定表B，再锁定表A，这可能就会导致一个死锁。如果锁定顺序没有被预先详细的设计好，死锁很难被发现<br>　　46、通过SQLServerPerformanceMonitor监视相应硬件的负载Memory:PageFaults/sec计数器如果该值偶尔走高，表明当时有线程竞争内存。如果持续很高，则内存可能是瓶颈。Process:<br>　　　　1、%DPCTime指在范例间隔期间处理器用在缓延程序调用(DPC)接收和提供服务的百分比。(DPC正在运行的为比标准间隔优先权低的间隔)。由于DPC是以特权模式执行的，DPC时间的百分比为特权时间百分比的一部分。这些时间单独计算并且不属于间隔计算总数的一部分。这个总数显示了作为实例时间百分比的平均忙时。<br>　　　　2、%ProcessorTime计数器　如果该参数值持续超过95%，表明瓶颈是CPU。可以考虑增加一个处理器或换一个更快的处理器。<br>　　　　3、%PrivilegedTime指非闲置处理器时间用于特权模式的百分比。(特权模式是为操作系统组件和操纵硬件驱动程序而设计的一种处理模式。它允许直接访问硬件和所有内存。另一种模式为用户模式，它是一种为应用程序、环境分系统和整数分系统设计的一种有限处理模式。操作系统将应用程序线程转换成特权模式以访问操作系统服务)。特权时间的%包括为间断和DPC提供服务的时间。特权时间比率高可能是由于失败设备产生的大数量的间隔而引起的。这个计数器将平均忙时作为样本时间的一部分显示。<br>　　　　4、%UserTime表示耗费CPU的数据库操作，如排序，执行aggregatefunctions等。如果该值很高，可考虑增加索引，尽量使用简单的表联接，水平分割大表格等方法来降低该值。PhysicalDisk:CurretnDiskQueueLength计数器该值应不超过磁盘数的1.5~2倍。要提高性能，可增加磁盘。SQLServer:CacheHitRatio计数器该值越高越好。如果持续低于80%，应考虑增加内存。注意该参数值是从SQLServer启动后，就一直累加记数，所以运行经过一段时间后，该值将不能反映系统当前值。<br>　　47、分析selectemp_nameformemployeewheresalary&gt;3000在此语句中若salary是Float类型的，则优化器对其进行优化为Convert(float,3000)，因为3000是个整数，我们应在编程时使用3000.0而不要等运行时让DBMS进行转化。同样字符和整型数据的转换</p><p>转载于</p><p><a href="https://www.cnblogs.com/gaoxh/p/5230739.html">https://www.cnblogs.com/gaoxh/p/5230739.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript面向对象</title>
      <link href="2021/03/03/ziliao/javascript/javascript-mian-xiang-dui-xiang/"/>
      <url>2021/03/03/ziliao/javascript/javascript-mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript面向对象"><a href="#JavaScript面向对象" class="headerlink" title="JavaScript面向对象"></a>JavaScript面向对象</h2><h1 id="JavaScript面向对象-1"><a href="#JavaScript面向对象-1" class="headerlink" title="JavaScript面向对象"></a>JavaScript面向对象</h1><p>[<img src="https://upload.jianshu.io/users/upload_avatars/12323997/4baf502b-274d-4914-8cad-e410e6f402e3?imageMogr2/auto-orient/strip%7CimageView2/1/w/96/h/96" alt="img"><a href="https://www.jianshu.com/u/07b4cf0c78a1">https://www.jianshu.com/u/07b4cf0c78a1</a>)</p><p>收录于：<a href="https://www.jianshu.com/p/f9792fdd9915">https://www.jianshu.com/p/f9792fdd9915</a></p><h4 id="一、面向对象基本特征"><a href="#一、面向对象基本特征" class="headerlink" title="一、面向对象基本特征"></a>一、面向对象基本特征</h4><ol><li>封装：也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</li><li>继承：通过继承创建的新类称为“子类”或“派生类”。继承的过程，就是从一般到特殊的过程。</li><li>多态：对象的多功能，多方法，一个方法多种表现形式。</li><li>Javascript是一种基于对象（object-based）的语言。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）—–es6以前是这样的。所以es5只有使用函数模拟的面向对象。</li></ol><h4 id="二、对象实例化方式"><a href="#二、对象实例化方式" class="headerlink" title="二、对象实例化方式"></a>二、对象实例化方式</h4><ol><li>原始模式：这样的写法有两个缺点，一是如果多生成几个（100个！）实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出没有什么联系。</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> Car <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    color<span class="token punctuation">:</span> <span class="token string">'red'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//车的颜色</span>    wheel<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//车轮数量</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> Car2 <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    color<span class="token punctuation">:</span> <span class="token string">'blue'</span><span class="token punctuation">,</span>    wheel<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>Car<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//red</span></code></pre><ol><li>原始模式的改进：通过写一个函数，解决代码重复的问题。</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createCar</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span>wheel<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        color<span class="token punctuation">:</span>color<span class="token punctuation">,</span>        wheel<span class="token punctuation">:</span>wheel    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//然后生成实例对象，就等于是在调用函数：</span><span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token function">createCar</span><span class="token punctuation">(</span><span class="token string">"红色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token function">createCar</span><span class="token punctuation">(</span><span class="token string">"蓝色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//红色</span></code></pre><ol><li>工厂模式</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createCar</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span>wheel<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//createCar工厂</span>    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//或obj = &amp;#123;&amp;#125; 原材料阶段</span>    obj<span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加工</span>    obj<span class="token punctuation">.</span>wheel <span class="token operator">=</span> wheel<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加工</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出产品</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//实例化</span><span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token function">createCar</span><span class="token punctuation">(</span><span class="token string">"红色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token function">createCar</span><span class="token punctuation">(</span><span class="token string">"蓝色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//红色</span></code></pre><ol><li>构造函数模式：为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。  所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。加<code>new</code>执行的函数构造内部变化：自动生成一个对象，this指向这个新创建的对象，函数自动返回这个新创建的对象</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">CreateCar</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span>wheel<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//构造函数首字母大写</span>    <span class="token comment" spellcheck="true">//不需要自己创建对象了</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加属性，this指向构造函数的实例对象</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>wheel <span class="token operator">=</span> wheel<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加属性</span>    <span class="token comment" spellcheck="true">//不需要自己return了</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//实例化</span><span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateCar</span><span class="token punctuation">(</span><span class="token string">"红色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateCar</span><span class="token punctuation">(</span><span class="token string">"蓝色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//红色</span></code></pre><h4 id="三、构造函数注意事项"><a href="#三、构造函数注意事项" class="headerlink" title="三、构造函数注意事项"></a>三、构造函数注意事项</h4><ol><li>此时CreateCar称之为构造函数，也可以称之类，构造函数就是类 。</li><li>cat1，cat2均为CreateCar的实例对象。</li><li>CreateCar构造函数中this指向CreateCar实例对象即 <code>new CreateCar( )</code>出来的对象。</li><li>必须带new 。</li><li>构造函数首字母大写，这是规范，官方都遵循这一个规范，如Number() Array()。</li><li>contructor：这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数,即CreateCar。</li></ol><pre class=" language-js"><code class="language-js"><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>constructor <span class="token operator">==</span> CreateCar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span><span class="token function">alert</span><span class="token punctuation">(</span>cat2<span class="token punctuation">.</span>constructor <span class="token operator">==</span> CreateCar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><ol><li>每定义一个函数，这个函数就有一个 prototype 的属性{}，<code>__proto__</code> 指向被实例化的构造函数的prototype，prototype默认带constructor属性，constructor指向构造函数。</li><li>instanceof 运算符：<code>object instanceof constructor</code>运算符，验证构造函数与实例对象之间的关系。</li></ol><pre class=" language-js"><code class="language-js"><span class="token function">alert</span><span class="token punctuation">(</span>cat1 <span class="token keyword">instanceof</span> <span class="token class-name">CreateCar</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span><span class="token function">alert</span><span class="token punctuation">(</span>cat2 <span class="token keyword">instanceof</span> <span class="token class-name">CreateCar</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><h4 id="四、构造函数的问题"><a href="#四、构造函数的问题" class="headerlink" title="四、构造函数的问题"></a>四、构造函数的问题</h4><p>构造函数方法很好用，但是存在一个浪费内存的问题。如果现在为其再添加一个方法<code>showWheel</code>。那么，CreateCar就变成了下面这样，这样做有一个很大的弊端，对于每一个实例对象，<code>showWheel</code>都是一模一样的内容，每一次生成一个实例，都必须生成重复的内容，多占用一些内存。这样既不环保，也缺乏效率。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">CreateCar</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span>wheel<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>wheel <span class="token operator">=</span> wheel<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>showWheel <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加一个新方法</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>wheel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//还是采用同样的方法，生成实例：</span><span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateCar</span><span class="token punctuation">(</span><span class="token string">"红色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateCar</span><span class="token punctuation">(</span><span class="token string">"蓝色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>showWheel <span class="token operator">==</span> cat2<span class="token punctuation">.</span>showWheel<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span></code></pre><h4 id="五、Prototype-原型"><a href="#五、Prototype-原型" class="headerlink" title="五、Prototype 原型"></a>五、Prototype 原型</h4><p>Javascript规定，每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。 这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。<code>__proto__</code>是原型链，指向实例化的函数原型。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">CreateCar</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span>wheel<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//属性写构造函数里面</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>wheel <span class="token operator">=</span> wheel<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//方法写原型里面</span>CreateCar<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>showWheel <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>wheel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>CreateCar<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>showName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'车'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//生成实例。</span><span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateCar</span><span class="token punctuation">(</span><span class="token string">"红色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> cat2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateCar</span><span class="token punctuation">(</span><span class="token string">"蓝色"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cat1<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//'车'</span><span class="token comment" spellcheck="true">//这时所有实例的showWheel属性和showName方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。</span><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>showWheel <span class="token operator">==</span> cat2<span class="token punctuation">.</span>showWheel <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span><span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>showName <span class="token operator">==</span> cat2<span class="token punctuation">.</span>showName <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> CreateCar<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><h4 id="六、对象和函数的关系"><a href="#六、对象和函数的关系" class="headerlink" title="六、对象和函数的关系"></a>六、对象和函数的关系</h4><p>对象是由函数构造出来的。</p><ol><li>Object是Function 的一个实例。</li></ol><pre class=" language-js"><code class="language-js">Object<span class="token punctuation">.</span>constructor  <span class="token operator">==</span> Function  <span class="token comment" spellcheck="true">//true</span></code></pre><ol><li>函数是Function 的实例，但不是Object 的实例。</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>fn<span class="token punctuation">.</span>constructor  <span class="token operator">==</span> Function  <span class="token comment" spellcheck="true">//true</span>fn<span class="token punctuation">.</span>constructor  <span class="token operator">==</span> Object    <span class="token comment" spellcheck="true">//false </span></code></pre><ol><li>{} 与 Object 的关系。</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>constructor  <span class="token operator">===</span> Object   <span class="token comment" spellcheck="true">//true</span></code></pre><h4 id="七、静态方法和静态属性"><a href="#七、静态方法和静态属性" class="headerlink" title="七、静态方法和静态属性"></a>七、静态方法和静态属性</h4><p>只属于类而不属于实例化对象</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>foo<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//静态属性</span>foo<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>foo<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//实例化的新的对象，this指向这个新的对象，不能访问类的静态方法</span>fn<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Noname1.html:45 Uncaught TypeError: fn.say is not a function</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> fn<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="八、对象继承"><a href="#八、对象继承" class="headerlink" title="八、对象继承"></a>八、对象继承</h4><ol><li>利用<code>call()</code>及<code>for in</code>继承 。<br> 给对象的constructor.prototype添加方法属性，对象就会继承，如果要实现一个对象继承其他对象，采用如下方法。</li></ol><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//人类</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>run <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'跑路~'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'说话~'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//男人</span><span class="token keyword">function</span> <span class="token function">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">"男"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>Man<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>Man<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>yyy <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'嘤嘤嘤'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//会发现Person的prototype也改变了，因为复杂对象的赋值操作是引用而不是赋值</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//人类</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>run <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'跑路~'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'说话~'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//男人</span><span class="token keyword">function</span> <span class="token function">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">"男"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Man<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>Man<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>yyy <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'嘤嘤嘤'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> xm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xm<span class="token punctuation">.</span><span class="token function">yyy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol><li>采用中介</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">ClassA</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>ClassA<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//中继来做准备工作</span><span class="token keyword">function</span> <span class="token function">Ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>Ready<span class="token punctuation">.</span>prototype <span class="token operator">=</span> ClassA<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引用</span><span class="token comment" spellcheck="true">//需要来继承ClassA</span><span class="token keyword">function</span> <span class="token function">ClassB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>ClassB<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//new 返回了一个新对象 __proto__指向被实例化的构造函数的prototype</span>ClassB<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> ClassB<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ClassB<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol><li>采用中介，使用<code>call</code>改变this指向</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">ClassA</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>ClassA<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>showName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//中继来做准备工作</span><span class="token keyword">function</span> <span class="token function">Ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>Ready<span class="token punctuation">.</span>prototype <span class="token operator">=</span> ClassA<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引用</span><span class="token comment" spellcheck="true">//需要来继承ClassA</span><span class="token keyword">function</span> <span class="token function">ClassB</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    ClassA<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>ClassB<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//new 返回了一个新对象 __proto__指向被实例化的构造函数的prototype</span>ClassB<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> ClassB<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ClassB<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> xiaoming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassB</span><span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xiaoming<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="九、多态"><a href="#九、多态" class="headerlink" title="九、多态"></a>九、多态</h4><p>同一个方法,面对不同的对象有不同的表现形式就叫做多态。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    eat <span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>_type<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>_type <span class="token operator">==</span> <span class="token string">'猫'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'猫粮'</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>_type <span class="token operator">==</span> <span class="token string">"狗"</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'狗粮'</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"吃饭"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token string">"狗"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="十、hasOwnProperty"><a href="#十、hasOwnProperty" class="headerlink" title="十、hasOwnProperty"></a>十、hasOwnProperty</h4><p>查看该属性是否在这个对象本身上，只有在自身属性上才会返回真，在原型链上会返回假。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>ClassA<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span></code></pre><h4 id="十一、描述符（修饰符）"><a href="#十一、描述符（修饰符）" class="headerlink" title="十一、描述符（修饰符）"></a>十一、描述符（修饰符）</h4><p>描述符是对一个属性的特性的描述，<code>defineProperty</code>设置描述符（修饰符），<code>value</code>设置属性值，<code>configurable</code>是否允许修饰符被改变 默认为false，<code>enumerable</code> 是否可以被枚举 默认为false，<code>writable</code> 是否可以被 = 等号改变 默认为false。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    a <span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//value : 233,</span>    <span class="token comment" spellcheck="true">//enumerable : false,</span>    <span class="token comment" spellcheck="true">//writable : true,//他的值能否改变</span>                <span class="token comment" spellcheck="true">//设置的时候调用</span>    <span class="token keyword">set</span> <span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//n 就是等号的右边的值</span>        c <span class="token operator">=</span> c<span class="token operator">*</span>n<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//获取的时候调用</span>    <span class="token keyword">get</span> <span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    configurable <span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//是否可以再次修改修饰符</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>因为会MySQL查询优化，领导给我升职了</title>
      <link href="2021/03/03/niuke/sql/mysql-suo-yin-xiang-guan-mian-shi-ti/"/>
      <url>2021/03/03/niuke/sql/mysql-suo-yin-xiang-guan-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="因为会MySQL查询优化，领导给我升职了"><a href="#因为会MySQL查询优化，领导给我升职了" class="headerlink" title="因为会MySQL查询优化，领导给我升职了"></a>因为会MySQL查询优化，领导给我升职了</h1><p>查询优化本就不是一蹴而就的，需要学会使用对应的工具、借鉴别人的经验来对 SQL 进行优化，并且提升自己</p><p>先来巩固一下索引的优点，检索数据快、查询稳定、存储具有顺序性避免服务器建立临时表、将随机的 I/O 变为有序的 I/O。</p><p>但索引一旦创建的不规范就会造成以下问题，占用额外空间，浪费内存，降低数据的增、删、改性能。</p><p>所以只有在理解索引数据结构的基础上才能创建出高效的索引。本文所有操作均在 MySQL 8.0.12。</p><h2 id="创建索引规范"><a href="#创建索引规范" class="headerlink" title="创建索引规范"></a>创建索引规范</h2><p>在学习索引优化之前，需要对创建索引的规范有一定的了解，此规范来自于阿里巴巴开发手册。</p><p><strong>主键索引：</strong>pk_column_column。</p><p><strong>唯一索引：</strong>uk_column_column。</p><p><strong>普通索引：</strong>idx_column_column。</p><h2 id="索引失效原因"><a href="#索引失效原因" class="headerlink" title="索引失效原因"></a>索引失效原因</h2><p>创建索引需知道在什么情况下索引会失效，只有了解索引失效的原因，在创建索引时才不会出现一些已知错误。</p><h3 id="带头大哥不能死"><a href="#带头大哥不能死" class="headerlink" title="带头大哥不能死"></a><strong>带头大哥不能死</strong></h3><p>这局经典的语句就是涵盖创建索引时一定要符合最左侧原则。</p><p>例如表结构为 u_id，u_name，u_age，u_sex，u_phone，u_time，创建索引为 idx_user_name_age_sex。</p><p>查询条件必须带上 u_name 这一列。</p><h3 id="不在索引列上做任何操作"><a href="#不在索引列上做任何操作" class="headerlink" title="不在索引列上做任何操作"></a><strong>不在索引列上做任何操作</strong></h3><p>不在索引列上做任何计算、函数、自动或者手动的类型转换，否则会进行全表扫描。简而言之不要在索引列上做任何操作。</p><h3 id="俩边类型不等"><a href="#俩边类型不等" class="headerlink" title="俩边类型不等"></a><strong>俩边类型不等</strong></h3><p>例如建立了索引 idx_user_name，name 字段类型为 varchar。在查询时使用 where name = kaka，这样的查询方式会直接造成索引失效。</p><p>正确的用法为 where name = “kaka”。</p><h3 id="不适当的-like-查询会导致索引失效"><a href="#不适当的-like-查询会导致索引失效" class="headerlink" title="不适当的 like 查询会导致索引失效"></a><strong>不适当的 like 查询会导致索引失效</strong></h3><p>创建索引为 idx_user_name，执行语句为 select * from user where name like “kaka%”；可以命中索引。</p><p>执行语句为 select name from user where name like “%kaka”；可以使用到索引（仅在 8.0 以上版本）。</p><p>执行语句为 select * from user where name like ‘’%kaka”；会直接导致索引失效。</p><h3 id="范围条件之后的索引会失效"><a href="#范围条件之后的索引会失效" class="headerlink" title="范围条件之后的索引会失效"></a><strong>范围条件之后的索引会失效</strong></h3><p>创建索引为：idx_user_name_age_sex</p><p>执行语句</p><p>select * from user where name = ‘kaka’ and age &gt; 11 and sex = 1;</p><p>上面这条 SQL 语句只会命中 name 和 age 索引，sex 索引会失效。复合索引失效需要查看 key_len 的长度即可。</p><p>总结：% 在后边会命令索引，当使用了覆盖索引时任何查询方式都可命中索引。</p><p>以上就是我关于索引失效会出现的原因总结，在很多文章中没有标注 MySQL 版本，所以你有可能会看到 is null 、or 索引会失效的结论。</p><h2 id="SQL-优化杀手锏之-Explain"><a href="#SQL-优化杀手锏之-Explain" class="headerlink" title="SQL 优化杀手锏之 Explain"></a>SQL 优化杀手锏之 Explain</h2><p>在写完 SQL 语句之后必须要做的一件事情就是使用 Explain 进行 SQL 语句检测，看是否命中索引。</p><p><img src="../../../../../../images/image-20210303225229769.png" alt="image-20210303225229769"></p><p>上图就是使用 Explain 输出格式，接下来将会对输出格式进行简单的解释：</p><p><strong>①id：</strong>这列就是查询的编号，如果查询语句中没有子查询或者联合查询这个标识就一直是 1。如存在子查询或者联合查询这个编号会自增。</p><p><strong>②select_type：</strong>最常见的类型就是 SIMPLE 和 PRIMARY，此列知道就行了。**<br>**</p><p><strong>③table：</strong>理解为表名即可。**<br>**</p><p><strong>④\</strong>type：**此列是在优化 SQL 语句时最需要关注的列之一，此列显示了查询使用了何种类型。</p><p>以下排序从最优到最差：</p><ul><li><strong>system：</strong>表内只有一行数据。</li><li><strong>const：</strong>最多只会有一条记录匹配，常用于主键或者唯一索引为条件查询。</li><li><strong>eq_ref：</strong>当连接使用的索引为主键和唯一时会出现。</li><li><strong>ref：</strong>使用普通索引 = 或 &lt;=&gt; 运算符进行比较将会出现。</li><li><strong>fulltext：</strong>使用全文索引。</li><li><strong>ref_or_null：</strong>跟 ref 类型类似，只是增加了 null 值的判断，实际用的不多。语句为 where name = ‘kaka’ and name is null，name 为普通索引。</li><li><strong>index_merge：</strong>查询语句使用了俩个以上的索引，常见在使用 and、or 会出现，官方文档将此类型放在 ref_or_null 之后，但是在很多的情况下由于读取索引过多性能有可能还不如 range。</li><li><strong>unique_subquery：</strong>用于 where 中的 in 查询，完全替换子查询，效率更高。语句为 value IN (SELECT primary_key FROM single_table WHERE some_expr)</li><li><strong>index_subquery：</strong>子查询中的返回结果字段组合是一个索引（或索引组合），但不是一个主键或唯一索引。</li><li><strong>range：</strong>索引范围查询，常见于使用 =，&lt;&gt;，&gt;，&gt;=，&lt;，&lt;=，IS NULL，&lt;=&gt;，BETWEEN，IN() 或者 like 等运算符的查询中。</li><li><strong>index：</strong>索引全表扫描，把索引从头到尾扫一遍。</li><li><strong>all：</strong>全表扫描，性能最差。</li></ul><p><strong>⑤possible_keys：</strong>此列显示的可能会使用到的索引。</p><p><strong>⑥\</strong>key：**优化器从 possible_keys 中命中的索引。</p><p><strong>⑦key_len：</strong>查询用到的索引长度（字节数），key_len 只计算 where 条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到 key_len 中。</p><p><strong>⑧ref：</strong>如果是使用的常数等值查询，这里会显示 const。</p><p>如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段。如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为 func。</p><p><strong>⑨\</strong>rows：**这是 MySQL 估算的需要扫描的行数（不是精确值）。这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。</p><p><strong>⑩filtered：</strong>此列表示存储引擎返回的数据在 server 层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。</p><p><strong>⑪\</strong>extra：**在大多数情况下会出现以下几种情况。</p><ul><li>Using index：使用了覆盖索引，查询列都为索引字段。</li><li>Using where：使用了 where 语句。</li><li>Using temporary：查询结果进行排序的时候使用了一张临时表。</li><li>Using filesort：对数据使用一个外部的索引排序。</li><li>Using index condition：使用了索引下推。</li></ul><p>关于索引下推可以查看我之前的一篇文章《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&mid=2655842725&idx=1&sn=2c207731cb368e3d055671632172114d&chksm=bd74bc728a03356417750e561e790add150c2575306da987b274b92ad8609f4e92661b018dc2&scene=21#wechat_redirect">MySQL 索引</a>》。</p><p><strong>总结：</strong>以上就是关于 Explain 所有列的说明，在平时开发的过程中，一般只会关注 type、key、rows、extra 这四列。</p><p>type 优化目标至少达到 range 级别，要求是 ref 级别，如果可以 consts 最好。key 是查询使用到的索引，如果此列为空，要么未建立索引，要么索引失效。</p><p>rows 是这条 SQL 语句扫描的行数，越少越好。extra：此列为扩展列，如果出现临时表、文件排序则需要优化。</p><h2 id="SQL-优化杀手锏之慢查询"><a href="#SQL-优化杀手锏之慢查询" class="headerlink" title="SQL 优化杀手锏之慢查询"></a>SQL 优化杀手锏之慢查询</h2><p>上文说到了可以直接使用 Explain 来分析自己的 SQL 语句是否合理，接下来再聊一个点那就是慢查询。</p><p>查看慢查询是否打开：</p><p><img src="../../../../../../images/image-20210303225349781.png" alt="image-20210303225349781"></p><p>查看是否记录没有使用索引的 SQL 语句：</p><p><img src="../../../../../../images/image-20210303225400938.png" alt="image-20210303225400938"></p><p>开启慢查询、开启记录没有使用到索引的 SQL 语句</p><p>set global log_queries_not_using_idnexes=‘on’;<br>set global log_queries_not_using_indexes=‘on’;</p><p><img src="../../../../../../images/image-20210303225419735.png" alt="image-20210303225419735"></p><p>查询以上俩个配置是否打开：</p><p><img src="../../../../../../images/image-20210303225431247.png" alt="image-20210303225431247"></p><p>设置慢查询时间，这个时间由自己把控，一般 1s 即可：</p><p>set globle long_query_time=1;</p><p>如果查看这个时间没有变，则关于客户端在重新连接一次即可。</p><p><img src="../../../../../../images/image-20210303225458539.png" alt="image-20210303225458539"></p><p>查看慢查询存储位置：</p><p><img src="../../../../../../images/image-20210303225515519.png" alt="image-20210303225515519"></p><p>然后随便执行一条不执行索引的语句即可在这个日志中查看到此语句：</p><p><img src="../../../../../../images/image-20210303225531585.png" alt="image-20210303225531585"></p><p>上图中一般需要主要观察的是 Query_time、SQL 语句内容。以上就是关于如何使用慢查询来查看项目中出现问题的 SQL 语句。</p><h2 id="优化大法"><a href="#优化大法" class="headerlink" title="优化大法"></a>优化大法</h2><p>此处跟大家聊一些常用的 SQL 语句优化方案，以上的俩个工具要好好的利用，辅助我们进行打怪：</p><p><strong>①</strong>禁止使用 select *，需要什么字段查询什么字段。</p><p><strong>②</strong>where 字段设置索引。</p><p><strong>③</strong>group by、order by 字段设置索引。</p><p><strong>④</strong>舍弃 offset，limit 分页，使用延迟关联来实现分页（数据量不大时可不用）。</p><p><strong>⑤</strong>写分页时当 count 为 0 时，直接返回避免执行分页语句。</p><p><strong>⑥</strong>利用覆盖索引进行查询避免回表。</p><p><strong>⑦</strong>建立复合索引时区分度最高的放在最左侧。</p><p><strong>⑧</strong>统计数据行数只用 count(*)，别整的花里胡哨的。</p><p><strong>⑨</strong>关于 in 和 exist，如果查询的俩个表大小一致则性能差别可忽略，如果子查询表大用 exist，否则使用 in。</p><p><strong>⑩</strong>查询一行数据时加上 limit 1。</p><p><strong>⑪</strong>选择合理的数据类型，在满足条件下数据类型越小越好。</p><p><strong>⑫</strong>联合查询 join 最多三个表，并且需要 join 的字段数据类型保持一致。</p><p><strong>⑬</strong>in 操作能避免尽量避免，无法避免的情况下 in 元素控制在 1000 以内。</p><p><strong>⑭</strong>数据更新频繁，区分度不高的列不适合建立索引。</p><p><strong>⑮</strong>explain 中的 type 至少要达到 range，要求为 ref。</p><p><strong>⑯</strong>联合索引满足最左侧原则。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL查询优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网华为机试</title>
      <link href="2021/03/03/niuke/suanfa/huaweijs-01/"/>
      <url>2021/03/03/niuke/suanfa/huaweijs-01/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客网华为机试在线训练JavaScript-V8-版2"><a href="#牛客网华为机试在线训练JavaScript-V8-版2" class="headerlink" title="牛客网华为机试在线训练JavaScript(V8)版2"></a>牛客网华为机试在线训练JavaScript(V8)版2</h1><h2 id="1-易"><a href="#1-易" class="headerlink" title="1.(易)"></a>1.(易)</h2><p>  编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次 </p><p>  例如，对于字符串abaca而言，有a、b、c三种不同的字符，因此输出3。 </p><p>输入描述:</p><pre><code>输入一行没有空格的字符串。</code></pre><p>输出描述:</p><pre><code>输出范围在(0~127)字符的个数。</code></pre><p>输入</p><pre><code>abc</code></pre><p>输出</p><pre><code>3</code></pre><p>解析：</p><pre><code>while (line = readline()) &#123;    let s1 = new Set();    for(let i =0; i&lt;line.length; i++)&#123;        s1.add(line[i]);    &#125;    print(Array.from(s1).length);&#125;</code></pre><h1 id="2-易"><a href="#2-易" class="headerlink" title="2(易)"></a>2(易)</h1><p>题目描述</p><p>给定n个字符串，请对n个字符串按照字典序排列。</p><p>输入描述:</p><pre><code>输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。</code></pre><p>输出描述:</p><pre><code>数据输出n行，输出结果为按照字典序排列的字符串。</code></pre><p>输入</p><pre><code>9captocatcardtwotooupboatboot</code></pre><p>输出</p><pre><code>boatbootcapcardcattotootwoup</code></pre><p>解答：</p><pre><code>while (line = readline()) &#123;   var num = parseInt(line);   var list =[];   for(i=0;i&lt;num;i++)&#123;        list.push(readline());   &#125;   list =list.sort();    for(i=0;i&lt;num;i++)&#123;        print(list[i]);   &#125; &#125;</code></pre><h2 id="3-易"><a href="#3-易" class="headerlink" title="3:(易)"></a>3:(易)</h2><p>  输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。 </p><p>输入描述:</p><pre><code> 输入一个整数（int类型）</code></pre><p>输出描述:</p><pre><code> 这个数转换成2进制后，输出1的个数</code></pre><p>输入</p><pre><code>5</code></pre><p>输出</p><pre><code>2</code></pre><p>解析：</p><pre><code>while (line = readline()) &#123;    var a = parseInt(line);    var b = a.toString(2);    var count =0;    for( i=0 ; i&lt;b.length ;i++)&#123;        if(b[i]==1)&#123;            count =count +1;        &#125;    &#125;    print(count);&#125;</code></pre><h2 id="4（难）"><a href="#4（难）" class="headerlink" title="4（难）"></a>4（难）</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><table><thead><tr><th>主件</th><th>附件</th></tr></thead><tbody><tr><td>电脑</td><td>打印机，扫描仪</td></tr><tr><td>书柜</td><td>图书</td></tr><tr><td>书桌</td><td>台灯，文具</td></tr><tr><td>工作椅</td><td>无</td></tr></tbody></table><p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等：用整数 1 <strong>~</strong> 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。</p><p>  设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品，编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为：</p><p>v[j 1 ]*w[j 1 ]+v[j 2 ]*w[j 2 ]+ … +v[j k ]*w[j k ] 。（其中 * 为乘号）</p><p>  请你帮助王强设计一个满足要求的购物单。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code>输入的第 1 行，为两个正整数，用一个空格隔开：N m（其中 N （ &lt;32000 ）表示总钱数， m （ &lt;60 ）为希望购买物品的个数。）从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q（其中 v 表示该物品的价格（ v&lt;10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q&gt;0 ，表示该物品为附件， q 是所属主件的编号） </code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code> 输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ &lt;200000 ）。</code></pre><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code>1000 5800 2 0400 5 1300 5 1400 3 0500 2 0</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>2200</code></pre><p>初步解题思路：</p><pre><code>//输入//总金额   物品个数//价格  重要度  0主件/q附件 主件编号//输出 max（价格* 重要程度）&lt;总金额//解题思路：//接受输入 总金额money   物品个数 num//循环接受多行输入  价格price  重要度inport   0主件/q附件 主件编号 qwhile (line = readline()) &#123;    var lines = line.split(&#39; &#39;);    var money = parseInt(lines[0]);    var num = parseInt(lines[1]);    var zjlist =[];    for(i=1; i&lt;num+1; i++)&#123;       let lineitem = readline().split(&#39; &#39;);       let price =parseInt(lineitem[0]);       let inport =parseInt(lineitem[1]);       let fj =parseInt(lineitem[2]);       if(fj)&#123;          var item = zjlist.findIndex()(x=&gt;x.ID==fj);          zjlist[item].allimpt += inport；          zjlist[item].alln += 1；          zjlist[item].price += price；                &#125;else&#123;          var zj = new CreateFoo(i,price,inport);          zjlist.push(zj);       &#125;    &#125;    &#125;//定义一个主件列表  加入主件//对象  ID  ，价格price  ，重要度 inport，总重要度allimpt，总数量 n//下一个是附件时，添加到主件信息 ，价格累计，重要度累计（价格乘以重要度）function CreateFoo(ID,price,inport)&#123;//构造函数首字母大写    this.ID = ID;    this.price = price;    this.goal = price*inport;    this.allimpt = inport;    this.alln = 1;&#125;// 计算最大总和// 物品总数量k[i] 主件数量n[i]*k[i]的和&lt;=num// 物品总价格v[i] 主件总价格 n[i]*v[i] 的和&lt;=moneyfunction SumMaxImp(arr)&#123;    &#125;//求最大重要度  allimpt[i]*n[i] 最大//求值思路   总重要度/总数量  重要比 优先给重要比大的物件购买数量 //  例如  总金额处理 金额  最大数如果小于总数量限制，则设定最大值，如果大于最大值，则取最大数量限制数//  剩余金额迭代//</code></pre><h3 id="参考解析："><a href="#参考解析：" class="headerlink" title="参考解析："></a>参考解析：</h3><pre><code>while (str1 = readline()) &#123;    var arr = str1.split(&#39; &#39;);    //总钱数    var m = parseInt(arr[0])/10;    //希望购买物品的件数    var n = parseInt(arr[1]);    var goods = [], count=1;    // 第j行数据表示编号j-1的物品的基本数据 价格 重要度 主附件（0 主件 &gt;0 附件值为其所属主件的编号）    while (count&lt;=n) &#123;        var item = readline().split(&#39; &#39;).map(val =&gt; parseInt(val));        // 是主件        if (item[2] == 0) &#123;            goods[count] = [&#123;v:item[0]/10, w:item[0]/10*item[1]&#125;];        // 是附件， 同时必须购买相应的主件        &#125; else &#123;            var add = goods[item[2]].map(val =&gt; &#123;                return &#123;                    v: item[0]/10 + val.v,                    w: item[0]/10*item[1] +val.w                &#125;            &#125;);            goods[item[2]] = [...goods[item[2]], ...add];        &#125;        count++;    &#125;    console.log(choose(goods));&#125;function choose(goods) &#123;    var res = Array(m+1).fill(0);    for (var i=0;i&lt;goods.length;i++) &#123;        for (var j=m;j&gt;=0;j--) &#123;            if (goods[i]) &#123;                goods[i].forEach(val =&gt; &#123;                    if (val.v &lt;= j) &#123;                        // 买权重较高的物品                        res[j] = Math.max(res[j], res[j-val.v]+val.w);                    &#125;                &#125;)            &#125;        &#125;    &#125;    return res[m] * 10;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 牛客网华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引相关面试题</title>
      <link href="2021/03/03/niuke/sql/mysql-cha-xun-you-hua/"/>
      <url>2021/03/03/niuke/sql/mysql-cha-xun-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL索引相关面试题"><a href="#MySQL索引相关面试题" class="headerlink" title="MySQL索引相关面试题"></a>MySQL索引相关面试题</h1><p><strong><em>\</em>-   来源于网络资料   -**</strong></p><p>索引底层数据结构B+构详解<br>说下索引底层数据结构<br>什么是聚集索引<br>InnoDB表为什么必须有主键<br>InnoDB表主键为什么推荐使用自增的整型<br>如何建立高性能索引<br>面试关于索引都问些什么</p><p>正确的创建合适的索引是数据库优化的基础</p><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的数据结构</p><p>在RDBMS系统中数据的索引都是硬盘级索引</p><p>全表扫描：复杂度O(n)<br>数组扫描：复杂度O(1)<br>hash索引优劣势是什么？<br>查询快；hash冲突<br>不支持范围查询</p><p><img src="../../../../../../images/image-20210303091212732.png" alt="image-20210303091212732"></p><p><img src="../../../../../../images/image-20210303091224483.png" alt="image-20210303091224483"></p><p><img src="../../../../../../images/image-20210303091234197.png" alt="image-20210303091234197"></p><p><img src="../../../../../../images/image-20210303091244722.png" alt="image-20210303091244722"></p><p><img src="../../../../../../images/image-20210303101216332.png" alt="image-20210303101216332"></p><p><img src="../../../../../../images/image-20210303101224311.png" alt="image-20210303101224311"></p><p><img src="../../../../../../images/image-20210303101239974.png" alt="image-20210303101239974"></p><p>为什么mysql页文件默认16K?<br>假如我们一行数据大小为1k，那么一页就能存16条数据，也就是一个叶子节点能存16条数据；<br>再看非叶节子节点，假设主键ID为bigint类型，那么长度为8B，指针大小在Innodb源码中为6B，<br>一共就是14B，那么一页里就可以存储16K/14=1170个（主键+指针）</p><p>那么一颗高度为2的B+树能存储的数据为：1170*16=18720条，一颗高度为3的B+树能存储的数据为1170 * 1170 * 16 = 2190240（千万级条）</p><p><img src="../../../../../../images/image-20210303101303012.png" alt="image-20210303101303012"></p><p><img src="../../../../../../images/image-20210303101312106.png" alt="image-20210303101312106"></p><p>其他参考：<a href="https://mp.weixin.qq.com/s/TZvHp-lFON8IXYggKWUAHw">https://mp.weixin.qq.com/s/TZvHp-lFON8IXYggKWUAHw</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库性能优化</title>
      <link href="2021/03/02/zhaoxistu/sqlsuoyin/"/>
      <url>2021/03/02/zhaoxistu/sqlsuoyin/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库性能优化"><a href="#数据库性能优化" class="headerlink" title="数据库性能优化"></a>数据库性能优化</h1><p>如果不能设计一个合理的数据库模型，不仅会增加客户端和服务器段程序的编程和维护的难度，而且将会影响系统实际运行的性能。所以，在一个系统开始实施之前，完备的数据库模型的设计是必须的。</p><p><strong>一、数据库结构的设计</strong></p><p>在一个系统分析、设计阶段，因为数据量较小，负荷较低。我们往往只注意到功能的实现，而很难注意到性能的薄弱之处，等到系统投入实际运行一段时间后，才发现系统的性能在降低，这时再来考虑提高系统性能则要花费更多的人力物力，而整个系统也不可避免的形成了一个打补丁工程。</p><p>所以在考虑整个系统的流程的时候，我们必须要考虑，在高并发大数据量的访问情况下，我们的系统会不会出现极端的情况。（例如：对外统计系统在7月16日出现的数据异常的情况，并发大数据量的的访问造成，数据库的响应时间不能跟上数据刷新的速度造成。具体情况是：在日期临界时（00：00：00），判断数据库中是否有当前日期的记录，没有则插入一条当前日期的记录。在低并发访问的情况下，不会发生问题，但是当日期临界时的访问量相当大的时候，在做这一判断的时候，会出现多次条件成立，则数据库里会被插入多条当前日期的记录，从而造成数据错误。），数据库的模型确定下来之后，我们有必要做一个系统内数据流向图，分析可能出现的瓶颈。</p><p>为了保证数据库的一致性和完整性，在逻辑设计的时候往往会设计过多的表间关联，尽可能的降低数据的冗余。（例如用户表的地区，我们可以把地区另外存放到一个地区表中）如果数据冗余低，数据的完整性容易得到保证，提高了数据吞吐速度，保证了数据的完整性，清楚地表达数据元素之间的关系。而对于多表之间的关联查询（尤其是大数据表）时，其性能将会降低，同时也提高了客户端程序的编程难度，因此，物理设计需折衷考虑，根据业务规则，确定对关联表的数据量大小、数据项的访问频度，对此类数据表频繁的关联查询应适当提高数据冗余设计但增加了表间连接查询的操作，也使得程序的变得复杂，为了提高系统的响应时间，合理的数据冗余也是必要的。设计人员在设计阶段应根据系统操作的类型、频度加以均衡考虑。<br>另外，最好不要用自增属性字段作为主键与子表关联。不便于系统的迁移和数据恢复。对外统计系统映射关系丢失（**<strong><strong><strong>****</strong></strong></strong>）。</p><p>原来的表格必须可以通过由它分离出去的表格重新构建。使用这个规定的好处是，你可以确保不会在分离的表格中引入多余的列，所有你创建的表格结构都与它们的实际需要一样大。应用这条规定是一个好习惯，不过除非你要处理一个非常大型的数据，否则你将不需要用到它。（例如一个通行证系统，我可以将USERID，USERNAME，USERPASSWORD，单独出来作个表，再把USERID作为其他表的外键）</p><p><strong>表的设计具体注意的问题：</strong></p><p>1、数据行的长度不要超过8020字节，如果超过这个长度的话在物理页中这条数据会占用两行从而造成存储碎片，降低查询效率。<br>2、能够用数字类型的字段尽量选择数字类型而不用字符串类型的（电话号码），这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接回逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>3、对于不可变字符类型char和可变字符类型varchar  都是8000字节,char查询快，但是耗存储空间，varchar查询相对慢一些但是节省存储空间。在设计字段的时候可以灵活选择，例如用户名、密码等长度变化不大的字段可以选择CHAR，对于评论等长度变化大的字段可以选择VARCHAR。</p><p>4、字段的长度在最大限度的满足可能的需要的前提下，应该尽可能的设得短一些，这样可以提高查询的效率，而且在建立索引的时候也可以减少资源的消耗。</p><p>**<br>二、查询的优化**</p><p>保证在实现功能的基础上，尽量减少对数据库的访问次数；通过搜索参数，尽量减少对表的访问行数,最小化结果集，从而减轻网络负担；能够分开的操作尽量分开处理，提高每次的响应速度；在数据窗口使用SQL时，尽量把使用的索引放在选择的首列；算法的结构尽量简单；在查询时，不要过多地使用通配符如SELECT * FROM T1语句，要用到几列就选择几列如：SELECT COL1,COL2 FROM  T1；在可能的情况下尽量限制尽量结果集行数如：SELECT TOP 300 COL1,COL2,COL3 FROM  T1,因为某些情况下用户是不需要那么多的数据的。<br>在没有建索引的情况下，数据库查找某一条数据，就必须进行全表扫描了，对所有数据进行一次遍历，查找出符合条件的记录。在数据量比较小的情况下，也许看不出明显的差别，但是当数据量大的情况下，这种情况就是极为糟糕的了。<br>SQL语句在SQL SERVER中是如何执行的，他们担心自己所写的SQL语句会被SQL SERVER误解。比如： </p><pre><code>select * from table1 where name=&#39;zhangsan&#39; and tID &gt; 10000</code></pre><p>和执行: </p><pre><code>select * from table1 where tID &gt; 10000 and name=&#39;zhangsan&#39;</code></pre><p>一些人不知道以上两条语句的执行效率是否一样，因为如果简单的从语句先后上看，这两个语句的确是不一样，如果tID是一个聚合索引，那么后一句仅仅从表的10000条以后的记录中查找就行了；而前一句则要先从全表中查找看有几个name=’zhangsan’的，而后再根据限制条件条件tID&gt;10000来提出查询结果。<br>事实上，这样的担心是不必要的。SQL  SERVER中有一个“查询分析优化器”，它可以计算出where子句中的搜索条件并确定哪个索引能缩小表扫描的搜索空间，也就是说，它能实现自动优化。虽然查询优化器可以根据where子句自动的进行查询优化，但有时查询优化器就会不按照您的本意进行快速查询。<br>在查询分析阶段，查询优化器查看查询的每个阶段并决定限制需要扫描的数据量是否有用。如果一个阶段可以被用作一个扫描参数（SARG），那么就称之为可优化的，并且可以利用索引快速获得所需数据。<br>SARG的定义：用于限制搜索的一个操作，因为它通常是指一个特定的匹配，一个值的范围内的匹配或者两个以上条件的AND连接。形式如下：<br><strong>列名 操作符 &lt;常数 或 变量&gt; 或 &lt;常数 或 变量&gt; 操作符 列名</strong><br>列名可以出现在操作符的一边，而常数或变量出现在操作符的另一边。如：<br>Name=’张三’<br>价格&gt;5000<br>5000&lt;价格<br>Name=’张三’ and 价格&gt;5000<br>如果一个表达式不能满足SARG的形式，那它就无法限制搜索的范围了，也就是SQL SERVER必须对每一行都判断它是否满足WHERE子句中的所有条件。所以一个索引对于不满足SARG形式的表达式来说是无用的。<br>所以，优化查询最重要的就是，尽量使语句符合查询优化器的规则避免全表扫描而使用索引查询。</p><p><strong>具体要注意的：</strong></p><p>1.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><pre><code>select id from t where num is null</code></pre><p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</p><pre><code>select id from t where num=0</code></pre><p>2.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。</p><p>3.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><pre><code>select id from t where num=10 or num=20</code></pre><p>可以这样查询：</p><pre><code>select id from t where num=10 union all select id from t where num=20</code></pre><p>4.in 和 not in 也要慎用，因为IN会使系统无法使用索引,而只能直接搜索表中的数据。如：</p><pre><code>select id from t where num in(1,2,3)</code></pre><p>对于连续的数值，能用 between 就不要用 in 了：</p><pre><code>select id from t where num between 1 and 3</code></pre><p>5.尽量避免在索引过的字符数据中，使用非打头字母搜索。这也使得引擎无法利用索引。<br>见如下例子： </p><pre><code>SELECT * FROM T1 WHERE NAME LIKE ‘%L%&#39;  SELECT * FROM T1 WHERE SUBSTING(NAME,2,1)=&#39;L&#39;  SELECT * FROM T1 WHERE NAME LIKE ‘L%&#39;</code></pre><p>即使NAME字段建有索引，前两个查询依然无法利用索引完成加快操作，引擎不得不对全表所有数据逐条操作来完成任务。而第三个查询能够使用索引来加快操作。</p><p>6.必要时强制查询优化器使用某个索引，如在 where  子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><pre><code>select id from t where num=@num</code></pre><p>可以改为强制查询使用索引：</p><pre><code>select id from t with(index(索引名)) where num=@num</code></pre><p>7.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><pre><code>SELECT * FROM T1 WHERE F1/2=100 </code></pre><p>应改为: </p><pre><code>SELECT * FROM T1 WHERE F1=100*2SELECT * FROM RECORD WHERE SUBSTRING(CARD_NO,1,4)=&#39;5378&#39;</code></pre><p>应改为: </p><pre><code>SELECT * FROM RECORD WHERE CARD_NO LIKE ‘5378%&#39;SELECT member_number, first_name, last_name FROM members  WHERE DATEDIFF(yy,datofbirth,GETDATE()) &gt; 21</code></pre><p>应改为: </p><pre><code>SELECT member_number, first_name, last_name FROM members  WHERE dateofbirth &lt; DATEADD(yy,-21,GETDATE()) </code></pre><p>即：任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。</p><p>8.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><pre><code>select id from t where substring(name,1,3)=&#39;abc&#39;--name以abc开头的id select id from t where datediff(day,createdate,&#39;2005-11-30&#39;)=0--‘2005-11-30&#39;生成的id</code></pre><p>应改为:</p><pre><code>select id from t where name like &#39;abc%&#39; select id from t where createdate&gt;=&#39;2005-11-30&#39; and createdate&lt;&#39;2005-12-1&#39;</code></pre><p>9.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><p>10.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><p>11.很多时候用 exists是一个好的选择：</p><pre><code>select num from a where num in(select num from b)</code></pre><p>用下面的语句替换：</p><pre><code>select num from a where exists(select 1 from b where num=a.num)  SELECT SUM(T1.C1)FROM T1 WHERE(  (SELECT COUNT(*)FROM T2 WHERE T2.C2=T1.C2&gt;0)  SELECT SUM(T1.C1) FROM T1WHERE EXISTS(  SELECT * FROM T2 WHERE T2.C2=T1.C2) </code></pre><p>两者产生相同的结果，但是后者的效率显然要高于前者。因为后者不会产生大量锁定的表扫描或是索引扫描。</p><p>如果你想校验表里是否存在某条纪录，不要用count(*)那样效率很低，而且浪费服务器资源。可以用EXISTS代替。如： </p><pre><code>IF (SELECT COUNT(*) FROM table_name WHERE column_name = &#39;xxx&#39;) </code></pre><p>可以写成： </p><pre><code>IF EXISTS (SELECT * FROM table_name WHERE column_name = &#39;xxx&#39;)</code></pre><p>经常需要写一个T_SQL语句比较一个父结果集和子结果集，从而找到是否存在在父结果集中有而在子结果集中没有的记录，如： </p><pre><code>SELECT a.hdr_key FROM hdr_tbl a---- tbl a 表示tbl用别名a代替  WHERE NOT EXISTS (SELECT * FROM dtl_tbl b WHERE a.hdr_key = b.hdr_key)  SELECT a.hdr_key FROM hdr_tbl a  LEFT JOIN dtl_tbl b ON a.hdr_key = b.hdr_key WHERE b.hdr_key IS NULL SELECT hdr_key FROM hdr_tbl  WHERE hdr_key NOT IN (SELECT hdr_key FROM dtl_tbl) </code></pre><p>三种写法都可以得到同样正确的结果，但是效率依次降低。</p><p>12.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><p>13.避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><p>14.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p><p>15.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p><p>16.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><p>17.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p><p>18.尽量避免大事务操作，提高系统并发能力。</p><p>19.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p><p>\20. 避免使用不兼容的数据类型。例如float和int、char和varchar、binary和varbinary是不兼容的。数据类型的不兼容可能使优化器无法执行一些本来可以进行的优化操作。例如: </p><pre><code>SELECT name FROM employee WHERE salary &gt; 60000</code></pre><p>在这条语句中,如salary字段是money型的,则优化器很难对其进行优化,因为60000是个整型数。我们应当在编程时将整型转化成为钱币型,而不要等到运行时转化。</p><p>21.充分利用连接条件，在某种情况下，两个表之间可能不只一个的连接条件，这时在 WHERE 子句中将连接条件完整的写上，有可能大大提高查询速度。<br>例： </p><pre><code>SELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NO  SELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NO AND A.ACCOUNT_NO=B.ACCOUNT_NO </code></pre><p>第二句将比第一句执行快得多。</p><p>22、使用视图加速查询<br>把表的一个子集进行排序并创建视图，有时能加速查询。它有助于避免多重排序 操作，而且在其他方面还能简化优化器的工作。例如：</p><pre><code>SELECT cust.name，rcvbles.balance，……other columns  FROM cust，rcvbles  WHERE cust.customer_id = rcvlbes.customer_id  AND rcvblls.balance&gt;0  AND cust.postcode&gt;“98000”  ORDER BY cust.name</code></pre><p>如果这个查询要被执行多次而不止一次，可以把所有未付款的客户找出来放在一个视图中，并按客户的名字进行排序： </p><pre><code>CREATE VIEW DBO.V_CUST_RCVLBES  AS SELECT cust.name，rcvbles.balance，……other columns  FROM cust，rcvbles  WHERE cust.customer_id = rcvlbes.customer_id  AND rcvblls.balance&gt;0  ORDER BY cust.name</code></pre><p>然后以下面的方式在视图中查询： </p><pre><code>SELECT ＊ FROM V_CUST_RCVLBES  WHERE postcode&gt;“98000” </code></pre><p>视图中的行要比主表中的行少，而且物理顺序就是所要求的顺序，减少了磁盘I/O，所以查询工作量可以得到大幅减少。</p><p>23、能用DISTINCT的就不用GROUP BY </p><pre><code>SELECT OrderID FROM Details WHERE UnitPrice &gt; 10 GROUP BY OrderID</code></pre><p>可改为： </p><pre><code>SELECT DISTINCT OrderID FROM Details WHERE UnitPrice &gt; 10</code></pre><p>24.能用UNION ALL就不要用UNION<br>UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源</p><p>25.尽量不要用SELECT INTO语句。<br>SELECT INOT 语句会导致表锁定，阻止其他用户访问该表。</p><p>上面我们提到的是一些基本的提高查询速度的注意事项,但是在更多的情况下,往往需要反复试验比较不同的语句以得到最佳方案。最好的方法当然是测试，看实现相同功能的SQL语句哪个执行时间最少，但是数据库中如果数据量很少，是比较不出来的，这时可以用查看执行计划，即：把实现相同功能的多条SQL语句考到查询分析器，按CTRL+L看查所利用的索引，表扫描次数（这两个对性能影响最大），总体上看询成本百分比即可。</p><p><strong>三、算法的优化</strong></p><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD  游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。<br>　　游标提供了对特定集合中逐行扫描的手段，一般使用游标逐行遍历数据，根据取出的数据不同条件进行不同的操作。尤其对多表和大表定义的游标（大的数据集合）循环很容易使程序进入一个漫长的等特甚至死机。<br>　 在有些场合，有时也非得使用游标，此时也可考虑将符合条件的数据行转入临时表中，再对临时表定义游标进行操作，可时性能得到明显提高。<br>（例如：对内统计第一版）<br>封装存储过程</p><p><strong>四、建立高效的索引</strong></p><p>　  创建索引一般有以下两个目的：维护被索引列的唯一性和提供快速访问表中数据的策略。大型数据库有两种索引即簇索引和非簇索引，一个没有簇索引的表是按堆结构存储数据，所有的数据均添加在表的尾部，而建立了簇索引的表，其数据在物理上会按照簇索引键的顺序存储，一个表只允许有一个簇索引，因此，根据B树结构，可以理解添加任何一种索引均能提高按索引列查询的速度，但会降低插入、更新、删除操作的性能，尤其是当填充因子（Fill  Factor）较大时。所以对索引较多的表进行频繁的插入、更新、删除操作，建表和索引时因设置较小的填充因子，以便在各数据页中留下较多的自由空间，减少页分割及重新组织的工作。<br>索引是从数据库中获取数据的最高效方式之一。95%  的数据库性能问题都可以采用索引技术得到解决。作为一条规则，我通常对逻辑主键使用唯一的成组索引，对系统键（作为存储过程）采用唯一的非成组索引，对任何外键列[字段]采用非成组索引。不过，索引就象是盐，太多了菜就咸了。你得考虑数据库的空间有多大，表如何进行访问，还有这些访问是否主要用作读写。<br>实际上，您可以把索引理解为一种特殊的目录。微软的SQL SERVER提供了两种索引：聚集索引（clustered index，也称聚类索引、簇集索引）和非聚集索引（nonclustered  index，也称非聚类索引、非簇集索引）。下面，我们举例来说明一下聚集索引和非聚集索引的区别：<br>其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。<br>我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。<br>如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。<br>我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。<br>进一步引申一下，我们可以很容易的理解：每个表只能有一个聚集索引，因为目录只能按照一种方法进行排序。</p><p>**（一）何时使用聚集索引或非聚集索引<br>**下面的表总结了何时使用聚集索引或非聚集索引（很重要）。<br>动作描述 使用聚集索引 使用非聚集索引<br>列经常被分组排序 应 应<br>返回某范围内的数据 应 不应<br>一个或极少不同值 不应 不应<br>小数目的不同值 应 不应<br>大数目的不同值 不应 应<br>频繁更新的列 不应 应<br>外键列 应 应<br>主键列 应 应<br>频繁修改索引列 不应 应</p><p>事实上，我们可以通过前面聚集索引和非聚集索引的定义的例子来理解上表。如：返回某范围内的数据一项。比如您的某个表有一个时间列，恰好您把聚合索引建立在了该列，这时您查询2004年1月1日至2004年10月1日之间的全部数据时，这个速度就将是很快的，因为您的这本字典正文是按日期进行排序的，聚类索引只需要找到要检索的所有数据中的开头和结尾数据即可；而不像非聚集索引，必须先查到目录中查到每一项数据对应的页码，然后再根据页码查到具体内容。</p><p><strong>（二）结合实际，谈索引使用的误区</strong></p><p>理论的目的是应用。虽然我们刚才列出了何时应使用聚集索引或非聚集索引，但在实践中以上规则却很容易被忽视或不能根据实际情况进行综合分析。下面我们将根据在实践中遇到的实际问题来谈一下索引使用的误区，以便于大家掌握索引建立的方法。<br><strong>1、主键就是聚集索引</strong><br>这种想法笔者认为是极端错误的，是对聚集索引的一种浪费。虽然SQL SERVER默认是在主键上建立聚集索引的。<br>通常，我们会在每个表中都建立一个ID列，以区分每条数据，并且这个ID列是自动增大的，步长一般为1。我们的这个办公自动化的实例中的列Gid就是如此。此时，如果我们将这个列设为主键，SQL SERVER会将此列默认为聚集索引。这样做有好处，就是可以让您的数据在数据库中按照ID进行物理排序，但笔者认为这样做意义不大。<br>显而易见，聚集索引的优势是很明显的，而每个表中只能有一个聚集索引的规则，这使得聚集索引变得更加珍贵。<br>从我们前面谈到的聚集索引的定义我们可以看出，使用聚集索引的最大好处就是能够根据查询要求，迅速缩小查询范围，避免全表扫描。在实际应用中，因为ID号是自动生成的，我们并不知道每条记录的ID号，所以我们很难在实践中用ID号来进行查询。这就使让ID号这个主键作为聚集索引成为一种资源浪费。其次，让每个ID号都不同的字段作为聚集索引也不符合“大数目的不同值情况下不应建立聚合索引”规则；当然，这种情况只是针对用户经常修改记录内容，特别是索引项的时候会负作用，但对于查询速度并没有影响。<br>在办公自动化系统中，无论是系统首页显示的需要用户签收的文件、会议还是用户进行文件查询等任何情况下进行数据查询都离不开字段的是“日期”还有用户本身的“用户名”。<br>通常，办公自动化的首页会显示每个用户尚未签收的文件或会议。虽然我们的where语句可以仅仅限制当前用户尚未签收的情况，但如果您的系统已建立了很长时间，并且数据量很大，那么，每次每个用户打开首页的时候都进行一次全表扫描，这样做意义是不大的，绝大多数的用户1个月前的文件都已经浏览过了，这样做只能徒增数据库的开销而已。事实上，我们完全可以让用户打开系统首页时，数据库仅仅查询这个用户近3个月来未阅览的文件，通过“日期”这个字段来限制表扫描，提高查询速度。如果您的办公自动化系统已经建立的2年，那么您的首页显示速度理论上将是原来速度8倍，甚至更快。</p><p>**2、只要建立索引就能显著提高查询速度<br>**事实上，我们可以发现上面的例子中，第2、3条语句完全相同，且建立索引的字段也相同；不同的仅是前者在fariqi字段上建立的是非聚合索引，后者在此字段上建立的是聚合索引，但查询速度却有着天壤之别。所以，并非是在任何字段上简单地建立索引就能提高查询速度。<br>从建表的语句中，我们可以看到这个有着1000万数据的表中fariqi字段有5003个不同记录。在此字段上建立聚合索引是再合适不过了。在现实中，我们每天都会发几个文件，这几个文件的发文日期就相同，这完全符合建立聚集索引要求的：“既不能绝大多数都相同，又不能只有极少数相同”的规则。由此看来，我们建立“适当”的聚合索引对于我们提高查询速度是非常重要的。</p><p>**3、把所有需要提高查询速度的字段都加进聚集索引，以提高查询速度<br>**上面已经谈到：在进行数据查询时都离不开字段的是“日期”还有用户本身的“用户名”。既然这两个字段都是如此的重要，我们可以把他们合并起来，建立一个复合索引（compound index）。<br>很多人认为只要把任何字段加进聚集索引，就能提高查询速度，也有人感到迷惑：如果把复合的聚集索引字段分开查询，那么查询速度会减慢吗？带着这个问题，我们来看一下以下的查询速度（结果集都是25万条数据）：（日期列fariqi首先排在复合聚集索引的起始列，用户名neibuyonghu排在后列）<br>我们可以看到如果仅用聚集索引的起始列作为查询条件和同时用到复合聚集索引的全部列的查询速度是几乎一样的，甚至比用上全部的复合索引列还要略快（在查询结果集数目一样的情况下）；而如果仅用复合聚集索引的非起始列作为查询条件的话，这个索引是不起任何作用的。当然，语句1、2的查询速度一样是因为查询的条目数一样，如果复合索引的所有列都用上，而且查询结果少的话，这样就会形成“索引覆盖”，因而性能可以达到最优。同时，请记住：无论您是否经常使用聚合索引的其他列，但其前导列一定要是使用最频繁的列。</p><p><strong>（三）其他注意事项</strong><br>“水可载舟，亦可覆舟”，索引也一样。索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。<br>所以说，我们要建立一个“适当”的索引体系，特别是对聚合索引的创建，更应精益求精，以使您的数据库能得到高性能的发挥</p>]]></content>
      
      
      <categories>
          
          <category> 数据库性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端设计模式</title>
      <link href="2021/03/02/kaikeba/javascript-she-ji-mo-shi/"/>
      <url>2021/03/02/kaikeba/javascript-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="前端设计模式"><a href="#前端设计模式" class="headerlink" title="前端设计模式"></a>前端设计模式</h1><p>​        设计模式（Design Pattern）是⼀套被反复使⽤、多数⼈知晓的、经过分类的、代码设计经验的总结。</p><h2 id="订阅-发布模式-（观察者）"><a href="#订阅-发布模式-（观察者）" class="headerlink" title="订阅**/**发布模式 （观察者）"></a>订阅**/**发布模式 （观察者）</h2><p>pub/sub 这个应该⼤家⽤到最⼴的设计模式了，</p><p>​    在这种模式中，并不是⼀个对象调⽤另⼀个对象的⽅法，⽽是⼀个对象订阅另⼀个对象的 特定活动并在</p><p>​    状态改编后获得通知。订阅者因此也成为观察者，⽽被观察的对象成为发布者或者主题。当发⽣了⼀个</p><p>​    重要事件时候 发布者会通知（调⽤）所有订阅者并且可能经常已事件对象的形式传递消息。</p><pre><code>class Event&#123; constructor()&#123;     this.callbacks = &#123;&#125; &#125; $off(name)&#123;     this.callbacks[name] = null &#125; $emit(name, args)&#123;     let cbs = this.callbacks[name]     if (cbs) &#123;         cbs.forEach(c=&gt;&#123;             c.call(this, args)         &#125;)     &#125; &#125; $on(name, fn)&#123;     (this.callbacks[name] || (this.callbacks[name] = [])).push(fn) &#125;&#125;let event = new Event()event.$on(&#39;event1&#39;, function(arg)&#123; console.log(&#39;事件1&#39;,arg)&#125;)event.$on(&#39;event1&#39;, function(arg)&#123; console.log(&#39;⼜⼀个时间1&#39;,arg)&#125;)event.$on(&#39;event2&#39;, function(arg)&#123; console.log(&#39;事件2&#39;,arg)&#125;)event.$emit(&#39;event1&#39;,&#123;name:&#39;开课吧&#39;&#125;)event.$emit(&#39;event2&#39;,&#123;name:&#39;全栈&#39;&#125;)event.$off(&#39;event1&#39;)event.$emit(&#39;event1&#39;,&#123;name:&#39;开课吧&#39;&#125;)</code></pre><p>vue中的 emit,on源码 ⼤概也是这个样⼦</p><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/events.js#L54">https://github.com/vuejs/vue/blob/dev/src/core/instance/events.js#L54</a></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式的定义：保证⼀个类仅有⼀个实例，并提供⼀个访问它的全局访问点。实现的⽅法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了⼀个类只有⼀个实例对象。</p><p>适⽤场景：⼀个单⼀对象。⽐如：弹窗，⽆论点击多少次，弹窗只应该被创建⼀次’ 实现起来也很简单，⽤⼀个变量缓存即可.</p><pre><code>&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .model&#123; border:1px solid black; position: fixed; width:300px; height:300px; top:20%; left:50%; margin-left:-150px; text-align: center;  &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;loginBtn&quot;&gt;点我&lt;/div&gt; &lt;script&gt;  var getSingle = function( fn )&#123;     var result;     return function()&#123;         return result || ( result = fn.apply(this, arguments )              );  &#125;&#125;;var createLoginLayer = function()&#123;     var div = document.createElement( &#39;div&#39; );     div.innerHTML = &#39;我是登录浮窗&#39;;     div.className = &#39;model&#39;     div.style.display = &#39;none&#39;;      document.body.appendChild( div );     return div;&#125;;var createSingleLoginLayer = getSingle( createLoginLayer );document.getElementById( &#39;loginBtn&#39; ).onclick = function()&#123;     var loginLayer = createSingleLoginLayer();     loginLayer.style.display = &#39;block&#39;;&#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>应⽤场景</p><p>我们再element中的弹窗代码中，可以看到单例模式的实际案例 保证全局唯⼀性 <a href="https://github.com/ElemeFE/element/blob/dev/packages/message-box/src/main.js#L79">https://github.com/ElemeFE/element/blob/dev/packages/message-box/src/main.js#L79</a></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式的定义：定义⼀系列的算法，把他们⼀个个封装起来，并且使他们可以相互替换。</p><p>策略模式的⽬的就是将算法的使⽤算法的实现分离开来。</p><p>⼀个基于策略模式的程序⾄少由两部分组成。第⼀个部分是⼀组策略类（可变），策略类封装了具体的算法，并负责具体的计算过程。第⼆个部分是环境类Context（不变），Context接受客户的请求，随后将请求委托给某⼀个策略类。要做到这⼀点，说明Context中要维持对某个策略对象的引⽤举个栗⼦</p><p>奖⾦计算，绩效为 S 的⼈年 终奖有 4 倍⼯资，绩效为 A 的⼈年终奖有 3 倍⼯资，⽽绩效为 B 的⼈年终奖是 2 倍⼯资</p><pre><code>var calculateBonus = function( performanceLevel, salary )&#123; if ( performanceLevel === &#39;S&#39; )&#123; return salary * 4; &#125; if ( performanceLevel === &#39;A&#39; )&#123; return salary * 3; &#125; if ( performanceLevel === &#39;B&#39; )&#123; return salary * 2; &#125;&#125;;calculateBonus( &#39;B&#39;, 20000 ); // 输出:40000calculateBonus( &#39;S&#39;, 6000 ); // 输出:24000</code></pre><p>使⽤策略模式</p><pre><code>var strategies = &#123; &quot;S&quot;: function( salary )&#123; return salary * 4; &#125;, &quot;A&quot;: function( salary )&#123; return salary * 3; &#125;, &quot;B&quot;: function( salary )&#123; return salary * 2; &#125;&#125;;var calculateBonus = function( level, salary )&#123; return strategies[ level ]( salary );&#125;;console.log( calculateBonus( &#39;S&#39;, 20000 ) );// 输出:80000console.log( calculateBonus( &#39;A&#39;, 10000 ) );// 输出:30000</code></pre><p>表单校验</p><pre><code>// 正常写法var registerForm = document.getElementById( &#39;registerForm&#39; );registerForm.onsubmit = function()&#123; if ( registerForm.userName.value === &#39;&#39; )&#123; alert ( &#39;⽤户名不能为空&#39; ); return false; &#125; if ( registerForm.password.value.length &lt; 6 )&#123; alert ( &#39;密码⻓度不能少于 6 位&#39; ); return false; &#125; if ( !/(^1[3|5|8][0-9]&#123;9&#125;$)/.test( registerForm.phoneNumber.value ) )&#123; alert ( &#39;⼿机号码格式不正确&#39; ); return false; &#125;&#125;</code></pre><p>使⽤策略模式</p><pre><code>var strategies = &#123; isNonEmpty: function( value, errorMsg )&#123; if ( value === &#39;&#39; )&#123; return errorMsg ; &#125; &#125;, minLength: function( value, length, errorMsg )&#123; if ( value.length &lt; length )&#123; return errorMsg; &#125; &#125;, isMobile: function( value, errorMsg )&#123; // ⼿机号码格式 if ( !/(^1[3|5|8][0-9]&#123;9&#125;$)/.test( value ) )&#123; return errorMsg; &#125; &#125;&#125;;var Validator = function()&#123; this.cache = []; // 保存校验规则&#125;;Validator.prototype.add = function( var ary = rule.split( &#39;:&#39; ); this.cache.push(function()&#123; // var strategy = ary.shift(); ary.unshift( dom.value ); ary.push( errorMsg ); //  return strategies[strategy].apply(dom, ary); &#125;);&#125;;Validator.prototype.start = function()&#123; for ( var i = 0, validatorFunc; validatorFunc = this.cache[ i++ ]; )&#123; var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息 if ( msg )&#123; // 如果有确切的返回值，说明校验没有通过 return msg; &#125; &#125;&#125;;var validataFunc = function()&#123; var validator = new Validator(); // 创建⼀个 validator 对象 /***************添加⼀些校验规则****************/ validator.add( registerForm.userName, &#39;isNonEmpty&#39;, &#39;⽤户名不能为空&#39; );   validator.add( registerForm.password, &#39;minLength:6&#39;, &#39;密码⻓度不能少于 6位&#39;);  validator.add( registerForm.phoneNumber, &#39;isMobile&#39;, &#39;⼿机号码格式不正确&#39; ); var errorMsg = validator.start(); // 获得校验结果 return errorMsg; // 返回校验结果&#125;var registerForm = document.getElementById( &#39;registerForm&#39; );registerForm.onsubmit = function()&#123; var errorMsg = validataFunc(); // 如果 errorMsg 有确切的返回值，说明未通过校验 if ( errorMsg )&#123; alert ( errorMsg ); return false; // 阻⽌表单提交 &#125;s&#125;;</code></pre><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的定义：为⼀个对象提供⼀个代⽤品或占位符，以便控制对它的访问。</p><p>常⽤的虚拟代理形式：某⼀个花销很⼤的操作，可以通过虚拟代理的⽅式延迟到这种需要它的时候才去创建（例：使⽤虚拟代理实现图⽚懒加载）</p><p>图⽚懒加载的⽅式：先通过⼀张loading图占位，然后通过异步的⽅式加载图⽚，等图⽚加载好了再把完成的图⽚加载到img标签⾥⾯。</p><pre><code>var imgFunc = (function() &#123; var imgNode = document.createElement(&#39;img&#39;); document.body.appendChild(imgNode); return &#123; setSrc: function(src) &#123;  imgNode.src = src; &#125; &#125;&#125;)();var proxyImage = (function() &#123; var img = new Image(); img.onload = function() &#123; imgFunc.setSrc(this.src); &#125; return &#123; setSrc: function(src) &#123; imgFunc.setSrc(&#39;./loading,gif&#39;); img.src = src; &#125; &#125;&#125;)();proxyImage.setSrc(&#39;./pic.png&#39;);</code></pre><p>假设我们在做⼀个⽂件同步的功能，当我们选中⼀个 checkbox 的时候，它对应的⽂件就会被同 步到另外⼀台备⽤服务器上⾯。当⼀次选中过多时，会产⽣频繁的⽹络请求。将带来很⼤的开销。可以通过⼀个代理函数 proxySynchronousFile 来收集⼀段时间之内的请求， 最后⼀次性发送给服务器</p><pre><code>var synchronousFile = function( id )&#123; console.log( &#39;开始同步⽂件，id 为: &#39; + id );&#125;;var proxySynchronousFile = (function()&#123; var cache = [], // 保存⼀段时间内需要同步的 ID timer; // 定时器 return function( id )&#123; cache.push( id ); if ( timer )&#123; // 保证不会覆盖已经启动的定时器 return; &#125; timer = setTimeout(function()&#123; synchronousFile( cache.join( &#39;,&#39; ) ); clearTimeout( timer ); // 清空定时器 timer = null; cache.length = 0; // 清空 ID 集合 &#125;, 2000 ); &#125;// 2 秒后向本体发送需要同步的 ID 集合&#125;)();var checkbox = document.getElementsByTagName( &#39;input&#39; ); for ( var i = 0, c; c = checkbox[ i++ ]; )&#123; c.onclick = function()&#123; if ( this.checked === true )&#123; proxySynchronousFile( this.id ); &#125;  &#125;&#125;;</code></pre><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式的定义：通过⼀个中介者对象，其他所有的相关对象都通过该中介者对象来通信，⽽不是相互引⽤，当其中的⼀个对象发⽣改变时，只需要通知中介者对象即可。通过中介者模式可以解除对象与对象之间的紧耦合关系。</p><p>例如：现实⽣活中，航线上的⻜机只需要和机场的塔台通信就能确定航线和⻜⾏状态，⽽不需要和所有⻜机通信。同时塔台作为中介者，知道每架⻜机的⻜⾏状态，所以可以安排所有⻜机的起降和航线安排。</p><p>中介者模式适⽤的场景：例如购物⻋需求，存在商品选择表单、颜⾊选择表单、购买数量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。</p><p>redux，vuex 都属于中介者模式的实际应⽤，我们把共享的数据，抽离成⼀个单独的store， 每个都通过store这个中介来操作对象</p><p>⽬的就是减少耦合</p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰者模式的定义：在不改变对象⾃身的基础上，在程序运⾏期间给对象动态地添加⽅法。常⻅应⽤，react的⾼阶组件, 或者react-redux中的@connect 或者⾃⼰定义⼀些⾼阶组件</p><pre><code>import React from &#39;react&#39;const withLog = Component=&gt;&#123; // 类组件 class NewComponent extends React.Component&#123; componentWillMount()&#123; console.time(`CompoentRender`) console.log(`准备完毕了`) &#125; render()&#123; return &lt;Component &#123;...this.props&#125;&gt;&lt;/Component&gt; &#125;开课吧web全栈架构师  componentDidMount()&#123; console.timeEnd(`CompoentRender`) console.log(`渲染完毕了`) &#125; &#125; return NewComponent&#125;export &#123;withLog&#125;@withLogclass XXexport const connect = (mapStateToProps = state =&gt; state, mapDispatchToProps =&#123;&#125;) =&gt; (WrapComponent) =&gt; &#123; return class ConnectComponent extends React.Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor(props, context) &#123; super(props, context) this.state = &#123; props: &#123;&#125; &#125; &#125; componentDidMount() &#123; const &#123; store &#125; = this.context // 当前状态 update 后, 放⼊监听器中, ⽤于下⼀次的更新(每次 dispatch 后会执⾏subscribe 中的所有函数) store.subscribe(() =&gt; this.update()) this.update() &#125; update() &#123; const &#123; store &#125; = this.context const stateProps = mapStateToProps(store.getState()) const dispatchProps = bindActionCreators(mapDispatchToProps,store.dispatch) this.setState(&#123; props: &#123; ...this.state.props, ...stateProps, ...dispatchProps &#125; &#125;) &#125; render() &#123; return &lt;WrapComponent &#123;...this.state.props&#125;&gt;&lt;/WrapComponent&gt; &#125;  &#125;   &#125;</code></pre><p>假设我们在编写⼀个⻜机⼤战的游戏，随着经验值的增加，我们操作的⻜机对象可以升级成更厉害的⻜机，⼀开始这些⻜机只能发射普通的⼦弹，升到第⼆级时可以发射导弹，升到第三级时可以发射原⼦弹。</p><pre><code>Function.prototype.before = function( beforefn )&#123; var __self = this; // 保存原函数的引⽤ return function()&#123; // 返回包含了原函数和新函数的&quot;代理&quot;函数 beforefn.apply( this, arguments ); // 执⾏新函数，且保证 this 不被劫持，新函数接受的参数 // 也会被原封不动地传⼊原函数，新函数在原函数之前执⾏ return __self.apply( this, arguments ); // 执⾏原函数并返回原函数的执⾏结果， // 并且保证 this 不被劫持&#125; &#125;Function.prototype.after = function( afterfn )&#123; var __self = this; return function()&#123; var ret = __self.apply( this, arguments ); afterfn.apply( this, arguments ); return ret; &#125;&#125;;</code></pre><p>⽐如⻚⾯中有⼀个登录 button，点击这个 button 会弹出登录浮层，与此同时要进⾏数据上报， 来统计有多少⽤户点击了这个登录 button</p><pre><code>var showLogin = function()&#123; console.log( &#39;打开登录浮层&#39; ); log( this.getAttribute( &#39;tag&#39; ) );&#125;var log = function( tag )&#123; console.log( &#39;上报标签为: &#39; + tag ); (new Image).src = &#39;http:// xxx.com/report?tag=&#39; + tag; &#125;document.getElementById( &#39;button&#39; ).onclick = showLogin;</code></pre><p>使⽤装饰器</p><pre><code>var showLogin = function()&#123; console.log( &#39;打开登录浮层&#39; );&#125;var log = function()&#123; console.log( &#39;上报标签为: &#39; + this.getAttribute( &#39;tag&#39; ) );&#125;showLogin = showLogin.after( log ); // 打开登录浮层之后上报数据document.getElementById( &#39;button&#39; ).onclick = showLogin;</code></pre><p>装饰者模式和代理模式的结构看起来⾮常相像，这两种模式都描述了怎样为对象提供 ⼀定程度上的间接引⽤，它们的实现部分都保留了对另外⼀个对象的引⽤，并且向那个对象发送 请求。 代理模式和装饰者模式最重要的区别在于它们的意图和设计⽬的。代理模式的⽬的是，当直接访问本体不⽅便或者不符合需要时，为这个本体提供⼀个替代者。本体定义了关键功能，⽽代理提供或拒绝对它的访问，或者在访问本体之前做⼀些额外的事情。装饰者模式的作⽤就是为对 象动态加⼊⾏为。</p><p>其实Vue中的v-input，v-checkbox也可以认为是装饰器模式， 对原⽣的input和checkbox做⼀层装饰</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式即让多个⽅法⼀起被调⽤涉及到兼容性，参数⽀持多格式，有很多这种代码，对外暴露统⼀的api，⽐如上⾯的$on ⽀持数组，￥offff参数⽀持多个情况， 对⾯只⽤⼀个函数，内部判断实现</p><p>⾃⼰封装组件库 经常看到</p><pre><code>myEvent = &#123; stop: function(e) &#123; if (typeof e.preventDefault() === &quot;function&quot;) &#123; e.preventDefault(); &#125; if (typeof e.stopPropagation() === &quot;function&quot;) &#123; e.stopPropagation(); &#125; //for IE if (typeof e.returnValue === &quot;boolean&quot;) &#123; e.returnValue = false; &#125; if (typeof e.cancelBubble === &quot;boolean&quot;) &#123; e.cancelBubble = true; &#125; &#125; addEvent(dom, type, fn) &#123;  if (dom.addEventListener) &#123; dom.addEventListener(type, fn, false); &#125; else if (dom.attachEvent) &#123; dom.attachEvent(&#39;on&#39; + type, fn); &#125; else &#123; dom[&#39;on&#39; + type] = fn; &#125; &#125;&#125;</code></pre><h2 id="⼯⼚模式"><a href="#⼯⼚模式" class="headerlink" title="⼯⼚模式"></a>⼯⼚模式</h2><p>提供创建对象的接⼝，把成员对象的创建⼯作转交给⼀个外部对象，好处在于消除对象之间的耦合(也就</p><p>是相互影响)</p><p>常⻅的例⼦，我们的弹窗，message，对外提供的api，都是调⽤api，然后新建⼀个弹窗或者Message</p><p>的实例，就是典型的⼯⼚模式</p><pre><code>const Notification = function(options) &#123; if (Vue.prototype.$isServer) return; options = options || &#123;&#125;; const userOnClose = options.onClose; const id = &#39;notification_&#39; + seed++; const position = options.position || &#39;top-right&#39;; options.onClose = function() &#123; Notification.close(id, userOnClose); &#125;; instance = new NotificationConstructor(&#123; data: options &#125;); if (isVNode(options.message)) &#123; instance.$slots.default = [options.message]; options.message = &#39;REPLACED_BY_VNODE&#39;; &#125; instance.id = id; instance.$mount(); document.body.appendChild(instance.$el); instance.visible = true; instance.dom = instance.$el; instance.dom.style.zIndex = PopupManager.nextZIndex();  let verticalOffset = options.offset || 0; instances.filter(item =&gt; item.position === position).forEach(item =&gt; &#123; verticalOffset += item.$el.offsetHeight + 16; &#125;); verticalOffset += 16; instance.verticalOffset = verticalOffset; instances.push(instance); return instance;&#125;;</code></pre><p><a href="https://github.com/ElemeFE/element/blob/dev/packages/notifification/src/main.js#L11">https://github.com/ElemeFE/element/blob/dev/packages/notifification/src/main.js#L11</a></p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>和⼯⻓模式相⽐，参与了更多创建的过程 或者更复杂</p><pre><code>var Person = function(name, work) &#123; // 创建应聘者缓存对象 var _person = new Human(); // 创建应聘者姓名解析对象 _person.name = new Named(name); // 创建应聘者期望职位 _person.work = new Work(work); return _person;&#125;;var person = new Person(&#39;xiao ming&#39;, &#39;code&#39;);console.log(person)</code></pre><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式是指提供⼀种⽅法顺序访问⼀个聚合对象中的各个元素，⽽⼜不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来,在使⽤迭代器模式之后，即使不关⼼对象的内部构造，也可以按顺序访问其中的每个元素</p><p>这个⽤的就太多了 each map啥乱遭的</p><pre><code>var each = function( ary, callback )&#123; for ( var i = 0, l = ary.length; i &lt; l; i++ )&#123; callback.call( ary[i], i, ary[ i ] ); &#125;&#125;;each( [ 1, 2, 3 ], function( i, n )&#123; alert ( [ i, n ] );&#125;)</code></pre><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元(flflyweight)模式是⼀种⽤于性能优化的模式，“flfly”在这⾥是苍蝇的意思，意为蝇量级。享元模式的核⼼是象⽽导致内存占⽤过⾼，享元模式就⾮常有⽤了。在 JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了⼀件⾮常有意义的事情。</p><p>假设有个内⾐⼯⼚，⽬前的产品有 50 种男式内⾐和 50 种⼥⼠内⾐，为了推销产品，⼯⼚决定⽣产⼀些塑料模特来穿上他们的内⾐拍成⼴告照⽚。 正常情况下需要 50个男模特和50个⼥模特，然后让他们每⼈分别穿上⼀件内⾐来拍照</p><pre><code>var Model = function( sex, underwear)&#123; this.sex = sex; this.underwear = underwear;&#125;;Model.prototype.takePhoto = function()&#123; console.log( &#39;sex= &#39; + this.sex + &#39; underwear=&#39; + this.underwear);&#125;;for ( var i = 1; i &lt;= 50; i++ )&#123; var maleModel = new Model( &#39;male&#39;, &#39;underwear&#39; + i );  maleModel.takePhoto(); &#125;;for ( var j = 1; j &lt;= 50; j++ )&#123; var femaleModel= new Model( &#39;female&#39;, &#39;underwear&#39; + j ); femaleModel.takePhoto();&#125;;</code></pre><p>如上所述，现在⼀共有 50 种男内 ⾐和 50 种⼥内⾐，所以⼀共会产⽣ 100 个对象。如果将来⽣产了10000 种内⾐，那这个程序可能会因为存在如此多的对象已经提前崩溃。 下⾯我们来考虑⼀下如何优化这个场景。虽然有 100 种内⾐，但很显然并不需要 50 个男 模特和 50 个⼥模特。其实男模特和⼥模特各⾃有⼀个就⾜够了，他们可以分别穿上不同的内⾐来拍照。</p><pre><code>/*只需要区别男⼥模特那我们先把 underwear 参数从构造函数中 移除，构造函数只接收 sex 参数*/var Model = function( sex )&#123; this.sex = sex;&#125;;Model.prototype.takePhoto = function()&#123; console.log( &#39;sex= &#39; + this.sex + &#39; underwear=&#39; + this.underwear);&#125;;/*分别创建⼀个男模特对象和⼀个⼥模特对象*/var maleModel = new Model( &#39;male&#39; ), femaleModel = new Model( &#39;female&#39; );/*给男模特依次穿上所有的男装，并进⾏拍照*/for ( var i = 1; i &lt;= 50; i++ )&#123; maleModel.underwear = &#39;underwear&#39; + i; maleModel.takePhoto();&#125;;/*给⼥模特依次穿上所有的⼥装，并进⾏拍照*/for ( var j = 1; j &lt;= 50; j++ )&#123; femaleModel.underwear = &#39;underwear&#39; + j; femaleModel.takePhoto();&#125;;//只需要两个对象便完成了同样的功能</code></pre><p>内部状态存储于对象内部</p><p>内部状态可以被⼀些对象共享</p><p>内部状态独⽴于具体的场景，通常不会改变</p><p>外部状态取决于具体的场景，并根据场景⽽变化，外部状态不能被共享</p><p>性别是内部状态，内⾐是外部状态，通过区分这两种状态，⼤⼤减少了系 统中的对象数量。通常来讲，</p><p>内部状态有多少种组合，系统中便最多存在多少个对象，因为性别 通常只有男⼥两种，所以该内⾐⼚商最多只需要 2 个对象。</p><h2 id="应⽤案例"><a href="#应⽤案例" class="headerlink" title="应⽤案例"></a>应⽤案例</h2><p>消息组件</p><p>应⽤案例</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210302163543092.png" alt="image-20210302163543092"></p><p>需求</p><ol><li><p>弹窗逻辑⼀样</p></li><li><p>四中弹窗，颜⾊，icon不同</p></li><li><p>接收⽂案</p></li></ol><p>交互⽅式——弹出、隐藏，由共享对象所拥有</p><p>提示icon、背景样式、字体样式提供接⼝可配置</p><p>使⽤api统一</p><pre><code>export default &#123; install (Vue) &#123; // 在使⽤插件Vue.use(Message)时实例化⼀个Dialog组件对象 const Dialog = new Vue(&#123; data () &#123; return &#123; icon: &#39;&#39;, fontStyle: &#39;&#39;, backgroundStyle: &#39;&#39;, text: &#39;&#39; &#125; &#125; ... &#125;)  // 扩展Vue的`prototype` Vue.prototype.$Message = &#123; success (text) &#123; // 改变Dialog的data.xx的值触发Dialog的更新 Dialog.icon = successIcon Dialog.fontStyle = successFontStyle Dialog.backgroundStyle = successBackgroundStyle Dialog.text = text // 获取Dialog的最新DOM添加到body标签中 document.body.appendChild(Dialog.$el) &#125;, warning (text) &#123; // 同上 ... document.body.appendChild(Dialog.$el) &#125;, error (text) &#123; // 同上 ... document.body.appendChild(Dialog.$el) &#125; &#125; &#125;&#125;</code></pre><p>Dialog只会在项⽬初始化时被 new ⼀次，每次使⽤Message组件通过改变Dialog的状态获取组件DOM，其实很容易知道new⼀个组件的成本要⽐⼀个组件的更新成本⾼很多</p><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>职责链模式的定义是:使多个对象都有机会处理请求，从⽽避免请求的发送者和接收者之间的耦合关系，将这些对象连成⼀条链，并沿着这条链传递该请求，直到有⼀个对象处理它为⽌。 职责链模式的名字⾮常形象，⼀系列可能会处理请求的对象被连接成⼀条链，请求在这些对 象之间依次传递，直到遇到⼀个可以处理它的对象，我们把这些对象称为链中的节点</p><p>假设我们负责⼀个售卖⼿机的电商⽹站，经过分别交纳 500 元定⾦和 200 元定⾦的两轮预定后(订单已在此时⽣成)，现在已经到了正式购买的阶段。 公司针对⽀付过定⾦的⽤户有⼀定的优惠政策。在正式购买后，已经⽀付过 500 元定⾦的⽤ 户会收到 100 元的商城优惠券，200 元定⾦的⽤户可以收到 50 元的优惠券，⽽之前没有⽀付定⾦的⽤户只能进⼊普通购买模式，也就是没有优惠券，且在库存有限的情况下不⼀定保证能买到</p><pre><code>var order = function( orderType, pay, stock )&#123; if ( orderType === 1 )&#123; // 500 元定⾦购买模式 if ( pay === true )&#123; // 已⽀付定⾦ console.log( &#39;500 元定⾦预购, 得到 100 优惠券&#39; ); &#125; else&#123; // 未⽀付定⾦，降级到普通购买模式 if ( stock &gt; 0 )&#123; // ⽤于普通购买的⼿机还有库存 console.log( &#39;普通购买, ⽆优惠券&#39; ); &#125;else&#123; console.log( &#39;⼿机库存不⾜&#39; ); &#125; &#125; &#125; else if ( orderType === 2 )&#123; if ( pay === true )&#123; // 200 元定⾦购买模式 console.log( &#39;200 元定⾦预购, 得到 50 优惠券&#39; ); &#125;else&#123; if ( stock &gt; 0 )&#123; console.log( &#39;普通购买, ⽆优惠券&#39; ); &#125;else&#123; console.log( &#39;⼿机库存不⾜&#39; ); &#125; &#125; &#125; else if (orderType === 3) &#123; if ( stock &gt; 0 )&#123; console.log( &#39;普通购买, ⽆优惠券&#39; ); &#125; else&#123; console.log( &#39;⼿机库存不⾜&#39; ); &#125; &#125;&#125;;order( 1 , true, 500); // 输出: 500 元定⾦预购, 得到 100 优惠券</code></pre><p>现在我们采⽤职责链模式重构这段代码，先把 500 元订单、200 元订单以及普通购买分成 3 个函数。接下来把 orderType、pay、stock 这 3 个字段当作参数传递给 500 元订单函数，如果该函数不符合处理条件，则把这个请求传递给后⾯的 200 元订单函数，如果 200 元订单函数依然不能处理该请求，则继续传递请求给普通购买函数。</p><pre><code>var order500 = function( orderType, pay, stock )&#123; if ( orderType === 1 &amp;&amp; pay === true )&#123; console.log( &#39;500 元定⾦预购，得到 100 优惠券&#39; ); &#125; else&#123; return &#39;nextSuccessor&#39;; // 我不知道下⼀个节点是谁，反正把请求往后⾯传递 &#125;&#125;;var order200 = function( orderType, pay, stock )&#123; if ( orderType === 2 &amp;&amp; pay === true )&#123; console.log( &#39;200 元定⾦预购，得到 50 优惠券&#39; ); &#125; else&#123; return &#39;nextSuccessor&#39;; // 我不知道下⼀个节点是谁，反正把请求往后⾯传递 &#125;&#125;;var orderNormal = function( orderType, pay, stock )&#123; if ( stock &gt; 0 )&#123; console.log( &#39;普通购买，⽆优惠券&#39; ); &#125; else&#123; console.log( &#39;⼿机库存不⾜&#39; ); &#125;&#125;;// Chain.prototype.setNextSuccessor 指定在链中的下⼀个节点// Chain.prototype.passRequest 传递请求给某个节点var Chain = function( fn )&#123; this.fn = fn; this.successor = null;&#125;;Chain.prototype.setNextSuccessor = function( successor )&#123; return this.successor = successor;&#125;;Chain.prototype.passRequest = function()&#123; var ret = this.fn.apply( this, arguments ); if ( ret === &#39;nextSuccessor&#39; )&#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments ); &#125; return ret;&#125;;var chainOrder500 = new Chain( order500 );var chainOrder200 = new Chain( order200 );var chainOrderNormal = new Chain( orderNormal );chainOrder500.setNextSuccessor( chainOrder200 );chainOrder200.setNextSuccessor( chainOrderNormal);chainOrder500.passRequest( 1, true, 500 ); // 输出:500 元定⾦预购，得到 100 优惠券chainOrder500.passRequest( 2, true, 500 ); // 输出:200 元定⾦预购，得到 50 优惠券chainOrder500.passRequest( 3, true, 500 ); // 输出:普通购买，⽆优惠券chainOrder500.passRequest( 1, false, 0 ); // 输出:⼿机库存不⾜</code></pre><p>通过改进，我们可以⾃由灵活地增加、移除和修改链中的节点顺序，假如某天⽹站运营⼈员 ⼜想出了⽀持 300 元定⾦购买，那我们就在该链中增加⼀个节点即可</p><pre><code>var order300 = function()&#123;// 具体实现略&#125;;chainOrder300= new Chain( order300 );chainOrder500.setNextSuccessor( chainOrder300);chainOrder300.setNextSuccessor( chainOrder200);</code></pre><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式的作⽤是解决两个软件实体间的接⼝不兼容的问题。使⽤适配器模式之后，原本 由于接⼝不兼容⽽不能⼯作的两个软件实体可以⼀起⼯作。 适配器的别名是包装器(wrapper)，这是⼀个相对简单的模式。在程序开发中有许多这样的 场景:当我们试图调⽤模块或者对象的某个接⼝时，却发现这个接⼝的格式并不符合⽬前的需求。 这时候有两种解决办法，第⼀种是修改原来的接⼝实现，但如果原来的模块很复杂，或者我们拿 到的模块是⼀段别⼈编写的经过压缩的代码，修改原接⼝就显得不太现实了。第⼆种办法是创建 ⼀个适配器，将原接⼝转换为客户希望的另⼀个接⼝，客户只需要和适配器打交道。</p><pre><code>var googleMap = &#123; show: function()&#123; console.log( &#39;开始渲染⾕歌地图&#39; ); &#125;&#125;;var baiduMap = &#123; display: function()&#123; console.log( &#39;开始渲染百度地图&#39; ); &#125;&#125;;var baiduMapAdapter = &#123; show: function()&#123; return baiduMap.display(); &#125;&#125;;renderMap( googleMap ); // 输出:开始渲染⾕歌地图renderMap( baiduMapAdapter ); // 输出:开始渲染百度地图</code></pre><p>适配器模式主要⽤来解决两个已有接⼝之间不匹配的问题，它不考虑这些接⼝是怎样实 现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接⼝，就能够 使它们协同作⽤。</p><p>装饰者模式和代理模式也不会改变原有对象的接⼝，但装饰者模式的作⽤是为了给对象 增加功能。装饰者模式常常形成⼀条⻓的装饰链，⽽适配器模式通常只包装⼀次。代理 模式是为了控制对对象的访问，通常也只包装⼀次。</p><p>我们设计很多插件，有默认值，也算是适配器的⼀种应⽤， vue的prop校验，default也算是适配器的应⽤了</p><p>外观模式的作⽤倒是和适配器⽐较相似，有⼈把外观模式看成⼀组对象的适配器，但外观模式最显著的特点是定义了⼀个新的接⼝。</p><h2 id="模板⽅法模式"><a href="#模板⽅法模式" class="headerlink" title="模板⽅法模式"></a>模板⽅法模式</h2><p>模板⽅法模式在⼀个⽅法中定义⼀个算法的⻣架，⽽将⼀些步骤的实现延迟到⼦类中。模板⽅法使得⼦类可以在不改变算法结构的情况下，重新定义算法中某些步骤的具体实现</p><p>这个我们⽤的很多，vue中的slot，react中的children</p><pre><code>class Parent &#123; constructor() &#123;&#125; render () &#123; &lt;div&gt; &lt;div name=&quot;tom&quot;&gt;&lt;/div&gt; &lt;!-- 算法过程：children要渲染在name为joe的div中 --&gt; &lt;div name=&quot;joe&quot;&gt;&#123;this.props.children&#125;&lt;/div&gt; &lt;/div&gt; &#125;&#125;class Stage &#123; constructor() &#123;&#125; render () &#123; // 在parent中已经设定了children的渲染位置算法 &lt;Parent&gt; // children的具体实现 &lt;div&gt;child&lt;/div&gt; &lt;/Parent&gt; &#125; &#125;</code></pre><pre><code>&lt;template&gt;&lt;div&gt; &lt;div name=&quot;tom&quot;&gt;&lt;/div&gt; &lt;div name=&quot;joe&quot;&gt; &lt;!--vue中的插槽渲染children--&gt; &lt;slot /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;template&gt; &lt;div&gt; &lt;parent&gt; &lt;!-- children的具体实现 --&gt; &lt;div&gt;child&lt;/div&gt; &lt;/parent&gt; &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>可以恢复到对象之前的某个状态，其实⼤家学习react或者redux的时候，时间旅⾏的功能，就算是备忘录模式的⼀个应⽤</p><p><a href="https://zh-hans.reactjs.org/tutorial/tutorial.html#implementing-time-travel">https://zh-hans.reactjs.org/tutorial/tutorial.html#implementing-time-travel</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>创建设计模式： ⼯⼚，单例，建造者 原型</p><p>结构化设计模式：外观，适配器，代理，装饰器，享元 桥接，组合</p><p>⾏为型：策略，模板⽅法，观察者，迭代器，责任链，命令，备忘录，状态，访问者，终结者，解释器</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6、ES7、ES8、ES9、ES10、ES11、ES12新特性</title>
      <link href="2021/03/01/ziliao/javascript/es6/"/>
      <url>2021/03/01/ziliao/javascript/es6/</url>
      
        <content type="html"><![CDATA[<h2 id="ES6、ES7、ES8、ES9、ES10、ES11、ES12新特性"><a href="#ES6、ES7、ES8、ES9、ES10、ES11、ES12新特性" class="headerlink" title="ES6、ES7、ES8、ES9、ES10、ES11、ES12新特性"></a>ES6、ES7、ES8、ES9、ES10、ES11、ES12新特性</h2><p>本文集合了 ES6 至 ES11 常用到的特性，包括还在规划的 ES12，只列举大概使用，详细介绍的话内容量将十分巨大<del>.</del>。PS：使用新特性需要使用最新版的 bable 就行转义</p><hr><h1 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a><strong>新特性</strong></h1><h2 id="ES6（2015）"><a href="#ES6（2015）" class="headerlink" title="ES6（2015）"></a><strong>ES6（2015）</strong></h2><h3 id="1-类（class）"><a href="#1-类（class）" class="headerlink" title="1. 类（class）"></a><strong>1. 类（class）</strong></h3><pre><code>class Man &#123;  constructor(name) &#123;    this.name = &#39;小豪&#39;;  &#125;  console() &#123;    console.log(this.name);  &#125;&#125;const man = new Man(&#39;小豪&#39;);man.console(); // 小豪</code></pre><h3 id="2-模块化-ES-Module"><a href="#2-模块化-ES-Module" class="headerlink" title="2. 模块化(ES Module)"></a><strong>2. 模块化(ES Module)</strong></h3><pre><code>// 模块 A 导出一个方法export const sub = (a, b) =&gt; a + b;// 模块 B 导入使用import &#123; sub &#125; from &#39;./A&#39;;console.log(sub(1, 2)); // 3</code></pre><h3 id="3-箭头（Arrow）函数"><a href="#3-箭头（Arrow）函数" class="headerlink" title="3. 箭头（Arrow）函数"></a><strong>3. 箭头（Arrow）函数</strong></h3><pre><code>const func = (a, b) =&gt; a + b;func(1, 2); // 3</code></pre><h3 id="4-函数参数默认值"><a href="#4-函数参数默认值" class="headerlink" title="4. 函数参数默认值"></a><strong>4. 函数参数默认值</strong></h3><pre><code>function foo(age = 25,)&#123; // ...&#125;</code></pre><h3 id="5-模板字符串"><a href="#5-模板字符串" class="headerlink" title="5. 模板字符串"></a><strong>5. 模板字符串</strong></h3><pre><code>const name = &#39;小豪&#39;;const str = `Your name is $&#123;name&#125;`;</code></pre><h3 id="6-解构赋值"><a href="#6-解构赋值" class="headerlink" title="6. 解构赋值"></a><strong>6. 解构赋值</strong></h3><pre><code>let a = 1, b= 2;[a, b] = [b, a]; // a 2  b 1</code></pre><h3 id="7-延展操作符"><a href="#7-延展操作符" class="headerlink" title="7. 延展操作符"></a><strong>7. 延展操作符</strong></h3><pre><code>let a = [...&#39;hello world&#39;]; // [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;]</code></pre><h3 id="8-对象属性简写"><a href="#8-对象属性简写" class="headerlink" title="8. 对象属性简写"></a><strong>8. 对象属性简写</strong></h3><pre><code>const name=&#39;小豪&#39;,const obj = &#123; name &#125;;</code></pre><h3 id="9-Promise"><a href="#9-Promise" class="headerlink" title="9. Promise"></a><strong>9. Promise</strong></h3><pre><code>Promise.resolve().then(() =&gt; &#123; console.log(2); &#125;);console.log(1);// 先打印 1 ，再打印 2</code></pre><h3 id="10-let和const"><a href="#10-let和const" class="headerlink" title="10. let和const"></a><strong>10. let和const</strong></h3><pre><code>let name = &#39;小豪&#39;；const arr = [];</code></pre><h2 id="ES7（2016）"><a href="#ES7（2016）" class="headerlink" title="ES7（2016）"></a><strong>ES7（2016）</strong></h2><h3 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1. Array.prototype.includes()"></a><strong>1. Array.prototype.includes()</strong></h3><pre><code>[1].includes(1); // true</code></pre><h3 id="2-指数操作符"><a href="#2-指数操作符" class="headerlink" title="2. 指数操作符"></a><strong>2. 指数操作符</strong></h3><pre><code>2**10; // 1024</code></pre><hr><h2 id="ES8（2017）"><a href="#ES8（2017）" class="headerlink" title="ES8（2017）"></a><strong>ES8（2017）</strong></h2><h3 id="1-async-await"><a href="#1-async-await" class="headerlink" title="1. async/await"></a><strong>1. async/await</strong></h3><p>异步终极解决方案</p><pre><code>async getData()&#123;    const res = await api.getTableData(); // await 异步任务    // do something    &#125;</code></pre><h3 id="2-Object-values"><a href="#2-Object-values" class="headerlink" title="2. Object.values()"></a><strong>2. Object.values()</strong></h3><pre><code>Object.values(&#123;a: 1, b: 2, c: 3&#125;); // [1, 2, 3]</code></pre><h3 id="3-Object-entries"><a href="#3-Object-entries" class="headerlink" title="3. Object.entries()"></a><strong>3. Object.entries()</strong></h3><pre><code>Object.entries(&#123;a: 1, b: 2, c: 3&#125;); // [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]</code></pre><h3 id="4-String-padding"><a href="#4-String-padding" class="headerlink" title="4. String padding"></a><strong>4. String padding</strong></h3><pre><code>// padStart&#39;hello&#39;.padStart(10); // &quot;     hello&quot;// padEnd&#39;hello&#39;.padEnd(10) &quot;hello     &quot;</code></pre><h3 id="5-函数参数列表结尾允许逗号"><a href="#5-函数参数列表结尾允许逗号" class="headerlink" title="5. 函数参数列表结尾允许逗号"></a><strong>5. 函数参数列表结尾允许逗号</strong></h3><h3 id="6-Object-getOwnPropertyDescriptors"><a href="#6-Object-getOwnPropertyDescriptors" class="headerlink" title="6. Object.getOwnPropertyDescriptors()"></a><strong>6. Object.getOwnPropertyDescriptors()</strong></h3><blockquote><p>获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。</p></blockquote><h3 id="7-SharedArrayBuffer对象"><a href="#7-SharedArrayBuffer对象" class="headerlink" title="7. SharedArrayBuffer对象"></a><strong>7. SharedArrayBuffer对象</strong></h3><blockquote><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，</p></blockquote><pre><code>/** *  * @param &#123;*&#125; length 所创建的数组缓冲区的大小，以字节(byte)为单位。 * @returns &#123;SharedArrayBuffer&#125; 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。 */new SharedArrayBuffer(10)</code></pre><h3 id="8-Atomics对象"><a href="#8-Atomics对象" class="headerlink" title="8. Atomics对象"></a><strong>8. Atomics对象</strong></h3><blockquote><p>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。</p></blockquote><hr><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="ES9（2018）"><a href="#ES9（2018）" class="headerlink" title="ES9（2018）"></a><strong>ES9（2018）</strong></h2><h3 id="1-异步迭代"><a href="#1-异步迭代" class="headerlink" title="1. 异步迭代"></a><strong>1. 异步迭代</strong></h3><p>await可以和for…of循环一起使用，以串行的方式运行异步操作</p><pre><code>async function process(array) &#123;  for await (let i of array) &#123;    // doSomething(i);  &#125;&#125;</code></pre><h3 id="2-Promise-finally"><a href="#2-Promise-finally" class="headerlink" title="2. Promise.finally()"></a><strong>2. Promise.finally()</strong></h3><pre><code>Promise.resolve().then().catch(e =&gt; e).finally();</code></pre><h3 id="3-Rest-Spread-属性"><a href="#3-Rest-Spread-属性" class="headerlink" title="3. Rest/Spread 属性"></a><strong>3. Rest/Spread 属性</strong></h3><pre><code>const values = [1, 2, 3, 5, 6];console.log( Math.max(...values) ); // 6</code></pre><h3 id="4-正则表达式命名捕获组"><a href="#4-正则表达式命名捕获组" class="headerlink" title="4. 正则表达式命名捕获组"></a><strong>4. 正则表达式命名捕获组</strong></h3><pre><code>const reg = /(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/;const match = reg.exec(&#39;2021-02-23&#39;);</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0eXyeV3DhlcSziaeQOfC1BD4fbFGHUKE0xaOw1OA4wFBS2eSyYpongxtIbX96j9fEw5F9vVOFYTcFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="5-正则表达式反向断言"><a href="#5-正则表达式反向断言" class="headerlink" title="5. 正则表达式反向断言"></a><strong>5. 正则表达式反向断言</strong></h3><pre><code>(?=p)、(?&lt;=p)  p 前面(位置)、p 后面(位置)(?!p)、(?&lt;!p&gt;) 除了 p 前面(位置)、除了 p 后面(位置)</code></pre><p>(?&lt;=w)</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0eXyeV3DhlcSziaeQOfC1BD4aZx6EK0wGkEJPaUAEBqbOSEEEBoIPVh7qQZDEI2VBdvV5uuralgoRQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>(?&lt;!w)</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0eXyeV3DhlcSziaeQOfC1BD4FxVOk82vM23akL4SFN018MWK8WajfL8PuyjVYh3UWAUoZgVMfIx07A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="6-正则表达式dotAll模式"><a href="#6-正则表达式dotAll模式" class="headerlink" title="6. 正则表达式dotAll模式"></a><strong>6. 正则表达式dotAll模式</strong></h3><blockquote><p>正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许行终止符的出现</p></blockquote><pre><code>/hello.world/.test(&#39;hello\nworld&#39;); // false</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0eXyeV3DhlcSziaeQOfC1BD4AfQsEJ47aG753VYERIeNDH0n4ZH66RWiaOtYibXzPfGsl0ibHXbt023mg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="ES10（2019）"><a href="#ES10（2019）" class="headerlink" title="ES10（2019）"></a><strong>ES10（2019）</strong></h2><h3 id="1-Array-flat-和Array-flatMap"><a href="#1-Array-flat-和Array-flatMap" class="headerlink" title="1. Array.flat()和Array.flatMap()"></a><strong>1. Array.flat()和Array.flatMap()</strong></h3><p>flat()</p><pre><code>[1, 2, [3, 4]].flat(Infinity); // [1, 2, 3, 4]</code></pre><p>flatMap()</p><pre><code>[1, 2, 3, 4].flatMap(a =&gt; [a**2]); // [1, 4, 9, 16]</code></pre><h3 id="2-String-trimStart-和String-trimEnd"><a href="#2-String-trimStart-和String-trimEnd" class="headerlink" title="2. String.trimStart()和String.trimEnd()"></a><strong>2. String.trimStart()和String.trimEnd()</strong></h3><p>去除字符串首尾空白字符</p><h3 id="3-String-prototype-matchAll"><a href="#3-String-prototype-matchAll" class="headerlink" title="3. String.prototype.matchAll"></a><strong>3. String.prototype.matchAll</strong></h3><blockquote><p>matchAll（）为所有匹配的匹配对象返回一个迭代器</p></blockquote><pre><code>const raw_arr = &#39;test1  test2  test3&#39;.matchAll((/t(e)(st(\d?))/g));const arr = [...raw_arr];</code></pre><h3 id="4-Symbol-prototype-description"><a href="#4-Symbol-prototype-description" class="headerlink" title="4. Symbol.prototype.description"></a><strong>4. Symbol.prototype.description</strong></h3><blockquote><p>只读属性，回 Symbol 对象的可选描述的字符串。</p></blockquote><pre><code>Symbol(&#39;description&#39;).description; // &#39;description&#39;</code></pre><h3 id="5-Object-fromEntries"><a href="#5-Object-fromEntries" class="headerlink" title="5. Object.fromEntries()"></a><strong>5. Object.fromEntries()</strong></h3><blockquote><p>返回一个给定对象自身可枚举属性的键值对数组</p></blockquote><pre><code>// 通过 Object.fromEntries， 可以将 Map 转化为 Object:const map = new Map([ [&#39;foo&#39;, &#39;bar&#39;], [&#39;baz&#39;, 42] ]);console.log(Object.fromEntries(map)); // &#123; foo: &quot;bar&quot;, baz: 42 &#125;</code></pre><h3 id="6-可选-Catch"><a href="#6-可选-Catch" class="headerlink" title="6. 可选 Catch"></a><strong>6. 可选 Catch</strong></h3><hr><h2 id="ES11（2020）"><a href="#ES11（2020）" class="headerlink" title="ES11（2020）"></a><strong>ES11（2020）</strong></h2><h3 id="1-Nullish-coalescing-Operator-空值处理"><a href="#1-Nullish-coalescing-Operator-空值处理" class="headerlink" title="1. Nullish coalescing Operator(空值处理)"></a><strong>1. Nullish coalescing Operator(空值处理)</strong></h3><p>表达式在 ?? 的左侧 运算符求值为undefined或null，返回其右侧。</p><pre><code>let user = &#123;    u1: 0,    u2: false,    u3: null,    u4: undefined    u5: &#39;&#39;,&#125;let u2 = user.u2 ?? &#39;用户2&#39;  // falselet u3 = user.u3 ?? &#39;用户3&#39;  // 用户3let u4 = user.u4 ?? &#39;用户4&#39;  // 用户4let u5 = user.u5 ?? &#39;用户5&#39;  // &#39;&#39;</code></pre><h3 id="2-Optional-chaining（可选链）"><a href="#2-Optional-chaining（可选链）" class="headerlink" title="2. Optional chaining（可选链）"></a><strong>2. Optional chaining（可选链）</strong></h3><p>?.用户检测不确定的中间节点</p><pre><code>let user = &#123;&#125;let u1 = user.childer.name // TypeError: Cannot read property &#39;name&#39; of undefinedlet u1 = user.childer?.name // undefined</code></pre><h3 id="3-Promise-allSettled"><a href="#3-Promise-allSettled" class="headerlink" title="3. Promise.allSettled"></a><strong>3. Promise.allSettled</strong></h3><blockquote><p>返回一个在所有给定的promise已被决议或被拒绝后决议的promise，并带有一个对象数组，每个对象表示对应的promise结果</p></blockquote><pre><code>const promise1 = Promise.resolve(3);const promise2 = 42;const promise3 = new Promise((resolve, reject) =&gt; reject(&#39;我是失败的Promise_1&#39;));const promise4 = new Promise((resolve, reject) =&gt; reject(&#39;我是失败的Promise_2&#39;));const promiseList = [promise1,promise2,promise3, promise4]Promise.allSettled(promiseList).then(values=&gt;&#123;  console.log(values)&#125;);</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0eXyeV3DhlcSziaeQOfC1BD4Ok2DTTaWpCraTLMeAtRicdy0F6cjZHG5cmEJcEFNMPzezejSJibLmKog/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="4-import"><a href="#4-import" class="headerlink" title="4. import()"></a><strong>4. import()</strong></h3><p>按需导入</p><h3 id="5-新基本数据类型BigInt"><a href="#5-新基本数据类型BigInt" class="headerlink" title="5. 新基本数据类型BigInt"></a><strong>5. 新基本数据类型BigInt</strong></h3><blockquote><p>任意精度的整数</p></blockquote><h3 id="6-globalThis"><a href="#6-globalThis" class="headerlink" title="6. globalThis"></a><strong>6. globalThis</strong></h3><ul><li>浏览器：window</li><li>worker：self</li><li>node：global</li></ul><h2 id="ES12（2021）"><a href="#ES12（2021）" class="headerlink" title="ES12（2021）"></a><strong>ES12（2021）</strong></h2><h3 id="1-replaceAll"><a href="#1-replaceAll" class="headerlink" title="1. replaceAll"></a><strong>1. replaceAll</strong></h3><blockquote><p>返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉</p></blockquote><pre><code>const str = &#39;hello world&#39;;str.replaceAll(&#39;l&#39;, &#39;&#39;); // &quot;heo word&quot;</code></pre><h3 id="2-Promise-any"><a href="#2-Promise-any" class="headerlink" title="2. Promise.any"></a><strong>2. Promise.any</strong></h3><blockquote><p>Promise.any() 接收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise</p></blockquote><pre><code>const promise1 = new Promise((resolve, reject) =&gt; reject(&#39;我是失败的Promise_1&#39;));const promise2 = new Promise((resolve, reject) =&gt; reject(&#39;我是失败的Promise_2&#39;));const promiseList = [promise1, promise2];Promise.any(promiseList).then(values=&gt;&#123;  console.log(values);&#125;).catch(e=&gt;&#123;  console.log(e);&#125;);</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0eXyeV3DhlcSziaeQOfC1BD4lt4KQZdfNJsf0xauWce8C915PDbDFn0Nnhulsq89ib0JTvmO6S4RHBg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="3-WeakRefs"><a href="#3-WeakRefs" class="headerlink" title="3. WeakRefs"></a><strong>3. WeakRefs</strong></h3><blockquote><p>使用WeakRefs的Class类创建对对象的弱引用(对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为)</p></blockquote><h3 id="4-逻辑运算符和赋值表达式"><a href="#4-逻辑运算符和赋值表达式" class="headerlink" title="4. 逻辑运算符和赋值表达式"></a><strong>4. 逻辑运算符和赋值表达式</strong></h3><blockquote><p>逻辑运算符和赋值表达式，新特性结合了逻辑运算符（&amp;&amp;，||，??）和赋值表达式而JavaScript已存在的 复合赋值运算符有：</p></blockquote><pre><code>a ||= b//等价于a = a || (a = b)a &amp;&amp;= b//等价于a = a &amp;&amp; (a = b)a ??= b//等价于a = a ?? (a = b)</code></pre><h3 id="5-数字分隔符"><a href="#5-数字分隔符" class="headerlink" title="5. 数字分隔符"></a><strong>5. 数字分隔符</strong></h3><blockquote><p>数字分隔符，可以在数字之间创建可视化分隔符，通过_下划线来分割数字，使数字更具可读性</p></blockquote><pre><code>const money = 1_000_000_000;//等价于const money = 1000000000;1_000_000_000 === 1000000000; // true</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0eXyeV3DhlcSziaeQOfC1BD4z9GDBholQBmLqRUNNnGbqick6aHVslKQeib6HsXuTluibhTibWjFFT7BIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>作者：小豪看世界</p><p>来源：SegmentFault 思否社区</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> ES7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>52 条 SQL 语句性能优化策略</title>
      <link href="2021/03/01/niuke/sql/sql-you-hua-jian-yi/"/>
      <url>2021/03/01/niuke/sql/sql-you-hua-jian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="52-条-SQL-语句性能优化策略"><a href="#52-条-SQL-语句性能优化策略" class="headerlink" title="52 条 SQL 语句性能优化策略"></a>52 条 SQL 语句性能优化策略</h1><p><strong><em>\</em>-   52 条 SQL 语句性能优化策略   -**</strong></p><p>1、对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。</p><p>2、应尽量避免在where子句中对字段进行null值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默认值。</p><p>3、应尽量避免在where子句中使用!=或&lt;&gt;操作符，MySQL只有对以下操作符才使用索引：&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE。</p><p>4、应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用UNION合并查询：select id from t where num=10 union all select id from t where num=20。</p><p>5、in和not in也要慎用，否则会导致全表扫描，对于连续的数值，能用between就不要用in了：Select id from t where num between 1 and 3。</p><p>6、下面的查询也将导致全表扫描：select id from t where name like‘%abc%’或者select id from t where name like‘%abc’若要提高效率，可以考虑全文检索。而select id from t where name like‘abc%’才用到索引。</p><p>7、如果在where子句中使用参数，也会导致全表扫描。</p><p>8、应尽量避免在where子句中对字段进行表达式操作，应尽量避免在where子句中对字段进行函数操作。</p><p>9、很多时候用exists代替in是一个好的选择：select num from a where num in(select num from b)。用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)。</p><p>10、索引固然可以提高相应的select的效率，但同时也降低了insert及update的效率，因为insert或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><p>11、应尽可能的避免更新clustered索引数据列， 因为clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新clustered索引数据列，那么需要考虑是否应将该索引建为clustered索引。</p><p>12、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</p><p>13、尽可能的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>14、最好不要使用”“返回所有：select from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p><p>15、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p><p>16、使用表的别名(Alias)：当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个Column上。这样一来，就可以减少解析的时间并减少那些由Column歧义引起的语法错误。</p><p>17、使用“临时表”暂存中间结果 ：</p><p>简化SQL语句的重要方法就是采用临时表暂存中间结果，但是临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。</p><p>18、一些SQL查询语句应加上nolock，读、写是会相互阻塞的，为了提高并发性能，对于一些查询，可以加上nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。</p><p>使用nolock有3条原则：</p><ul><li>查询的结果用于“插、删、改”的不能加nolock；</li><li>查询的表属于频繁发生页分裂的，慎用nolock ；</li><li>使用临时表一样可以保存“数据前影”，起到类似Oracle的undo表空间的功能，能采用临时表提高并发性能的，不要用nolock。</li></ul><p>19、常见的简化规则如下：</p><p>不要有超过5个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。少用子查询，视图嵌套不要过深，一般视图嵌套不要超过2个为宜。</p><p>20、将需要查询的结果预先计算好放在表中，查询的时候再Select。这在SQL7.0以前是最重要的手段，例如医院的住院费计算。</p><p>21、用OR的字句可以分解成多个查询，并且通过UNION 连接多个查询。他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用UNION all执行的效率更高。多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。</p><p>22、在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。</p><p>23、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。</p><p>存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL，可以使用临时存储过程，该过程（临时表）被放在Tempdb中。</p><p>24、当服务器的内存够多时，配制线程数量 = 最大连接数+5，这样能发挥最大的效率；否则使用 配制线程数量&lt;最大连接数启用SQL SERVER的线程池来解决，如果还是数量 = 最大连接数+5，严重的损害服务器的性能。</p><p>25、查询的关联同写的顺序 ：</p><p>select a.personMemberID, * from chineseresume a,personmember b where personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ （A = B ,B = ‘号码’） </p><p>select a.personMemberID, * from chineseresume a,personmember b where a.personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ and b.referenceid = ‘JCNPRH39681’ （A = B ,B = ‘号码’， A = ‘号码’） </p><p>select a.personMemberID, * from chineseresume a,personmember b where b.referenceid = ‘JCNPRH39681’ and a.personMemberID = ‘JCNPRH39681’ （B = ‘号码’， A = ‘号码’）</p><p>26、尽量使用exists代替select count(1)来判断是否存在记录，count函数只有在统计表中所有行数时使用，而且count(1)比count(*)更有效率。</p><p>27、尽量使用“&gt;=”，不要使用“&gt;”。</p><p>28、索引的使用规范：</p><ul><li>索引的创建要与应用结合考虑，建议大的OLTP表不要超过6个索引；</li><li>尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index_name来强制指定索引；</li><li>避免对大表查询时进行table scan，必要时考虑新建索引；</li><li>在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用；</li><li>要注意索引的维护，周期性重建索引，重新编译存储过程。　　</li></ul><p>29、下列SQL条件语句中的列都建有恰当的索引，但执行速度却非常慢： </p><p>SELECT * FROM record WHERE substrINg(card_no,1,4)=’5378’ (13秒) </p><p>SELECT * FROM record WHERE amount/30&lt; 1000 （11秒） </p><p>SELECT * FROM record WHERE convert(char(10),date,112)=’19991201’ （10秒） </p><p><strong>分析：</strong> </p><p>WHERE子句中对列的任何操作结果都是在SQL运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引。</p><p>如果这些结果在查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免表搜索，因此将SQL重写成下面这样： </p><p>SELECT * FROM record WHERE card_no like ‘5378%’ （&lt; 1秒） </p><p>SELECT * FROM record WHERE amount&lt; 1000*30 （&lt; 1秒） </p><p>SELECT * FROM record WHERE date= ‘1999/12/01’ （&lt; 1秒）</p><p>30、当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新。</p><p>31、在所有的存储过程中，能够用SQL语句的，我绝不会用循环去实现。</p><p>例如：列出上个月的每一天，我会用connect by去递归查询一下，绝不会去用循环从上个月第一天到最后一天。</p><p>32、选择最有效率的表名顺序（只在基于规则的优化器中有效）： </p><p>Oracle的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表（基础表 driving table）将被最先处理，在FROM子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。</p><p>如果有3个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表。</p><p>33、提高GROUP BY语句的效率，可以通过将不需要的记录在GROUP BY之前过滤掉。下面两个查询返回相同结果，但第二个明显就快了许多。 </p><p>低效：</p><p>SELECT JOB , AVG(SAL) </p><p>FROM EMP </p><p>GROUP BY JOB </p><p>HAVING JOB =’PRESIDENT’ </p><p>OR JOB =’MANAGER’ </p><p>高效: </p><p>SELECT JOB , AVG(SAL) </p><p>FROM EMP </p><p>WHERE JOB =’PRESIDENT’ </p><p>OR JOB =’MANAGER’ </p><p>GROUP BY JOB</p><p>34、SQL语句用大写，因为Oracle总是先解析SQL语句，把小写的字母转换成大写的再执行。</p><p>35、别名的使用，别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询速度要比建连接表快1.5倍。</p><p>36、避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序；事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量；永远不要在事务中等待用户输入。</p><p>37、避免使用临时表，除非却有需要，否则应尽量避免使用临时表，相反，可以使用表变量代替；大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在TempDb数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。</p><p>38、最好不要使用触发器：</p><ul><li>触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程；</li><li>如果能够使用约束实现的，尽量不要使用触发器；</li><li>不要为不同的触发事件(Insert，Update和Delete)使用相同的触发器；</li><li>不要在触发器中使用事务型代码。</li></ul><p>39、索引创建规则： </p><ul><li>表的主键、外键必须有索引； </li><li>数据量超过300的表应该有索引； </li><li>经常与其他表进行连接的表，在连接字段上应该建立索引； </li><li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引； </li><li>索引应该建在选择性高的字段上； </li><li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； </li><li>复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替； </li><li>正确选择复合索引中的主列字段，一般是选择性较好的字段； </li><li>复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引； </li><li>如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引； </li><li>如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段； </li><li>如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引； </li><li>频繁进行数据操作的表，不要建立太多的索引； </li><li>删除无用的索引，避免对执行计划造成负面影响； </li><li>表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。 </li><li>尽量不要对数据库中某个含有大量重复的值的字段建立索引。</li></ul><p>40、MySQL查询优化总结：</p><p>使用慢查询日志去发现慢查询，使用执行计划去判断查询是否正常运行，总是去测试你的查询看看是否他们运行在最佳状态下。</p><p>久而久之性能总会变化，避免在整个表上使用count(*)，它可能锁住整张表，使查询保持一致以便后续相似的查询可以使用查询缓存，在适当的情形下使用GROUP BY而不是DISTINCT，在WHERE、GROUP BY和ORDER BY子句中使用有索引的列，保持索引简单，不在多个索引中包含同一个列。</p><p>有时候MySQL会使用错误的索引，对于这种情况使用USE INDEX，检查使用SQL_MODE=STRICT的问题，对于记录数小于5的索引字段，在UNION的时候使用LIMIT不是是用OR。 </p><p>为了避免在更新前SELECT，使用INSERT ON DUPLICATE KEY或者INSERT IGNORE，不要用UPDATE去实现，不要使用MAX，使用索引字段和ORDER BY子句，LIMIT M，N实际上可以减缓查询在某些情况下，有节制地使用，在WHERE子句中使用UNION代替子查询，在重新启动的MySQL，记得来温暖你的数据库，以确保数据在内存和查询速度快，考虑持久连接，而不是多个连接，以减少开销。</p><p>基准查询，包括使用服务器上的负载，有时一个简单的查询可以影响其他查询，当负载增加在服务器上，使用SHOW PROCESSLIST查看慢的和有问题的查询，在开发环境中产生的镜像数据中测试的所有可疑的查询。</p><p>41、MySQL备份过程：</p><ul><li>从二级复制服务器上进行备份；</li><li>在进行备份期间停止复制，以避免在数据依赖和外键约束上出现不一致；</li><li>彻底停止MySQL，从数据库文件进行备份；</li><li>如果使用MySQL dump进行备份，请同时备份二进制日志文件 – 确保复制没有中断；</li><li>不要信任LVM快照，这很可能产生数据不一致，将来会给你带来麻烦；</li><li>为了更容易进行单表恢复，以表为单位导出数据——如果数据是与其他表隔离的。 </li><li>当使用mysqldump时请使用–opt；</li><li>在备份之前检查和优化表；</li><li>为了更快的进行导入，在导入时临时禁用外键约束。；</li><li>为了更快的进行导入，在导入时临时禁用唯一性检测；</li><li>在每一次备份后计算数据库，表以及索引的尺寸，以便更够监控数据尺寸的增长；</li><li>通过自动调度脚本监控复制实例的错误和延迟；</li><li>定期执行备份。</li></ul><p>42、查询缓冲并不自动处理空格，因此，在写SQL语句时，应尽量减少空格的使用，尤其是在SQL首和尾的空格（因为查询缓冲并不自动截取首尾空格）。</p><p>43、member用mid做标准进行分表方便查询么？一般的业务需求中基本上都是以username为查询依据，正常应当是username做hash取模来分表。</p><p>而分表的话MySQL的partition功能就是干这个的，对代码是透明的；在代码层面去实现貌似是不合理的。</p><p>44、我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。</p><p>45、在所有的存储过程和触发器的开始处设置SET NOCOUNT ON，在结束时设置SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC消息。</p><p>46、MySQL查询可以启用高速查询缓存。这是提高数据库性能的有效MySQL优化方法之一。当同一个查询被执行多次时，从缓存中提取数据和直接从数据库中返回数据快很多。</p><p>47、EXPLAIN SELECT查询用来跟踪查看效果：</p><p>使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的。</p><p>48、当只要一行数据时使用LIMIT 1 ：</p><p>当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。</p><p>在这种情况下，加上LIMIT 1可以增加性能。这样一来，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。</p><p>49、选择表合适存储引擎： </p><ul><li><p>myisam：应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。 </p></li><li><p>InnoDB：事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（InnoDB有效地降低删除和更新导致的锁定）。</p><p>对于支持事务的InnoDB类型的表来说，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行SQL前调用begin，多条SQL形成一个事物（即使autocommit打开也可以），将大大提高性能。</p></li></ul><p>50、优化表的数据类型，选择合适的数据类型： </p><p>原则：更小通常更好，简单就好，所有字段都得有默认值，尽量避免null。 </p><p>例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型。(mediumint就比int更合适) </p><p>比如时间字段：datetime和timestamp，datetime占用8个字节，而timestamp占用4个字节，只用了一半，而timestamp表示的范围是1970—2037适合做更新时间 </p><p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。 </p><p>因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p><p>例如：在定义邮政编码这个字段时，如果将其设置为CHAR(255)，显然给数据库增加了不必要的空间。甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。</p><p>同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段，应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。 </p><p>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p><p>51、字符串数据类型：char，varchar，text选择区别。</p><p>52、任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。</p><p>转载于<a href="https://mp.weixin.qq.com/s/thMEKUvGUzznzbr8K0g5Rg">https://mp.weixin.qq.com/s/thMEKUvGUzznzbr8K0g5Rg</a></p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript入门</title>
      <link href="2021/03/01/niuke/qianduan/ts-kuai-su-ru-men/"/>
      <url>2021/03/01/niuke/qianduan/ts-kuai-su-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript入门"><a href="#TypeScript入门" class="headerlink" title="TypeScript入门"></a>TypeScript入门</h1><h2 id="1：TypeScript简介"><a href="#1：TypeScript简介" class="headerlink" title="1：TypeScript简介"></a>1：TypeScript简介</h2><p>中文官网：<a href="http://www.tslang.cn/">http://www.tslang.cn</a></p><p>英文官网<a href="http://www.typescriptlang.org/">http://www.typescriptlang.org</a></p><p>学习前景：</p><ol><li><p>Egret游戏开发工程师20-40K  h5游戏开发</p></li><li><p>angular  vue</p></li><li><p>typescript-&gt;  ES6 ES7  ES8</p></li><li><p>后台协作</p></li><li><p>大幅度提升工作效率，减少错误</p></li></ol><h2 id="2：开始使用ts"><a href="#2：开始使用ts" class="headerlink" title="2：开始使用ts"></a>2：开始使用ts</h2><p>安装node</p><p>安装TypeScript编译环境 npm install -g typescript</p><p>tsc helloworld.ts</p><h2 id="3-class导入-import-“-second”"><a href="#3-class导入-import-“-second”" class="headerlink" title="3.class导入 import “./second”"></a>3.class导入 import “./second”</h2><h2 id="4-ts项目开发编译配置"><a href="#4-ts项目开发编译配置" class="headerlink" title="4.ts项目开发编译配置"></a>4.ts项目开发编译配置</h2><pre><code>tsc --init</code></pre><p>tsconfig.json</p><pre><code>&quot;files&quot;:[    &quot;helloworld.ts&quot;,    &quot;main.ts&quot;],//编译的文件&quot;outDir&quot;:&quot;./dist&quot;, //输出目录</code></pre><h2 id="5-使用ts操作html"><a href="#5-使用ts操作html" class="headerlink" title="5.使用ts操作html"></a>5.使用ts操作html</h2><pre><code>document.body.innerHtml();</code></pre><h2 id="6-常见数据类型：-类型检查严格"><a href="#6-常见数据类型：-类型检查严格" class="headerlink" title="6.常见数据类型： 类型检查严格"></a>6.常见数据类型： 类型检查严格</h2><pre><code>//先定义let username:string =&quot;dabing&quot;;let age:number=12;//默认 any类型</code></pre><h2 id="7-枚举类型"><a href="#7-枚举类型" class="headerlink" title="7.枚举类型"></a>7.枚举类型</h2><pre><code>let arrNum:number[]=[12,3,,6,9];//混合let MixArr:(number|string)[] =[&#39;123&#39;,&#39;hah&#39;,15]//枚举enum Direction &#123;    up =38;    down, //39    left, //40    right //41&#125;//自动赋值function paly(dir:Direction)&#123;    if(dir==38)&#123;        console.log(&quot;向上&quot;)    &#125;else&#123;        connsole.log(dir);    &#125;&#125;play(666);</code></pre><h2 id="8-函数参数与强类型"><a href="#8-函数参数与强类型" class="headerlink" title="8.函数参数与强类型"></a>8.函数参数与强类型</h2><pre><code>function showIfno(age:number):number&#123;    return age;&#125;</code></pre><h2 id="9-class创建、实例化、属性、方法"><a href="#9-class创建、实例化、属性、方法" class="headerlink" title="9.class创建、实例化、属性、方法"></a>9.class创建、实例化、属性、方法</h2><pre><code>class Person&#123;    name:string;    age:number;    food:string =&#39;剁椒鱼头&#39;;    private money:nummber=2000;    constructor(name:string,age:number)&#123;        this.name =name;        this.age=age;    &#125;    favoriteFood()&#123;        return this.food;    &#125;    makeMoney(salary:number):number&#123;        return this.money +=salary;    &#125;&#125;//实例化let dabingge =new Person(&#39;dabing&#39;,28);console.log(dabingge.makeMoney(99));</code></pre><h2 id="10-类继承"><a href="#10-类继承" class="headerlink" title="10.类继承"></a>10.类继承</h2><pre><code>class binSons extends Person&#123;    isRich:boolean =true;    constructor(name:string,age:number)&#123;        suber(name,age);    &#125;&#125;let bigSon = new bigSons(&#39;dabing&#39;,20)console.log(bigSon.favariteFood());</code></pre><h2 id="11-抽象类"><a href="#11-抽象类" class="headerlink" title="11.抽象类"></a>11.抽象类</h2><pre><code>abstract class Jigoubiaozhun&#123;    abstract jigouName:string;    age:number =50;    abstract showMoney(money:number):number;&#125;class shamoChild extends Jigoubiaozhun&#123;    public jigouName =&quot;沙漠挖金基金协会&quot;；    private money :number=50000;    shouwMoney():number&#123;        return this.money;    &#125;    constructor(name:string,age:number)&#123;        super(name,age);    &#125;&#125;</code></pre><h2 id="12-接口-约束"><a href="#12-接口-约束" class="headerlink" title="12.接口  约束"></a>12.接口  约束</h2><pre><code>interface girl&#123;    dongshi:boolean;    job:string;    tenNi():boolean;&#125;class girlFriend implements girl&#123;    dongshi =true;    job=&quot;good&quot;;    tenNi():boolean&#123;        return true;    &#125;&#125;let CuiHua = new girlFriend();console.log(CuiHua.job);</code></pre><h2 id="13-泛型-gt-安全"><a href="#13-泛型-gt-安全" class="headerlink" title="13.泛型-&gt; 安全"></a>13.泛型-&gt; 安全</h2><pre><code>function showData(person any)&#123;    return person;&#125;//不安全function shoWData&lt;T&gt;(person T)&#123;    return person;&#125;shoWData([21,32,4]).length;const arr:Array&lt;number&gt; = [12,5,6];function showArr&lt;T&gt;(data:T[])&#123;    for(let i =0;i&lt;data.length;i++)&#123;        console.log(data);    &#125;&#125;</code></pre><h2 id="14-装饰器-decorator"><a href="#14-装饰器-decorator" class="headerlink" title="14.装饰器  decorator"></a>14.装饰器  decorator</h2><pre><code>tsconfig.json&#123;    &quot;compilerOpeions&quot;:&#123;        &quot;experimentalDecorators&quot;:true,    &#125;&#125;</code></pre><pre><code>function hasKey(constructor:Function)&#123;    console.log(&#39;kkkkk&#39;);&#125;@hasKeyclass Person&#123;    name:string;    age:number;    constructor(name:string,age:number)&#123;        this.name=name;        this.age=age;        console.log(&#39;我是‘+name+&#39;今年&#39;+age+&#39;岁&#39;);    &#125;&#125;const baifumei = new Person(&#39;baifumei&#39;,18);console.log(baifumei);</code></pre><h2 id="15-模块化的定义与导入"><a href="#15-模块化的定义与导入" class="headerlink" title="15.模块化的定义与导入"></a>15.模块化的定义与导入</h2><p>为了代码的简洁</p><p>参考视频：<a href="https://www.bilibili.com/video/BV1Wt411V7yc?p=12&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1Wt411V7yc?p=12&amp;spm_id_from=pageDriver</a></p><p>根据参数学习视频总结</p>]]></content>
      
      
      <categories>
          
          <category> TypeScrip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScrip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js面向对象</title>
      <link href="2021/02/28/niuke/qianduan/js-oo/"/>
      <url>2021/02/28/niuke/qianduan/js-oo/</url>
      
        <content type="html"><![CDATA[<h1 id="js面向对象"><a href="#js面向对象" class="headerlink" title="js面向对象"></a>js面向对象</h1><h1 id="创建对象的三种方式"><a href="#创建对象的三种方式" class="headerlink" title="创建对象的三种方式"></a>创建对象的三种方式</h1><h2 id="1-单体模式"><a href="#1-单体模式" class="headerlink" title="1.单体模式"></a>1.单体模式</h2><pre><code>var Teacher =&#123;    name:&quot;大兵&quot;，    age:18,    showName:function()&#123;        return this.name;    &#125;&#125;Teacher.showName();</code></pre><h2 id="2-原型模式-ES5"><a href="#2-原型模式-ES5" class="headerlink" title="2.原型模式 ES5"></a>2.原型模式 ES5</h2><p>属性放在构造函数里，方法放在原型上</p><pre><code>function Teacher(name,age)&#123;    this.name =name;    this.age=age;&#125;Teacher.prototype.showName =function()&#123;    return this.name;&#125;var dabinge = new Teacher(&#39;dabing&#39;,18);dabinge.showName();</code></pre><h2 id="3-伪类模式（class）-ES6推荐"><a href="#3-伪类模式（class）-ES6推荐" class="headerlink" title="3.伪类模式（class） ES6推荐"></a>3.伪类模式（class） ES6推荐</h2><pre><code>class Teacher&#123;    constructor(name,age)&#123;        this.name = name;        this.age=age;    &#125;    showName()&#123;        return this.name;    &#125;&#125;var dabinge = new Teacher(&#39;dabing&#39;,18);dabinge.showName();</code></pre><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><pre><code>var Teacher =&#123;    name:&quot;大兵&quot;，    age:18,    job:&#39;10year&#39;    showName:function()&#123;        return this.name;    &#125;&#125;var student =Object.create(Teacher);student.name =&#39;wangteichui&#39;;student.job = &#39;2Month&#39;;conssole.log(student.showName());student.showJob = funtion(job)&#123;    return this.job;&#125;conssole.log(student.showJob());</code></pre><pre><code>class Person()&#123;    constructor(name,age)&#123;        this.name =name;        this.age=age;    &#125;    showName()&#123;        return this.name;    &#125;&#125;class Teacher extends Person&#123;    constructor(name,age,job)&#123;        super(name,age);        this.job= job;    &#125;    showInof()&#123;        return this.job +&#39;---&#39;+super.showName();    &#125;&#125;var t1 = new Teacher(&#39;dabing&#39;,18,&#39;搬砖&#39;);t1.showInfo();</code></pre><p>面试原理，工作必须会技术，数据交互 跨域</p><p>1.JSONP原理</p><pre><code>1.js是可以跨域2.服务器返回的数据，show([12,5,8])3.本地 方法的定义function show(data)&#123;    console.log(data);&#125;JSONP只能get方式</code></pre><p>2.CROS</p><pre><code>必须需要服务器端配合，否则没戏access-alow</code></pre><p>基本数据类型</p><p>数据类型转换</p><p>isNaN</p><p>严格模式</p><p>作用域</p><p>时间</p><p>对象</p><p>数据交互</p><p>————————前端就业方向——–</p><p>新闻  :数据交互,JSONP,AJAX,fetch,promise</p><p>00编程  -框架vue。。</p><p>游戏： canvas动画</p><p>数据可视化绘图（地图）：webgl</p>]]></content>
      
      
      <categories>
          
          <category> js面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网华为机试</title>
      <link href="2021/02/28/niuke/suanfa/huaweijs-00/"/>
      <url>2021/02/28/niuke/suanfa/huaweijs-00/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客网华为机试在线训练JavaScript-V8-版"><a href="#牛客网华为机试在线训练JavaScript-V8-版" class="headerlink" title="牛客网华为机试在线训练JavaScript(V8)版"></a>牛客网华为机试在线训练JavaScript(V8)版</h1><h2 id="注意！输入得到的都是字符串"><a href="#注意！输入得到的都是字符串" class="headerlink" title="注意！输入得到的都是字符串"></a>注意！输入得到的都是字符串</h2><blockquote><p>// 单行<br>var line = readline(); //获得的是一个字符串<br>//如果需要对其进行处理，比如 “1 2 3 4 5”，我们想以数组形式获取每个数字<br>var arr = line.split(“ “); // 数组内元素为字符串，eg: arr[0]=”1”</p><p>// 多行<br>// 如果每一行的操作相同<br>while(line = readline()){<br>    // 代码<br>}<br>/<em>如果每一行操作不同<br>eg: 第一行给数组长度<br>     第二行给用空格分开的字符串<br>那就每一次按照单行输入的方式来获取即可</em>/<br>var num = parseInt(readline()); // 获得数组长度<br>var arr = readline().split(“ “); // 获得数组</p></blockquote><h2 id="1-字符串-split（易）"><a href="#1-字符串-split（易）" class="headerlink" title="1.(字符串) split（易）"></a>1.(字符串) split（易）</h2><p><strong>计算字符串最后一个单词的长度，单词以空格隔开。(<a href="https://www.nowcoder.com/questionCenter?questionTypes=000100&mutiTagIds=579">字符串</a>)</strong><br>输入描述:<br>输入一行，代表要计算的字符串，非空，长度小于5000。<br>输出描述:<br>输出一个整数，表示输入字符串最后一个单词的长度。<br>示例1<br>输入:hello nowcoder<br>输出:8<br>解答：</p><pre><code>while (line = readline())&#123;    var stringlist  = line.split(&#39; &#39;);    var lastlen =stringlist[stringlist.length-1].length;    print(lastlen);&#125;</code></pre><h2 id="2-字符串-toLowerCase（易）"><a href="#2-字符串-toLowerCase（易）" class="headerlink" title="2.(字符串)toLowerCase（易）"></a>2.(字符串)toLowerCase（易）</h2><p><strong>写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字母，然后输出输入字符串中该字母的出现次数。不区分大小写。 (字符串，哈希）</strong><br>输入描述:第一行输入一个由字母和数字以及空格组成的字符串，第二行输入一个字母。<br>输出描述:输出输入字符串中含有该字符的个数。<br>示例1<br>输入<br>ABCabc<br>A<br>输出2<br>解答</p><pre><code>var aStr = readline().toLowerCase();var bStr = readline().toLowerCase();var count = 0;for (var i = 0 ; i &lt; aStr.length; i++)&#123;    if(aStr[i] == bStr)&#123;    count = count + 1;    &#125;&#125;print(count);</code></pre><h2 id="3-数组-sort-set（中）"><a href="#3-数组-sort-set（中）" class="headerlink" title="3.(数组)sort set（中）"></a>3.(数组)sort set（中）</h2><p><strong>题目描述</strong><br>   明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 </p><p>  注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 当没有新的输入时，说明输入结束。<br><strong>输入描述:</strong></p><pre><code>注意：输入可能有多组数据。每组数据都包括多行，第一行先输入随机整数的个数N，接下来的N行再输入相应个数的整数。具体格式请看下面的&quot;示例&quot;。</code></pre><p><strong>输出描述:</strong></p><pre><code>返回多行，处理后的结果</code></pre><p>示例1<br><strong>输入</strong></p><pre><code>322111102040326740208930040015</code></pre><p><strong>输出</strong></p><pre><code>1210152032406789300400</code></pre><p>说明</p><pre><code>样例输入解释：样例有两组测试第一组是3个数字，分别是：2，2，1。第二组是11个数字，分别是：10，20，40，32，67，40，20，89，300，400，15。 </code></pre><p>解答：<br>每组分段返回</p><pre><code>var lines = 0;var scoreList = [];while(line = readline())&#123; if(lines ==0 )&#123;     lines = parseInt(line);     outPut(scoreList); &#125;else&#123;     lines--;     scoreList.push(parseInt(line)); &#125;&#125;function outPut(arr)&#123; arr = unique(arr).sort((a,b)=&gt;&#123;return a-b&#125;); for(var i=0;i&lt; arr.length;i++)&#123;     print(arr[i]); &#125;&#125;function unique(arr) &#123; return Array.from(new Set(arr))&#125;</code></pre><p>通过解答</p><pre><code>while(line=readline())&#123; var arr=[]; for(var i=0;i&lt;line;i++)&#123;     arr.push(readline());         &#125; var tSet=[...new Set(arr)]; var setSort=tSet.sort(function(a,b)&#123;     return a-b; &#125;)​for(var j=0;j&lt;setSort.length;j++)&#123;​    console.log(setSort[j]);​&#125;&#125;</code></pre><h2 id="4-字符串-字符串分隔（中）"><a href="#4-字符串-字符串分隔（中）" class="headerlink" title="4(字符串) 字符串分隔（中）"></a>4(字符串) <strong>字符串分隔</strong>（中）</h2><p><strong>题目描述</strong></p><p>  •连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；<br> •长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。  </p><p><strong>输入描述:</strong></p><pre><code>连续输入字符串(输入多次,每个字符串长度小于100)</code></pre><p>输出描述:</p><pre><code>输出到长度为8的新字符串数组</code></pre><p>输入</p><pre><code>abc123456789</code></pre><p>输出</p><pre><code>abc000001234567890000000</code></pre><p> 解答：</p><p>第一次</p><pre><code>while(line=readline())&#123; var strLength =line.length; var N = Math.floor(strLength/8); var mLast =strLength-N*8; var addnum =8-mLast; for(i=0;i&lt;N;i++)&#123;    print(line.substring(i*8,8*(i+1))) &#125; if(addnum&gt;0)&#123;     var sstr=&#39;0&#39;;     for(i=1;i&lt;addnum;i++)&#123;        sstr+=&#39;0&#39;;     &#125;     var firstr = line.substring((N)*8,strLength);     print( firstr + sstr) &#125;&#125;</code></pre><p>第二次</p><pre><code>var arr=[];while(line=readline())&#123; arr.push(line);&#125;for(var j=0;j&lt;arr.length;j++)&#123; var strLength = arr[j].length; var N = Math.floor(strLength/8); var mLast = strLength-N*8; var addnum =8-mLast; for(i=0;i&lt;N;i++)&#123;    print(arr[j].substring(i*8,8*(i+1))) &#125; if(mLast&gt;0)&#123;     var sstr=&#39;0&#39;;     for(i=1;i&lt;addnum;i++)&#123;        sstr+=&#39;0&#39;;     &#125;     var firstr = arr[j].substring((N)*8,strLength);     print( firstr + sstr) &#125;&#125;</code></pre><p>参考</p><pre><code>var q=&#39;00000000&#39;;var arr=[];for(var i=0;i&lt;2;i++)&#123;     arr.push(readline());&#125;for(var j=0;j&lt;arr.length;j++)&#123;     if(arr[j].length&lt;=8)&#123;    var t=arr[j]+q;    console.log(t.slice(0,8));  &#125;else&#123;     var len=arr[j].length;     for(var i=0;i&lt;len;i+=8)&#123;         var s=arr[j].slice(i,i+8);         if(s.length&lt;8)&#123;             var p=s+q;             console.log(p.slice(0,8));          &#125;else&#123;         console.log(s);          &#125;      &#125;  &#125;&#125;</code></pre><h2 id="5-字符串-进制转换（易）"><a href="#5-字符串-进制转换（易）" class="headerlink" title="5(字符串)进制转换（易）"></a>5(字符串)进制转换（易）</h2><p><strong>题目描述</strong></p><p>  写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。 </p><p><strong>输入描述:</strong></p><pre><code>输入一个十六进制的数值字符串。注意：一个用例会同时有多组输入数据，请参考帖子https://www.nowcoder.com/discuss/276处理多组输入的问题。</code></pre><p>输出描述:</p><pre><code>输出该数值的十进制字符串。不同组的测试用例用\n隔开。</code></pre><p>输入</p><pre><code>0xA0xAA</code></pre><p>输出</p><pre><code>10170</code></pre><pre><code>while(line=readline())&#123;    var output = parseInt(line, 16);    print(output);&#125;</code></pre><h2 id="6质数因子（难）"><a href="#6质数因子（难）" class="headerlink" title="6质数因子（难）"></a>6<strong>质数因子</strong>（难）</h2><p><strong>题目描述</strong></p><p>  功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2 2 3 3 5 ） </p><p>  最后一个数后面也要有空格  </p><p>输入描述:</p><pre><code>输入一个long型整数</code></pre><p>输出描述:</p><pre><code>按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。</code></pre><p>输入</p><pre><code>180</code></pre><p>输出</p><pre><code>2 2 3 3 5</code></pre><p>解析:</p><p> 查找质数的方法，从2开始除,不能被2除，则尝试3，不能被3除，也不能被4除，尝试5。。。 每除一次进行一次循环。从小到大找出所有质数</p><pre><code>while(line=readline())&#123;var num = parseInt(line);var arr=[];for(i=2;i&lt;=num;i++)&#123;   if(num%i==0)&#123;       num=num/i;       arr.push(i)       i=1;   &#125;&#125;print(arr.join(&quot; &quot;)+ &#39; &#39;);&#125;</code></pre><p><strong>优化解法：</strong></p><p>扩展补充：就分解的质数：</p><pre><code>function getPrimGens(a)&#123; var arr = getGens(a); var c = []; for(var i=0;i&lt;arr.length;i++)&#123;     var t = getGens(arr[i]);     if(t.length==0) c.push(arr[i]); &#125; return c;&#125;function getGens(a)&#123; var arr = []; var n = a/2 + 1; for(var i=2; i&lt;n; i++)&#123;     if(a%i == 0) arr.push(i) &#125; return arr;&#125;</code></pre><p>优化解:运行时间减少一半</p><pre><code>while(line=readline())&#123; var num = parseInt(line); var result = getPreGens(num); print(result.join(&quot; &quot;)+ &#39; &#39;);&#125;function getPreGens(a)&#123; var arr = []; var n = Math.floor(a/2)+ 1; var t = n; var i; while(1==1) &#123;     if(i==t)     &#123;         arr.push(a);         break;     &#125;     for(i=2; i&lt;t; i++)     &#123;         if(a%i == 0)          &#123;             arr.push(i);             a = a/i;             t = Math.floor(a/2 )+ 1;             break;         &#125;     &#125; &#125; return arr;&#125;</code></pre><h2 id="7-取近似值（易）"><a href="#7-取近似值（易）" class="headerlink" title="7 取近似值（易）"></a>7 取近似值（易）</h2><p>题目描述</p><p>  写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。 </p><p>输入描述:</p><pre><code>输入一个正浮点数值</code></pre><p>输出描述:</p><pre><code>输出该数值的近似整数值</code></pre><p>输入</p><pre><code>5.5</code></pre><p>输出</p><pre><code>6</code></pre><p>解析</p><pre><code>while(line=readline())&#123; var num = Math.round(line); print(num);&#125;</code></pre><p>扩展</p><ul><li>只保留整数部分（丢弃小数部分）parseInt(5.1234); </li><li>向下取整（&lt;= 该数值的最大整数，和parseInt()一样)Math.floor(5.1234); </li><li>向上取整（有小数，整数部分就+1）Math.ceil(5.1234);  </li><li>四舍五入（小数部分）Math.round(5.1234)；</li><li>取绝对值Math.abs(-1);   </li><li>返回两数中的较大者Math.max(1,2);   Math.min(1,2);  </li><li>随机数（0-1）Math.random();</li></ul><h2 id="8合并表记录-中"><a href="#8合并表记录-中" class="headerlink" title="8合并表记录(中)"></a>8合并表记录(中)</h2><p>题目描述</p><p>  数据表记录包含表索引和数值（int范围的正整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。 </p><p>输入描述:</p><pre><code>先输入键值对的个数然后输入成对的index和value值，以空格隔开</code></pre><p>输出描述:</p><pre><code>输出合并后的键值对（多行）</code></pre><p>输入</p><pre><code>40 10 21 23 4</code></pre><p>输出</p><pre><code>0 31 23 4</code></pre><p> 解析</p><pre><code>while(line=readline())&#123; let lines = Math.round(line); let arrs =[]; let m = new Map(); for(i=0;i&lt;lines;i++)&#123;    let arr = readline().split(&#39; &#39;);    if(m.has(arr[0]))&#123;        m.set(arr[0],m.get(arr[0])+parseInt(arr[1]));    &#125;else&#123;         m.set(arr[0],parseInt(arr[1]));    &#125; &#125; let keys = new Array(); for (var key of m.keys()) &#123;     keys.push(key) &#125; keys.sort(function(key1, key2) &#123;   return key1 - key2 &#125;); keys.forEach(key =&gt; &#123;     print(key +&#39; &#39; + m.get(key)); &#125;)&#125;</code></pre><p>9</p><p>题目描述</p><p>  输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 </p><p>  保证输入的整数最后一位不是0。</p><p>输入描述:</p><pre><code>输入一个int型整数</code></pre><p>输出描述:</p><pre><code>按照从右向左的阅读顺序，返回一个不含重复数字的新的整数</code></pre><p>输入</p><pre><code>9876673</code></pre><p>输出</p><pre><code>37689</code></pre><p>解析</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">while</span><span class="token punctuation">(</span>line<span class="token operator">=</span><span class="token function">readline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 空Set</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> i <span class="token operator">=</span> line<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>           s1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>line<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> result<span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 牛客网华为机试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="2021/02/27/niuke/suanfa/sort/"/>
      <url>2021/02/27/niuke/suanfa/sort/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-算法-排序"><a href="#第一章-算法-排序" class="headerlink" title="第一章 算法-排序"></a>第一章 算法-排序</h1><p><strong>归并排序的时间复杂度（B ）</strong></p><p>A:O(log(N))</p><p>B:O(N*log(N))</p><p>C:O(N)</p><p>D:O(N^2)</p><p>解答：</p><p><img src="https://uploadfiles.nowcoder.com/images/20170825/838172_1503666046674_C5D4F39E60A08C51D0B825E76F6E68BC" alt="img"></p><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><p>​    和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。   </p><h4 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote><p>​      归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and  Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。     </p></blockquote><h4 id="2-算法描述和实现"><a href="#2-算法描述和实现" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>​     具体算法描述如下：    </p><ul><li>​      &lt;1&gt;.把长度为n的输入序列分成两个长度为n/2的子序列；          </li><li>​      &lt;2&gt;.对这两个子序列分别采用归并排序；          </li><li>​      &lt;3&gt;.将两个排序好的子序列合并成一个最终的排序序列。         </li></ul><p>​     <strong>Javscript代码实现:</strong>   </p><blockquote><p>function mergeSort(arr) {  </p><p>​    //采用自上而下的递归方法     </p><p>​    ar len = arr.length;     </p><p>​    if(len &lt; 2) {         return arr;     }    </p><pre><code> var middle =  Math.floor(len / 2),            left = arr.slice(0, middle),        </code></pre><p>​     right = arr.slice(middle);    </p><p>​     return merge(mergeSort(left), mergeSort(right)); </p><p>}</p><p> function merge(left, right) {     </p><p>var result = [];    </p><p>  console.time(‘归并排序耗时’);     </p><p>while (left.length &amp;&amp; right.length) { </p><p>​        if (left[0] &lt;= right[0]) { result.push(left.shift()); } </p><p>​        else result.push(right.shift()); </p><p>while (left.length) (right.length) console.timeend(‘归并排序耗时’);</p><p> return result; </p><p>var arr=”[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];” console.log(mergesort(arr));</p></blockquote><p><strong>一组记录的值为(12,38,35,25,74,50,63,90),按2路归并排序方法对序列进行一趟归并后的结果为(  A  )</strong></p><p>A:12,38,25,35,50,74,63,90</p><p>B:12,38,35,25,74,50,63,90</p><p>C:12,25,35,38,50,74,63,90</p><p>D:12,35,38,25,63,50,74,90</p><p>解析：</p><p><img src="https://uploadfiles.nowcoder.com/images/20181213/530580337_1544714285748_772E62849C030C48EBF52D9B1548A428" alt="img"></p><p><img src="https://uploadfiles.nowcoder.com/images/20170701/6428287_1498913261898_265C7FA7B7393A64D86043C1E57DD398" alt="img"></p><p>将两个相邻位置的有序子列，归并为一个有序列的序列，是典型的 <strong>分治法</strong> 应用 </p><h3 id><a href="#" class="headerlink" title></a></h3><p><strong>数据表A中有10000个元案，如果仅要求求出其中最大的10个元素，则采用()排序算法最节省时间。</strong>   </p><p>A:简单选择排序</p><p>B:希尔排序</p><p>C:堆排序</p><p>D:快速排序</p><p>解析：堆排序，利用到了树的结构，树的顶端就是最大值，很快就能找到，最值</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>下面的哪种排序算法在算复杂度平均不是O(nlogn)的?（B）</strong></p><p>A:快速排序</p><p>B:桶排序</p><p>C:合并排序</p><p>D:二叉树排序树排序</p><p>E:堆排序</p><p>解答：  </p><p><img src="http://uploadfiles.nowcoder.com/images/20160507/426198_1462607057516_67578A2B2E254243415482C36347C471" alt="img"></p><p>  桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。  当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序的时间复杂度是线性的，即O(n)的。比如：对n个数排序，这n个数的值在一定范围内（比如在1到100之间），那么直接构建一个大小为100的数组arr，在遍历包含n个数的数组num时，令arr[num[i]]++即可，最后从头到尾遍历arr，若arr[i]=m，则输出m个i即可。</p><p>  <strong>对  n  个记录的文件进行快速排序，所需要的辅助存储空间大致为(C)</strong></p><p>A:O（1）</p><p>B:O（n）</p><p>C:O（1og2n）</p><p>D:O（n2）</p><p>解析：</p><p>  辅助存储空间 = 时间复杂度 </p><p>  额外存储空间 = 空间复杂度</p><p>快速排序对待排序序列得划分大约是log2n次，因为快速排序是通过递归算法来实现的，递归深度大约是log2n，所以所需得辅助空间为log2n</p><p>如果选取的主元使得枢纽值将T(n)划分成T(n - 1)和一个T(0)，并且接下来的递归都是这样划分，那么就要递归n -  1次，需要n-1个栈空间单元(?)，考虑选取枢纽值用去的O(n)代价，总复杂度：T(n) = T(n - 1) +  O(n),用递归树得到T(n) = O(n ^ 2), ；如果主元使得T(n)恰好划分成T(n) = 2T(n / 2) +  O(n)，递归树共lgn层，T(n) = O(nlgn)，需要的栈空间：O(lgn)。</p><p>  对图B-2进行拓扑排序，可以得到不同的拓扑序列的个数是（B）。</p><p><img src="https://uploadfiles.nowcoder.com/images/20180512/7574500_1526106876774_1739550CD29F99D6FC52E3E6A49E8DFF" alt="img"> </p><p>A:4</p><p>B:3</p><p>C:2</p><p>D:1</p><p>解析</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>  拓扑排序的过程如下图所示。 </p><p>  <img src="https://uploadfiles.nowcoder.com/images/20180512/7574500_1526106976712_CA170FCB84F41A75AE0AF731CA65B4C7" alt="img"></p><p>   可以得到3个不同的拓扑序列，分别为：abced、abecd、aebcd。  </p><p><img src="https://uploadfiles.nowcoder.com/images/20190826/591802503_1566796873401_90C481E22DA191B81E3913D8E3698AB8" alt="img"></p><p><strong>设一组初始记录关键字序列为（49,38,65,97,76,13,27,49），则以第一个关键字49为基准而得到的一趟快速排序结果是：（）</strong></p><p>A:38，13，27，49，49，65，97，76</p><p>B:13，27，38，49，65，76，97，49</p><p>C:27，38，13，49，76，97，65，49</p><p>D:27，38，13，49，97，76，65，49</p><p>解析：</p><p>基本思想： </p><p> 第一步：(初始化)设置两个指针i和j，它们的初值分别为区间的下界和上界，即i=low，i=high；选取无序区的第一个记录R<a href="%E5%8D%B3R%5Blow%5D">i</a>作为基准记录，并将它保存在变量pivot中；<br>  第二步：令j自high起向左扫描，直到找到第1个关键字小于pivot.key的记录R[j]，将R[j])移至i所指的位置上，这相当于R[j]和基准R<a href="%E5%8D%B3pivot">i</a>进行了交换，使关键字小于基准关键字pivot.key的记录移到了基准的左边，交换后R[j]中相当于是pivot；然后，令i指针自i+1位置开始向右扫描，直至找到第1个关键字大于pivot.key的记录R[i]，将R[i]移到i所指的位置上，这相当于交换了R[i]和基准R[j]，使关键字大于基准关键字的记录移到了基准的右边，交换后R[i]中又相当于存放了pivot；接着令指针j自位置j-1开始向左扫描，如此交替改变扫描方向，从两端各自往中间靠拢，直至i=j时，i便是基准pivot最终的位置，将pivot放在此位置上就完成了一次划分。</p><p> 排序过程：<br> [49 38 65 97 76 13 27 49] //初始关键字<br> [27 38 13] 49 [76 97 65 49] //第1次划分完成之后，对应递归树第2层</p><p>以49为基准，取出49，两个指针，前指针指向38，后指针指向最后一个49<br> 首先移动后指针，找到27&lt;49，将27放在 0 位置，后指针前移<br> 再根据前指针查找，65&gt;49，将65放在原27的位置<br> 现在结果是 27,38, ,97,76,13,65,49<br> 继续用后指针查找，13&lt;49,放在空位中，后指针前移，<br> 结果是 27,38,13,97,76, ,65,49<br> 继续前指针查找，97&gt;49，放在空位，变成27,38,13, ,76,97,65,49<br> 然后前后指针都指向76，结束，将49放入空位中，得到27,38,13,49,76,97,65,49</p><p><strong>下列排序算法的常规实现中，哪些空间复杂度是O(1)(A B E)</strong></p><p>A:冒泡</p><p>B:选择</p><p>C:归并</p><p>D:快排</p><p>E:堆排序</p><p>解析：  冒泡排序,选择排序,堆排序的空间复杂度为O(1),因为需要一个临时变量来交换元素位置,(另外遍历序列时自然少不了用一个变量来做索引). </p><p>  快速排序空间复杂度为logn(因为递归调用了) ,归并排序空间复杂是O(n),需要一个大小为n的临时数组.</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
            <tag> 堆排序 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web前端</title>
      <link href="2021/02/26/niuke/qianduan/qianduan/"/>
      <url>2021/02/26/niuke/qianduan/qianduan/</url>
      
        <content type="html"><![CDATA[<h1 id="web前端"><a href="#web前端" class="headerlink" title="web前端"></a>web前端</h1><p><strong>元素的alt和title有什么异同，选出正确的说法？（B）</strong></p><p>A:不同的浏览器，表现一样</p><p>B:alt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字</p><p>C:alt和title同时设置的时候，title作为图片的替代文字出现，alt是图片的解释文字</p><p>D:以上说法都不正确</p><p>解析：</p><p>  alt是html标签的属性，而title既是html标签，又是html属性。<br>  title标签这个不用多说，网页的标题就是写在<title></title>这对标签之内的。<br>  title作为属性时，用来为元素提供额外说明信息。例如，给超链接标签a添加了title属性，把鼠标移动到该链接上面是，就会显示title的内容，以达到补充说明或者提示的效果。<br>  而alt属性则是用来指定替换文字，只能用在img、area和input元素中（包括applet元素），用于网页中图片无法正常显示时给用户提供文字说明使其了解图像信息。</p><p><strong>下面有关浏览器中使用js跨域获取数据的描述，说法错误的是？</strong>正确答案: A</p><p>A:域名、端口相同，协议不同，属于相同的域</p><p>B:js可以使用jsonp进行跨域</p><p>C:通过修改document.domain来跨子域</p><p>D:使用window.name来进行跨域</p><p>解析：</p><p>  <strong>1.CORS</strong></p><p>  CORS（Corss-Origin Resource  Sharing,跨资源共享），基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应的成功或失败。即给请求附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部决定是否给予响应。 </p><p>  <strong>2.document.domain</strong></p><p>  将页面的document.domain设置为相同的值，页面间可以互相访问对方的JavaScript对象。 </p><p>  注意： </p><p>  不能将值设置为URL中不包含的域； </p><p>  松散的域名不能再设置为紧绷的域名。 </p><p>  <strong>3.图像Ping</strong></p><p>  var img=new Image(); </p><p>  img.onload=img.onerror=function(){ </p><p>  … … </p><p>  } </p><p>  img.src=”url?name=value”; </p><p>  请求数据通过查询字符串的形式发送，响应可以是任意内容，通常是像素图或204响应。 </p><p>  图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。 </p><p>  缺点： </p><p>  只能发送GET请求； </p><p>  无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信。 </p><p>  <strong>4.Jsonp</strong></p><p>  var script=document.createElement(“script”); </p><p>  script.src=”url?callback=handleResponse”; </p><p>  document.body.insertBefore(script,document.body.firstChild); </p><p>  JSONP由两部分组成：回调函数和数据 </p><p>  回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。 </p><p>  数据是传入回调函数中的JSON数据。 </p><p>  优点： </p><p>  能够直接访问响应文本，可用于浏览器与服务器间的双向通信。 </p><p>  缺点： </p><p>  JSONP从其他域中加载代码执行，其他域可能不安全； </p><p>  难以确定JSONP请求是否失败。 </p><p>  <strong>5.Comet</strong></p><p>  Comet可实现服务器向浏览器推送数据。 </p><p>  Comet是实现方式：长轮询和流 </p><p>  短轮询即浏览器定时向服务器发送请求，看有没有数据更新。 </p><p>  长轮询即浏览器向服务器发送一个请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又向服务器发起一个新请求。其优点是所有浏览器都支持，使用XHR对象和setTimeout()即可实现。 </p><p>  流即浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据，页面的整个生命周期内只使用一个HTTP连接。 </p><p>  <strong>6.WebSocket</strong></p><p>  WebSocket可在一个单独的持久连接上提供全双工、双向通信。</p><p>  WebSocket使用自定义协议，未加密的连接时ws://；加密的链接是wss://。 </p><p>  var webSocket=new WebSocket(“ws://“); </p><p>  webSocket.send(message); </p><p>  webSocket.onmessage=function(event){ </p><p>  var data=event.data; </p><p>  … …. </p><p>  } </p><p>  注意： </p><p>  必须给WebSocket构造函数传入绝对URL； </p><p>  WebSocket可以打开任何站点的连接，是否会与某个域中的页面通信，完全取决于服务器；</p><p>  WebSocket只能发送纯文本数据，对于复杂的数据结构，在发送之前必须进行序列化JSON.stringify(message))。</p><p>   优点：  </p><p>   在客户端和服务器之间发送非常少的数据，减少字节开销。  </p><p>下面有关CSS sprites说法错误的是？正确答案: C</p><p>A:允许你将一个页面涉及到的所有零星图片都包含到一张大图中去</p><p>B:利用CSS的“background-image”，“background-repeat”，“background-position”的组合进行背景定位</p><p>C:CSS Sprites虽然增加了总的图片的字节，但是很好地减少网页的http请求，从而大大的提高页面的性能</p><p>D:CSS Sprites整理起来更为方便，同一个按钮不同状态的图片也不需要一个个切割出来并个别命名</p><p>解析：</p><h4 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h4><p>   1.简介  </p><p>   CSS    Sprites在国内很多人叫css精灵，是一种网页图片应用处理方式。它允许将一个页面涉及到的所有零星图片都包含到一张大图中，    利用CSS的“background-image”，“background-    repeat”，“background-position”的组合进行背景定位， 访问页面时避免图片载入缓慢的现象。  </p><p>   2.优点  </p><p> （1）CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能，这是CSS  Sprites最大的优点，也是其被广泛传播和应用的主要原因；  </p><p>   （2）CSS Sprites能减少图片的字节；  </p><p>   （3）CSS    Sprites解决了网页设计师在图片命名上的困扰，只需对一张集合的图片命名，不需要对每一个小图片进行命名，从而提高了网页制作效率。  </p><p>   （4）CSS Sprites只需要修改一张或少张图片的颜色或样式来改变整个网页的风格。  </p><p>   3.缺点  </p><p>   （1）图片合并麻烦：图片合并时，需要把多张图片有序的合理的合并成一张图片，并留好足够的空间防止版块出现不必要的背景。  </p><p>   （2）图片适应性差：在高分辨的屏幕下自适应页面，若图片不够宽会出现背景断裂。  </p><p>   （3）图片定位繁琐：开发时需要通过工具测量计算每个背景单元的精确位置。  </p><p>​    （4）可维护性差：页面背景需要少许改动，可能要修改部分或整张已合并的图片，进而要改动css。在避免改动图片的前提下，又只能（最好）往下追加图片，但这样增加了图片字节。  </p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法</title>
      <link href="2021/02/26/niuke/suanfa/search/"/>
      <url>2021/02/26/niuke/suanfa/search/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-算法-查找"><a href="#第一章-算法-查找" class="headerlink" title="第一章 算法-查找"></a>第一章 算法-查找</h1><p><strong>在长度为n的顺序线性表中顺序查找值为x的元素时，查找成功时的平均查找长度（假定查找每个元素的概率均相等）为（D）。</strong></p><p>A:n</p><p>B:(n-1)/2</p><p>C:n/2</p><p>D:(n+1)/2</p><p>解答：长度为n的线性表顺序查找x，则查找次数可能是1,2,3,…,n次，则和sum为n*(1+n)/2，所以平均查找次数为sum/n=(n+1)/2</p><p><strong>二叉查找树的查找效率与二叉树的树型有关，在（）时其查找效率最低（C）</strong></p><p>A:结点太多</p><p>B:完全二叉树</p><p>C:是单枝树</p><p>D:节点太复杂</p><p>解答：当二叉查询树变成一条链表效率最差。所以有AVL平衡树 限制节点深度差不超过1，避免产生链表一般的树。</p><p><strong>KMP算法下，长为n的字符串中匹配长度为m的子串的复杂度为（B）</strong></p><p>A:O(n)</p><p>B:O（M+N）</p><p>C:O（M+LOGM）</p><p>D:O（N+LOGM）</p><p>解答：给定两个字符串O和f，长度分别为n和    m，判断f是否在O中出现，如果出现则返回出现的位置。常规方法是遍历O的每一个位置，然后从该位置开始和f进行匹配，但是这种方法的复杂度是 O(nm)。kmp算法通过一个O(m)的预处理，使匹配的复杂度降为O(n+m)。</p><h2 id="kmp算法思想—字符串比较"><a href="#kmp算法思想—字符串比较" class="headerlink" title="kmp算法思想—字符串比较"></a>kmp算法思想—字符串比较</h2><p>​    我们首先用一个图来描述kmp算法的思想。在字符串O中寻       找f，当匹配到位置i时两个字符串不相等，这时我们需要将字符串f向前移动。常规方法是每次向前移动一位，但是它没有考虑前i-1位已经比较过这个事实，  所以效率不高。事实上，如果我们提前计算某些信息，就有可能一次前移多位。假设我们根据已经获得的信息知道可以前移k位，我们分析移位前后的f有什么特点。我们可以得到如下的结论：  </p><ul><li>​              A段字符串是f的一个前缀。          </li><li>​              B段字符串是f的一个后缀。          </li><li>​              A段字符串和B段字符串相等。        </li></ul><p>​    所以前移k位之后，可以继续比较位置i的前提是f的前i-1个位置满足：<strong>长度为i-k-1的前缀A和后缀B相同</strong>。只有这样，我们才可以前移k位后从新的位置继续比较。  </p><p><img src="http://img.blog.csdn.net/20130924000026250" alt="img"></p><p>​          所以kmp算法的核心即是计算字符串f每一个位置之前的字       符串的前缀和后缀公共部分的最大长度（不包括字符串本身，否则最大长度始终是字符串本身）。获得f每一个位置的最大公共长度之后，就可以利用该最大公共长       度快速和字符串O比较。当每次比较到两个字符串的字符不同时，我们就可以根据最大公共长度将字符串f向前移动(已匹配长度-最大公共长度)位，接着继续比 较下一个位置。事实上，字符串f的前移只是概念上的前移，只要我们在比较的时候从最大公共长度之后比较f和O即可达到字符串f前移的目的。</p><p><img src="http://img.blog.csdn.net/20130924000843031" alt="img"></p><h3 id="next数组计算"><a href="#next数组计算" class="headerlink" title="next数组计算"></a>next数组计算</h3><p>理解了kmp算法的基本原理，下一步就是要获得字符串f每一个位置的最大公共长度。这个最大公共长度在算法导论里面被记为next数组。在这里要注意一点，      next      数组表示的是长度，下标从      1      开始；但是在遍历原字符串时，下标还是从      0      开始。假设我们现在已经求得next[1]、next[2]、……next[i]，分别表示长度为1到i的字符串的前缀和后缀最大公共长度，现在要求next[i+1]。由上图我们可以看到，如果位置i和位置next[i]处的两个字符相同（下标从零开始），      则next[i+1]等于next[i]加1。如果两个位置的字符不相同，我们可以将长度为next[i]的字符串继续分割，获得其最大公共长度      next[next[i]]，然后再和位置i的字符比较。这是因为长度为next[i]前缀和后缀都可以分割成上部的构造，如果位置      next[next[i]]和位置i的字符相同，则next[i+1]就等于next[next[i]]加1。如果不相等，就可以继续分割长度为        next[next[i]]的字符串，直到字符串长度为0为止。由此我们可以写出求next数组的代码（<a href="http://lib.csdn.net/base/17">Java</a>版）：</p><blockquote><pre class=" language-java"><code class="language-java">publicint<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getNext</span><span class="token punctuation">(</span>String b<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> len<span class="token operator">=</span>b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//next表示长度为i的字符串前缀和后缀的最长公共部分，从1开始 </span>  next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//i表示字符串的下标，从0开始 </span>  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//j在每次循环开始都表示next[i]的值，同时也表示需要比较的下一个位置 </span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>b<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">!=</span>b<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>j<span class="token operator">=</span>next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">==</span>b<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>j<span class="token operator">++</span><span class="token punctuation">;</span>     next<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>j<span class="token punctuation">;</span>   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        retur nnext<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> </code></pre></blockquote><p>上述代码需要注意的问题是，我们求取的next数组表示长度为1      到m的字符串f前缀的最大公共长度，所以需要多分配一个空间。而在遍历字符串f的时候，还是从下标0开始(位置0和1的next值为0，所以放在循环外 面)，到m-1为止。代码的结构和上面的讲解一致，都是利用前面的next值去求下一个next值。</p><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><p>计算完成next数组之后，我们就可以利用next数组在      字符串O中寻找字符串f的出现位置。匹配的代码和求next数组的代码非常相似，因为匹配的过程和求next数组的过程其实是一样的。假设现在字符串f的      前i个位置都和从某个位置开始的字符串O匹配，现在比较第i+1个位置。如果第i+1个位置相同，接着比较第i+2个位置；如果第i+1个位置不同，则出      现不匹配，我们依旧要将长度为i的字符串分割，获得其最大公共长度next[i]，然后从next[i]继续比较两个字符串。这个过程和求next数组一 致，所以可以匹配代码如下（java版）：</p><blockquote><pre><code>public void search(String original, String find, int next[]) &#123;   int j = 0;   for (int i = 0; i &lt; original.length(); i++) &#123;     while (j &gt; 0 &amp;&amp; original.charAt(i) != find.charAt(j))       j = next[j];     if (original.charAt(i) == find.charAt(j))       j++;     if (j == find.length()) &#123;       System.out.println(&quot;find at position &quot; + (i - j));       System.out.println(original.subSequence(i - j + 1, i + 1));       j = next[j];     &#125;   &#125; &#125; </code></pre></blockquote><p><strong>推荐这篇博客里对KMP算法的讲解很清晰，通过一个实际的例子来讲解了如何进行匹配：</strong></p><h3 id="http-www-ruanyifeng-com-blog-2013-05-Knuth"><a href="#http-www-ruanyifeng-com-blog-2013-05-Knuth" class="headerlink" title="http://www.ruanyifeng.com/blog/2013/05/Knuth"></a><strong><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">http://www.ruanyifeng.com/blog/2013/05/Knuth</a></strong></h3><h3 id="https-blog-csdn-net-yutianzuijin-article-details-11954939"><a href="#https-blog-csdn-net-yutianzuijin-article-details-11954939" class="headerlink" title="https://blog.csdn.net/yutianzuijin/article/details/11954939/"></a><a href="https://blog.csdn.net/yutianzuijin/article/details/11954939/">https://blog.csdn.net/yutianzuijin/article/details/11954939/</a></h3><p>已知字符串S 为“abaabaabacacaabaabcc”，模式串 t 为“abaabc”。采用 KMP 算法进行匹配，第一     次出现“失配”(s[i]≠t[j])  时，i=j=5，则下次开始匹配时，i 和 j 的值分别是 （C） 。  </p><p>A:i=1,j=0</p><p>B:i=5,j=0</p><p>C:i=5,j=2</p><p>D:i=6,j=2</p><p><strong>给定一个整数sum,从有N个有序元素的数组中寻找元素a,b,使得a+b的结果最接近sum,最快的平均时间复杂度是：(A)</strong></p><p>A:O(n)</p><p>B:O(nlogn)</p><p>C:O(n^2)</p><p>D:O(logn)</p><p>解答：  思想类似于两端向中间扫描 </p><p>  1、设定两个指针P1、P2，分别指向数组开始和结尾，即P1指向最小值，P2指向最大值； </p><p>  2、计算 *P1+*P2 的值为 SUM，与 sum 比较，记录它们的差值 DIF 和 SUM，若 SUM&lt;sum，P1++，若SUM&gt;sum，P2–;</p><p>  3、重复以上过程直到DIF最小</p><p><img src="https://uploadfiles.nowcoder.com/images/20170630/6428287_1498792227319_82DC6157EE49E83E8E9BFC64AAA92B29" alt="img"></p><p><strong>下面关于查找算法的论述中哪个不是正确的？</strong></p><p>A:顺序查找需要查找表为有序表</p><p>B:折半查找需要查找表为有序表</p><p>C:查找表可分为静态查找表和动态查找表</p><p>D:动态查找表的特点是表结构本身在查找过程中动态生成的</p><p>解答：</p><p>  <strong>静态查找表</strong>：仅做查询和检索操作的查找表； </p><p>  <strong>动态查找表</strong>：在查询之后，还需要将查询结果为不在查找表中的数据元素插入到查找表中；或者，从查找表中删除其查询结果为在查找表中的数据元素； </p><p>  简而言之，动态查找表的结构是可以随时修改或变化的，表结构本身在查找过程中动态生成，一般而言链式结构有这个特征，比如二叉查找树、三棵B树等，另外，基于顺序存储的Hash查找应该也算动态查找表；而静态查找表的结构一次性生成后就不再允许改变，就像在有序数组上使用折半查找那样。 </p><p><strong>具有12个关键字的有序表，折半查找的平均查找长度（A）</strong></p><p>A:3.1</p><p>B:4</p><p>C:2.5</p><p>D:5</p><p>解答：</p><p>方法一：12个关键字的有序表，折半查找的判定树如下：<br>     6        （1<em>1）次<br>    /  <br>    3  9       （2</em>2）次<br>   / \  / <br>   1 4 7 11     （3<em>4）次<br>   \  \  \   / <br>   2 5 8 10 12  （4</em>5）次</p><p>  平均查找长度=1/12*(1<em>1+2</em>2+3<em>4+4</em>5)=37/12</p><p>方法二：  查找长度是底数为2的logn 即log12，2^3=8,2^4=16，查12个也就是说长度在3~4之间…..故答案A</p><p><strong>设顺序线性表的长度为30，分成5块，每块6个元素，如果采用分块查找，则其平均查找长度为（D）。</strong></p><p>A:6</p><p>B:11</p><p>C:5</p><p>D:6.5</p><p>解析</p><p>找块：（1+2+3+4+5）/5=3<br> 在块内找元素：  (1+2+3+4+5+6)/6=3.5<br> 合计：3+3.5=6.5</p><p><strong>对于静态表的顺序查找法，若在表头设置监视哨，则正确的查找方式为（C）。</strong> </p><p>A:从第0个元素往后查找该数据元素</p><p>B:从第1个元素往后查找该数据元素</p><p>C:从第n个元素往开始前查找该数据元素</p><p>D:与查找顺序无关</p><p>解析</p><p>  常把第一个或最后一个元素作为哨兵 </p><p>  表头设置监视哨，就是将空出来的下标为0的这个元素的值设为Key, </p><p>  这样我们就不用多次判断 i 是否越界，因为就算静态表中找不到，也会在0位置上配对成功，返回0！</p><p>   n个元素都要比较一次,但都不成功,最后监视哨也要比较一次,比较成功,一共比较n+1次.  </p><p>   例子：有5个元素,分别是1,2,3,4,5.要找的元素是8.那么8就是监视哨,数列如下：  </p><p>   8,1,2,3,4,5.  </p><p>   从5开始向前查找,一共要比较6次,比较到监视哨成功,监视哨所在的下标是0,所以返回值为0.  </p><p>  <strong>下列选项中，不能构成折半查找中关键字比较序列的是 （A）。</strong>  </p><p>A:500,200,450,180</p><p>B:500,450,200,180</p><p>C:180,500,200,450</p><p>D:180,200,500,450</p><p>解析  画出查找路径图，因为折半查找的判定树是一棵二叉排序树，看其是否满足二叉排序树的要求。</p><p>  很显然，选项  A  的查找路径不满足</p><p><img src="https://uploadfiles.nowcoder.com/images/20170408/7031383_1491662188654_B034E3196CEA908FE6A93789F835033F" alt="img"></p><p><strong>在ASC算法team日常开发中，常常面临一些数据结构的抉择，令人纠结。目前大家在策划一个FBI项目（Fast Binary  Indexing），其中用到的词汇有6200条，词汇长度在10-15之间，词汇字符是英文字母，区分大小写。请在下面几个数据结构中选择一个使检索速度最快的：（D）</strong></p><p>A:二叉搜索树，比较函数开销：1次运算/每字符</p><p>B:哈希表，hash算法开销：10次运算/每字符</p><p>C:链表，比较函数开销：1次运算/每字符</p><p>D:TRIE树，寻找子节点开销：1次运算/每字符</p><p>解析：又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p><p><strong>关于红黑树和AVL树，以下哪种说法不正确？（D）</strong></p><p>A:两者都属于自平衡二叉树</p><p>B:两者查找,插入，删除的时间复杂度相同</p><p>C:包含n个内部节点的红黑树的高度是O(log(n))</p><p>D:JDK的TreeMap是一个AVL的实现</p><p>解析：</p><p>​                  <strong><em>1 好处 及 用途\</em></strong>            </p><p>​       红黑树      <strong>并不追求“完全平衡</strong>    ”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。  </p><p>​      红黑树能够以      <strong>O(*log2*         n)</strong>      的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构    能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高。  </p><p>​        当然，红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。  </p><p>​    在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。  </p><p>​          <em>典型的用途是实现关联数组</em>      </p><p>​          <strong><em>2\</em></strong>     AVL树是最先发明的自平衡二叉查    找树。在AVL树中任何节点的两个儿子子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O(log    n)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和    E.M. Landis，他们在 1962 年的论文 “An algorithm for the organization of    information” 中发表了它。  </p><p>   引入二叉树的目的是为了提高二叉树的搜索的效率,减少树的平均搜索长度.为此,就必须每向二叉树插入一个结点时调整树的结构,使得二叉树搜索保持平衡,从而可能降低树的高度,减少的平均树的搜索长度. </p><p> AVL树的定义:<br> 一棵AVL树满足以下的条件:<br> 1&gt;它的左子树和右子树都是AVL树<br>    2&gt;左子树和右子树的高度差不能超过1<br> 从条件1可能看出是个递归定义,如GNU一样. </p><p> 性质:<br>    1&gt;一棵n个结点的AVL树的其高度保持在0(log2(n)),不会超过3/2log2(n+1)<br>      2&gt;一棵n个结点的AVL树的平均搜索长度保持在0(log2(n)).<br> 3&gt;一棵n个结点的AVL树删除一个结点做平衡化旋转所需要的时间为0(log2(n)). </p><p> 从1这点来看              <strong><em>红黑树是牺牲了严格的高度平衡的优越条件</em></strong>          为 代价红黑树能够以O(log2    n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构    能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高.  </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找 </tag>
            
            <tag> 字符串比较 </tag>
            
            <tag> kmp </tag>
            
            <tag> 分块查找 </tag>
            
            <tag> 二分法 </tag>
            
            <tag> 算法 </tag>
            
            <tag> AVL树 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js试题</title>
      <link href="2021/02/26/niuke/qianduan/js-shi-ti/"/>
      <url>2021/02/26/niuke/qianduan/js-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="js试题"><a href="#js试题" class="headerlink" title="js试题"></a>js试题</h1><p><strong>下面这个JS程序的输出是什么：</strong> </p><pre><code>function Foo() &#123;  var i = 0;  return function() &#123;    console.log(i++);  &#125;&#125;</code></pre><pre><code>var f1 = Foo(),  f2 = Foo();f1();f1();f2();</code></pre><p>正确答案: A</p><p>A:0 1 0</p><p>B:0 1 2</p><p>C:0 0 0</p><p>D:0 0 2</p><p>解析：</p><p>这道题考察<strong>闭包</strong>和<strong>引用类型对象</strong>的知识点：<br>1.一般来说函数执行完后它的局部变量就会随着函数调用结束被销毁，但是此题foo函数返回了一个匿名函数的引用（即一个<strong>闭包</strong>），它可以访问到foo()被调用产生的环境，而局部变量i一直处在这个环境中，只要一个环境有可能被访问到，它就不会被销毁，所以说闭包有延续变量作用域的功能。这就好理解为什么：</p><pre><code>f1();//0f1();//1</code></pre><p>2.我一开始认为f1和f2都=foo()是都指向了同一个function引用类型，所以顺理成章就会答错认为：</p><pre><code>f2();//2</code></pre><p>但其实foo()返回的是一个匿名函数，所以f1,f2相当于指向了两个不同的函数对象，所以结果也就顺理成章的变为：</p><p><a href="https://www.nowcoder.com/test/question/done?tid=41312304&qid=14899#">复制代码</a></p><pre><code>f2();//0</code></pre><p>下面有关JavaScript中 call和apply的描述，错误的是？</p><p>都是非正确答案: B </p><p>A:call与apply都属于Function.prototype的一个方法，所以每个function实例都有call、apply属性</p><p>B:两者传递的参数不同，call函数第一个参数都是要传入给当前对象的对象，apply不是</p><p>C:apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入</p><p>D:call传入的则是直接的参数列表。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</p>]]></content>
      
      
      <categories>
          
          <category> js试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第十二章 特殊集合</title>
      <link href="2021/02/25/c-10/c-10th-12/"/>
      <url>2021/02/25/c-10/c-10th-12/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第十二章-特殊集合"><a href="#c-语言-第十二章-特殊集合" class="headerlink" title="c#语言 第十二章 特殊集合"></a>c#语言 第十二章 特殊集合</h1><h3 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h3><p>​        使用位数组和位矢量</p><p>​        使用可观察的集合</p><p>​        使用不可变得集合</p><p>​        使用并发的集合</p><p>12.1概述</p><p>   11张介绍了列表、队列、堆栈、字典和链表。</p><p>12.2处理位</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 特殊的集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第十一章 集合</title>
      <link href="2021/02/23/c-10/c-10th-11/"/>
      <url>2021/02/23/c-10/c-10th-11/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第十一章-集合"><a href="#c-语言-第十一章-集合" class="headerlink" title="c#语言 第十一章 集合"></a>c#语言 第十一章 集合</h1><h2 id="1-集合接口和类型"><a href="#1-集合接口和类型" class="headerlink" title="1.集合接口和类型"></a>1.集合接口和类型</h2><table><thead><tr><th>接口</th><th>说明</th></tr></thead><tbody><tr><td>IEnumerable<T></T></td><td>如果foreach语句用于集合,就需要IEnumerable接口.这个借口定义了方法GetEnumerator(),他返回一个实现了IEnumerator接口的枚举</td></tr><tr><td>ICollection<T></T></td><td>ICollection<T>接口有泛型集合类实现.使用这个借口可以获得集合中的元素个数(Count属性),把集合复制到数组中(CopyTo()方法),还可以从集合中添加和删除元素(Add(),Remove(),Clear())</T></td></tr><tr><td>List<T></T></td><td>IList<T>接口用于可通过位置访问其中的元素列表,这个接口定义了一个 索引器,可以在集合的指定位置插入或删除 mount些项(Insert()和Remove()方法).IList<T>接口派生自ICollection<T>接口</T></T></T></td></tr><tr><td>ISet<T></T></td><td>ISet<T>接口是.NET4中新增的.实现这个接口的集允许合并不同的集.获得两个集的交集,检查两个集合是否重叠.ISet<T>接口派生自ICollection<T>接口</T></T></T></td></tr><tr><td>IDictionary&lt;TKey,TValue&gt;</td><td>IDictionary&lt;TKey,TValue&gt;接口由包含键和值的泛型集合类 实现.使用这个接口可以访问所有的键和值,使用键类型的索引器可以访问某些项,还可以添加或删除某些项</td></tr><tr><td>ILookup&lt;TKey,TValue&gt;</td><td>ILookup&lt;TKey,TValue&gt;接口类似于IDictionary&lt;TKey,TValue&gt;接口,实现该接口的集合有键和值,且可以通过一个键包含多个值</td></tr><tr><td>IComparer<T></T></td><td>接口ICommparer<T>由比较器实现,通过Comparer()方法给集合中的元素排序</T></td></tr><tr><td>IEqualityComparer<T></T></td><td>接口IEqualityComparer<T>由一个比较器实现,该比较器可用于字典中的键.使用这个接口,可以对对象进行相等性比较.在.NET中,这个接口也由数组和元组实现</T></td></tr><tr><td>IProducerConsumerColllection<T></T></td><td>IProducerConsumerCollection<T>接口是.NET4中新增的,它支持新的线程安全的集合类</T></td></tr><tr><td>IReadOnlyList<T>、 IReadOnlyDictionary<T>、 IReadOnlyCollection<T></T></T></T></td><td>初始化后不能修改的集合，只能检索对象，不能添加和删除.</td></tr></tbody></table><h2 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h2><blockquote><pre><code>[Serializable]  public class Racer : IComparable&lt;Racer&gt;, IFormattable  &#123;    public int Id &#123; get; private set; &#125;    public string FirstName &#123; get; set; &#125;    public string LastName &#123; get; set; &#125;    public string Country &#123; get; set; &#125;    public int Wins &#123; get; set; &#125;    public Racer(int id, string firstName, string lastName, string country)      : this(id, firstName, lastName, country, wins: 0)    &#123;    &#125;    public Racer(int id, string firstName, string lastName, string country, int wins)    &#123;      this.Id = id;      this.FirstName = firstName;      this.LastName = lastName;      this.Country = country;      this.Wins = wins;    &#125;    public override string ToString()    &#123;      return String.Format(&quot;&#123;0&#125; &#123;1&#125;&quot;, FirstName, LastName);    &#125;    public string ToString(string format, IFormatProvider formatProvider)    &#123;      if (format == null) format = &quot;N&quot;;      switch (format.ToUpper())      &#123;        case null:        case &quot;N&quot;: // name          return ToString();        case &quot;F&quot;: // first name          return FirstName;        case &quot;L&quot;: // last name          return LastName;        case &quot;W&quot;: // Wins          return String.Format(&quot;&#123;0&#125;, Wins: &#123;1&#125;&quot;, ToString(), Wins);        case &quot;C&quot;: // Country          return String.Format(&quot;&#123;0&#125;, Country: &#123;1&#125;&quot;, ToString(), Country);        case &quot;A&quot;: // All          return String.Format(&quot;&#123;0&#125;, &#123;1&#125; Wins: &#123;2&#125;&quot;, ToString(), Country, Wins);        default:          throw new FormatException(String.Format(formatProvider,                &quot;Format &#123;0&#125; is not supported&quot;, format));      &#125;    &#125;    public string ToString(string format)    &#123;      return ToString(format, null);    &#125;    public int CompareTo(Racer other)    &#123;      if (other == null) return -1;      int compare = string.Compare(this.LastName, other.LastName);      if (compare == 0)        return string.Compare(this.FirstName, other.FirstName);      return compare;    &#125;  &#125;</code></pre></blockquote><p>​        使用默认的构造函数创建一个空列表，元素添加到列表后，列表容量会扩大到可接纳4个元素。<br>​        如果添加了第5个元素，列表大小会重新设置为8个元素。每次都会将列表的容量重新设置为原来的2倍.</p><blockquote><pre><code>var intList=new List&lt;int&gt;();</code></pre></blockquote><p>​        如果列表的容量变了，整个集合就要重新分配到新的内存块中，我们可以在初始化时设置它的容量：</p><blockquote><pre><code>List&lt;int&gt; intList=new List&lt;int&gt;(10);</code></pre></blockquote><p>如果列表的个数超过10个，可以设置容量Capacity：</p><blockquote><pre><code>intList.Capacity = 20;</code></pre></blockquote><p>如果列表的元素已经添加完了，列表会存在多余的容量空间。可以使用TrimExcess方法去除不要的容量:</p><blockquote><pre><code>intList.TrimExcess();</code></pre></blockquote><h3 id="a-集合初始值设定项"><a href="#a-集合初始值设定项" class="headerlink" title="a.集合初始值设定项"></a>a.集合初始值设定项</h3><p>使用初始化构造器初始化设定项</p><blockquote><pre><code>int[] arr = &#123; 1, 2, 3 &#125;;var intList = new List&lt;int&gt;(arr) ;</code></pre></blockquote><p>括号中初始化</p><pre><code>var intList = new List&lt;int&gt;() &#123; 4, 5 &#125;;</code></pre><h3 id="b-添加元素"><a href="#b-添加元素" class="headerlink" title="b.添加元素"></a>b.添加元素</h3><pre><code>intList.Add(5);</code></pre><h3 id="添加数组"><a href="#添加数组" class="headerlink" title="添加数组"></a>添加数组</h3><pre><code>intList.AddRange(new int[] &#123; 3, 5 &#125;);</code></pre><h3 id="c-插入元素"><a href="#c-插入元素" class="headerlink" title="c.插入元素"></a>c.插入元素</h3><pre><code>intList.Insert(3, 4);</code></pre><h3 id="d-访问元素"><a href="#d-访问元素" class="headerlink" title="d.访问元素"></a>d.访问元素</h3><p>使用索引获取：</p><pre><code>var value = intList[3];</code></pre><p>循环遍历：</p><pre><code>foreach (var item in intList)&#123;     var res = item;&#125;</code></pre><p>forEach方法：</p><pre><code>class List&lt;T&gt; : IList&lt;T&gt;&#123;    private T[] items;    public void forEach(Action&lt;T&gt; action)    &#123;        if (action == null) throw new ArgumentNullException(&quot;action&quot;);        foreach (var item in items)        &#123;            action(item);        &#125;    &#125;&#125;</code></pre><p>然后我们可以这样调用：</p><pre><code>intList.ForEach(m =&gt; Console.WriteLine(m));</code></pre><h3 id="e-删除元素"><a href="#e-删除元素" class="headerlink" title="e.删除元素"></a>e.删除元素</h3><p>按索引删除,比较快</p><pre><code>intList.RemoveAt(3);</code></pre><p>按元素值删除</p><pre><code>intList.Remove(4);</code></pre><h3 id="f-搜索"><a href="#f-搜索" class="headerlink" title="f.搜索"></a>f.搜索</h3><p>在集合中搜索元素。可以查找索引和元素。</p><p>FindIndex通过匹配元素值，获得索引：</p><pre><code>intList.FindIndex(m =&gt; m==4);</code></pre><p>FindIndex方法参数Predicate<T>传入匹配的表达式，返回匹配的元素索引值,Predicate<T>委托表示定义一组条件并确定指定对象是否符合这些条件的方法</T></T></p><pre><code>intList.Find(m =&gt; m == 4);intList.FindAll(m =&gt; m &gt; 2);</code></pre><p>Find返回了匹配条件的元素值，FindAll返回了匹配条件的所有元素</p><h3 id="g-排序"><a href="#g-排序" class="headerlink" title="g.排序"></a>g.排序</h3><p>列表使用Sort方法进行元素排序</p><pre><code>intList.Sort();intList.Sort((m, n) =&gt; m);</code></pre><p>Sort(Comparison<T> comparison)方法参数中的委托Comparison含有2个参数,方法将这2个元素进行比较，然后返回绝对值,如果返回-1的，元素需要排前面，返回1的元素需要排后面.</T></p><p>Sort(IComparer<T> comparer)方法参数中是一个比较接口，接口实现Comparer方法</T></p><pre><code>public enum CompareType  &#123;    FirstName,    LastName,    Country,    Wins  &#125;  public class RacerComparer : IComparer&lt;Racer&gt;  &#123;    private CompareType compareType;    public RacerComparer(CompareType compareType)    &#123;      this.compareType = compareType;    &#125;    public int Compare(Racer x, Racer y)    &#123;      if (x == null &amp;&amp; y == null) return 0;      if (x == null) return -1;      if (y == null) return 1;      int result;      switch (compareType)      &#123;        case CompareType.FirstName:          return string.Compare(x.FirstName, y.FirstName);        case CompareType.LastName:          return string.Compare(x.LastName, y.LastName);        case CompareType.Country:          result = string.Compare(x.Country, y.Country);          if (result == 0)            return string.Compare(x.LastName, y.LastName);          else            return result;        case CompareType.Wins:          return x.Wins.CompareTo(y.Wins);        default:          throw new ArgumentException(&quot;Invalid Compare Type&quot;);      &#125;    &#125;  &#125;</code></pre><h3 id="h-类型转换"><a href="#h-类型转换" class="headerlink" title="h.类型转换"></a>h.类型转换</h3><p> Converter委托</p><pre><code>public delegate TOutput Converter&lt;in TInput, out TOutput&gt;(TInput input);ConvertAll可以将一种类型的集合转换为另一种类型的集合。intList.ConvertAll(m =&gt; m.ToString());</code></pre><h6 id="只读集合"><a href="#只读集合" class="headerlink" title="只读集合"></a>只读集合</h6><p>创建集合后，它们是只读的。</p><h2 id="3-队列"><a href="#3-队列" class="headerlink" title="3.队列"></a>3.队列</h2><p>代表了一个<strong>先进先出</strong>的对象集合。当您需要对各项进行先进先出的访问时，则使用队列。当您在列表中添加一项，称为<strong>入队</strong>，当您从列表中移除一项时，称为<strong>出队</strong>。</p><p>添加队列元素时加上lock,因为多线程可以同时访问，所以对队列进行锁定访问。</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523112249101-324688636.png" alt="img"></p><pre><code>using System;using System.Collections;namespace CollectionsApplication&#123;   class Program   &#123;      static void Main(string[] args)      &#123;         Queue q = new Queue();         q.Enqueue(&#39;A&#39;);         q.Enqueue(&#39;M&#39;);         q.Enqueue(&#39;G&#39;);         q.Enqueue(&#39;W&#39;);                  Console.WriteLine(&quot;Current queue: &quot;);         foreach (char c in q)            Console.Write(c + &quot; &quot;);         Console.WriteLine();         q.Enqueue(&#39;V&#39;);         q.Enqueue(&#39;H&#39;);         Console.WriteLine(&quot;Current queue: &quot;);                  foreach (char c in q)            Console.Write(c + &quot; &quot;);         Console.WriteLine();         Console.WriteLine(&quot;Removing some values &quot;);         char ch = (char)q.Dequeue();         Console.WriteLine(&quot;The removed value: &#123;0&#125;&quot;, ch);         ch = (char)q.Dequeue();         Console.WriteLine(&quot;The removed value: &#123;0&#125;&quot;, ch);         Console.ReadKey();      &#125;   &#125;&#125;</code></pre><p>当上面的代码被编译和执行时，它会产生下列结果：</p><pre><code>Current queue: A M G W Current queue: A M G W V H Removing valuesThe removed value: AThe removed value: M</code></pre><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>class Program    &#123;        static void Main()        &#123;            var dm = new DocumentManager();            ProcessDocuments.Start(dm);            // Create documents and add them to the DocumentManager            for (int i = 0; i &lt; 1000; i++)            &#123;                Document doc = new Document(&quot;Doc &quot; + i.ToString(), &quot;content&quot;);                dm.AddDocument(doc);                Console.WriteLine(&quot;Added document &#123;0&#125;&quot;, doc.Title);                Thread.Sleep(new Random().Next(20));            &#125;        &#125;    &#125;</code></pre><p>Program</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>public class ProcessDocuments  &#123;    public static void Start(DocumentManager dm)    &#123;      Task.Factory.StartNew(new ProcessDocuments(dm).Run);    &#125;    protected ProcessDocuments(DocumentManager dm)    &#123;      if (dm == null)        throw new ArgumentNullException(&quot;dm&quot;);      documentManager = dm;    &#125;    private DocumentManager documentManager;    protected void Run()    &#123;      while (true)      &#123;        if (documentManager.IsDocumentAvailable)        &#123;          Document doc = documentManager.GetDocument();          Console.WriteLine(&quot;Processing document &#123;0&#125;&quot;, doc.Title);        &#125;        Thread.Sleep(new Random().Next(20));      &#125;    &#125;  &#125;</code></pre><p>ProcessDocuments</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>public class DocumentManager  &#123;    private readonly Queue&lt;Document&gt; documentQueue = new Queue&lt;Document&gt;();    public void AddDocument(Document doc)    &#123;      lock (this)      &#123;        documentQueue.Enqueue(doc);      &#125;    &#125;    public Document GetDocument()    &#123;      Document doc = null;      lock (this)      &#123;        doc = documentQueue.Dequeue();      &#125;      return doc;    &#125;    public bool IsDocumentAvailable    &#123;      get      &#123;        return documentQueue.Count &gt; 0;      &#125;    &#125;  &#125;</code></pre><p>DocumentManager</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>public class Document  &#123;    public string Title &#123; get; private set; &#125;    public string Content &#123; get; private set; &#125;    public Document(string title, string content)    &#123;      this.Title = title;      this.Content = content;    &#125;  &#125;</code></pre><h2 id="4-栈"><a href="#4-栈" class="headerlink" title="4.栈"></a>4.栈</h2><p>代表了一个<strong>后进先出</strong>的对象集合。当您需要对各项进行后进先出的访问时，则使用堆栈。当您在列表中添加一项，称为<strong>推入</strong>元素，当您从列表中移除一项时，称为<strong>弹出</strong>元素。</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523134233945-207787536.png" alt="img"></p><pre><code>class Program    &#123;        static void Main()        &#123;            var alphabet = new Stack&lt;char&gt;();            alphabet.Push(&#39;A&#39;);            alphabet.Push(&#39;B&#39;);            alphabet.Push(&#39;C&#39;);            Console.Write(&quot;First iteration: &quot;);            foreach (char item in alphabet)            &#123;                Console.Write(item);            &#125;            Console.WriteLine();            Console.Write(&quot;Second iteration: &quot;);            while (alphabet.Count &gt; 0)            &#123;                Console.Write(alphabet.Pop());            &#125;            Console.WriteLine();        &#125;    &#125;</code></pre><h2 id="5-链表"><a href="#5-链表" class="headerlink" title="5.链表"></a>5.链表</h2><p>LinkedList<T>是一个双向链表，其元素指向它前面和后面的元素，这样通过移动下一个元素就可以正向遍历整个链表。通过移动到前一个元素可以反向遍历这个链表</T></p><p>链表的优点是，如果将元素插入列表的中间位置，使用链表会很快，在插入一个元素时，只需要修改上一个元素的Next引用和下一个元素的Previous引用，使他们引用所插入的元素。</p><pre><code>public class Document  &#123;    public string Title &#123; get; private set; &#125;    public string Content &#123; get; private set; &#125;    public byte Priority &#123; get; private set; &#125;    public Document(string title, string content, byte priority)    &#123;      this.Title = title;      this.Content = content;      this.Priority = priority;    &#125;  &#125;</code></pre><pre><code>public class PriorityDocumentManager  &#123;    private readonly LinkedList&lt;Document&gt; documentList;    // priorities 0.9    private readonly List&lt;LinkedListNode&lt;Document&gt;&gt; priorityNodes;    public PriorityDocumentManager()    &#123;      documentList = new LinkedList&lt;Document&gt;();      priorityNodes = new List&lt;LinkedListNode&lt;Document&gt;&gt;(10);      for (int i = 0; i &lt; 10; i++)      &#123;        priorityNodes.Add(new LinkedListNode&lt;Document&gt;(null));      &#125;    &#125;    public void AddDocument(Document d)    &#123;      Contract.Requires&lt;ArgumentNullException&gt;(d != null, &quot;argument d must not be null&quot;);      //  if (d == null) throw new ArgumentNullException(&quot;d&quot;);      AddDocumentToPriorityNode(d, d.Priority);    &#125;    private void AddDocumentToPriorityNode(Document doc, int priority)    &#123;      Contract.Requires&lt;ArgumentException&gt;(priority &gt;= 0 &amp;&amp; priority &lt; 10, &quot;priority value must be between 0 and 9&quot;);      //if (priority &gt; 9 || priority &lt; 0)      //    throw new ArgumentException(&quot;Priority must be between 0 and 9&quot;);      if (priorityNodes[priority].Value == null)      &#123;        --priority;        if (priority &gt;= 0)        &#123;          // check for the next lower priority          AddDocumentToPriorityNode(doc, priority);        &#125;        else // now no priority node exists with the same priority or lower        // add the new document to the end        &#123;          documentList.AddLast(doc);          priorityNodes[doc.Priority] = documentList.Last;        &#125;        return;      &#125;      else // a priority node exists      &#123;        LinkedListNode&lt;Document&gt; prioNode = priorityNodes[priority];        if (priority == doc.Priority)        // priority node with the same priority exists        &#123;          documentList.AddAfter(prioNode, doc);          // set the priority node to the last document with the same priority          priorityNodes[doc.Priority] = prioNode.Next;        &#125;        else // only priority node with a lower priority exists        &#123;          // get the first node of the lower priority          LinkedListNode&lt;Document&gt; firstPrioNode = prioNode;          while (firstPrioNode.Previous != null &amp;&amp;             firstPrioNode.Previous.Value.Priority == prioNode.Value.Priority)          &#123;            firstPrioNode = prioNode.Previous;            prioNode = firstPrioNode;          &#125;          documentList.AddBefore(firstPrioNode, doc);          // set the priority node to the new value          priorityNodes[doc.Priority] = firstPrioNode.Previous;        &#125;      &#125;    &#125;    public void DisplayAllNodes()    &#123;      foreach (Document doc in documentList)      &#123;        Console.WriteLine(&quot;priority: &#123;0&#125;, title &#123;1&#125;&quot;, doc.Priority, doc.Title);      &#125;    &#125;    // returns the document with the highest priority    // (that&#39;s first in the linked list)    public Document GetDocument()    &#123;      Document doc = documentList.First.Value;      documentList.RemoveFirst();      return doc;    &#125;  &#125;</code></pre><pre><code> class Program  &#123;    static void Main()    &#123;        PriorityDocumentManager pdm = new PriorityDocumentManager();        pdm.AddDocument(new Document(&quot;one&quot;, &quot;Sample&quot;, 8));        pdm.AddDocument(new Document(&quot;two&quot;, &quot;Sample&quot;, 3));        pdm.AddDocument(new Document(&quot;three&quot;, &quot;Sample&quot;, 4));        pdm.AddDocument(new Document(&quot;four&quot;, &quot;Sample&quot;, 8));        pdm.AddDocument(new Document(&quot;five&quot;, &quot;Sample&quot;, 1));        pdm.AddDocument(new Document(&quot;six&quot;, &quot;Sample&quot;, 9));        pdm.AddDocument(new Document(&quot;seven&quot;, &quot;Sample&quot;, 1));        pdm.AddDocument(new Document(&quot;eight&quot;, &quot;Sample&quot;, 1));        pdm.DisplayAllNodes();    &#125;  &#125;</code></pre><h2 id="6-有序列表"><a href="#6-有序列表" class="headerlink" title="6.有序列表"></a>6.有序列表</h2><p>SortedList基于键对集合进行排序.</p><pre><code>class Program  &#123;    static void Main()    &#123;      var books = new SortedList&lt;string, string&gt;();      books.Add(&quot;sty&quot;, &quot;&quot;);      books.Add(&quot;abc&quot;, &quot;&quot;);      books.Add(&quot;123&quot;, &quot;&quot;);      foreach (var item in books.Keys)      &#123;          Console.WriteLine(item);      &#125;    &#125;  &#125;</code></pre><h2 id="7-字典"><a href="#7-字典" class="headerlink" title="7.字典"></a>7.字典</h2><p>字典：用于在名称/值对中存储信息，字典的名称即键不能重复.</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523142813132-1598220317.png" alt="img"></p><p>HashTable和Dictionary</p><p>1.HashTable大数据量插入数据时需要花费比Dictionary大的多的时间。</p><p>2.for方式遍历HashTable和Dictionary速度最快。</p><p>3.在foreach方式遍历时Dictionary遍历速度更快。</p><p>4.HashTable在取值时需要进行类型转换,Dictionary不用做类型转换。</p><p>在单线程的时候使用Dictionary更好一些，多线程的时候使用HashTable更好。</p><p>有序字典SortedList和SortedDictionary</p><p><strong>SortedDictionary</strong> 泛型类是检索运算复杂度为 O(log n) 的二叉搜索树，其中 n 是字典中的元素数。就这一点而言，它与 <a href="http://blog.csdn.net/nma_123456/article/details/7298343">SortedList</a> 泛型类相似。这两个类具有相似的对象模型，并且都具有 O(log n) 的检索运算复杂度。这两个类的区别在于内存的使用以及插入和移除元素的速度：</p><ul><li><strong>SortedList</strong> 使用的内存比 <strong>SortedDictionary</strong> 少。</li><li><strong>SortedDictionary</strong> 可对未排序的数据执行更快的插入和移除操作：它的时间复杂度为 O(log n)，而<strong>SortedList</strong> 为 O(n)。</li><li>如果使用排序数据一次性填充列表，则 <strong>SortedList</strong> 比 <strong>SortedDictionary</strong> 快。</li><li></li></ul><h2 id="8-集"><a href="#8-集" class="headerlink" title="8.集"></a>8.集</h2><p>包含不重复元素的集合，叫“集”。.NET包含2个集。HashSet<T>和SortedSet<T>，它们继承ISet;SortedSet是一个有序集.</T></T></p><p>ISet提供了Add方法,如果HashSet中存在这个元素，再次使用Add方法不会抛出异常，返回bool值是否添加</p><blockquote><p>var companyTeams = new HashSet<string>() { “Ferrari”, “McLaren”, “Mercedes” };<br>var traditionalTeams = new HashSet<string>() { “Ferrari”, “McLaren” };<br>var privateTeams = new HashSet<string>() { “Red Bull”, “Lotus”, “Toro Rosso”, “Force India”, “Sauber” };</string></string></string></p><p>if (privateTeams.Add(“Williams”))<br>    Console.WriteLine(“Williams added”);<br>if (!companyTeams.Add(“McLaren”))<br>    Console.WriteLine(“McLaren was already in this set”);</p></blockquote><pre><code>IsSubsetOf方法判断了traditionalTeams集合是否companyTeams的子集IsSupersetOf方法判断了companyTeams集合是否traditionalTeams的超集(包含它拥有的所有元素，并且多余它的元素)</code></pre><pre><code>var companyTeams = new HashSet&lt;string&gt;() &#123; &quot;Ferrari&quot;, &quot;McLaren&quot;, &quot;Mercedes&quot; &#125;;var traditionalTeams = new HashSet&lt;string&gt;() &#123; &quot;Ferrari&quot;, &quot;McLaren&quot; &#125;;var privateTeams = new HashSet&lt;string&gt;() &#123; &quot;Red Bull&quot;, &quot;Lotus&quot;, &quot;Toro Rosso&quot;, &quot;Force India&quot;, &quot;Sauber&quot; &#125;;if (traditionalTeams.IsSubsetOf(companyTeams))&#123;  Console.WriteLine(&quot;traditionalTeams is subset of companyTeams&quot;);&#125;if (companyTeams.IsSupersetOf(traditionalTeams))&#123;   Console.WriteLine(&quot;companyTeams is a superset of traditionalTeams&quot;);&#125;SortedSet的UnionWith方法可以修改这个集合，并且包含传入的集合var allTeams = new SortedSet&lt;string&gt;(companyTeams);allTeams.UnionWith(privateTeams);allTeams.UnionWith(traditionalTeams);</code></pre><h2 id="9-可视察的集合"><a href="#9-可视察的集合" class="headerlink" title="9.可视察的集合"></a>9.可视察的集合</h2><p>如果需要记录集合何时添加和删除元素的信息，可以使用ObservableCollection<T>,这个本身是为WPF定制的。</T></p><p>ObservableCollection<T>类用于创建自定义集合，在内部使用List<T>类,重写虚方法RemoveItem和SetItem()方法触发CollectionChanged事件。</T></T></p><pre><code>class Program  &#123;    static void Main()    &#123;      var data = new ObservableCollection&lt;string&gt;();      data.CollectionChanged += Data_CollectionChanged;      data.Add(&quot;One&quot;);      data.Add(&quot;Two&quot;);      data.Insert(1, &quot;Three&quot;);      data.Remove(&quot;One&quot;);    &#125;    static void Data_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)    &#123;      Console.WriteLine(&quot;action: &#123;0&#125;&quot;, e.Action.ToString());      if (e.OldItems != null)      &#123;        Console.WriteLine(&quot;starting index for old item(s): &#123;0&#125;&quot;, e.OldStartingIndex);        Console.WriteLine(&quot;old item(s):&quot;);        foreach (var item in e.OldItems)        &#123;          Console.WriteLine(item);        &#125;      &#125;      if (e.NewItems != null)      &#123;        Console.WriteLine(&quot;starting index for new item(s): &#123;0&#125;&quot;, e.NewStartingIndex);        Console.WriteLine(&quot;new item(s): &quot;);        foreach (var item in e.NewItems)        &#123;          Console.WriteLine(item);        &#125;      &#125;      Console.WriteLine();    &#125;  &#125;</code></pre><p>Data_CollectionChanged方法接收了NotifyCollectionChangedEventArgs，包含了集合的变化信息，Action属性给出了是否添加或删除一项的信息，对于删除的项，会设置OldItems属性，列出删除的项</p><p>对于添加的项，会设置NewItems属性，列出添加的项。</p><pre><code>action: Addstarting index for new item(s): 0new item(s):Oneaction: Addstarting index for new item(s): 1new item(s):Twoaction: Addstarting index for new item(s): 1new item(s):Threeaction: Removestarting index for old item(s): 0old item(s):One</code></pre><h2 id="10-位数组"><a href="#10-位数组" class="headerlink" title="10.位数组"></a>10.位数组</h2><h3 id="BitArray类的方法和属性"><a href="#BitArray类的方法和属性" class="headerlink" title="BitArray类的方法和属性"></a>BitArray类的方法和属性</h3><p>下表列出了一些BitArray类的常用属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Count</td><td>获取包含在BitArray元素的数量</td></tr><tr><td>IsReadOnly</td><td>获取一个值，指示BitArray是否是只读</td></tr><tr><td>Item</td><td>获取或设置在所述BitArray的特定位置的比特的值</td></tr><tr><td>Length</td><td>获取或设置在BitArray元素的数量</td></tr></tbody></table><p>下表列出了一些BitArray类的常用方法：</p><table><thead><tr><th>S.N</th><th>方法名称及用途</th></tr></thead><tbody><tr><td>1</td><td><strong>public BitArray And( BitArray value );</strong>  执行对指定BitArray的相应元素在当前BitArray元素的按位与运算</td></tr><tr><td>2</td><td><strong>public bool Get( int index );</strong>  获取在所述BitArray的特定位置的比特的值</td></tr><tr><td>3</td><td><strong>public BitArray Not();</strong> 反转当前BitArray所有的位值，使设置为true的元素被更改为false，并设置为false元素更改为true</td></tr><tr><td>4</td><td><strong>public BitArray Or( BitArray value );</strong>  在执行对指定BitArray的相应元素在当前BitArray的元素的按位或操作</td></tr><tr><td>5</td><td><strong>public void Set( int index, bool value );</strong>  设置在所述BitArray为指定值的特定位置的比特值</td></tr><tr><td>6</td><td><strong>public void SetAll( bool value );</strong>  设置在BitArray所有位设置为指定值</td></tr><tr><td>7</td><td><strong>public BitArray Xor( BitArray value );</strong>  执行关于对在指定BitArray的相应元素中的当前BitArray的元素按位异或运算</td></tr></tbody></table><p>当需要存储位，但不知道事先比特数就使用它。您可以通过使用一个整数索引，它从零开始访问BitArray集合中的项。</p><pre><code>using System;using System.Collections;namespace CollectionsApplication&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //creating two  bit arrays of size 8            BitArray ba1 = new BitArray(8);            BitArray ba2 = new BitArray(8);            byte[] a = &#123; 60 &#125;;            byte[] b = &#123; 13 &#125;;                        //storing the values 60, and 13 into the bit arrays            ba1 = new BitArray(a);            ba2 = new BitArray(b);            //content of ba1            Console.WriteLine(&quot;Bit array ba1: 60&quot;);            for (int i = 0; i &lt; ba1.Count; i++)            &#123;                Console.Write(&quot;&#123;0, -6&#125; &quot;, ba1[i]);            &#125;            Console.WriteLine();                        //content of ba2            Console.WriteLine(&quot;Bit array ba2: 13&quot;);            for (int i = 0; i &lt; ba2.Count; i++)            &#123;                Console.Write(&quot;&#123;0, -6&#125; &quot;, ba2[i]);            &#125;            Console.WriteLine();                                   BitArray ba3 = new BitArray(8);            ba3 = ba1.And(ba2);            //content of ba3            Console.WriteLine(&quot;Bit array ba3 after AND operation: 12&quot;);            for (int i = 0; i &lt; ba3.Count; i++)            &#123;                Console.Write(&quot;&#123;0, -6&#125; &quot;, ba3[i]);            &#125;            Console.WriteLine();            ba3 = ba1.Or(ba2);            //content of ba3            Console.WriteLine(&quot;Bit array ba3 after OR operation: 61&quot;);            for (int i = 0; i &lt; ba3.Count; i++)            &#123;                Console.Write(&quot;&#123;0, -6&#125; &quot;, ba3[i]);            &#125;            Console.WriteLine();                        Console.ReadKey();        &#125;    &#125;&#125;</code></pre><p>让我们编译和运行上面的程序，这将产生以下结果：</p><pre><code>Bit array ba1: 60 False False True True True True False False Bit array ba2: 13True False True True False False False False Bit array ba3 after AND operation: 12False False True True False False False False Bit array ba3 after OR operation: 61True False True True False False False False </code></pre><h6 id="BitVector32"><a href="#BitVector32" class="headerlink" title="BitVector32"></a><a href="http://www.cnblogs.com/kingdom_0/articles/2024941.html">BitVector32</a></h6><p>提供了一个简单结构，该结构以32位内存存储布尔和小数值</p><p>对于内部使用的布尔值和小整数，BitVector32 比 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.bitarray.aspx">BitArray</a> 更有效。 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.bitarray.aspx">BitArray</a> 可以按需要无限地扩大，但它有内存和性能方面的系统开销，这是类实例所要求的。 相比之下，BitVector32 只使用 32 位。</p><p>BitVector32 结构可以设置成包含小整数的若干节或包含布尔值的若干位标志，但不能同时包含两者。<a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.section.aspx">BitVector32.Section</a> 是 BitVector32 中的窗口，且由最小数量的连续位构成，连续位可以包含 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.createsection.aspx">CreateSection</a> 中指定的最大值。 例如，带有最大值 1 的节只由一个位构成，而带有最大值 5 的节由三个位构成。 可以创建带有最大值 1 的 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.section.aspx">BitVector32.Section</a> 作为布尔值，从而使您能够在同一 BitVector32 中存储整数和布尔值。</p><p>BitVector32 既可以设置为节，也可以设置为位标志，分别有成员可以应用于这两种情形。 例如，<a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.item.aspx">BitVector32.Item</a> 属性是作为节设置的 BitVector32 的索引器，而 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.item.aspx">BitVector32.Item</a> 属性是作为位标志设置的BitVector32 的索引器。 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.specialized.bitvector32.createmask.aspx">CreateMask</a> 创建一系列屏蔽，这些屏蔽可用于访问作为位标志设置的 BitVector32 中的单个位。</p><p>在作为节设置的 BitVector32 上使用屏蔽可能会导致意外的结果</p><pre><code>using System;using System.Collections.Specialized;public class SamplesBitVector32  &#123;   public static void Main()  &#123;      // Creates and initializes a BitVector32 with all bit flags set to FALSE.      BitVector32 myBV = new BitVector32( 0 );      // Creates masks to isolate each of the first five bit flags.      int myBit1 = BitVector32.CreateMask();      int myBit2 = BitVector32.CreateMask( myBit1 );      int myBit3 = BitVector32.CreateMask( myBit2 );      int myBit4 = BitVector32.CreateMask( myBit3 );      int myBit5 = BitVector32.CreateMask( myBit4 );      // Sets the alternating bits to TRUE.      Console.WriteLine( &quot;Setting alternating bits to TRUE:&quot; );      Console.WriteLine( &quot;   Initial:         &#123;0&#125;&quot;, myBV.ToString() );      myBV[myBit1] = true;      Console.WriteLine( &quot;   myBit1 = TRUE:   &#123;0&#125;&quot;, myBV.ToString() );      myBV[myBit3] = true;      Console.WriteLine( &quot;   myBit3 = TRUE:   &#123;0&#125;&quot;, myBV.ToString() );      myBV[myBit5] = true;      Console.WriteLine( &quot;   myBit5 = TRUE:   &#123;0&#125;&quot;, myBV.ToString() );   &#125;&#125;/*This code produces the following output.Setting alternating bits to TRUE:   Initial:         BitVector32&#123;00000000000000000000000000000000&#125;   myBit1 = TRUE:   BitVector32&#123;00000000000000000000000000000001&#125;   myBit3 = TRUE:   BitVector32&#123;00000000000000000000000000000101&#125;   myBit5 = TRUE:   BitVector32&#123;00000000000000000000000000010101&#125;*/BitVector用作节集合using System;using System.Collections.Specialized;public class SamplesBitVector32  &#123;   public static void Main()  &#123;      // Creates and initializes a BitVector32.      BitVector32 myBV = new BitVector32( 0 );      // Creates four sections in the BitVector32 with maximum values 6, 3, 1, and 15.      // mySect3, which uses exactly one bit, can also be used as a bit flag.      BitVector32.Section mySect1 = BitVector32.CreateSection( 6 );      BitVector32.Section mySect2 = BitVector32.CreateSection( 3, mySect1 );      BitVector32.Section mySect3 = BitVector32.CreateSection( 1, mySect2 );      BitVector32.Section mySect4 = BitVector32.CreateSection( 15, mySect3 );      // Displays the values of the sections.      Console.WriteLine( &quot;Initial values:&quot; );      Console.WriteLine( &quot;\tmySect1: &#123;0&#125;&quot;, myBV[mySect1] );      Console.WriteLine( &quot;\tmySect2: &#123;0&#125;&quot;, myBV[mySect2] );      Console.WriteLine( &quot;\tmySect3: &#123;0&#125;&quot;, myBV[mySect3] );      Console.WriteLine( &quot;\tmySect4: &#123;0&#125;&quot;, myBV[mySect4] );      // Sets each section to a new value and displays the value of the BitVector32 at each step.      Console.WriteLine( &quot;Changing the values of each section:&quot; );      Console.WriteLine( &quot;\tInitial:    \t&#123;0&#125;&quot;, myBV.ToString() );      myBV[mySect1] = 5;      Console.WriteLine( &quot;\tmySect1 = 5:\t&#123;0&#125;&quot;, myBV.ToString() );      myBV[mySect2] = 3;      Console.WriteLine( &quot;\tmySect2 = 3:\t&#123;0&#125;&quot;, myBV.ToString() );      myBV[mySect3] = 1;      Console.WriteLine( &quot;\tmySect3 = 1:\t&#123;0&#125;&quot;, myBV.ToString() );      myBV[mySect4] = 9;      Console.WriteLine( &quot;\tmySect4 = 9:\t&#123;0&#125;&quot;, myBV.ToString() );      // Displays the values of the sections.      Console.WriteLine( &quot;New values:&quot; );      Console.WriteLine( &quot;\tmySect1: &#123;0&#125;&quot;, myBV[mySect1] );      Console.WriteLine( &quot;\tmySect2: &#123;0&#125;&quot;, myBV[mySect2] );      Console.WriteLine( &quot;\tmySect3: &#123;0&#125;&quot;, myBV[mySect3] );      Console.WriteLine( &quot;\tmySect4: &#123;0&#125;&quot;, myBV[mySect4] );   &#125;&#125;</code></pre><h2 id="11-不变的集合"><a href="#11-不变的集合" class="headerlink" title="11.不变的集合"></a>11.不变的集合</h2><p><strong>Net提供的不可变集合</strong></p><pre><code>ImmutableStack&lt;int&gt; a1 = ImmutableStack&lt;int&gt;.Empty;ImmutableStack&lt;int&gt; a2 = a1.Push(10);ImmutableStack&lt;int&gt; a3 = a2.Push(20);ImmutableStack&lt;int&gt; a4 = a3.Push(30);ImmutableStack&lt;int&gt; iv3 = a4.Pop(); </code></pre><p>使用Net不可变列表集合有一点要注意的是，当我们Push值时要重新赋值给原变量才正确，因为push后会生成一个新对象，原a1只是旧值：</p><pre><code>ImmutableStack&lt;int&gt; a1 = ImmutableStack&lt;int&gt;.Empty;a1.Push(10); //不正确，a1仍是空值值，push会生成新的栈。a1 = a1.Push(10); //需要将新栈重新赋值给a1</code></pre><p><strong>NET提供的常用数据结构</strong></p><p>1.ImmutableStack<br>2.ImmutableQueue<br>3.ImmutableList<br>4.ImmutableHashSet<br>5.ImmutableSortedSet<br>6.ImmutableDictionary&lt;K, V&gt;<br>7.ImmutableSortedDictionary&lt;K, V&gt;</p><p><strong>不可变优点</strong></p><p>1.集合共享安全，从不被改变<br>2.访问集合时，不需要锁集合（线程安全）<br>3.修改集合不担心旧集合被改变<br>4.书写更简洁，函数式风格。 var list = ImmutableList.Empty.Add(10).Add(20).Add(30);<br>5.保证数据完整性，安全性</p><p><strong>不可变对象缺点</strong></p><p>不可变本身的优点即是缺点，当每次对象/集合操作都会返回个新值。而旧值依旧会保留一段时间，这会使内存有极大开销，也会给GC造成回收负担，性能也比可变集合差的多。</p><h2 id="12-并发集合"><a href="#12-并发集合" class="headerlink" title="12.并发集合"></a>12.并发集合</h2><p>线程安全的集合可防止多个线程以相互冲突的方式访问集合</p><p>.NET 的System.Collections.Concurrent提供了几个安全的类和功能：</p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd267312.aspx">BlockingCollection</a></td><td>为实现 <a href="https://msdn.microsoft.com/zh-cn/library/dd287147.aspx">IProducerConsumerCollection</a> 的线程安全集合提供阻塞和限制功能。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd381779.aspx">ConcurrentBag</a></td><td>表示对象的线程安全的无序集合。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd287191.aspx">ConcurrentDictionary</a></td><td>表示可由多个线程同时访问的键/值对的线程安全集合。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd267265.aspx">ConcurrentQueue</a></td><td>表示线程安全的先进先出 (FIFO) 集合。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd267331.aspx">ConcurrentStack</a></td><td>表示线程安全的后进先出 (LIFO) 集合。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd394988.aspx">OrderablePartitioner</a></td><td>表示将可排序数据源拆分为多个分区的特定方式。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/system.collections.concurrent.partitioner.aspx">Partitioner</a></td><td>为数组、列表和可枚举对象提供常见的分区策略。</td></tr><tr><td><a href="https://msdn.microsoft.com/zh-cn/library/dd381768.aspx">Partitioner</a></td><td>表示将数据源拆分为多个分区的特定方式。</td></tr></tbody></table><h3 id="1-创建管道"><a href="#1-创建管道" class="headerlink" title="1)创建管道"></a>1)创建管道</h3><p>将这些并发集合类用于管道,一个任务向一个集合类写入一些内容，同时另一个任务从该集合中读取内容</p><p>示例中多个任务形成一个管道.<br>第一个管道，<br>第1阶段的任务读取文件名，添加到队列，这个任务运行同时，<br>第2阶段的任务已经开始从队列中读取文件名并加载它们的程序,结果被写入另一个队列。<br>第3阶段同时启动，读取并处理第2个队列的内容，结果被写入一个字典。</p><p>第3阶段完成，并且内容已被最终处理，字典得到完整结果时，下一阶段才开始。<br>第4阶段从字典中读取内容，转换数据，然后写入队列中<br>第5阶段在项中添加颜色信息，然后把它们添加到另一个队列中，最后一个阶段显示信息。<br>第4到第6阶段也可以并发运行.</p><pre><code>class Program  &#123;    static void Main(string[] args)    &#123;      StartPipeline();      Console.ReadLine();    &#125;    private static async void StartPipeline()    &#123;      var fileNames = new BlockingCollection&lt;string&gt;();      var lines = new BlockingCollection&lt;string&gt;();      var words = new ConcurrentDictionary&lt;string, int&gt;();      var items = new BlockingCollection&lt;Info&gt;();      var coloredItems = new BlockingCollection&lt;Info&gt;();      Task t1 = PipelineStages.ReadFilenamesAsync(@&quot;../../..&quot;, fileNames);      ConsoleHelper.WriteLine(&quot;started stage 1&quot;);      Task t2 = PipelineStages.LoadContentAsync(fileNames, lines);      ConsoleHelper.WriteLine(&quot;started stage 2&quot;);      Task t3 = PipelineStages.ProcessContentAsync(lines, words);      await Task.WhenAll(t1, t2, t3);      ConsoleHelper.WriteLine(&quot;stages 1, 2, 3 completed&quot;);      Task t4 = PipelineStages.TransferContentAsync(words, items);      Task t5 = PipelineStages.AddColorAsync(items, coloredItems);      Task t6 = PipelineStages.ShowContentAsync(coloredItems);      ConsoleHelper.WriteLine(&quot;stages 4, 5, 6 started&quot;);      await Task.WhenAll(t4, t5, t6);      ConsoleHelper.WriteLine(&quot;all stages finished&quot;);    &#125;  &#125;</code></pre><pre><code>public class ConsoleHelper  &#123;    private static object syncOutput = new object();    public static void WriteLine(string message)    &#123;      lock (syncOutput)      &#123;        Console.WriteLine(message);      &#125;    &#125;    public static void WriteLine(string message, string color)    &#123;      lock (syncOutput)      &#123;        Console.ForegroundColor = (ConsoleColor)Enum.Parse(typeof(ConsoleColor), color);        Console.WriteLine(message);        Console.ResetColor();      &#125;    &#125;  &#125;</code></pre><pre><code>public static class PipelineStages  &#123;    public static Task ReadFilenamesAsync(string path, BlockingCollection&lt;string&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (string filename in Directory.EnumerateFiles(path, &quot;*.cs&quot;, SearchOption.AllDirectories))          &#123;            output.Add(filename);            ConsoleHelper.WriteLine(string.Format(&quot;stage 1: added &#123;0&#125;&quot;, filename));          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static async Task LoadContentAsync(BlockingCollection&lt;string&gt; input, BlockingCollection&lt;string&gt; output)    &#123;      foreach (var filename in input.GetConsumingEnumerable())      &#123;        using (FileStream stream = File.OpenRead(filename))        &#123;          var reader = new StreamReader(stream);          string line = null;          while ((line = await reader.ReadLineAsync()) != null)          &#123;            output.Add(line);            ConsoleHelper.WriteLine(string.Format(&quot;stage 2: added &#123;0&#125;&quot;, line));          &#125;        &#125;      &#125;      output.CompleteAdding();    &#125;    public static Task ProcessContentAsync(BlockingCollection&lt;string&gt; input, ConcurrentDictionary&lt;string, int&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var line in input.GetConsumingEnumerable())          &#123;            string[] words = line.Split(&#39; &#39;, &#39;;&#39;, &#39;\t&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;:&#39;, &#39;,&#39;, &#39;&quot;&#39;);            foreach (var word in words.Where(w =&gt; !string.IsNullOrEmpty(w)))            &#123;              output.AddOrIncrementValue(word);              ConsoleHelper.WriteLine(string.Format(&quot;stage 3: added &#123;0&#125;&quot;, word));            &#125;          &#125;        &#125;);    &#125;    public static Task TransferContentAsync(ConcurrentDictionary&lt;string, int&gt; input, BlockingCollection&lt;Info&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var word in input.Keys)          &#123;            int value;            if (input.TryGetValue(word, out value))            &#123;              var info = new Info &#123; Word = word, Count = value &#125;;              output.Add(info);              ConsoleHelper.WriteLine(string.Format(&quot;stage 4: added &#123;0&#125;&quot;, info));            &#125;          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static Task AddColorAsync(BlockingCollection&lt;Info&gt; input, BlockingCollection&lt;Info&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var item in input.GetConsumingEnumerable())          &#123;            if (item.Count &gt; 40)            &#123;              item.Color = &quot;Red&quot;;            &#125;            else if (item.Count &gt; 20)            &#123;              item.Color = &quot;Yellow&quot;;            &#125;            else            &#123;              item.Color = &quot;Green&quot;;            &#125;            output.Add(item);            ConsoleHelper.WriteLine(string.Format(&quot;stage 5: added color &#123;1&#125; to &#123;0&#125;&quot;, item, item.Color));          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static Task ShowContentAsync(BlockingCollection&lt;Info&gt; input)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var item in input.GetConsumingEnumerable())          &#123;            ConsoleHelper.WriteLine(string.Format(&quot;stage 6: &#123;0&#125;&quot;, item), item.Color);          &#125;        &#125;);    &#125;  &#125;</code></pre><p>2)使用<a href="https://msdn.microsoft.com/zh-cn/library/dd267312.aspx">BlockingCollection</a></p><p>第1阶段的ReadFilenamesAsync方法，实现了迭代目录文件名。在完成文件名添加后调用output.CompleteAdding();用以通知所有读取器不再等待集合中任何额外的项.如果没有调用的话，循环中读取器会添加等待更多的项.</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>public static Task ReadFilenamesAsync(string path, BlockingCollection&lt;string&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (string filename in Directory.EnumerateFiles(path, &quot;*.cs&quot;, SearchOption.AllDirectories))          &#123;            output.Add(filename);            ConsoleHelper.WriteLine(string.Format(&quot;stage 1: added &#123;0&#125;&quot;, filename));          &#125;          output.CompleteAdding();        &#125;);    &#125;</code></pre><p>ReadFilenamesAsync </p><p>下一阶段读取文件并将器内容添加到另一个集合中，由LoadContentAsync方法完成，该方法使用了输入集合传递的文件名，打开文件，把文件中的所有行添加到输出的集合中。在循环中用输入阻塞集合调用GetConsumingEnumerable()方法，以迭代各项，不使用也是可以的，但是值会迭代当前状态的集合。不会迭代以后添加的项。</p><p>如果在填充集合的同时，使用读取器读取集合，则需要使用GetConsumingEnumerable()方法获取阻塞集合的枚举器，而不是直接迭代集合</p><pre><code>public static async Task LoadContentAsync(BlockingCollection&lt;string&gt; input, BlockingCollection&lt;string&gt; output)    &#123;      foreach (var filename in input.GetConsumingEnumerable())      &#123;        using (FileStream stream = File.OpenRead(filename))        &#123;          var reader = new StreamReader(stream);          string line = null;          while ((line = await reader.ReadLineAsync()) != null)          &#123;            output.Add(line);            ConsoleHelper.WriteLine(string.Format(&quot;stage 2: added &#123;0&#125;&quot;, line));          &#125;        &#125;      &#125;      output.CompleteAdding();    &#125;</code></pre><p>3)使用<a href="https://msdn.microsoft.com/zh-cn/library/dd287191.aspx">ConcurrentDictionary</a></p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523162236413-845354975.png" alt="img"></p><pre><code>public static Task ProcessContentAsync(BlockingCollection&lt;string&gt; input, ConcurrentDictionary&lt;string, int&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var line in input.GetConsumingEnumerable())          &#123;            string[] words = line.Split(&#39; &#39;, &#39;;&#39;, &#39;\t&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;:&#39;, &#39;,&#39;, &#39;&quot;&#39;);            foreach (var word in words.Where(w =&gt; !string.IsNullOrEmpty(w)))            &#123;              output.AddOrIncrementValue(word);              ConsoleHelper.WriteLine(string.Format(&quot;stage 3: added &#123;0&#125;&quot;, word));            &#125;          &#125;        &#125;);    &#125;</code></pre><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523162311476-1014974724.png" alt="img"></p><pre><code>public static class ConcurrentDictionaryExtension  &#123;    public static void AddOrIncrementValue(this ConcurrentDictionary&lt;string, int&gt; dict, string key)    &#123;      bool success = false;      while (!success)      &#123;        int value;        if (dict.TryGetValue(key, out value))        &#123;          if (dict.TryUpdate(key, value + 1, value))          &#123;            success = true;          &#125;        &#125;        else        &#123;          if (dict.TryAdd(key, 1))          &#123;            success = true;          &#125;        &#125;      &#125;    &#125;  &#125;</code></pre><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523162341117-33389163.png" alt="img"></p><p>在完成第3个阶段后，第4到6阶段也可以并行运行，TransferContentAsync从字典中获取数据，进行类型转换，输出到BlockingCollection<string>中</string></p><pre><code>public static Task ProcessContentAsync(BlockingCollection&lt;string&gt; input, ConcurrentDictionary&lt;string, int&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var line in input.GetConsumingEnumerable())          &#123;            string[] words = line.Split(&#39; &#39;, &#39;;&#39;, &#39;\t&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;:&#39;, &#39;,&#39;, &#39;&quot;&#39;);            foreach (var word in words.Where(w =&gt; !string.IsNullOrEmpty(w)))            &#123;              output.AddOrIncrementValue(word);              ConsoleHelper.WriteLine(string.Format(&quot;stage 3: added &#123;0&#125;&quot;, word));            &#125;          &#125;        &#125;);    &#125;    public static Task TransferContentAsync(ConcurrentDictionary&lt;string, int&gt; input, BlockingCollection&lt;Info&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var word in input.Keys)          &#123;            int value;            if (input.TryGetValue(word, out value))            &#123;              var info = new Info &#123; Word = word, Count = value &#125;;              output.Add(info);              ConsoleHelper.WriteLine(string.Format(&quot;stage 4: added &#123;0&#125;&quot;, info));            &#125;          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static Task AddColorAsync(BlockingCollection&lt;Info&gt; input, BlockingCollection&lt;Info&gt; output)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var item in input.GetConsumingEnumerable())          &#123;            if (item.Count &gt; 40)            &#123;              item.Color = &quot;Red&quot;;            &#125;            else if (item.Count &gt; 20)            &#123;              item.Color = &quot;Yellow&quot;;            &#125;            else            &#123;              item.Color = &quot;Green&quot;;            &#125;            output.Add(item);            ConsoleHelper.WriteLine(string.Format(&quot;stage 5: added color &#123;1&#125; to &#123;0&#125;&quot;, item, item.Color));          &#125;          output.CompleteAdding();        &#125;);    &#125;    public static Task ShowContentAsync(BlockingCollection&lt;Info&gt; input)    &#123;      return Task.Run(() =&gt;        &#123;          foreach (var item in input.GetConsumingEnumerable())          &#123;            ConsoleHelper.WriteLine(string.Format(&quot;stage 6: &#123;0&#125;&quot;, item), item.Color);          &#125;        &#125;);    &#125;</code></pre><h2 id="13-性能"><a href="#13-性能" class="headerlink" title="13.性能"></a>13.性能</h2><p>集合的方法常常有性能提示，给出大写O记录操作时间。</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523162826570-2112606748.png" alt="img"></p><p>O(1)表示无论集合中有多少数据项，这个操作需要的时间都不变。<br>O(n)表示对于集合执行一个操作需要的事件在最坏情况时是N.<br>O(log n)表示操作需要的时间随集合中元素的增加而增加</p><p><img src="https://images2015.cnblogs.com/blog/618680/201705/618680-20170523163051320-952892312.png" alt="img"></p><h3 id="非泛型类集合"><a href="#非泛型类集合" class="headerlink" title="非泛型类集合"></a>非泛型类集合</h3><p>泛型集合类是在.NET2.0的时候出来的,也就是说在1.0的时候是没有这么方便的东西的。现在基本上我们已经不使用这些集合类了，除非在做一些和老代码保持兼容的工作的时候。来看看1.0时代的.NET程序员们都有哪些集合类可以用。</p><p>ArraryList后来被List<T>替代。</T></p><p>HashTable 后来被Dictionary&lt;TKey,TValue&gt;替代。<br>Queue 后来被Queue<T>替代。<br>SortedList 后来被SortedList<T>替代。<br>Stack 后来被Stack<T>替代。</T></T></T></p><h3 id="线程安全的集合类"><a href="#线程安全的集合类" class="headerlink" title="线程安全的集合类"></a>线程安全的集合类</h3><p>ConcurrentQueue 线程安全版本的Queue<br>ConcurrentStack线程安全版本的Stack<br>ConcurrentBag线程安全的对象集合<br>ConcurrentDictionary线程安全的Dictionary<br>BlockingCollection</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第十章 字符串和正则表达式</title>
      <link href="2021/02/20/c-10/c-10th-10/"/>
      <url>2021/02/20/c-10/c-10th-10/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第十章-字符串和正则表达式"><a href="#c-语言-第十章-字符串和正则表达式" class="headerlink" title="c#语言 第十章 字符串和正则表达式"></a>c#语言 第十章 字符串和正则表达式</h1><p>10.1 System.String类</p><p>​        System.String是一个类，专门用于存储字符串，允许对字符串进行许多操作。C#提供了关键字string和相关的语法，以便使用这个类更轻松。</p><blockquote><pre><code>你可以通过运算符重载连接字符串string message1 = &quot;hello&quot;;message1 += &quot; world&quot;;Console.WriteLine(message1);</code></pre></blockquote><blockquote><pre><code>C#还允许通过使用类似索引器的语法来提取字符串中的指定字符：string message1 = &quot;hello&quot;;char char1 = message1[0];Console.WriteLine(char1);</code></pre></blockquote><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Compare</td><td>比较字符串的内容，考虑区域设置之间的某些字符的等价性。</td></tr><tr><td>CompareOrdinal</td><td>比较字符串的内容，但不考虑区域设置。</td></tr><tr><td>Concat</td><td>将不同的字符串实例合并成一个字符串实例。</td></tr><tr><td>CopyTo</td><td>将指定序号，指定长度的字符拷贝到另外一个新建的数组中。</td></tr><tr><td>Format</td><td>根据指定的格式格式化一个含有多种数值的字符串。</td></tr><tr><td>IndexOf</td><td>定位某个字符或者子串在字符串中首次出现的位置。</td></tr><tr><td>IndexOfAny</td><td>定位一组字符中任意一个字符在字符串中首次出现的位置。</td></tr><tr><td>Insert</td><td>在指定位置插入另外一个字符串。</td></tr><tr><td>Join</td><td>按照要求将一个字符串数组合并成一个字符串实例。</td></tr><tr><td>LastIndexOf</td><td>跟IndexOf一样，但返回最后一次出现的位置。</td></tr><tr><td>LastIndexOfAny</td><td>跟IndexOfAny一样，但返回最后一次出现的位置。</td></tr><tr><td>PadLeft</td><td>如果字符串不够指定位数，则在其左侧按给定字符补全位数。</td></tr><tr><td>PadRight</td><td>如果字符串不够指定位数，则在其右侧按给定字符补全位数。</td></tr><tr><td>Replace</td><td>将指定字符或者子串替换成另外一个字符或者子串。</td></tr><tr><td>Split</td><td>根据指定字符分隔成若干子串。</td></tr><tr><td>Substring</td><td>根据指定位置和长度获取一个子串。</td></tr><tr><td>ToLower</td><td>转成小写。</td></tr><tr><td>ToUpper</td><td>转成大写。</td></tr><tr><td>Trim</td><td>移除字符串开头与结尾的空格。</td></tr></tbody></table><p>10.1.1构建字符串</p><p>​        String类存在一个问题：重复修改给定的字符串，效率会很低，它实际上是一个不可变的数据类型，一旦对字符串对象进行了初始化，该字符串对象就不能改变了</p><blockquote><pre><code>string message1 = &quot;hello&quot;;message1 = &quot;hello world&quot;;</code></pre></blockquote><p>​        表面上message1修改了字符串的内容，实际上是创建了一个新的字符串hello world然后将其指向meesage1，原来的hello字符串就没有变量引用它，下一次垃圾收集器清理时就会删除它</p><p>10.1.2 StringBuilder成员</p><p>​        实例化StringBuilder时有很多重载可以选择，其中就有提供一个字符串和给定容量</p><blockquote><pre><code>StringBuilder strb1 = new StringBuilder(&quot;hello&quot;);StringBuilder strb2 = new StringBuilder(100);</code></pre></blockquote><p>​        还可以随时显示地设置容量，当字符串长度超出时，就会抛出异常：</p><blockquote><pre><code>StringBuilder strb = new StringBuilder(&quot;1个字符&quot;);strb.Capacity = 1;</code></pre></blockquote><p>​        StringBuilder类上可以进行的处理仅限于替换和追加或删除字符串中的文本。StringBuilder转换为string的唯一方法就是使用ToString()方法。StringBuilder类基本上应在处理多个字符串时使用。</p><p>10.2字符串格式</p><p><strong>格式字符串</strong></p><p>例子：</p><pre><code>Console.WriteLine(&quot;张三有存款：&#123;0,10:C&#125;&quot;,1000);Console.WriteLine(&quot;李四有存款：&#123;0,10:C&#125;&quot;, 800);Console.WriteLine(&quot;赵六有存款：&#123;0,10:C&#125;&quot;, 20000);</code></pre><p>运行以上代码，结果如下：</p><p>​        解释一下{0,10:C}的作用，其中{0}是占位符，逗号后的数字是表示该项字符串要占用的字符宽度，冒号后面的字母是格式说明符。在使用格式说明符时，会检查占位符替换内容的类型是否实现IFormattable接口，如果没有则调用对象的ToString()方法。</p><p>​        在自定义类中实现IFormattable</p><blockquote><pre><code>1 class Program2 &#123;3     static void Main(string[] args)4     &#123;5         Person p = new Person();6         p.FirstName = &quot;zhang&quot;;7         p.SecondName = &quot;san&quot;;8         Console.WriteLine(&quot;无格式说明符：&#123;0&#125;&quot;, p);9         Console.WriteLine(&quot;格式说明符C：&#123;0:C&#125;&quot;, p);10         Console.WriteLine(&quot;格式说明符A：&#123;0:A&#125;&quot;, p);11     &#125;12 13 &#125;14 public class Person : IFormattable15 &#123;16     public string FirstName &#123; get; set; &#125;17     public string SecondName &#123; get; set; &#125;18     public string ToString(string format, IFormatProvider formatProvider)19     &#123;20         //当没有传入格式说明符时，直接调用ToString()21         if (format == null)22         &#123;23             return ToString();24         &#125;25         //C表示返回中国格式名字  A表示返回美国格式名字26         switch (format.ToUpper())27         &#123;28             case &quot;C&quot;:29                 return FirstName + SecondName;30             case &quot;A&quot;:31                 return SecondName + FirstName;32             default:33                 return ToString();34         &#125;35     &#125;36 &#125;</code></pre></blockquote><p>10.2.1字符串插值</p><p>10.2.2日期事件和数字格式</p><p>10.2.3自定义字符串格式</p><p>10.3正则表达式</p><p>​        .NET正则表达式引擎用于兼容Perl 5 的正则表达式</p><p>10.3.1正则表达式概述</p><p>​        正则表达式是一种专门用于字符串处理的语言</p><p>10.3.2RegularExpressionsPlayaround示例</p><blockquote><pre><code>MatchCollection match = Regex.Matches(&quot;happy hapy hay&quot;, &quot;ha.+?y&quot;);foreach (Match item in match)&#123;    Console.WriteLine(&quot;&#123;0&#125;位置，匹配到&#123;1&#125;&quot;, item.Index, item.Value);&#125;Console.ReadKey();</code></pre></blockquote><p>10.3.3显示结果</p><p>10.3.4匹配、组合捕获</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 字符串和正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第九章 运算符和强制类型转换</title>
      <link href="2021/02/20/c-10/c-10th-09/"/>
      <url>2021/02/20/c-10/c-10th-09/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第九章-委托、lambda表达式和事件"><a href="#c-语言-第九章-委托、lambda表达式和事件" class="headerlink" title="c#语言 第九章 委托、lambda表达式和事件"></a>c#语言 第九章 委托、lambda表达式和事件</h1><p>9.1引用方法</p><p>​        委托是寻址方法的.NET版本。委托是类型安全的类，它定义了返回类型和参数的类型。委托不仅包含对方法的引用，也可以包含对多个方法的引用。</p><p>​        Lambda表达式与委托直接相关。当参数是委托类型时，就可以使用lambda表达式实现委托引用的方法。</p><p>9.2委托</p><p>​        当要把方法传递给其它方法时，需要使用委托。委托是一种特殊类型的对象，其特殊之处在于，我们以前定义的所有对象都包含数据，而委托包含的只是一个或多个方法的地址。</p><p>9.2.1声明委托</p><p>​    委托使用关键字 delegate 进行定义。</p><p>例子：</p><p>​    定义一个返回类型为void参数为一个int的名为IntMethodInvoker的委托</p><blockquote><p>delegate void IntMethodInvoker(int x);</p></blockquote><p>​    因为定义委托基本上就是定义一个新类，所以可以在定义类的任何相同地方定义委托。可以在委托定义上应用常见的访问修饰符：public、private、protected等。</p><p>9.2.2使用委托</p><p>9.2.3简单的委托示例</p><blockquote><p>delegate int CalculateMethodInvoker(int x, int y);<br>class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        CalculateMethodInvoker calculateMethodInvoker = CalculateMethodHelper.Sum;<br>        int x = 100, y = 200;<br>        Console.WriteLine(“x,y相加：{0}”, Calculate(calculateMethodInvoker, x, y));<br>        calculateMethodInvoker = CalculateMethodHelper.Multiply;<br>        Console.WriteLine(“x,y相乘：{0}”, Calculate(calculateMethodInvoker, x, y));<br>        Console.ReadKey();<br>    }<br>    public static int Calculate(CalculateMethodInvoker calculateMethodInvoker, int x, int y)<br>    {<br>        return calculateMethodInvoker(x, y);<br>    }<br>}<br>public class CalculateMethodHelper<br>{<br>    public static int Sum(int x, int y)<br>    {<br>        return x + y;<br>    }<br>    public static int Multiply(int x, int y)<br>    {<br>        return x * y;<br>    }<br>}</p></blockquote><p>​        为了减少输入量，只需要委托实例，就可以只传递地址的名称。这称为委托推断。</p><p>9.2.4action<T>和Func<T>委托</T></T></p><p>​        除了为每个参数和返回类型定义一个新的委托类型外，还可以使用Action<T>和Func<T>委托。</T></T></p><p>​        泛型Action<T>委托表示引用一个void返回类型的方法，没有泛型参数的Action类可调用没有参数的方法。</T></p><p>​        泛型Func<T>委托表示引用一个有返回值的方法</T></p><p>9.2.5BubbleSorter示例</p><p>9.2.6 多播委托</p><p>​        委托也可以包含多个方法。这种委托成为多播委托。如果调用多播委托，就可以按顺序连续调用多个方法。为此，委托的签名就必须返回void；否则，就只能得到委托调用的最后一个方法的结果。多播委托识别运算符“-”、“+”、“-=”、“+=”以从委托中增加或删除方法调用。</p><blockquote><p>class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        Action&lt;int, int&gt; calFunc = CalculateMethodHelper.Sum;<br>        calFunc += CalculateMethodHelper.Multiply;<br>        int x = 100, y = 200;<br>        Calculate(calFunc, x, y);<br>        Console.ReadKey();<br>    }<br>    public static void Calculate(Action&lt;int, int&gt; calculateMethodInvoker, int x, int y)<br>    {<br>        Console.WriteLine(“运行结果：”);<br>        calculateMethodInvoker(x, y);<br>    }<br>}<br>public class CalculateMethodHelper<br>{<br>    public static void Sum(int x, int y)<br>    {<br>        Console.WriteLine(“x,y相加：{0}”, x + y);<br>    }<br>    public static void Multiply(int x, int y)<br>    {<br>        Console.WriteLine(“x,y相乘：{0}”, x * y);<br>    }<br>}</p></blockquote><p>​        如果通过委托调用的其中一个方法抛出异常，整个迭代就会停止。解决的方法是，使用Delegate类中定义的GetInvocationList()方法获取Delegate对象数组，再使用循环遍历执行，在过程中捕获异常，来继续下一次迭代。</p><p>9.2.7匿名方法</p><p>匿名方法是用作委托的参数的一段代码。</p><blockquote><pre><code>Action&lt;int, int&gt; calFunc = delegate (int i, int j)&#123;    Console.WriteLine(&quot;x,y相加：&#123;0&#125;&quot;, i + j);&#125;;</code></pre></blockquote><p>在匿名方法中不可使用跳转语句（break、goto或continue），在匿名方法内部不能访问不安全代码，不能访问在匿名方法外部使用的ref和out参数。</p><p>9.3lambda表达式</p><p>自C#3.0开始，可以使用新的语法把实现代码赋予委托，只要有委托参数类型的地方，就可以使用lambda表达式。</p><blockquote><pre><code>Action&lt;int, int&gt; calFunc = (i, j) =&gt;&#123;    Console.WriteLine(&quot;x,y相加：&#123;0&#125;&quot;, i + j);&#125;;</code></pre></blockquote><p>9.3.1参数</p><p>lambda表达式有几种定义参数的方式。如果只有一个参数，只写出参数名就足够了。如果除一个参数以外，需要圆括号把参数名括起来。</p><blockquote><p>Action<int> one = i =&gt;<br>{<br>    //方法内容<br>};<br>Action&lt;int, int&gt; two = (i, j) =&gt;<br>{<br>    //方法内容<br>};</int></p></blockquote><p>9.3.2多行代码</p><p>如果lambda表示只有一条语句，在方法块内就不需要花括号和return语句，因为编译器会隐式添加return</p><blockquote><pre><code>Func&lt;int&gt; lambdaOne = () =&gt; 0;</code></pre></blockquote><p>如果实现代码超过一行，就需要使用return语句显式返回</p><blockquote><p>Func<int> lambdaOne = () =&gt;<br>{<br>    int i = 0;<br>    i++;<br>    ++i;<br>    return i;<br>};</int></p></blockquote><p>9.3.3闭包</p><p>通过lambda表达式可以访问lambda表达式块外部的变量。这称为闭包。</p><blockquote><p>int param = 10;<br>Action<int> lambdaSecond = (i) =&gt;<br>{<br>    Console.WriteLine(i + param);<br>};<br>lambdaSecond(3);<br>Console.ReadKey();</int></p></blockquote><p>9.4事件</p><p>事件基于委托，为委托提供了一种发布/订阅机制。</p><blockquote><p>class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        AlarmClock alarmClock = new AlarmClock();<br>        Student zsStudent = new Student(“张三”);<br>        alarmClock.ItsGetUpClockEvent += zsStudent.ItsGetUpClock;<br>        alarmClock.ItsGetUpClock();<br>        Student lsStudent = new Student(“李四”);<br>        WeakEventManager&lt;AlarmClock, EventArgs&gt;.AddHandler(alarmClock, “ItsGetUpClockEvent”, lsStudent.ItsGetUpClock);//弱事件<br>        alarmClock.ItsGetUpClock();<br>        Console.ReadKey();<br>    }</p><p>}<br>//事件发布类<br>public class AlarmClock<br>{<br>    public event EventHandler<EventArgs> ItsGetUpClockEvent;<br>    public void ItsGetUpClock()<br>    {<br>        Console.WriteLine(“时间到，起床了！”);<br>        ItsGetUpClockEvent?.Invoke(this, new EventArgs());<br>    }<br>}<br>//事件侦听类<br>public class Student<br>{<br>    public string Name { get; set; }<br>    public Student(string name)<br>    {<br>        this.Name = name;<br>    }<br>    public void ItsGetUpClock(object sender, EventArgs e)<br>    {<br>        Console.WriteLine(“{0}关掉闹钟，起床了。”,Name);<br>    }<br>}</EventArgs></p></blockquote><p>9.4.1事件发布程序</p><p>9.4.2事件侦听器</p><p>9.4.3弱事件</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 运算符和强制类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第八章 运算符和强制类型转换</title>
      <link href="2021/02/20/c-10/c-10th-08/"/>
      <url>2021/02/20/c-10/c-10th-08/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第八章-运算符和强制类型转换"><a href="#c-语言-第八章-运算符和强制类型转换" class="headerlink" title="c#语言 第八章 运算符和强制类型转换"></a>c#语言 第八章 运算符和强制类型转换</h1><h2 id="本章要点："><a href="#本章要点：" class="headerlink" title="本章要点："></a>本章要点：</h2><p>​    c#中的运算符</p><p>​    使用c#6的新运算符nameof和控制传播</p><p>​    隐式和显示转换</p><p>​    使用装箱技术把值类型转换为引用类型</p><p>​    比较值类型和引用类型</p><p>​    重载标准的运算符以支持自定义类型</p><p>​    实现索引运算符</p><p>​    通过类型强制转换在引用类型之间的转换</p><h2 id="8-1运算符和类型转换"><a href="#8-1运算符和类型转换" class="headerlink" title="8.1运算符和类型转换"></a>8.1运算符和类型转换</h2><h2 id="8-2运算符"><a href="#8-2运算符" class="headerlink" title="8.2运算符"></a>8.2运算符</h2><table><thead><tr><th>类别</th><th>运算符</th></tr></thead><tbody><tr><td>算术运算符</td><td>+ - * / %</td></tr><tr><td>逻辑运算符</td><td>&amp; | ^ ~ &amp;&amp; || !</td></tr><tr><td>字符串连接运算符</td><td>+</td></tr><tr><td>增量和减量运算符</td><td>++ –</td></tr><tr><td>移位运算符</td><td>&lt;&lt; &gt;&gt;</td></tr><tr><td>比较运算符</td><td>== != &lt; &gt; &lt;= &gt;=</td></tr><tr><td>赋值运算符</td><td>= += -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=</td></tr><tr><td>成员访问运算符（用于对象和结构）</td><td>.</td></tr><tr><td>索引运算符（用于数组和索引器）</td><td>[]</td></tr><tr><td>类型转换运算符</td><td>()</td></tr><tr><td>条件运算符（三元运算符）</td><td>?:</td></tr><tr><td>委托连接和删除运算符</td><td>+ -</td></tr><tr><td>对象创建运算符</td><td>new</td></tr><tr><td>类型信息运算符</td><td>sizeof is typeof as</td></tr><tr><td>溢出异常控制运算符</td><td>checked unchecked</td></tr><tr><td>间接寻址运算符</td><td>[]</td></tr><tr><td>名称空间别名限定符</td><td>::</td></tr><tr><td>空合并运算符</td><td>??</td></tr></tbody></table><p>​        有4个运算符（sizeof()、*、-&gt;和&amp;）只能用于不安全的代码（这些代码忽略了c#的类型安全性检查），这些不安全的代码见第五章细节</p><p>​        c#中很少用到指针，因此很少用到间接寻址运算符（-&gt;）。</p><h3 id="8-2-1运算符的简化操作"><a href="#8-2-1运算符的简化操作" class="headerlink" title="8.2.1运算符的简化操作"></a>8.2.1运算符的简化操作</h3><p>​        x+=y等同于x=x+y，赋值运算符中（+= -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=）都是相同的模式。</p><p>​        当x++和++x单独一行时等同于x=x+1。当他们用于较长的表达式内部时，运算符放在前面（++x）会在计算表达式之前增加x。</p><blockquote><p>int x = 0,y=0;</p><p>x++;</p><p>++y;</p><p>if (x==y)</p><p>{</p><p>   Console.WriteLine(“单独一行++在前在后结果一样”);</p><p>}</p><p>if (++x==2)</p><p>{</p><p>   Console.WriteLine(“++在前提前计算”);</p><p>}</p><p>if (y++==2)</p><p>{</p><pre class=" language-c#"><code class="language-c#">Console.WriteLine("++在后没有提前计算");</code></pre><p>}</p></blockquote><h4 id="（1）条件运算符"><a href="#（1）条件运算符" class="headerlink" title="（1）条件运算符"></a>（1）<strong>条件运算符</strong></h4><p>​        条件运算符（?:）也称单元运算符，是if…else的简化形式。它判断一个条件真假来返回对应的值（为真返回:之前的值，为假返回:之后的值）。</p><blockquote><pre><code>int x = 0;string str = x == 0 ? &quot;x等于0&quot; : &quot;x不等于0&quot;;Console.WriteLine(str)</code></pre></blockquote><h4 id="（2）checked运算符和unchecked运算符"><a href="#（2）checked运算符和unchecked运算符" class="headerlink" title="（2）checked运算符和unchecked运算符"></a>（2）<strong>checked运算符和unchecked运算符</strong></h4><p>​        C#提供checked运算符和unchecked运算符，来对一个代码块进行标记，是否执行溢出检查。</p><blockquote><pre><code>byte x = 255;x++;Console.WriteLine(x);</code></pre></blockquote><p>​        运行以上代码，结果如下：</p><p> <img src="https://images2015.cnblogs.com/blog/682781/201703/682781-20170327225436358-244304394.png" alt="img"></p><p>​        这是因为，C#默认使用unchecked运算符不对溢出执行检查，这会导致数据丢失（byte不能超过255，溢出的位会丢失，所以结果为0）。</p><p>​        如果要防止溢出导致的数据丢失，可以使用checked运算符对代码块进行标记。</p><blockquote><p>byte x = 255;</p><p>checked</p><p>{</p><p>   x++;</p><p>}</p><p>Console.WriteLine(x);</p></blockquote><p>​    运行以上代码，结果如下：</p><p> <img src="https://images2015.cnblogs.com/blog/682781/201703/682781-20170327225448951-1311569589.png" alt="img"></p><p>​    程序会抛出异常，这个时候我们就能捕捉异常，来防止溢出丢失数据。</p><h4 id="（3）is运算符"><a href="#（3）is运算符" class="headerlink" title="（3）is运算符"></a><strong>（3）is运算符</strong></h4><p>​        Is运算符检查对象是否与特定类型兼容（是该类型或者派生自该类型）。</p><blockquote><p>int x = 0;</p><p>if (x is object)</p><p>{</p><p>   Console.WriteLine(“x是object类型或派生自object的类型”);</p><p>}</p></blockquote><h4 id="（4）as运算符"><a href="#（4）as运算符" class="headerlink" title="（4）as运算符"></a>（4）<strong>as运算符</strong></h4><p>​        as运算符用于执行引用类型的显式类型转换。如果要转换的类型与指定的类型兼容，转换就会成功；如果不兼容，as运算符就会返回null。</p><blockquote><p>object obj1 = “字符串”;</p><p>object obj2 = 0;</p><p>string str1 = obj1 as string;</p><p>string str2 = obj2 as string;</p><p>Console.WriteLine(“obj1 as string转换结果：” + str1);</p><p>Console.WriteLine(“obj2 as string转换结果：” + str2);</p></blockquote><p>​        运行以上代码，结果如下：</p><p> <img src="https://images2015.cnblogs.com/blog/682781/201703/682781-20170327225525951-930522724.png" alt="img"></p><p>​        as运算符允许在一步中执行安全的类型转换，不需要先使用is运算符测试类型，再执行转换。</p><h4 id="（5）sizeof运算符"><a href="#（5）sizeof运算符" class="headerlink" title="（5）sizeof运算符"></a>（5）<strong>sizeof运算符</strong></h4><p>​        使用sizeof运算符可以确定栈中值类型的长度（单位是字节）：</p><blockquote><pre><code>Console.WriteLine(sizeof(int));//4</code></pre></blockquote><h4 id="（6）typeof运算符"><a href="#（6）typeof运算符" class="headerlink" title="（6）typeof运算符"></a>（6）<strong>typeof运算符</strong></h4><p>​        typeof运算符返回一个表示特定类型的System.Type对象。例如，typeof(string)返回表示System.String类型的Type类型。在使用反射技术动态地查找对象的信息时，这个运算符很有用。</p><h4 id="7-nameof运算符"><a href="#7-nameof运算符" class="headerlink" title="(7)nameof运算符"></a>(7)nameof运算符</h4><p>​        nameof是新的c#6运算符，该运算符接受一个符号、属性或方法，并返回其名称</p><h4 id="8-index运算符"><a href="#8-index运算符" class="headerlink" title="(8)index运算符[]"></a>(8)index运算符[]</h4><blockquote><p>int x = arr[2];</p></blockquote><h4 id="9-可空类型和运算符"><a href="#9-可空类型和运算符" class="headerlink" title="(9)可空类型和运算符"></a>(9)可空类型和运算符</h4><p>如果在程序中使用可空类型，就必须考虑null值与各种运算符一起使用时的影响。</p><blockquote><pre><code>int? x = null;int? y = x + 1;//null</code></pre></blockquote><h4 id="10-空合并运算符"><a href="#10-空合并运算符" class="headerlink" title="(10)空合并运算符"></a>(10)<strong>空合并运算符</strong></h4><p>​        空合并运算符（??）提供了一种快捷方式，可以在处理可空类型和引用类型时表示null可能的值。</p><p>例子：</p><blockquote><p>int? x = null;</p><p>int y;</p><p>y = x ?? 0;</p><p>Console.WriteLine(y);</p></blockquote><h4 id="11-空值传播运算符"><a href="#11-空值传播运算符" class="headerlink" title="(11)空值传播运算符"></a>(11)空值传播运算符</h4><blockquote><p>public void ShowPerson(Person p){</p><p>​    string firstName = p?.FirstName;</p><p>}</p></blockquote><h3 id="8-2-2运算符的优先级和关联性"><a href="#8-2-2运算符的优先级和关联性" class="headerlink" title="8.2.2运算符的优先级和关联性"></a>8.2.2运算符的优先级和关联性</h3><p>优先级由上到下依次递减</p><table><thead><tr><th>组</th><th>运算符</th></tr></thead><tbody><tr><td>初级运算符</td><td>() . [] x++ x– new typeof sizeof checked unchecked</td></tr><tr><td>一元运算符</td><td>+ - ! ~ ++x –x 和数据类型强制转换</td></tr><tr><td>乘除运算符</td><td>* / %</td></tr><tr><td>加减运算符</td><td>+ -</td></tr><tr><td>移位运算符</td><td>&lt;&lt; &gt;&gt;</td></tr><tr><td>关系运算符</td><td>&lt; &gt; &gt;= &lt;= is as</td></tr><tr><td>比较运算符</td><td>== !=</td></tr><tr><td>按位AND运算符</td><td>&amp;</td></tr><tr><td>按位XOR运算符</td><td>^</td></tr><tr><td>按位OR运算符</td><td>|</td></tr><tr><td>布尔AND运算符</td><td>&amp;&amp;</td></tr><tr><td>布尔OR运算符</td><td>||</td></tr><tr><td>条件运算符</td><td>?:</td></tr><tr><td>赋值运算符</td><td>= += -= *= /= %= &amp;= |= ^= &lt;&lt;== &gt;&gt;= &gt;&gt;&gt;=</td></tr></tbody></table><p>​        除了运算符优先级外，对于二元运算符，需要注意运算符是从左到右还是从右到左计算，除了少数运算符外，所有的运算符都是做关联的。例如</p><blockquote><p>x+y+z  就等于 （x+y）+z</p></blockquote><p>​        <strong>关联性的重要例外就是赋值运算符，他们是右关联的</strong>。例如</p><blockquote><p>x=y=z=3  从右向左赋值，所以x、y、z的值都是3</p></blockquote><p>​        <strong>一个重要的，可能误导的有关联运算符是条件运算符</strong></p><blockquote><p>a?b:c?d:e   </p><p>等于</p><p>a=b:(c?d:e)</p></blockquote><p>​        在复杂的表达式中，应避免利用运算符优先级来生成正确的结果，使用圆括号制定运算符的执行顺序，可以是代码更整洁，避免出现潜在的冲突。</p><h2 id="8-3类型的安全性"><a href="#8-3类型的安全性" class="headerlink" title="8.3类型的安全性"></a>8.3类型的安全性</h2><p>​        c#也支持不同引用类型之间的转换，在与其他类型相互转换时还允许定义所创建的数据类型的行为方式，</p><h3 id="8-3-1类型转换"><a href="#8-3-1类型转换" class="headerlink" title="8.3.1类型转换"></a>8.3.1类型转换</h3><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>​        只要保证值不会发生任何变化，类型转换就可以自动（隐式）进行。当值的数量级不受影响，而精度可能受到影响时，也可以进行隐式转换，因为编译器认为这是可以接受的错误。</p><h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><p>​        当无法保证值不会发生任何变化时，就需要使用显式转换，否则编译器会报错。</p><p>例子：</p><p>​        long类型无法隐式的转换为int，但我们可以显式地进行转换</p><blockquote><pre><code>long lon = 1;int i = (int)lon;</code></pre></blockquote><p>​        显式转换是一种比较危险的操作，因为有可能造成溢出，这样导致结果与正确值不同。在进行隐式转换时，应使用checked运算符进行检查。</p><h3 id="8-3-2装箱和拆箱"><a href="#8-3-2装箱和拆箱" class="headerlink" title="8.3.2装箱和拆箱"></a>8.3.2装箱和拆箱</h3><p>​    装箱用于描述一个值类型转换为引用类型</p><blockquote><pre><code>int i = 100;object obj = i;</code></pre></blockquote><p>​    拆箱用于描述相反的过程，其中以前装箱的值类型强制转换回值类型</p><blockquote><pre><code>int i = 100;object obj = i;int _i = (int)obj;</code></pre></blockquote><h2 id="8-4比较对象的相等性"><a href="#8-4比较对象的相等性" class="headerlink" title="8.4比较对象的相等性"></a>8.4比较对象的相等性</h2><p>​        对象相等的机制有所不同，这取决于比较的是引用类型（类的实例）还是值类型（基本数据类型、结构或枚举的实例）</p><h3 id="8-4-1比较引用类型的相等性"><a href="#8-4-1比较引用类型的相等性" class="headerlink" title="8.4.1比较引用类型的相等性"></a>8.4.1比较引用类型的相等性</h3><p>（1）<strong>ReferenceEquals()方法</strong></p><p>​        ReferenceEquals()是一个静态方法，测试两个引用是否引用类的同一个实例，特别是两个引用是否包含内存中的相同地址。最为静态方法，它不可重写。</p><blockquote><p>Person p1, p2;</p><p>p1 = new Person();</p><p>p2 = new Person();</p><p>bool b1 = ReferenceEquals(null, null);</p><p>bool b2 = ReferenceEquals(null, p1);</p><p>bool b3 = ReferenceEquals(p1, p2);</p><p>Console.WriteLine(“ReferenceEquals(null, null) 的结果：{0}”, b1);</p><p>Console.WriteLine(“ReferenceEquals(null, p1) 的结果：{0}”, b2);</p><p>Console.WriteLine(“ReferenceEquals(p1, p2) 的结果：{0}”, b3);</p></blockquote><p>（2）<strong>虚拟的Equals()方法</strong></p><p>​        Equals()方法是虚拟方法，所以可以在自己的类中重写，从而按值来比较对象。</p><p>（3）<strong>静态的Equals()方法</strong></p><p>Equals()静态版本与其虚拟实例版本的作用相同，其区别是静态版本带有两个参数，并对它们进行相等性比较。</p><p>（4）<strong>比较运算符==</strong></p><p>​    最好将比较运算符看作严格的值比较和严格的引用比较之间的中间选项</p><h3 id="8-4-2比较值类型的相等性"><a href="#8-4-2比较值类型的相等性" class="headerlink" title="8.4.2比较值类型的相等性"></a>8.4.2比较值类型的相等性</h3><p>​        在比较值类型的相等性时，采用与引用类型相同的规则：ReferenceEquals()用于比较引用，Equals()用于比较值，比较运算符可以看作一个中间选项。但最大的区别是值类型需要进行装箱，才能把它们转换为引用类型，进而才能对它们执行方法。</p><p>​        在System.ValueType类中重载了实例方法Equals()，以便对值类型进行合适的相等性测试。</p><h2 id="8-5运算符重载"><a href="#8-5运算符重载" class="headerlink" title="8.5运算符重载"></a>8.5运算符重载</h2><p>​        如果要对自定义的类使用运算符，就必须告诉编译器相关的运算符在这个类的上下文中的含义，此时就需要使用运算符重载。</p><p>​        C#要求所有的运算符重载都声明为public和static，这表示它们与它们的类相关联而不是特定实例。重载运算符需要使用operator关键字。编译器处理运算符重载和处理方法重载是一样的。C#要求成对的重载比较运算符，且必须返回布尔值。</p><blockquote><p>public static decimal operator +(Person lhs, Person rhs)</p><p>{</p><pre><code>return lhs.Money + rhs.Money;</code></pre><p>}</p></blockquote><h3 id="8-5-1运算符的工作方式"><a href="#8-5-1运算符的工作方式" class="headerlink" title="8.5.1运算符的工作方式"></a>8.5.1运算符的工作方式</h3><p>​        它们会根据参数类型查找最匹配的运算符重载。</p><h3 id="8-5-2运算符重载的示例"><a href="#8-5-2运算符重载的示例" class="headerlink" title="8.5.2运算符重载的示例"></a>8.5.2运算符重载的示例</h3><h3 id="8-5-3比较运算符的重载"><a href="#8-5-3比较运算符的重载" class="headerlink" title="8.5.3比较运算符的重载"></a>8.5.3比较运算符的重载</h3><h3 id="8-5-4可以重载的运算符"><a href="#8-5-4可以重载的运算符" class="headerlink" title="8.5.4可以重载的运算符"></a>8.5.4可以重载的运算符</h3><table><thead><tr><th>类别</th><th>运算符</th><th>限制</th></tr></thead><tbody><tr><td>算术二元运算符</td><td>+、*、/、-、%</td><td>无</td></tr><tr><td>算术一元运算符</td><td>+、-、++、–</td><td>无</td></tr><tr><td>按位二元运算符</td><td>&amp;、|、^、&lt;&lt;、&gt;&gt;</td><td>无</td></tr><tr><td>按位一元运算符</td><td>!、~、true、false</td><td>true和false运算符必须成对重载</td></tr><tr><td>比较运算符</td><td>==、!=、&gt;=、&lt;、&lt;=、&gt;</td><td>比较运算符必须成对重载</td></tr><tr><td>赋值运算符</td><td>+=、-=、*=、/=、&gt;&gt;=、&lt;&lt;=、%=、&amp;=、|=、^=</td><td>不能显式地重载这些运算符，在重写单个运算符（如+、-等）时，它们会被隐式地重写</td></tr><tr><td>索引运算符</td><td>[]</td><td>不能直接重载索引运算符。索引器成员类型允许在类和结构上支持索引运算符。</td></tr><tr><td>数据类型强制转换运算符</td><td>()</td><td>不能直接重载类型强制运算符。用户定义的类型强制转换允许定义定制的类型强制转换。</td></tr></tbody></table><p>8.6实现自定义的索引运算符</p><p>​    可以给自定义类创建一个索引器，索引器看起来非常类似于属性，因为它也包含get和set访问器。指定索引器要使用this关键字，this关键字后面的括号指定索引使用的类型。数组体用int类型的索引器，所以这里使用int类型直接把信息传递给包含的数组people。</p><blockquote><p>public Person this[int index]{</p><p>​    get{return _people[index];}</p><p>​    set{_people[index]=value;}</p><p>}</p></blockquote><p>​        对于索引器，不能仅定义int类型作为索引类型。任何类型都是有效的。例如：</p><blockquote><p>public IEnumerable<Person> this[DateTime birthday]{</Person></p><p>​    get{ return _people.where(p=&gt;p.Birthday ==birthday);}</p><p>}</p></blockquote><p>8.7实现用户定义的类型强制转换</p><p>​        C#允许定义自己的数据类型（结构和类），这意味着需要某些工具支持在自定义的数据类型之间进行类型转换。方法是把类型强制转换运算符定义为相关类的成员运算符，类型强制装换运算符必须标记为隐式或显式，以说明希望如何使用它。我们应遵守与预定义的类型强制转换相同的规则，如果知道无论在元变量中存储什么值，类型强制转换总是安全的，就可以把它定义为隐式强制转换。然而，如果某些数值可能会出错，如丢失数据或抛出异常，就应把数据类型转换定义为显式强制转换。</p><p>例子：</p><p>显式关键字explicit，隐式关键字implicit</p><blockquote><p>class Program</p><p>{</p><pre><code>static void Main(string[] args)&#123;    Water water = new Water(100);        Ice ice = (Ice)water;//Water显示转换为Ice        Water water2 = ice;//Ice隐式转换为Water        Console.ReadKey();&#125;</code></pre><p>}</p><p>public class Water</p><p>{</p><pre><code>public int Volume &#123; get; set; &#125;public Water(int volume)&#123;    this.Volume = volume;&#125;public static explicit operator Ice(Water lhs)&#123;    return new Ice(lhs.Volume+1);&#125;</code></pre><p>}</p><p>public class Ice</p><p>{</p><pre><code>public int Volume &#123; get; set; &#125;public Ice(int volume)&#123;    this.Volume = volume;&#125;public static implicit operator Water(Ice lhs)&#123;    return new Water(lhs.Volume-1);&#125;</code></pre><p>}</p></blockquote><p>​    定义不同结构或类的实例之间的类型强制转换时完全合法的，但有两个限制：</p><ul><li>如果某个类派生自另一个类，就不能定义这两个类之间的类型强制转换（这些类型的类型转换已经存在）。</li><li>类型强制转换必须在源数据类型或目标数据类型的内部定义。</li></ul><p>​     C#要求把类型强制转换的定义放置在源类（或结构）或目标类（或结构）的内部。它的副作用是不能定义两个类之间的类型强制转换，除非至少可以编辑其中一个类的源代码。这是因为，这样可以防止第三方把类型转换引入类中。</p><p>8.7.1实现用户定义的类型强制转换</p><p>类之间的强制转换</p><p>基类和派生类之间的类型强制转换</p><p>装箱和拆箱类型强制转换</p><p>8.7.2多重类型强制转换</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 运算符和强制类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第七章 数组和元祖</title>
      <link href="2021/02/19/c-10/c-10th-07/"/>
      <url>2021/02/19/c-10/c-10th-07/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第七章-数组和元祖"><a href="#c-语言-第七章-数组和元祖" class="headerlink" title="c#语言 第七章 数组和元祖"></a>c#语言 第七章 数组和元祖</h1><h2 id="7-1-同一类型Array和不同类型Tuple的多个对象"><a href="#7-1-同一类型Array和不同类型Tuple的多个对象" class="headerlink" title="7.1 同一类型Array和不同类型Tuple的多个对象"></a>7.1 同一类型Array和不同类型Tuple的多个对象</h2><p>​        对于同一个类型的多个对象，我们可以使用集合和数组。</p><p>​        C#用特殊的记号声明、初始化和使用数组。Array类在后台发挥作用，它为数组中元素的排序和过滤提供了几个方法。使用枚举器，就可以迭代数组中的所有元素。</p><p>​        对于不同类型的多个对象，可以使用Tuple（元组）类型。</p><h2 id="7-2简单数组"><a href="#7-2简单数组" class="headerlink" title="7.2简单数组"></a>7.2简单数组</h2><p>​        数组是一种数据结构，可以包含统一类型的多个元素。</p><h3 id="7-2-1数组的声明"><a href="#7-2-1数组的声明" class="headerlink" title="7.2.1数组的声明"></a>7.2.1数组的声明</h3><p>​        在声明数组时，应先定义元素的类型，其后是一对空方括号，后面是变量名</p><h3 id="7-2-2数组的初始化"><a href="#7-2-2数组的初始化" class="headerlink" title="7.2.2数组的初始化"></a>7.2.2数组的初始化</h3><p>​        在声明了数组之后，我们需要为数组的元素分配内存。因为数组时引用类型，所以我们必须用new来给它分配堆上的内存。使用new运算符，制定数组中元素的类型和数量来初始化数组的变量</p><blockquote><p>int[] myArray ;//声明数组</p><p>myArray = new int [4]；//分配内存</p><p>int[] myArray = new int [4]{1,2,3,4};</p><p>//如果我们在声明时使用初始化器为数组赋值，那就可以不必指定数组的大小，因为编译器会自动统计元素的个数</p><p>int[] myArray = new int []{1,2,3,4};</p><p>int[] myArray = {1,2,3,4}; //简化写法</p></blockquote><p><strong>如果你不知道数组应包含多少个元素个数，那你应该用集合而不是数组。</strong></p><h3 id="7-2-3访问数组元素"><a href="#7-2-3访问数组元素" class="headerlink" title="7.2.3访问数组元素"></a>7.2.3访问数组元素</h3><p>​        访问数组元素的下标都是从0开始，0代表第一个数组元素。</p><p><img src="https://img-blog.csdnimg.cn/2020050810080638.png" alt="img"></p><blockquote><p>int[] myArray = new int[]{1,2,3,4};</p><p>int v1 = myArray[0];</p><p>myArray[2]=5;</p></blockquote><h3 id="7-2-4使用引用类型"><a href="#7-2-4使用引用类型" class="headerlink" title="7.2.4使用引用类型"></a>7.2.4使用引用类型</h3><p>​        数组不仅可以声明值类型的元素，还可以声明引用类型的元素，而且往往使用引用类型的元素还挺常见。</p><p>​        要注意的是，使用引用类型如类类型，那你需要为该类型里面的每个元素分配内存，都要初始化值。</p><blockquote><p>public class Person<br>{<br>   public string name;<br>   public int age;</p><p>   public void GETAge()<br>   {<br>       DO…..<br>   }<br>}</p><p>public class M<br>{<br>   // 使用类的实例作为数组元素<br>   Person[] myPerson= new Person[2];</p><pre class=" language-c#"><code class="language-c#">// 每次初始化都是初始化这个对象myPerson[0] = new Person&#123; name = "马云"，age = 55&#125;;myPerson[1] = new Person&#123; name = "totoro"，age = 18&#125;;</code></pre><p>}</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200508100700528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RPVE9MT0c=,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="7-3多维数组"><a href="#7-3多维数组" class="headerlink" title="7.3多维数组"></a>7.3多维数组</h2><p>  <strong>声明数组后，就不能修改其阶数了</strong></p><blockquote><p>int[,] arr2 = new int[1, 2];<br>int[,,] arr3 = new int[2,2,2] {<br>                                {<br>                                    {1,2 },   //0,0,0 - 0,0,1<br>                                    {3,4 }    //0,1,0 - 0,1,1<br>                                },<br>                                {<br>                                    {5,6 },   //1,0,0 - 1,0,1<br>                                    {7,8 }    //1,1,0 - 1,1,1<br>                                }<br>                               };</p><p>Console.WriteLine(arr3[0, 0, 0]);  // 输出1<br>Console.WriteLine(arr3[0, 1, 0]);  // 输出3</p></blockquote><h2 id="7-4锯齿数组"><a href="#7-4锯齿数组" class="headerlink" title="7.4锯齿数组"></a>7.4锯齿数组</h2><p><img src="https://img-blog.csdnimg.cn/20200508104822207.png" alt="img"></p><blockquote><p>{<br>    // 声明一个3维的锯齿数组，最外维包有2个2维<br>    int[][][] arr = new int[2][][];</p><pre class=" language-c#"><code class="language-c#">// 表示最外围的第一个二维数组，该2为数组包含3个一维数组arr[0] = new int[3][]; // 表示中间的第一个一维数组，该一维数组包含2个元素arr[0][0] = new int[3] &#123; 1,2,3&#125;;arr[0][1] = new int[5] &#123; 4,5,6,7,8&#125;;arr[0][2] = new int[2] &#123; 9,10&#125;; // 验证，输出7Console.WriteLine(arr[0][1][3]);     </code></pre><p>}</p></blockquote><h2 id="7-5Array类"><a href="#7-5Array类" class="headerlink" title="7.5Array类"></a>7.5Array类</h2><p>​        上面声明数组都是通过Array类来实现的，就是说使用[]就是使用Array类的表示法。c#语法，会创建一个派生自抽象类基类Array类的新类。</p><p>​        Length属性和foreach语句迭代数组，其实是使用了Array类中的GetEnumerator()方法。</p><p>​        <strong>如果数组中包含的元素个数超过了整数范围，就可以使用LongLength属性获得元素个数。</strong></p><h3 id="7-5-1创建数组"><a href="#7-5-1创建数组" class="headerlink" title="7.5.1创建数组"></a>7.5.1创建数组</h3><p>​        Array类是一个抽象类，所以不能用构造函数来创建数组。</p><p>​        除了我们常规类如上面的[]创建数组,还有一种方法可以创建数组，那就是使用静态方法CreateInstance( )创建数组。如果你开始不知道数组的类型，那这方法就显得非常有用了。</p><p>​        <strong>CreateInstance()方法有许多重载版本，可以创建多维数组和不基于0的数组。</strong></p><blockquote><p>int[] lengths = { 2, 3 };<br>int[] lowerBounds = { 1, 10 };</p><p>// lengths 表示你要创建一个2*3维的数组，不能创建锯齿数组<br>// lowerBounds表示自定义每个维度的初始下标，默认是0开始，这里最外围自定义最小是1，最里维是从10开始<br>Array arr = Array.CreateInstance(typeof(string), lengths, lowerBounds);</p><p>// 给这个2维数组赋值<br>arr.SetValue(“A”, 1, 10); // 就相当于[0,0]<br>arr.SetValue(“B”, 1, 11);<br>arr.SetValue(“C”, 1, 12);<br>arr.SetValue(“D”, 2, 10); // 就相当于[1,0]<br>arr.SetValue(“E”, 2, 11);<br>arr.SetValue(“F”, 2, 12); // 就相当于[1,2]</p><p>// 对于Array类型的我们不能直接输出Console.Write(arr[1][11])，需要通过遍历数组<br>System.Collections.IEnumerator arr1  = arr.GetEnumerator();</p><p>// arr1.Rank得到数组的维度，这里arr1.Rank - 1得到1，即0-1<br>// arr1.GetLength(1),表示第二维上有几个元素<br>// arr1.MoveNext()表示是否存在元素<br>while (arr1.MoveNext())<br>{<br>   // 存在就输出该元素值<br>   Console.Write(“\t{0}”, arr1.Current);<br>}</p></blockquote><h3 id="7-5-2复制数组"><a href="#7-5-2复制数组" class="headerlink" title="7.5.2复制数组"></a>7.5.2复制数组</h3><p>​        因为数组是引用类型，所以将一个数组变量赋予另一个数组的变量，就会得到两个引用同一数组的变量。就是在栈上有两个引用的值都是一个堆上的某个地址。而复制数组，会使数组实现ICloneable接口。这个接口定义的Clone( )方法会创建数组的浅表副本。如：</p><blockquote><p>{<br>    int[] arr = {1,2,3，4,5};</p><pre><code>// 实现浅表复制（只动栈），对于引用类型复制引用而不动到对象，对于值类型直接复制值int[] arr1 = (int[])arr.Clone(); // 还有一种是复制堆对象数据 int[] arr2 = new int[3]; Array.Copy(arr, arr2, arr2.Length);</code></pre><p>}</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200508144252355.png" alt="img">    </p><p>​        如果元素是值类型，就会赋值所有值</p><p><img src="https://img-blog.csdnimg.cn/20200508144212691.png" alt="img"></p><p><strong>除了Clone()方法之外，还可以使用Array.Copy()方法创建浅表副本。但clone和copy的一个重要区别：</strong></p><p>​    clone会创建一个新数组</p><p>​    copy方法必须传递阶数相同且有足够元素的已有数组</p><h3 id="7-5-3排序"><a href="#7-5-3排序" class="headerlink" title="7.5.3排序"></a>7.5.3排序</h3><p>​        Array使用Quicksort算法对数组中的元素进行排序。Sort方法需要数组中元素实现IComparable接口。例如简单类型 string和int32实现IComparable接口，所以可以对包含这些类型的元素排序</p><blockquote><p>{<br>    int[] arr = { 5, 2, 1,4,3 };<br>    string[] brr = { “H”, “U”, “A”, “N”, “Z” };</p><pre><code>// 无论数字还是字符串都从小到大输出（对字符串判断首字母）Array.Sort(arr);Array.Sort(brr);</code></pre><p>}</p></blockquote><p>​        对于我们自定义的类类型数组也是可以排序的，但是一定要注意，使用自定义类做排序，那么这个自定义类一定要是实现Icomparable&lt;自定义类名&gt; 这个接口的</p><blockquote><p>public  class Class1: IComparable<Class1><br>{<br>     // 姓<br>     public string FirstName { get; set; }</Class1></p><pre><code>// 名public string LastName &#123; get; set; &#125; // 别忘了重写Tostring(),这样你才能狗输出字符串内容public override string ToString() =&gt; $&quot;&#123;FirstName&#125; &#123;LastName&#125;&quot;; // 也前往别忘了要实现接口public int CompareTo(Class1 other)&#123;    if (other == null) throw new ArgumentNullException(&quot;other&quot;);     // 比较 姓 先,不一致默认返回1，一致默认返回0    int result = FirstName .CompareTo(other.FirstName );    if (result == 0)    &#123;        result = LastName.CompareTo(other.LastName);    &#125;    return result;&#125;</code></pre><p>}</p><p>public class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        Class1[] arr = new Class1[]<br>        {<br>            new Class1 { FirstName=”马”, LastName=”云” },<br>            new Class1 { FirstName=”马”, LastName=”化腾” },<br>            new Class1 { FirstName=”李”, LastName=”庆国” },<br>            new Class1 { FirstName=”董”, LastName=”明珠” },<br>            new Class1 { FirstName=”宗”, LastName=”庆后” }<br>        }</p><pre><code>    // 进行排序，会触发CompareTo    Array.Sort(arr);         // 输出结果    foreach (var a in arr)    &#123;        Console.WriteLine(a);    &#125;    &#125;</code></pre><p>}</p></blockquote><h2 id="7-6数组作为参数"><a href="#7-6数组作为参数" class="headerlink" title="7.6数组作为参数"></a>7.6数组作为参数</h2><h3 id="7-6-1数组协变"><a href="#7-6-1数组协变" class="headerlink" title="7.6.1数组协变"></a>7.6.1数组协变</h3><p>​        数组支持协变，表示数组可以声明为基类，其派生类型的元素可以赋予数组元素。我们可以把自定义的Class1类数组赋值给object数组，因为Class1派生自object，这就是数组协变的表示，数组协变只能用于引用类型，不能用于值类型！！！如：</p><blockquote><p>// 接着上面代码<br>public class Program<br>{<br>    public static void DispalyArray(object[] data)<br>    {<br>        DO……<br>    }</p><pre><code>DispalyArray(arr);</code></pre><p>}</p></blockquote><h3 id="7-6-2ArraySegment"><a href="#7-6-2ArraySegment" class="headerlink" title="7.6.2ArraySegment"></a>7.6.2ArraySegment<T></T></h3><p>​        结构ArraySegment<T>表示数组的一个部分。如果需要使用不同的方法处理某个大型数组的不同部分，那么可以把相应的数组部分传到各个方法中。具体的使用如下：</T></p><blockquote><p>public class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        int[] ar1 = { 1, 4, 5, 11, 13, 18 };<br>        int[] ar2 = { 3, 4, 5, 18, 21, 27, 33 };</p><pre><code>    // 我们可以将一个数组或者多个数组的部分传给某个函数做处理    var segments = new ArraySegment&lt;int&gt;[2]    &#123;        new ArraySegment&lt;int&gt;(ar1, 0, 3),        new ArraySegment&lt;int&gt;(ar2, 3, 3)    &#125;         SumOfSegments(segments);&#125; static void SumOfSegments(ArraySegment&lt;int&gt;[] segments)&#123;    foreach (var segment in segments)    &#123;        for (int i = segment.Offset; i &lt; segment.Offset + segment.Count; i++)        &#123;            Console.WriteLine(segment.Array[i]);        &#125;    &#125;&#125;</code></pre><p>}</p></blockquote><p>​        来了来了，动脑的地方来了，数组段不复制原数组的元素，但是原数组可以通过ArraySegment<T>访问。如果数组段中的元素改变了，这些变化就会反映到原数组中。如：</T></p><blockquote><p>// 接着上面的代码，我们改一下：<br>{<br>        static void SumOfSegments(ArraySegment<int>[] segments)<br>        {<br>            foreach (var segment in segments)<br>            {<br>                for (int i = segment.Offset; i &lt; segment.Offset + segment.Count; i++)<br>                {<br>                    // 改一下这里，改一下数组的值<br>                    segment.Array[i] = 998 ;<br>                }</int></p><pre><code>        &#125;                &#125;         // 在最后    foreach (var a in ar1)    &#123;        Console.WriteLine(a);    &#125;</code></pre><p>}</p></blockquote><p>​        </p><h2 id="7-7枚举-foreach"><a href="#7-7枚举-foreach" class="headerlink" title="7.7枚举 foreach"></a>7.7枚举 foreach</h2><h3 id="7-7-1IEnumrtator接口"><a href="#7-7-1IEnumrtator接口" class="headerlink" title="7.7.1IEnumrtator接口"></a>7.7.1IEnumrtator接口</h3><p>​        在上面谈Array类的时候，代码中我们有用到这么一个方法——GetEnumerator( )，数组或集合都有实现带GetEnumerator()方法的IEumerator接口。调用了foreach方法的客户端和集合之间的关系显示如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200509104613177.png" alt="img"></p><p>​    IEumerator定义了current属性，来返回光标所在的元素，改接口的MoveNext( )方法移动到集合的下一个元素上，如果有这个元素，就返回true，否则返回false。</p><p>​    这个接口的泛型版本IEnumerator<T>派生自IDispossable,因此定义了Dispose()方法，来清理给枚举器分配的资源。</T></p><h3 id="7-7-2foreach语句"><a href="#7-7-2foreach语句" class="headerlink" title="7.7.2foreach语句"></a>7.7.2foreach语句</h3><p>​        foreach语句的实现并不真的需要在集合类中实现这个接口，它只需要通过一个名为GetEnumerator( )的方法，它返回实现了IEumerator接口就足够了</p><h3 id="7-7-3yield语句"><a href="#7-7-3yield语句" class="headerlink" title="7.7.3yield语句"></a>7.7.3yield语句</h3><p>​        c#2.0添加了yield语句，以便于创建枚举器。</p><p>​        yield return 语句返回集合的一个元素，并移动到下一个元素上，yield break可停止迭代。</p><blockquote><p>using System;</p><p>using System.Collections;</p><p>namespace Wrox.ProCSarp.Arrays{</p><p>​    public class HelloCollection{</p><p>​        public IEnumerator<string>  GetEnumerator(){</string></p><p>​            yield return “Hello”,</p><p>​            yield return “world”,</p><p>​        }</p><p>​    }</p><p>}</p></blockquote><p>​        迭代集合的不同方式</p><p>​        用yield return返回枚举器</p><h2 id="7-8元祖"><a href="#7-8元祖" class="headerlink" title="7.8元祖"></a>7.8元祖</h2><p>​        来讲讲元组吧，前面一直在说数组(同类型)，元组就是支持不同类型的元素。</p><p>​        元组的使用和数组不同，数组是new创建的，元组不是，且元组一直都是作为方法的类型。例如Tuple<T1>包含一个元素，Tuple&lt;T1,T2&gt;包含两个元素，以此类推。元组用静态的Create( )方法创建。Create( )方法的泛型参数定义了要实例化的元组类型。如：</T1></p><blockquote><p> public class Program<br>{<br>    static void Main(string[] args)<br>    {<br>        int[] a = { 1, 2, 3, 4, 5 };<br>        string b = “HeeloWorld!”;</p><pre><code>    var result = TT(a,b);&#125; // 通过Item取对应的类型值foreach (var i in result.Item1)&#123;    Console.WriteLine(i);&#125; // 元组可接纳不同类型的参数，返回不同类型的结果static Tuple&lt;int[], string&gt; SumOfSegments(int[] a,string b)&#123;    // Tuple.Create将计算结果打包成元组返回去    return Tuple.Create(a, b);&#125;</code></pre><p>}</p></blockquote><h2 id="7-9结构比较"><a href="#7-9结构比较" class="headerlink" title="7.9结构比较"></a>7.9结构比较</h2>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 数组和元祖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 第六章 泛型</title>
      <link href="2021/02/18/c-10/c-10th-06/"/>
      <url>2021/02/18/c-10/c-10th-06/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第六章-泛型"><a href="#c-语言-第六章-泛型" class="headerlink" title="c#语言 第六章 泛型"></a>c#语言 第六章 泛型</h1><h2 id="6-1泛型概述"><a href="#6-1泛型概述" class="headerlink" title="6.1泛型概述"></a>6.1泛型概述</h2><p>​        有了泛型就可以创建独立于被包含类型的类和方法，不必给不同的类型编写功能相同的许多方法或类，只创建一个方法和类即可</p><p>​        另一个减少代码的选项是使用object类，但使用派生自object类的类型进行传递不是类型安全的</p><p>​        泛型使用泛型类型，根据需要用特定的类型替换泛型类型，保证了类型安全性</p><h3 id="6-1-1-性能"><a href="#6-1-1-性能" class="headerlink" title="6.1.1 性能"></a>6.1.1 性能</h3><p>​        对值类型使用非泛型集合类，则在把值类型转换为引用类型和把引用类型转换为值类型时，需要进行装箱和拆箱操作。操作很容易，但是性能损失比较大，遍历许多项时尤其如此。</p><p>​        使用List<T>定义泛型为int时，就不需要再进行装箱和拆箱操作。</T></p><h3 id="6-1-2类型安全"><a href="#6-1-2类型安全" class="headerlink" title="6.1.2类型安全"></a>6.1.2类型安全</h3><p>​        泛型类List<T>中，泛型类型T定义了允许使用过的类型，有了List<int> 的定义，就只能把证书类型添加到集合中。</int></T></p><h3 id="6-1-3二进制代码的重用"><a href="#6-1-3二进制代码的重用" class="headerlink" title="#6.1.3二进制代码的重用"></a>#6.1.3二进制代码的重用</h3><p>​        泛型允许更好的重用二进制代码，泛型类可以定义一次，并且可以用许多不同的类型实例化。</p><h3 id="6-1-4代码的扩展"><a href="#6-1-4代码的扩展" class="headerlink" title="6.1.4代码的扩展"></a>6.1.4代码的扩展</h3><p>​        JIT编译器会把泛型类型编译为本地代码时，会给每个值类型创建一个新类</p><h3 id="6-1-5命名约定"><a href="#6-1-5命名约定" class="headerlink" title="6.1.5命名约定"></a>6.1.5命名约定</h3><p>​        泛型类型的命名名称用字母T作为前缀</p><p>​        如果没有特需要求，泛型类型允许用任意类代替</p><p>​        如果泛型类型有特殊要求，（必须实现一个借口）或使用多个泛型类型，就应给泛型类型使用描述性的名称</p><h2 id="6-2创建泛型类"><a href="#6-2创建泛型类" class="headerlink" title="6.2创建泛型类"></a>6.2创建泛型类</h2><p>​    每个处理兑现类型的类都可以有泛型的实现方式，另外，如果类使用了层次结构，泛型就非常有助于消除类型强制转换操作</p><h2 id="6-3泛型类的功能"><a href="#6-3泛型类的功能" class="headerlink" title="6.3泛型类的功能"></a>6.3泛型类的功能</h2><h3 id="6-3-1默认值"><a href="#6-3-1默认值" class="headerlink" title="6.3.1默认值"></a>6.3.1默认值</h3><p>​    不能把null赋值非泛型类型，因为泛型类型也可以实例化为值类型，而null只能用于引用;</p><p>​    使用default关键字，将null值赋予引用类型，将0赋予值类型</p><h3 id="6-3-2约束"><a href="#6-3-2约束" class="headerlink" title="6.3.2约束"></a>6.3.2约束</h3><p>​    如果泛型需要调用泛型类型中的方法，就必须添加约束</p><p>​    泛型支持的几种约束</p><p>​        where T:struct  必须是值类型</p><p>​        where T:class 必须是引用类型</p><p>​        where T:IFoo 必须是实现接口IFoo</p><p>​        where T:Foo 必须是派生自Foo</p><p>​        where T:new() 构造函数约束，指定T必须有一个默认构造函数</p><p>​        where T1:T2  类型T1派生自泛型类型T2</p><h3 id="6-3-3-继承"><a href="#6-3-3-继承" class="headerlink" title="6.3.3 继承"></a>6.3.3 继承</h3><p>​        泛型类可以实现泛型接口，也可以派生自一个类，泛型类可以派生自泛型类</p><p>​        要求必须重复接口的泛型类型，或者必须制定基类的类型</p><p>​        派生类可以是泛型类型或非泛型类型</p><h3 id="6-3-4静态成员"><a href="#6-3-4静态成员" class="headerlink" title="6.3.4静态成员"></a>6.3.4静态成员</h3><h2 id="6-4泛型接口"><a href="#6-4泛型接口" class="headerlink" title="6.4泛型接口"></a>6.4泛型接口</h2><p>6.4.1协变和抗变</p><p>.net 4之前泛型接口是不变的，。net4通过协变和抗变为泛型接口和泛型委托添加了一个重要的扩展。</p><p>协变和抗变指对参数和返回值的类型进行转换</p><p>6.4.2泛型接口的协变</p><p>​        如果泛型类型用out关键字标注，泛型接口是协变得。这也意味着返回类型只能是T</p><p>6.4.3泛型接口的抗变</p><p>​        如果泛型类型用in关键字标注，泛型接口是抗变的。这也意味着输入只能是T</p><h2 id="6-5泛型结构"><a href="#6-5泛型结构" class="headerlink" title="6.5泛型结构"></a>6.5泛型结构</h2><p>Nullable<T>  =&gt;Nullable<int> =&gt; int?</int></T></p><blockquote><p>int y1 = x1??0; </p></blockquote><h2 id="6-6泛型方法"><a href="#6-6泛型方法" class="headerlink" title="6.6泛型方法"></a>6.6泛型方法</h2><p>6.6.1泛型方法示例</p><p>6.6.2带约束的泛型方法</p><p>6.6.3带委托的泛型方法</p><p>6.6.4泛型方法规范</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第五章 托管和非托管的资源</title>
      <link href="2021/02/18/c-10/c-10th-05/"/>
      <url>2021/02/18/c-10/c-10th-05/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第五章-托管和非托管的资源"><a href="#c-语言-第五章-托管和非托管的资源" class="headerlink" title="c#语言 第五章 托管和非托管的资源"></a>c#语言 第五章 托管和非托管的资源</h1><h2 id="5-1资源"><a href="#5-1资源" class="headerlink" title="5.1资源"></a>5.1资源</h2><p>使用托管和非托管的资源—存储在托管或本机堆中的对象，尽管垃圾收集齐释放存储在托管堆中的托管对象，但不释放本机堆中的对象，必须由开发人员自己释放</p><p>什么是大小对象堆？</p><p>什么数据类型存储在堆栈上是非常有益的？</p><p>垃圾收集器处理托管的资源，那么非托管的资源呢？</p><h2 id="5-2后台内存管理"><a href="#5-2后台内存管理" class="headerlink" title="5.2后台内存管理"></a>5.2后台内存管理</h2><h3 id="5-2-1值类型数据"><a href="#5-2-1值类型数据" class="headerlink" title="5.2.1值类型数据"></a>5.2.1值类型数据</h3><p>虚拟内存：执行代码、代码加载的所有DLL、以及程序运行时使用的所有变量</p><p>栈–值类型数据</p><p>​    块作用域或结构作用域：生存期嵌套</p><p>​    编译器在内部确保先放在内存中的那个变量后删除</p><h3 id="5-2-2引用数据类型"><a href="#5-2-2引用数据类型" class="headerlink" title="5.2.2引用数据类型"></a>5.2.2引用数据类型</h3><p>​    所有引用类型，托管堆</p><p>首先创建对象时，分配堆上的内存以存储对象（真正的对象），然后把变量的值设置为分配给新对象的内存地址</p><p>把一个引用变量的值赋予两一个相同类型的变量，就有两个变量引用内存中的同一对象了；当一个引用变量超出作用域时，它会从栈中删除，但是引用对象的数据让保留在堆中</p><p>只有到程序停止，或垃圾回收器删除为止。只有数据不再被任何变量引用时，它才会被删除</p><h3 id="5-2-3-垃圾回收-System-GC-Collect"><a href="#5-2-3-垃圾回收-System-GC-Collect" class="headerlink" title="5.2.3 垃圾回收  System.GC.Collect()"></a>5.2.3 垃圾回收  System.GC.Collect()</h3><p>​    在垃圾回收器运行时，它会从堆中删除不再引用的所有对象</p><p>​    只要释放了能释放的所有对象，就会把其它对象移动回堆的端部，再次形成一个连续的内存块</p><p>​    垃圾回收器的这个压缩操作是托管的堆与非托管的堆的区别所在，使用托管的堆，就只需要读取指针的值即可，而不需要遍历地址的链表，来查找一个地方放置新数据</p><p>​    大对象堆：在.net 下，较大对象有自己的托管堆，使用大于85000个字节的对象时，就会放在这个特殊的堆上</p><h2 id="5-3强引用-和弱引用"><a href="#5-3强引用-和弱引用" class="headerlink" title="5.3强引用 和弱引用"></a>5.3强引用 和弱引用</h2><p>​    垃圾回收器不能回收仍在引用的对象的内存 —-这是一个强引用</p><p>​    弱引用WeakPeference：允许创建和使用对象，但垃圾回收器碰巧在运行，就会回收对象并释放内存，由于潜在的bug和性能问题，一般不这么做</p><h2 id="5-4处理非托管的资源"><a href="#5-4处理非托管的资源" class="headerlink" title="5.4处理非托管的资源"></a>5.4处理非托管的资源</h2><p>​    垃圾回收器不知道如何释放非托管的资源，例如：文件句柄、网络连接、和数据库连接</p><p>​    定义一个类时，可以使用两种机制来自动释放非托管的资源</p><p>​            声明一个析构函数（终结器），作为类的一个成员</p><p>​            在类中实现System.IDispossable接口</p><h3 id="5-4-1析构函数或终结器finalizer"><a href="#5-4-1析构函数或终结器finalizer" class="headerlink" title="5.4.1析构函数或终结器finalizer"></a>5.4.1析构函数或终结器finalizer</h3><p>​    c#编译器在编译析构函数时，会隐式的把析构函数的代码编译为等价于重写Finalize（）方法的代码，从而确保执行父类的Finalize（）方法</p><p>缺点：</p><p>​    无法确定c#对象的析构函数何时执行，所以不能再析构函数中放置需要在某一时刻运行的代码</p><p>​    c#析构函数的实现会延迟对象最终从内存中删除的时间</p><p>5.4.2IDispossable接口</p><pre><code> 在c#中，推荐使用System.IDispossable接口代替析构函数，接口定义了一种模式（具有语言级的支持）该模式为释放非托管资源提供了确定的机制，并避免产生析构函数固有的与垃圾回收器相关的问题。</code></pre><p>​    IDispossable接口声明了一个Dispose()方法，不带参数，返回void。显示的释放有对象直接使用的所有非托管资源</p><blockquote><p>ResourceGobbler theInstance =null;</p><p>try{</p><p>​    theInstance = new ResourceGobbler ()</p><p> }</p><p>finally{</p><p>theInstance ?.Dispose()</p><p>}</p></blockquote><p>​    </p><h3 id="5-4-3using语句"><a href="#5-4-3using语句" class="headerlink" title="5.4.3using语句"></a>5.4.3using语句</h3><p>​    使用try/finally，即使处理过程中出现异常，也可以确保总是在调用Dispose方法释放了资源，但是每个都需要这样重复度的结构；</p><p>​        c#提供另一种语法using，实现IDispossable接口的对象在超出作用域时，自动调用Dipose方法；</p><blockquote><p>using(var    theInstance = new ResourceGobbler ()){</p><p>//do something()</p><p>}</p></blockquote><h3 id="5-4-4-实现IDispossable接口和析构函数"><a href="#5-4-4-实现IDispossable接口和析构函数" class="headerlink" title="5.4.4 实现IDispossable接口和析构函数"></a>5.4.4 实现IDispossable接口和析构函数</h3><p>总结资源释放的两种方式：</p><p>​        利用运行库强制执行的析构函数，但它的执行是不确定的，而且由于垃圾回收的工作方式，会给运行库增加不可接受的系统开销</p><p>​        IDispossable接口提供了一种机制，允许类的用户控制释放资源的时间，但需要确保调用Dispose()方法</p><p>双重实现，创建终结器，实现IDispossabe结构，同时把析构函数作为一种安全机制，以防没有调用Dispose方法</p><h3 id="5-4-5IDispossable和终结器的规则"><a href="#5-4-5IDispossable和终结器的规则" class="headerlink" title="5.4.5IDispossable和终结器的规则"></a>5.4.5IDispossable和终结器的规则</h3><p>​    如果类定义实现了IDispossable的成员，该类也应该实现IDispossable</p><p>​    实现IDispossable并不以为也应该实现一个终结器，终结器会带来额外的开销</p><p>​    如果实现了终结器，也应该实现IDispossable接口，这样可以早些释放资源，不必等GC回收</p><p>​    如果使用的一个对象实现了IDispossable接口，就不在需要对象时调用Dispose方法。如果在方法中使用这个对象，using语句比较方便。如果对象时类的一个成员，就让类也实现IDispossable</p><h2 id="5-5不安全的代码"><a href="#5-5不安全的代码" class="headerlink" title="5.5不安全的代码"></a>5.5不安全的代码</h2><p>​    由于性能问题，要在外部的DLL中访问一个函数，该函数需要把一个指针当做参数来传递（WindowsAPI）,本节将讨论c#直接访问内存的内容的功能</p><h3 id="5-5-1用指针直接访问内存"><a href="#5-5-1用指针直接访问内存" class="headerlink" title="5.5.1用指针直接访问内存"></a>5.5.1用指针直接访问内存</h3><p>​    指针是一个以与引用相同的方式存储地址的变量；其区别是c#不允许直接访问在引用变量中包含的地址。</p><p>​    使用指针，就可以访问实际内存地址，执行新类型的操作</p><p>使用指针的两个原因：</p><p>​        向后兼容性：调用windowsAPI函数，这些函数都是用c++或c#语言编写的，通常要求把指针作为其参数，</p><p>​        性能：在一些情况下，速度是最重要的，而指针可以提供最优性能，</p><p>这种地接别的访问也是有代价的</p><p>​        指针使用起来比较困难，需要非常高的变成技巧和很强的能力</p><pre><code>     很容易重写其他变量，导致栈溢出，访问某些没有存储变量的内存区域，甚至重写.net运行库，使程序崩溃</code></pre><p>​        另外，如果使用指针，就必须授予代码运行库的代码访问安全机制的最高级别</p><p>强烈建议轻易不要使用指针，不仅难以编写，还无法通过CLR施加的内存类型和安全检查</p><h4 id="用unsafe编写不安全的代码"><a href="#用unsafe编写不安全的代码" class="headerlink" title="用unsafe编写不安全的代码"></a>用unsafe编写不安全的代码</h4><p>​    任何方法都可以标记为unsafe，还允许把指针作为参数，也可以把整个类或结构标记为unsafe，假定所有的成员都是不安全的</p><p>​    也可以把方法中的一块代码标记为unsafe；不能把局部变量本身标记为unsafe</p><h4 id="指针的语法"><a href="#指针的语法" class="headerlink" title="指针的语法 *"></a>指针的语法 *</h4><p>指针可以声明为任意一种值类型，也可以声明为一个结构</p><p>int* pWidth,pHeight;</p><p>&amp;表示取地址</p><p>*表示获取地址的内容</p><h4 id="将指针强制转换为整数类型"><a href="#将指针强制转换为整数类型" class="headerlink" title="将指针强制转换为整数类型"></a>将指针强制转换为整数类型</h4><h4 id="指针类型之间的强制转换"><a href="#指针类型之间的强制转换" class="headerlink" title="指针类型之间的强制转换"></a>指针类型之间的强制转换</h4><h4 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a>void指针</h4><h4 id="指针算术的运算"><a href="#指针算术的运算" class="headerlink" title="指针算术的运算"></a>指针算术的运算</h4><h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><h4 id="结构指针，指针成员访问运算符"><a href="#结构指针，指针成员访问运算符" class="headerlink" title="结构指针，指针成员访问运算符"></a>结构指针，指针成员访问运算符</h4><h4 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h4><h3 id="5-5-2指针实例-：PointerPlayground"><a href="#5-5-2指针实例-：PointerPlayground" class="headerlink" title="5.5.2指针实例  ：PointerPlayground"></a>5.5.2指针实例  ：PointerPlayground</h3><h3 id="5-5-3使用指针优化性能"><a href="#5-5-3使用指针优化性能" class="headerlink" title="5.5.3使用指针优化性能"></a>5.5.3使用指针优化性能</h3><p>创建一个基于栈的数组</p><p>QuickArray示例</p><h2 id="5-6平台调用"><a href="#5-6平台调用" class="headerlink" title="5.6平台调用"></a>5.6平台调用</h2>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 托管 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="2021/02/18/rabbitmq/rabbitmq/"/>
      <url>2021/02/18/rabbitmq/rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-RabbitMQ简介"><a href="#第一章-RabbitMQ简介" class="headerlink" title="第一章 RabbitMQ简介"></a>第一章 RabbitMQ简介</h1><h2 id="1-1-什么是消息中间件"><a href="#1-1-什么是消息中间件" class="headerlink" title="1.1 什么是消息中间件"></a>1.1 什么是消息中间件</h2><p> 　　消息是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串、Json等，也可以很复杂，比如内嵌对象。</p><p> 　　消息队列中间件是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。</p><p>　　一般有两种传递模式：点对点模式和发布/订阅模式。点对点模式是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息，队列的存在使得消息的异步传输称为可能。发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者从主题中订阅想消息。主题使得消息订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布/订阅模式在消息的一对多广播时采用。</p><p>　　比较流行的消息中间件有：RabbitMQ、Kafka、ActiveMQ、RocketMQ等。</p><p>　　消息中间件适用于需要可靠的数据传送的分布式环境。采用消息中间件的系统中，不同的对象之间通过传递消息来激活对方的事件，已完成相应的操作。发送者将消息发送给消息服务器，消息服务器将消息存放在若干队列中，在合适的时候，再将消息转发给接收者。</p><h2 id="1-2-消息中间件的作用"><a href="#1-2-消息中间件的作用" class="headerlink" title="1.2 消息中间件的作用"></a>1.2 消息中间件的作用</h2><p>　　解耦：在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束即可。</p><p>　　冗余（存储）：有些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。</p><p> 　　扩展性：因为消息中间件解耦了应用程序的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。</p><p>　　削峰：在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发方访压力，不会因为突发的超负荷请求而完全奔溃。</p><p>　　可恢复性：当系统一部分组件失效时，不会影响到整个系统，消息中间件降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。</p><p>　　顺序保证：在大多数情景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。</p><p>　　缓冲：在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制和优化数据流经过系统的速度。</p><p>　　异步通信：在很多时候应用不想在不需要立即处理消息。消息中间件提供了异步处理机制，允许应用把一些消息放入消息中间件中，但不立即处理它，在之后需要的时候再慢慢处理。</p><h2 id="1-3-RabbitMQ的起源"><a href="#1-3-RabbitMQ的起源" class="headerlink" title="1.3 RabbitMQ的起源"></a>1.3 RabbitMQ的起源</h2><p>　　RabbitMQ是采用Erlang语言实现的AMQP（Advanced Message Queuing Protocol，高级消息队列协议）的消息 中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p><h2 id="1-4-RabbitMQ的安装及简单实用"><a href="#1-4-RabbitMQ的安装及简单实用" class="headerlink" title="1.4 RabbitMQ的安装及简单实用"></a>1.4 RabbitMQ的安装及简单实用</h2><p>　　本示例演示在ubuntu18.04.3中安装和使用rabbitMQ</p><blockquote><p>sudo apt-get update -y<br>sudo apt-get install erlang-nox rabbitmq-server -y<br>sudo rabbitmq-server start<br>sudo rabbitmq-server stop<br>sudo rabbitmq-server restart<br>sudo rabbitmqctl status</p><p>添加用户并且赋予权限</p><p>sudo rabbitmqctl add_user admin admin<br>sudo rabbitmqctl set_user_tags admin administrator<br>sudo rabbitmqctl  set_permissions -p / admin ‘.<em>‘ ‘.</em>‘ ‘.*’<br>sudo rabbitmq-plugins enable rabbitmq_management</p><p>sudo rabbitmqctl change_password admin ‘admin’</p></blockquote><h1 id="第二章-RabbitMQ-入门"><a href="#第二章-RabbitMQ-入门" class="headerlink" title="第二章 RabbitMQ 入门"></a>第二章 RabbitMQ 入门</h1><h2 id="2-1-相关概念介绍"><a href="#2-1-相关概念介绍" class="headerlink" title="2.1 相关概念介绍"></a>2.1 相关概念介绍</h2><p>　　RabbitMQ整体上市一个是生产者与消费者模型。主要负责接收、存储和转发消息。</p><p>　　RabbitMQ的整体模型架构如下图所示：</p><p>　　<img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200116100133957-524774026.png" alt="img"></p><h2 id="2-1-1-生产者和消费者"><a href="#2-1-1-生产者和消费者" class="headerlink" title="2.1.1 生产者和消费者"></a>2.1.1 生产者和消费者</h2><p>　　Producer：生产者，就是投递消息的一方。消息一般可以包含2个部分：消息体和标签（Label）。消息体也可以称之为payload，在实际应用中，消息体一般是一个带有业务逻辑结构的数据，比如一个JSON字符串。</p><p>　　Consumer：消费者，就算是接收消息的一方。</p><p>　　Broker：消息中间件的服务节点。</p><p>　　对于RabbitMQ来说，一个RabbitMQ Broker可以简单地看作一个RabbitMQ服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个RabbitMQ Broker看作一台RabbitMQ服务器。</p><p>　　下图展示了生产者将消息存入RabbitMQ Broker，以及消费者从Broker中消费数据的整个流程。</p><p>　　<img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200116101001502-1945693905.png" alt="img"></p><p> 2.1.2 队列</p><p>Queue：队列，是RabbitMQ的内部对象，用于存储消息。</p><p><img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200117113432130-466580577.png" alt="img"></p><p> RabbitMQ中消息都只能存储在队列中。U盾讴歌消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p><p><img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200117114049922-590796568.png" alt="img"></p><p> RabbitMQ不支持队列层面的广播消息，如果需要广播消息，需要在其上进行二次开发，处理逻辑会变得异常复杂，同时也不建议这么做。</p><p>2.1.3 交换器、路由件、绑定</p><p>Exchange：交换器。生产者将消息发送到Exchange（交换器，通常也可以用大写的“X”来表示）。由交换器将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃。</p><p><img src="https://img2018.cnblogs.com/blog/228038/202001/228038-20200117114708911-1388748529.png" alt="img"></p><p> RoutingKey：路右键。生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个Routing Key需要与交换器类型和绑定建（BindingKey）联合使用才能最终生效。</p><p>在交换器类型和绑定建（BindingKey）固定的情况下，生产者可以发送消息给交换器时，通过指定RoutingKey来决定消息流向哪里。</p><p>备注：本文转载于<a href="https://www.cnblogs.com/yuzhou133/p/12197311.html">https://www.cnblogs.com/yuzhou133/p/12197311.html</a></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第四章 继承</title>
      <link href="2021/02/17/c-10/c-10th-04/"/>
      <url>2021/02/17/c-10/c-10th-04/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第四章-继承"><a href="#c-语言-第四章-继承" class="headerlink" title="c#语言 第四章 继承"></a>c#语言 第四章 继承</h1><h2 id="4-1继承"><a href="#4-1继承" class="headerlink" title="4.1继承"></a>4.1继承</h2><p>面向对象的三个重要概念：继承、封装、多态</p><h2 id="4-2继承的类型"><a href="#4-2继承的类型" class="headerlink" title="4.2继承的类型"></a>4.2继承的类型</h2><p>面向对象（Object-Oriented,OO）术语，c#的继承</p><p>单重继承：c#</p><p>多重继承：一个类可以派生自多个类，c#不支持</p><p>多层继承：B派生自A，C派生自B，c#支持</p><p>接口继承：c#允许接口多继承</p><h3 id="4-2-1-多重继承-c"><a href="#4-2-1-多重继承-c" class="headerlink" title="4.2.1 多重继承 c++"></a>4.2.1 多重继承 c++</h3><p>多重继承会给生成的代码增加复杂性，还会带来一些开销。c#决定不支持多重继承。</p><p>c#允许派生自多个接口，一个类型可以实现多个接口。System.Object 是一个公共的基类，每个c#类（除了Object类之外）都有一个基类，还可以有人以多个基接口</p><h3 id="4-2-2-结构和类"><a href="#4-2-2-结构和类" class="headerlink" title="4.2.2 结构和类"></a>4.2.2 结构和类</h3><p>使用结构的一个限制是结构不支持继承，但每个结构都派生自system.ValueType . 但接口可以实现接口</p><h2 id="4-3实现继承-class-A：B"><a href="#4-3实现继承-class-A：B" class="headerlink" title="4.3实现继承 class A：B{}"></a>4.3实现继承 class A：B{}</h2><p>如果类和接口都用于派生，则类总是必须放在接口的前面</p><p>结构只能实现接口继承</p><p>类定义中更没有指定基类，c#编译器就假定 System.Object是基类</p><h3 id="4-3-1虚方法"><a href="#4-3-1虚方法" class="headerlink" title="4.3.1虚方法"></a>4.3.1虚方法</h3><p>  virtual </p><p>​    把一个基类方法声明为virtual，就可以在任何派生类中重写该方法</p><p>​    也可以把属性声明为virtual</p><p>​    成员字段和静态函数不能声明为virtual，因为这个概念只对类中实例函数成员有意义</p><p>override 显示声明重写</p><h3 id="4-3-2-多态性"><a href="#4-3-2-多态性" class="headerlink" title="4.3.2 多态性"></a>4.3.2 多态性</h3><p>多态性，动态地定义调用的方法，而不是在编译期间定义</p><h3 id="4-3-3隐藏方法"><a href="#4-3-3隐藏方法" class="headerlink" title="4.3.3隐藏方法"></a>4.3.3隐藏方法</h3><p>如果签名相同的方法在基类和派生类中都进行了声明，但该方法没有分别声明为virtual和override，派生类方法就会隐藏基类方法</p><p>用new关键词隐藏方法，避免出现编译器警告</p><h3 id="4-3-4调用基类版本方法base-fn"><a href="#4-3-4调用基类版本方法base-fn" class="headerlink" title="4.3.4调用基类版本方法base.fn()"></a>4.3.4调用基类版本方法base.fn()</h3><h3 id="4-3-5抽象类和抽象方法"><a href="#4-3-5抽象类和抽象方法" class="headerlink" title="4.3.5抽象类和抽象方法"></a>4.3.5抽象类和抽象方法</h3><p>abstract 抽象类不能实例化，抽象法法不能直接实现，必须在非抽象类的派生类中重写； 如果类包含抽象方法，则该类也是抽象的，也必须声明为抽象的</p><h3 id="4-3-6密封类和密封方法sealed"><a href="#4-3-6密封类和密封方法sealed" class="headerlink" title="4.3.6密封类和密封方法sealed"></a>4.3.6密封类和密封方法sealed</h3><p>对于密封类，编译器知道不能派生类</p><p>string是密封的</p><h3 id="4-3-7派生类的构造函数"><a href="#4-3-7派生类的构造函数" class="headerlink" title="4.3.7派生类的构造函数"></a>4.3.7派生类的构造函数</h3><p>​        创建派生类实例时，会有多个构造函数起作用个，要实例化类的构造函数本身不能初始化类，还必须调用其基类中的构造函数，通过层级结构进行构造</p><p>​        如果派生类没必要定义新的构造函数，仍可以提供一个构造函数，条用基构造函数base()</p><h2 id="4-4修饰符"><a href="#4-4修饰符" class="headerlink" title="4.4修饰符"></a>4.4修饰符</h2><p>4.4.1访问修饰符</p><p>逻辑访问修饰符  public protected private</p><p>物理访问修饰符 internal</p><p>不能把类型定义为protected、private或 protected internal，因为这些修饰符对包含在命名空间中的类型没有意义，这些只能用于成员。但可以修饰嵌套的类型，类型也具有成员的状态</p><p>如果有嵌套的类型，内部的类型总是可以访问外部类型的所有成员</p><p>4.4.2其他修饰符</p><p>new static virtual abstract override sealed  extern</p><h2 id="4-5接口"><a href="#4-5接口" class="headerlink" title="4.5接口"></a>4.5接口</h2><p>Microsoft 预定义的一个几口System.IDisposable的完整定义，包含一个方法Dispose（），该方法由类实现，用于清理代码</p><p>声明接口在于发生和声明抽象类完全相同，但不允许提供接口中任何成员的实现方式，一般情况下，接口只能包含方法、属性、索引器、和事件的声明</p><p>抽象类： 可以有实现代码或没有实现代码的抽象成员，</p><p>接口：不能有任何实现代码，纯粹抽象的；所以接口不需要abstract关键字</p><p>接口不能有构造函数，也不能有字段，不能声明为virtual</p><p>4.5.1定义和实现接口</p><p>从接口中派生独立于从类中派生</p><p>4.5.2派生的接口</p><h2 id="4-6-is-和as-运算符"><a href="#4-6-is-和as-运算符" class="headerlink" title="4.6 is 和as 运算符"></a>4.6 is 和as 运算符</h2><p>as返回对象的引用，如果对象不是所要求的的类型，则返回null</p><p>is运算符，判读是否满足，true则继续进行强制转换</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第三章 对象和类型</title>
      <link href="2021/02/17/c-10/c-10th-03/"/>
      <url>2021/02/17/c-10/c-10th-03/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第三章-对象和类型"><a href="#c-语言-第三章-对象和类型" class="headerlink" title="c#语言 第三章 对象和类型"></a>c#语言 第三章 对象和类型</h1><h2 id="3-2-类和结构的区别"><a href="#3-2-类和结构的区别" class="headerlink" title="3.2 类和结构的区别"></a>3.2 类和结构的区别</h2><p>​    类和结构实际上都是常见对象的模板</p><p>​    类是引用类型</p><p>​    结构是值类型</p><p>​    较小的数据类型使用结构可以提高性能</p><p>​    类和结构都用new来声明实例</p><h2 id="3-3-类"><a href="#3-3-类" class="headerlink" title="3.3 类"></a>3.3 类</h2><p>类包含成员。成员可以是静态成员或实例成员，static静态成员属于类；实例成员属于对象</p><p>成员：字段、常量、方法、属性、构造函数、索引器、运算符、事件、析构函数、类型</p><h3 id="3-3-1字段"><a href="#3-3-1字段" class="headerlink" title="3.3.1字段"></a>3.3.1字段</h3><p>​       const 常量 公开 public</p><p>​      最好把字段声明为private</p><h3 id="2-3-2属性"><a href="#2-3-2属性" class="headerlink" title="2.3.2属性"></a>2.3.2属性</h3><p> 一个方法或一对方法，看起来是一个字段</p><h4 id="自动实现的属性："><a href="#自动实现的属性：" class="headerlink" title="自动实现的属性："></a>自动实现的属性：</h4><p>​    set；get；访问器没有任何逻辑，属性会自动实现后备成员变量</p><p>​    属性初始化器来初始化 public int Age {get;set;}=42;</p><h4 id="属性的访问修饰符"><a href="#属性的访问修饰符" class="headerlink" title="属性的访问修饰符"></a>属性的访问修饰符</h4><p>​    public get private set</p><h3 id="3-3-3方法"><a href="#3-3-3方法" class="headerlink" title="3.3.3方法"></a>3.3.3方法</h3><p>非数据成员</p><p>​      正式的c#术语区分函数和方法，在c#术语中，函数成员不仅包含方法，也包含类或结构的一些非数据成员，如索引器、运算符、构造函数、析构函数等，还有属性，这些事非数据成员</p><p>数据成员</p><p>​    字段、常量、事件才是数据成员</p><h4 id="方法的声明"><a href="#方法的声明" class="headerlink" title="方法的声明"></a>方法的声明</h4><p>​    表达式体方法：  =&gt; 区分操作符左边的声明和右边的实现代码</p><p>​    调用方法</p><h4 id="方法的重载："><a href="#方法的重载：" class="headerlink" title="方法的重载："></a>方法的重载：</h4><p>​    方法名相同，但是参数的数量和/或数据类型不同</p><h4 id="命名的参数："><a href="#命名的参数：" class="headerlink" title="命名的参数："></a>命名的参数：</h4><p>​    任何方法都可以使用命名的参数调用，编译器会去掉变量名</p><p>这种方式更改变量的顺序，编译器会重新安排，获得正确的顺序</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>​    一个或多个，可选参数置后</p><h4 id="个数可变的参数-params关键字"><a href="#个数可变的参数-params关键字" class="headerlink" title="个数可变的参数 params关键字"></a>个数可变的参数 params关键字</h4><p>​    如果params关键字与方法签名定义的多个参数一起使用，params只能使用一次，且必须是最后一个参数</p><h3 id="3-3-4构造函数"><a href="#3-3-4构造函数" class="headerlink" title="3.3.4构造函数"></a>3.3.4构造函数</h3><p>​    如果没有构造函数，编译器会默认生成一个默认的构造函数（引用类型为空引用，数值类型为0，bool为false）</p><p>构造函数的重载遵循与其他方法相同的规则 ；</p><p>​    构造函数的重载遵循与其他方法相同的</p><p>​    如果提供了带参数的构造函数，编译器就不会自动提供默认的构造函数</p><p>​    可以把构造函数定义为private或者protected，这样不相关的类就不能访问他们</p><p><strong>没有公有或受保护的构造函数的用法</strong></p><p>​    类仅仅是静态成员或属性的容器，永远不会实例化，static修饰类，只能包含静态成员，不能实例化</p><p>​    希望仅通过条用个某个静态成员函数来实例化（对象实例化的类工厂方法）（单例模式的实现）</p><h4 id="从构造函数中调用其他构造函数"><a href="#从构造函数中调用其他构造函数" class="headerlink" title="从构造函数中调用其他构造函数"></a>从构造函数中调用其他构造函数</h4><p>​    this关键字仅条用参数最匹配的那个构造函数</p><p>​    c#构造函数初始化器可以包含对同一个类的另一个构造函数的调用，也可以对直接基类的构造函数的调用应使用base代替this关键字，初始化器不能有多个调用</p><h4 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h4><p>​    无参数的静态构造函数</p><p>​        不能带任何参数，一个类只有一个静态构造函数</p><h4 id="只读成员-readonly"><a href="#只读成员-readonly" class="headerlink" title="只读成员 readonly"></a>只读成员 readonly</h4><h4 id="只读字段-readonly"><a href="#只读字段-readonly" class="headerlink" title="只读字段 readonly"></a>只读字段 readonly</h4><h4 id="只读readonly与const的区别"><a href="#只读readonly与const的区别" class="headerlink" title="只读readonly与const的区别"></a>只读readonly与const的区别</h4><p>​        const 编译器通过值取代了使用它的变量，编译器知道它的值</p><p>​        readonly在运行期间通过构造函数制定，与常量字段相反，只读字段可以是实例成员，使用只读字段作为类成员时，需要把static修饰符分配给该字段</p><p>只读字段，不能在构造函数外部赋值</p><p>只读属性{get}</p><p>​    自动实现的只读属性</p><p>​    只读属性也可以在构造函数中初始化</p><p>表达式体属性</p><blockquote><p>public string FullName =&gt; $”{FirstName} {LastName}”;</p></blockquote><p>不可变的类型</p><p>​        例如String，，任何改变总会返回一个新的字符串</p><h2 id="3-4匿名类型"><a href="#3-4匿名类型" class="headerlink" title="3.4匿名类型"></a>3.4匿名类型</h2><h2 id="3-5结构-struct"><a href="#3-5结构-struct" class="headerlink" title="3.5结构 struct"></a>3.5结构 struct</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>​    数据小 提升性能</p><p>​    值类型</p><p>​    不支持继承</p><p>​    分配内存非常快，销毁也快</p><p>​    互相赋予时，会复制一份，有性能损失</p><p>​    当把结构作为参数传递时，应把它作为ref参数传递---避免性能损失，只传递地址；被调用的方法可以改变结构的值</p><h3 id="结构和继承"><a href="#结构和继承" class="headerlink" title="结构和继承"></a>结构和继承</h3><p>​    不能从一个结构中继承</p><p>​    例外： 结构最终派生于类System.Object ,因此可以访问System.Object 的方法</p><p>​    结构 &lt;= System.ValueType&lt;= System.Object</p><h3 id="结构的构造函数"><a href="#结构的构造函数" class="headerlink" title="结构的构造函数"></a>结构的构造函数</h3><h2 id="3-6按值和按引用传递参数"><a href="#3-6按值和按引用传递参数" class="headerlink" title="3.6按值和按引用传递参数"></a>3.6按值和按引用传递参数</h2><h3 id="ref参数-gt-可以通过引用传递结构"><a href="#ref参数-gt-可以通过引用传递结构" class="headerlink" title="ref参数 -&gt;可以通过引用传递结构"></a>ref参数 -&gt;可以通过引用传递结构</h3><p>out参数 -&gt;</p><p>​    如果一个方法返回多个值，可能类型还不同</p><h2 id="3-7可空类型-int-x2-null"><a href="#3-7可空类型-int-x2-null" class="headerlink" title="3.7可空类型  int? x2=null;"></a>3.7可空类型  int? x2=null;</h2><h2 id="3-8枚举-enum"><a href="#3-8枚举-enum" class="headerlink" title="3.8枚举 enum"></a>3.8枚举 enum</h2><p>​    默认enum的类型是int</p><p>​    使用强制类型转换可以把数字改为枚举值，把枚举改为数字</p><p>​    Flags</p><h2 id="3-9-部分类-partial"><a href="#3-9-部分类-partial" class="headerlink" title="3.9 部分类 partial"></a>3.9 部分类 partial</h2><p>​    可以把类分开放在两个文件中</p><p>声明类和结构，返回信息都是类成员</p><p>元组类型</p><h2 id="3-10-扩展方法"><a href="#3-10-扩展方法" class="headerlink" title="3.10 扩展方法"></a>3.10 扩展方法</h2><p>扩展</p><p>​    继承给对象添加功能的好方法</p><p>​    扩展方法是给对象添加功能的另一个选项，在不能使用继承时，可以使用这个选项（例如类是密封的）</p><p>扩展方法是静态方法，是类的一部分，但实际上没有放在类的源代码中</p><p>使用this关键字和第一个参数来扩展字符串，这个关键字定义了要扩展的类型</p><blockquote><p>public static class StringExtension{ public static int<br>GetWordCount(this string s)=&gt; s.Split().Length; ​} ​</p></blockquote><p>好处：</p><p>​    可以使用实例方法的语法，而不是从代码中直接调用静态方法</p><p>​    该方法的实现可以用另一个类取代，而不需要更改代码</p><p>编译器如何找到某个类型的扩展方法？</p><p>​    this关键字必须匹配类型的扩展方法</p><p>​    而且需要打开定义扩展方法的静态类所在名称空间</p><p>​    如果类型还定义了同名的实例方法，扩展方法就永远不会使用</p><p>​    类中已有的实例方法都优先</p><p>Object类，其他类型都从该类派生而来</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> 对象和类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第二章 核心C#</title>
      <link href="2021/02/17/c-10/c-10th-02/"/>
      <url>2021/02/17/c-10/c-10th-02/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-2-核心c"><a href="#c-语言-2-核心c" class="headerlink" title="c#语言 2 核心c#"></a>c#语言 2 核心c#</h1><h2 id="2-3变量"><a href="#2-3变量" class="headerlink" title="2.3变量"></a>2.3变量</h2><p>c# 区分大小写</p><h3 id="2-3-1初始化变量"><a href="#2-3-1初始化变量" class="headerlink" title="2.3.1初始化变量"></a>2.3.1初始化变量</h3><p>​    c#编译器需要用某个初始值对变量进行初始化，之后才能在操作中引用变量；c#中有两个方法可确保变量使用前进行了初始化</p><p>​        变量是类或结构中的字段，如果没有显示初始化，则创建这些变量时，其默认值就是0</p><p>​        方法的局部变量必须在代码中显示初始化，变量初始化之前就使用了其值，编译器就会标记错误</p><h3 id="2-3-2类型推断"><a href="#2-3-2类型推断" class="headerlink" title="2.3.2类型推断"></a>2.3.2类型推断</h3><p>​    变量必须初始化，编译器推断类型的依据</p><p>​    初始化器不能为空</p><p>​    初始化器必须放在表达式中</p><p>​    不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象</p><h3 id="2-3-3变量的作用域"><a href="#2-3-3变量的作用域" class="headerlink" title="2.3.3变量的作用域"></a>2.3.3变量的作用域</h3><p>定义或规则</p><p>​    只要类在某个作用域内，其字段也在该作用域内</p><p>​    局部变量存在于表示声明该变量的块语句或方法结束的右花括号之前的作用域内</p><p>​    在 for whild 或类似语句中声明的局部变量存在于该循环体内</p><h4 id="局部变量的作用域冲突"><a href="#局部变量的作用域冲突" class="headerlink" title="局部变量的作用域冲突"></a>局部变量的作用域冲突</h4><h4 id="字段和局部变量的作用域冲突"><a href="#字段和局部变量的作用域冲突" class="headerlink" title="字段和局部变量的作用域冲突"></a>字段和局部变量的作用域冲突</h4><blockquote><p>class program{ static int j=20; static void Main(){ int<br>j=30;WriteLine(j); WriteLine(program.j) } ​}</p></blockquote><h3 id="2-3-4常量"><a href="#2-3-4常量" class="headerlink" title="2.3.4常量"></a>2.3.4常量</h3><p>特点</p><p>​    常量声明时必须初始化，指定其值后，就不能再改写了、</p><p>​    常量的值必须在编译时用于计算，因此不能用从变量中提取的值来初始化常亮</p><p>​    常量总是隐式静态的</p><p>好处</p><p>​    易于读取的名称</p><p>​    是程序更易于修改</p><p>​    更容易避免程序出现错误</p><h2 id="2-4预定义数据类型"><a href="#2-4预定义数据类型" class="headerlink" title="2.4预定义数据类型"></a>2.4预定义数据类型</h2><h3 id="2-4-1-值类型和引用类型"><a href="#2-4-1-值类型和引用类型" class="headerlink" title="2.4.1 值类型和引用类型"></a>2.4.1 值类型和引用类型</h3><p>堆栈</p><p>​    值类型存储在堆栈中stack</p><p>​    引用各类型存储在托管堆中 managed heap</p><p>bool 和long等都是值类型，值类型的赋予是通过值复制的</p><p>大多数更复杂的c#数据类型，包括自己声明的类，都是引用类型</p><p>​    CLR实现一种精细的算法，来跟踪哪些引用变量是可以访问的，哪些不能访问，CLR会定期删除不能访问的对象，把占用的内存返回给操作系统，垃圾回收器</p><p>​    如果要把自己的类型定义为值类型，就应把它声明为一个结构</p><h3 id="2-4-2-net-类型"><a href="#2-4-2-net-类型" class="headerlink" title="2.4.2 .net 类型"></a>2.4.2 .net 类型</h3><p>​    15个预定义类型，13个值类型，两个引用类型string 和 object</p><h3 id="2-4-3预定义的值类型"><a href="#2-4-3预定义的值类型" class="headerlink" title="2.4.3预定义的值类型"></a>2.4.3预定义的值类型</h3><p>整型 sbyte 8 short 16 int32 long64</p><p>浮点类型 float32位单精度浮点，double 64位双精度浮点 15/16</p><p>decimal类型 128位高精度十进制数表示法<br>（decimal类型不是基本类型，计算时有性能损失）(高精度计算)</p><blockquote><p>decimal d =12.30M;</p></blockquote><p>bool类型</p><p>字符类型 char 表示一个16位的Unicode字符</p><p>​    转义字符\</p><h3 id="2-4-4预定义的引用类型"><a href="#2-4-4预定义的引用类型" class="headerlink" title="2.4.4预定义的引用类型"></a>2.4.4预定义的引用类型</h3><h4 id="object-类型"><a href="#object-类型" class="headerlink" title="object 类型"></a>object 类型</h4><p>​     可以使用object引用来绑定任何特定子类型的对象;如值类型装箱，再移动到堆中，object引用也可以用于反射，此时必须有代码来处理类型未知的对象</p><p>​    object类型实现了许多一般用途的基本方法，包括Equals(),GetHashCode(),GetType()和ToString()用户定义的类型需要使用一种面向对象技术---重写</p><h4 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h4><p>​    字符串不可修改，修改会产生新的string对象</p><p>​    @的使用，看做所有字符保持原来的含义</p><p>​    字符串插值功能 $</p><h2 id="2-5程序流控制"><a href="#2-5程序流控制" class="headerlink" title="2.5程序流控制"></a>2.5程序流控制</h2><p>if</p><p>for</p><p>while</p><p>do while</p><p>foreach 不能改变集合中各项的值</p><p>跳转语句</p><p>goto语句<br>不能跳转像for循环这样的代码块中，也不能跳出类的范围，不能退出try<br>catch后面的finally</p><p>break语句</p><p>switch 中退出某个语句</p><p>也可用于for foreach whild do...while</p><p>continue语句 只能退出循环的当前迭代</p><p>return 语句 退出类的方法</p><h2 id="2-6-枚举"><a href="#2-6-枚举" class="headerlink" title="2.6 枚举"></a>2.6 枚举</h2><h3 id="枚举是用户定义的整数类型"><a href="#枚举是用户定义的整数类型" class="headerlink" title="枚举是用户定义的整数类型"></a>枚举是用户定义的整数类型</h3><p>优势</p><p>​    代码易于维护，有助于确保给变量制定合法的期望的值</p><p>​    枚举使代码更清晰，允许描述性的蒙城表示整数值，而不是含义模糊的数</p><p>​    更易于输入</p><p>​    枚举真正强大之处，在于实例化为派生自积累system.enum的结构，不会造成性能损失</p><h2 id="2-7名称空间"><a href="#2-7名称空间" class="headerlink" title="2.7名称空间"></a>2.7名称空间</h2><p>using语句</p><h3 id="2-7-2名称空间的别名"><a href="#2-7-2名称空间的别名" class="headerlink" title="2.7.2名称空间的别名"></a>2.7.2名称空间的别名</h3><h2 id="2-8main方法"><a href="#2-8main方法" class="headerlink" title="2.8main方法"></a>2.8main方法</h2><h2 id="2-9使用注释"><a href="#2-9使用注释" class="headerlink" title="2.9使用注释"></a>2.9使用注释</h2><h2 id="2-10-c-预处理指令"><a href="#2-10-c-预处理指令" class="headerlink" title="2.10 c#预处理指令"></a>2.10 c#预处理指令</h2><p>#define 和#undef</p><p>#if #elif #else #endif</p><p>#warning 和#ERROR</p><p>#region 和 #endregion</p><p>#LINE</p><p>#pragma</p><h2 id="2-11c-编程准则"><a href="#2-11c-编程准则" class="headerlink" title="2.11c#编程准则"></a>2.11c#编程准则</h2><h3 id="标识符的规则"><a href="#标识符的规则" class="headerlink" title="标识符的规则"></a>标识符的规则</h3><p>​    尽管可以包含数字字符，但他们必须以字母或下划线开头</p><p>​    不能把c#关键字用作标识符</p><p>用法约定</p><p>命名约定</p><p>​    名称的大小写 Pascal camel</p><p>​    名称的风格统一</p><p>​    名称和关键字</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th)第一章 .net 应用程序体系结构</title>
      <link href="2021/02/17/c-10/c-10th-01/"/>
      <url>2021/02/17/c-10/c-10th-01/</url>
      
        <content type="html"><![CDATA[<h1 id="c-语言-第一章-net-应用程序体系结构"><a href="#c-语言-第一章-net-应用程序体系结构" class="headerlink" title="c#语言 第一章 .net 应用程序体系结构"></a>c#语言 第一章 .net 应用程序体系结构</h1><h2 id="1-2-回顾net-历史"><a href="#1-2-回顾net-历史" class="headerlink" title="1.2.回顾net 历史"></a>1.2.回顾net 历史</h2><h3 id="net-版本"><a href="#net-版本" class="headerlink" title=".net 版本"></a>.net 版本</h3><p>​    CLR(Common Language Runtime) 公共语言运行库</p><p>​    c#</p><p>​    Visual Studio</p><h3 id="1-2-1c-1-0-新语言"><a href="#1-2-1c-1-0-新语言" class="headerlink" title="1.2.1c#1.0 新语言"></a>1.2.1c#1.0 新语言</h3><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><p>​        面向对象编程语言，具备继承，封装和多态性等特性</p><p>​        也提供了基于组件的变成改造，如委托和事件</p><h4 id="CLR"><a href="#CLR" class="headerlink" title="CLR"></a>CLR</h4><p>​     .net 编程语言都使用的运行库，类似java虚拟机</p><p>​     中间语言Intermediate Language IL代码，编译器生成IL代码，当程序运行时，JIT编译器会从IL代码生成本地代码</p><p>​     GC垃圾回收</p><p>​     调试器扩展</p><p>​     线程实用工具</p><p>​    CLR还负责线程的处理，C#中创建托管的线程不一定来自底层操作系统，线程的虚拟化和管理有CLR负责</p><h3 id="1-2-2带有泛型的c-2-和-net-2"><a href="#1-2-2带有泛型的c-2-和-net-2" class="headerlink" title="1.2.2带有泛型的c#2 和.net 2"></a>1.2.2带有泛型的c#2 和.net 2</h3><h3 id="1-2-3-net-3-0-WPF"><a href="#1-2-3-net-3-0-WPF" class="headerlink" title="1.2.3 .net 3.0 WPF"></a>1.2.3 .net 3.0 WPF</h3><p>​    WPF 矢量图形控件</p><p>​     WCF 通用通信</p><h3 id="1-2-4-c-LINQ-EF"><a href="#1-2-4-c-LINQ-EF" class="headerlink" title="1.2.4 c##  LINQ   EF"></a>1.2.4 c##  LINQ   EF</h3><h3 id="1-2-5-c-4-dynamic-TPL-任务并行库"><a href="#1-2-5-c-4-dynamic-TPL-任务并行库" class="headerlink" title="1.2.5  c# 4 dynamic TPL(任务并行库)"></a>1.2.5  c# 4 dynamic TPL(任务并行库)</h3><p>​    使用Task 和 Parallel 类抽象出线程</p><h3 id="1-2-6c-5-异步编程-async-和await"><a href="#1-2-6c-5-异步编程-async-和await" class="headerlink" title="1.2.6c#5 异步编程  async 和await"></a>1.2.6c#5 异步编程  async 和await</h3><h3 id="1-2-7-c-6-新的编译器引擎-Roslyn"><a href="#1-2-7-c-6-新的编译器引擎-Roslyn" class="headerlink" title="1.2.7 c#6 新的编译器引擎 Roslyn"></a>1.2.7 c#6 新的编译器引擎 Roslyn</h3><h4 id="1-3-2-net-core-1-0-CORE-CLI"><a href="#1-3-2-net-core-1-0-CORE-CLI" class="headerlink" title="1.3.2 .net core 1.0   CORE CLI"></a>1.3.2 .net core 1.0   CORE CLI</h4><p>特性：</p><p>​    开源</p><p>​    模块化的方式设计</p><p>​    可以很快更新</p><p>程序集 assembly：编译好的，面向.net framework的代码逻辑单元</p><p>​        私有程序集</p><p>​        共享程序集（Global Assembly Cache）</p><h3 id="1-3-5-公共语言运行库"><a href="#1-3-5-公共语言运行库" class="headerlink" title="1.3.5 公共语言运行库"></a>1.3.5 公共语言运行库</h3><p>​       编译器将源代码编译为Microsoft中间语言(Intermediate Language, IL)生成IL代码，当程序运行时，JIT编译器会从IL代码生成本地代码</p><p>​       CLR还负责线程的处理，C#中创建托管的线程不一定来自底层操作系统，线程的虚拟化和管理有CLR负责</p><h3 id="1-3-7windows运行库-windows-runtime"><a href="#1-3-7windows运行库-windows-runtime" class="headerlink" title="1.3.7windows运行库 windows runtime"></a>1.3.7windows运行库 windows runtime</h3><h2 id="net-2015"><a href="#net-2015" class="headerlink" title=".net 2015"></a>.net 2015</h2><h3 id="1-5-net-4-6编译"><a href="#1-5-net-4-6编译" class="headerlink" title="1.5.net 4.6编译"></a>1.5.net 4.6编译</h3><p>​    c# 命令行编译器（csc.exe）: csc HelloWorld.cs -&gt; 中间语言代码</p><p>​    DASM中间语言反汇编程序 （ildasm.exe）</p><p>.net core cli编译</p><p>​    repl学习 ： dotnet repl</p><h2 id="1-7应用程序类型与技术"><a href="#1-7应用程序类型与技术" class="headerlink" title="1.7应用程序类型与技术"></a>1.7应用程序类型与技术</h2><h3 id="1-7-1数据访问"><a href="#1-7-1数据访问" class="headerlink" title="1.7.1数据访问"></a>1.7.1数据访问</h3><pre><code>Database FirstModel First</code></pre><p>CodeFirst:<br>   代码优先有一定意味着数据库不能事先存在；数据库可以动态创建，属性和流利的API可以以编程方式定义映射</p><h3 id="1-7-2桌面应用程序"><a href="#1-7-2桌面应用程序" class="headerlink" title="1.7.2桌面应用程序"></a>1.7.2桌面应用程序</h3><p>WF WPF</p><h3 id="1-7-3-UWP"><a href="#1-7-3-UWP" class="headerlink" title="1.7.3 UWP"></a>1.7.3 UWP</h3><h3 id="1-7-4soap服务和WCF"><a href="#1-7-4soap服务和WCF" class="headerlink" title="1.7.4soap服务和WCF"></a>1.7.4soap服务和WCF</h3><h3 id="1-7-5WEB服务-WEB-API-基于REST"><a href="#1-7-5WEB服务-WEB-API-基于REST" class="headerlink" title="1.7.5WEB服务 WEB API 基于REST"></a>1.7.5WEB服务 WEB API 基于REST</h3><h3 id="1-7-6WebHooks-和SignalR-基于-webSocket"><a href="#1-7-6WebHooks-和SignalR-基于-webSocket" class="headerlink" title="1.7.6WebHooks 和SignalR 基于 webSocket"></a>1.7.6WebHooks 和SignalR 基于 webSocket</h3><h3 id="1-7-7windows服务"><a href="#1-7-7windows服务" class="headerlink" title="1.7.7windows服务"></a>1.7.7windows服务</h3><pre><code>world wide web服务 可以监听客户端的web请求</code></pre><h3 id="Microsoft-Azure服务"><a href="#Microsoft-Azure服务" class="headerlink" title="Microsoft Azure服务"></a>Microsoft Azure服务</h3><p>​    SaaS IaaS PaaS</p>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
            <tag> .net 应用程序体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello MyBlog</title>
      <link href="2021/02/17/hello-myblog/"/>
      <url>2021/02/17/hello-myblog/</url>
      
        <content type="html"><![CDATA[<h2 id="使用github-page-和hexo搭建第一个网站"><a href="#使用github-page-和hexo搭建第一个网站" class="headerlink" title="使用github page 和hexo搭建第一个网站"></a>使用github page 和hexo搭建第一个网站</h2><p><a href="https://www.zhihu.com/question/22197688">https://www.zhihu.com/question/22197688</a></p><h2 id="博客美化-博客主题之hexo-theme-matery的介绍"><a href="#博客美化-博客主题之hexo-theme-matery的介绍" class="headerlink" title="博客美化 博客主题之hexo-theme-matery的介绍"></a>博客美化 博客主题之hexo-theme-matery的介绍</h2><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#alipay">https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#alipay</a></p><p>pdf展示</p><p><a href="https://blog.csdn.net/qq_43701912/article/details/107291518">https://blog.csdn.net/qq_43701912/article/details/107291518</a></p><h3 id="hexo扩展学习"><a href="#hexo扩展学习" class="headerlink" title="hexo扩展学习"></a>hexo扩展学习</h3><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p><a href="https://hexo.io/themes/index.html">https://hexo.io/themes/index.html</a></p><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><h3 id="window下pandoc的如何使用-文档类型转换"><a href="#window下pandoc的如何使用-文档类型转换" class="headerlink" title="window下pandoc的如何使用 文档类型转换"></a>window下pandoc的如何使用 文档类型转换</h3><p><a href="https://www.jianshu.com/p/f4a9ceb68088">https://www.jianshu.com/p/f4a9ceb68088</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
            <tag> github gage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客资源站收集</title>
      <link href="2021/02/17/good-blogs/"/>
      <url>2021/02/17/good-blogs/</url>
      
        <content type="html"><![CDATA[<h2 id="免费编程练习"><a href="#免费编程练习" class="headerlink" title="免费编程练习"></a>免费编程练习</h2><p><a href="https://chinese.freecodecamp.org/learn/">https://chinese.freecodecamp.org/learn/</a></p><h2 id="WebGL教程"><a href="#WebGL教程" class="headerlink" title="WebGL教程"></a>WebGL教程</h2><p><a href="http://www.webgl3d.cn/WebGL/">http://www.webgl3d.cn/WebGL/</a></p><h2 id="Three教程"><a href="#Three教程" class="headerlink" title="Three教程"></a>Three教程</h2><p><a href="http://www.webgl3d.cn/Three.js/">http://www.webgl3d.cn/Three.js/</a></p><h3 id="一个不错的博客-算法-leet-code"><a href="#一个不错的博客-算法-leet-code" class="headerlink" title="一个不错的博客  算法 leet code"></a>一个不错的博客  算法 leet code</h3><p><a href="https://www.cxyxiaowu.com/">https://www.cxyxiaowu.com/</a></p><h3 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h3><p><a href="http://www.ptbird.cn/list.html">http://www.ptbird.cn/list.html</a></p><h3 id="javascript的内存管理"><a href="#javascript的内存管理" class="headerlink" title="javascript的内存管理"></a>javascript的内存管理</h3><p><a href="https://mp.weixin.qq.com/s/aNm6Fp-E1TJX0Mzb_amjVA">https://mp.weixin.qq.com/s/aNm6Fp-E1TJX0Mzb_amjVA</a></p><h3 id="Abp-Vnext-Pro-的-Vue-实现版本"><a href="#Abp-Vnext-Pro-的-Vue-实现版本" class="headerlink" title="Abp Vnext Pro 的 Vue 实现版本"></a>Abp Vnext Pro 的 Vue 实现版本</h3><p><a href="https://mp.weixin.qq.com/s/MtoTzaJYFVcZA5keeyABqQ">https://mp.weixin.qq.com/s/MtoTzaJYFVcZA5keeyABqQ</a></p><h3 id="2021年Node-js开发人员学习路线图"><a href="#2021年Node-js开发人员学习路线图" class="headerlink" title="2021年Node.js开发人员学习路线图"></a>2021年Node.js开发人员学习路线图</h3><p><a href="https://mp.weixin.qq.com/s/oDQNwvXNgnaLYgWZAUM0NQ">https://mp.weixin.qq.com/s/oDQNwvXNgnaLYgWZAUM0NQ</a></p><h3 id="几种常见的软件架构模式总结"><a href="#几种常见的软件架构模式总结" class="headerlink" title="几种常见的软件架构模式总结"></a>几种常见的软件架构模式总结</h3><p><a href="https://mp.weixin.qq.com/s/PBRRpAcNB82sCzQvholRJA">https://mp.weixin.qq.com/s/PBRRpAcNB82sCzQvholRJA</a></p><h3 id="使用-Tye-辅助开发-dotnet-应用程序"><a href="#使用-Tye-辅助开发-dotnet-应用程序" class="headerlink" title="使用 Tye 辅助开发 dotnet 应用程序"></a>使用 Tye 辅助开发 dotnet 应用程序</h3><p><a href="https://mp.weixin.qq.com/s/I_dT4tBIrq4edGZOxe5qtA">https://mp.weixin.qq.com/s/I_dT4tBIrq4edGZOxe5qtA</a></p><h3 id="C-手把手教你爬取优酷电影信息-进阶"><a href="#C-手把手教你爬取优酷电影信息-进阶" class="headerlink" title="C# 手把手教你爬取优酷电影信息-进阶"></a>C# 手把手教你爬取优酷电影信息-进阶</h3><p><a href="https://mp.weixin.qq.com/s/AvBzqPHr6ADIl6alEkqICQ">https://mp.weixin.qq.com/s/AvBzqPHr6ADIl6alEkqICQ</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoCAD开发</title>
      <link href="2021/02/17/autocad-c/c-autocad-00/"/>
      <url>2021/02/17/autocad-c/c-autocad-00/</url>
      
        <content type="html"><![CDATA[<h1 id="c-AutoCAD开发"><a href="#c-AutoCAD开发" class="headerlink" title="c# AutoCAD开发"></a>c# AutoCAD开发</h1><h1 id="第一章-AutoCAD-C-开发基础"><a href="#第一章-AutoCAD-C-开发基础" class="headerlink" title="第一章 AutoCAD C#开发基础"></a>第一章 AutoCAD C#开发基础</h1><h2 id="AutoCAD二次开发语言"><a href="#AutoCAD二次开发语言" class="headerlink" title="AutoCAD二次开发语言"></a>AutoCAD二次开发语言</h2><p>1.ObjectARX：优点：功能强大，编程效率高。缺点：必须掌握VC++</p><p>2.Lisp,VBA  优点：简单易上手，缺点：对于程序开发，很难</p><p>3.c# 结合了ObjectARX功能强大，效率高，以及简单易学</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226232629971.png" alt="image-20210226232629971"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226232718389.png" alt="image-20210226232718389"></p><h2 id="项目中添加cad引用"><a href="#项目中添加cad引用" class="headerlink" title="项目中添加cad引用"></a>项目中添加cad引用</h2><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226232851361.png" alt="image-20210226232851361"></p><p>引用之后修改属性</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226232919860.png" alt="image-20210226232919860"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226233032206.png" alt="image-20210226233032206"></p><p>程序集引入以及命名空间</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226233432913.png" alt="image-20210226233432913"></p><p>调用方法 标注</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226233554713.png" alt="image-20210226233554713"></p><p>AUTOCAD  netload  dll引用，可以命令行输入命令</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226233834674.png" alt="image-20210226233834674"></p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210226234328640.png" alt="image-20210226234328640"></p>]]></content>
      
      
      <categories>
          
          <category> AutoCAD开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoCAD开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoCAD开发</title>
      <link href="2021/02/17/autocad-c/c-autocad-01/"/>
      <url>2021/02/17/autocad-c/c-autocad-01/</url>
      
        <content type="html"><![CDATA[<h1 id="c-AutoCAD开发"><a href="#c-AutoCAD开发" class="headerlink" title="c# AutoCAD开发"></a>c# AutoCAD开发</h1><h1 id="第二章-AutoCAD-创建实体-C-基本概念"><a href="#第二章-AutoCAD-创建实体-C-基本概念" class="headerlink" title="第二章 AutoCAD 创建实体 C#基本概念"></a>第二章 AutoCAD 创建实体 C#基本概念</h1><p>AutoCAD的常用命名空间</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210227102402285.png" alt="image-20210227102402285"></p><p>新建项目</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210227102533248.png" alt="image-20210227102533248"></p><p>注册方法</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210227102707034.png" alt="image-20210227102707034"></p><p>定义</p><p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210227103116149.png" alt="image-20210227103116149"></p>]]></content>
      
      
      <categories>
          
          <category> AutoCAD开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoCAD开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# 高级编程(10th) 前言</title>
      <link href="2021/02/17/c-10/c-10th-00/"/>
      <url>2021/02/17/c-10/c-10th-00/</url>
      
        <content type="html"><![CDATA[<h1 id="c-是专门用于-net-的语言"><a href="#c-是专门用于-net-的语言" class="headerlink" title="c# 是专门用于 .net 的语言"></a>c# 是专门用于 .net 的语言</h1><p>web 页面<br>WPF<br>REST WEB服务<br>分布式应用程序的组件<br>数据库访问组件<br>桌面应用程序<br>UWP</p><h1 id="net-core-重要性"><a href="#net-core-重要性" class="headerlink" title=".net core 重要性"></a>.net core 重要性</h1><p>.net framework<br><a href="http://asp.net/">asp.net</a> web forms ？ MVC<br>WIN form /UWP<br>EF / LINQ</p><h1 id="NET-CORE"><a href="#NET-CORE" class="headerlink" title=".NET CORE"></a>.NET CORE</h1><p>开源<br>包较小，更快的创新<br>支持多个平台<br>可以编译为本地代码<br>Xamarin</p><h1 id="C-重要性"><a href="#C-重要性" class="headerlink" title="C# 重要性"></a>C# 重要性</h1><p>设计思想来源于C++ 、java、Pascal<br>面向对象的通用编程语言<br>给予组件的变成语言，支持属性、时间、特性和构建程序集<br>函数数编程理念<br>增加了泛型、语言集成查询linq、lambda表达式、动态特性、更简单的异步编程</p><h1 id="c-6-新特性"><a href="#c-6-新特性" class="headerlink" title="c#6 新特性"></a>c#6 新特性</h1><h2 id="静态using声明："><a href="#静态using声明：" class="headerlink" title="静态using声明："></a>静态using声明：</h2><p>静态的声明允许调用静态方式时不适用类名</p><blockquote><p>using static sysytem.console； Writeline(&quot;hello world&quot;) ​</p></blockquote><h2 id="表达式体方法"><a href="#表达式体方法" class="headerlink" title="表达式体方法:"></a>表达式体方法:</h2><p>表达式方法只包括一个可以用lambda语法编写的语句</p><blockquote><p>public bool isSquare（Rectangle rect）=&gt;rect.Height == rect.Width;</p></blockquote><h2 id="表达式体属性："><a href="#表达式体属性：" class="headerlink" title="表达式体属性："></a>表达式体属性：</h2><p>与表达式方法类似，只有get存取器的单行属性可以用lamabda语法编写</p><blockquote><p>public string FullName =&gt; FirstName +&quot;&quot;+ LastName;</p></blockquote><h2 id="自动实现的属性初始化器"><a href="#自动实现的属性初始化器" class="headerlink" title="自动实现的属性初始化器:"></a>自动实现的属性初始化器:</h2><p>自动实现的属性可以用属性初始化器来初始化</p><blockquote><p>public class Person{ public int Age{get;set;}=42; ​}</p></blockquote><h2 id="只读的自动属性"><a href="#只读的自动属性" class="headerlink" title="只读的自动属性"></a>只读的自动属性</h2><blockquote><p>public BookId {get;} </p></blockquote><h2 id="ameof-运算符："><a href="#ameof-运算符：" class="headerlink" title="ameof 运算符："></a>ameof 运算符：</h2><p>使用此运算符，可以访问字段名、属性名、方法名、类型名</p><h2 id="空值传播运算符"><a href="#空值传播运算符" class="headerlink" title="空值传播运算符"></a>空值传播运算符</h2><blockquote><p>int? age =p?.Age; handler?.Invoke(source,e)</p></blockquote><h2 id="字符串插值-占位符可以直接是表达式"><a href="#字符串插值-占位符可以直接是表达式" class="headerlink" title="字符串插值: 占位符可以直接是表达式"></a>字符串插值: 占位符可以直接是表达式</h2><blockquote><p>public override ToString() =&gt; $&quot;{Title} {Publisher}&quot;</p></blockquote><h2 id="字典初始化器"><a href="#字典初始化器" class="headerlink" title="字典初始化器"></a>字典初始化器</h2><blockquote><p>var dict = new Dictionary&lt;int,string&gt;(){<br>    2 =”three”,<br>  3=”seven”<br> ​}</p></blockquote><h2 id="异常过滤器"><a href="#异常过滤器" class="headerlink" title="异常过滤器"></a>异常过滤器</h2><h2 id="Catch-中的await"><a href="#Catch-中的await" class="headerlink" title="Catch 中的await"></a>Catch 中的await</h2><blockquote><p>try{ // }Catch(MyException ex){ await new<br>MessageDialog().showAsync(ex.Message); ​}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# 高级编程(10th) </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
