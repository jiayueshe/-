<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="abp学习博客（2016收录）, IT 学习 资源站 C# CAD .net core EF Javascript Flutter TypeScript 数据结构 算法 网络 测试 产品">
    <meta name="description" content="IT 学习 资源站 C# CAD .net core EF Javascript Flutter TypeScript 数据结构 算法 网络 测试 产品">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>abp学习博客（2016收录） | IT 学习 资源</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="IT 学习 资源" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">IT 学习 资源</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">IT 学习 资源</div>
        <div class="logo-desc">
            
            IT 学习 资源站 C# CAD .net core EF Javascript Flutter TypeScript 数据结构 算法 网络 测试 产品
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/jiayueshe/jiayueshe.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/jiayueshe/jiayueshe.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/8.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">abp学习博客（2016收录）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="container content">

    
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/abp/">
                                <span class="chip bg-color">abp</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/abp/" class="post-category">
                                abp
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-03-22
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-03-21
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    38.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    143 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="ABP理论学习之开篇介绍"><a href="#ABP理论学习之开篇介绍" class="headerlink" title="     ABP理论学习之开篇介绍         "></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPIntro.html">     ABP理论学习之开篇介绍         </a></h1><p><strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPTheory.html">返回总目录</a></strong></p>
<hr>
<p>为了和2016年春节赛跑，完成该系列博客，我牺牲了今天中午的时间来完成该系列的第一篇————开篇介绍。开篇介绍嘛，读过大学教材的同学都知道，这玩意总是那么无聊，跟考试没关系，干脆直接跳过，呵呵，多么美好的大学时光啊！不过，现在想想，开篇介绍确实不怎么重要，它只是告诉我们今后我要开始讲什么了，主要讲什么，大概浏览下重点。<br> 哦了，不扯了，时间不多了，干活！</p>
<hr>
<h2 id="本篇目录"><a href="#本篇目录" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPIntro.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPIntro.html#sample">快速样例</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPIntro.html#others">其他</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPIntro.html#startup">启动模板</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPIntro.html#touse">如何使用</a></strong></li>
</ul>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍###"></a>介绍###</h3><p>我们总是基于不同的需求创建不同的应用，但是在一定程度上，总在反复地实现通用而相似的结构。这些通用的结构包括<strong>授权，验证，异常处理，日志，本地化，数据库连接管理，设置管理，审计日志等</strong>。而且，我们总是在构建体系结构和最佳实践，比如<strong>分层</strong>和<strong>模块化</strong>架构，<strong>领域驱动设计（DDD），依赖注入等等</strong>。同时也在尝试基于<strong>惯例</strong>开发应用。</p>
<p>因为这些都是非常耗时的，并且对于每个项目单独创建是很困难的，所以很多公司都会创建自己私有的框架。通过使用私有的框架，他们总是可以快速地开发新的应用，同时应用的bug又会更少。当然了，不是所有的公司都是那么幸运了，你以为中国所有的公司都是BAT啊？！大多数公司还是没有<strong>时间，预算和团队</strong>来开发他们自己的私人框架。即使他们有可能构建这么一个框架，<strong>写文档，培训开发者以及维护</strong>也是很难的。</p>
<p>ABP是一个<strong>开源的且文档友好的应用框架</strong>，起始的想法是，“开发一款为所有公司和开发者通用的框架！”。它不仅仅是一个框架，更提供了一个基于<strong>DDD</strong>和<strong>最佳实践</strong>的健壮的<strong>体系模型</strong>。</p>
<h3 id="快速样例"><a href="#快速样例" class="headerlink" title="快速样例###"></a>快速样例###</h3><p>一起来研究一个简单的类来看看ABP有哪些好处 ：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService, ITaskAppService
{
    private readonly IRepository<Task> _taskRepository;

    public TaskAppService(IRepository<Task> taskRepository)
    {
        _taskRepository = taskRepository;
    }

    [AbpAuthorize(MyPermissions.UpdatingTasks)]
    public async Task UpdateTask(UpdateTaskInput input)
    {
        Logger.Info("Updating a task for input: " + input);

        var task = await _taskRepository.FirstOrDefaultAsync(input.TaskId);
        if (task == null)
        {
            throw new UserFriendlyException(L("CouldNotFoundTheTaskMessage"));
        }

        input.MapTo(task);
    }
}
</code></pre>
<p>这里我们看到了一个简单的应用服务方法。在DDD中，表现层直接使用应用服务来执行该应用的<strong>用例</strong>（其实就是一些操作方法）。我们还可以考虑使用Ajax调用上面的<em>UpdateTask</em>方法。</p>
<p>下面让我们总结一下ABP的一些优点：</p>
<ul>
<li><strong>依赖注入</strong>：ABP使用并提供了一个健壮而又传统的DI基础设施。因为上面的类是在一个应用服务中定义的，所以它会按照惯例约定短暂地（每个请求创建一次）注册到DI容器中。它也简单地注入了所有依赖（本例中注入了<em>IRepository</em>）。</li>
<li><strong>仓储</strong>：ABP可以为每一个实体创建一个默认的仓储（本例中是<em>IRepository</em>）。默认的仓储有许多有用的方法，如本例中的 <em>FirstOrDefault</em>。我们也可以根据我们的需求轻易地扩展默认仓储。仓储抽象了DBMS和ORM，并简化了数据的访问逻辑。</li>
<li><strong>授权</strong>：ABP可以检测权限。如果当前的用户没有“updating task”的权限或者没登录，那么ta不能访问<em>UpdateTask</em>方法。它使用声明式的特性简化了授权，而且还有其他的授权方法。</li>
<li><strong>验证</strong>：ABP会自动检测输入是否为null。它也基于标准的数据注解特性和自定义的验证规则验证输入对象的所有属性。如果请求不合法，那么它会抛出一个合适的验证异常。</li>
<li><strong>审计日志</strong>：用户，浏览器，IP地址，调用服务，方法，参数，调用时间，执行时长和其他的一些信息也会基于惯例和配置为每个请求自动地保存。</li>
<li><strong>工作单元（Unit of Work）</strong>：在ABP中，每个应用服务方法默认视为一个工作单元。它会自动创建一个连接并在方法的开始位置开启一个事务。如果方法不报异常地成功完成了，那么事务会提交并且连接被释放。即使该方法使用了不同的仓储或者方法，它们全部也都是原子的（事务的）。当事务提交时，实体的所有改变都会自动保存。因此，正如这里展示的那样，我们甚至都不用调用**_repository.Update(task)**方法。</li>
<li><strong>异常处理</strong>：在一个使用了ABP框架的Web应用中，我们基本上不用处理异常。所有的异常都会默认自动处理。如果一个异常发生了，那么ABP会自动地记录它，然后返回给客户端一个合适的结果。比如，如果这是一个Ajax请求，那么它会返回一个JSON到客户端，指明发生了一个错误。本例中使用了一个<em>UserFriendlyException</em>，这样就隐藏了客户端实际的异常信息。它也理解并处理客户端的错误，最后将合适的信息呈现给用户。</li>
<li><strong>日志</strong>：我们可以使用在基类中定义的Logger来写日志。ABP默认使用了Log4Net，但是它是可改变的或可配置的。</li>
<li><strong>本地化（Localization）</strong>：注意当抛出异常的时候我们使用了L方法。因此，它会基于当前用户的文化自动进行本地化。当然，我们可以在某些地方定义<em>CouldNotFoundTheTaskMessage</em>。</li>
<li><strong>自动映射</strong>：上面的最后一行代码，我们使用了ABP的MapTo扩展方法将输入对象的属性映射到实体属性。它使用了AutoMapper库来执行映射。因此，我们可以基于命名惯例轻易地将属性从一个对象上映射到另一个对象上。我的AutoMapper系列学习博客：**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/AutoMapperContent.html">http://www.cnblogs.com/farb/p/AutoMapperContent.html</a> **。</li>
<li><strong>动态Web API层</strong>：实际上，<em>TaskAppService</em> 是一个简单的类（甚至不需要从<em>ApplicationService</em> 继承）。我们一般会写一个Web API Controller包装器来将方法暴露给javascript客户端。ABP在运行时会自动完成。这样，我们可以从客户端直接使用应用服务方法。</li>
<li><strong>动态Ajax代理</strong>：ABP创建了javascript代理方法，它们可以调用应用服务方法就像调用客户端的javascript方法一样简单。</li>
</ul>
<p>在这么一个简单的类中，我们看到了ABP的优势。所有的这些任务正常情况下都是要花费很多时间的，但是所有的这些ABP自动帮我们完成了。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他###"></a>其他###</h3><p>除了这个简单的例子，ABP也提供了一个健壮的基础设施和应用模型。下面是ABP的一下其他特征：</p>
<ul>
<li>模块化：提供了一个健壮的基础设施来生成可复用的模块。</li>
<li>数据过滤器：提供了自动的数据过滤来实现一些模式，比如软删除和多租户。</li>
<li>多租户：支持单数据库、多客户形式的多租户。</li>
<li>设置管理：提供了健壮的基础设施类获得或者更改应用，租户和用户级别的设置。</li>
<li>单元测试和集成测试：基于可测试性构建，也提供了一些基类来简化单元测试和集成测试。</li>
</ul>
<p>更多的特征，请认真阅读其他文档。</p>
<h3 id="启动模板"><a href="#启动模板" class="headerlink" title="启动模板###"></a>启动模板###</h3><p>开始一个新的解决方案，创建层，安装nuget包，创建一个简单的布局和菜单…所有的这些都是非常耗时的。</p>
<p>ABP提供了一个预生成的**<a target="_blank" rel="noopener" href="http://www.aspnetboilerplate.com/Templates">启动模板</a><strong>，有了它，创建一个新的解决方案更容易了。模板支持</strong>SPA（单页应用）<strong>和</strong>MPA（多页应用）**。而且，我们可以选择不同的ORM。</p>
<h1 id="ABP理论学习之N层架构"><a href="#ABP理论学习之N层架构" class="headerlink" title="     ABP理论学习之N层架构         "></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html">     ABP理论学习之N层架构         </a></h1><p>自从写这个系列博客之后，发现很多园友还是希望有个直接运行的demo，其实在github上就有官方的demo，我直接把这demo的链接放到这里吧，另外，我分析，这些找不到demo的同学，很可能是不怎么用github，可能的原因就是英文不好。所以还是希望程序员多看看英文文档，一开始看得很慢不要紧，时间久了，速度绝对能上去。因为都是技术性的文章，没有特别难的语法，能让大家退而却步的最多是些生词，这个就要靠大家积累常见的词汇了，一些生僻词的话查一下意思，理解了那句话就可以过了。</p>
<p>跟ABP相关的所有源码，包括zero，demo，都在这个目录下了，大家可以一个个点击看一下。下面做一稍微解释。</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211000853121-406694237.png" alt="img"><br> <img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211001224840-1457640679.png" alt="img"><br> <img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211001755105-1002490250.png" alt="img"></p>
<hr>
<h2 id="本篇目录-1"><a href="#本篇目录-1" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#intro">介绍</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#abp">ABP架构</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#domain">领域层</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#app">应用层</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#infra">基础设施层</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#ui">Web和展现层</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#other">其他</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#summary">总结</a></strong></li>
</ul>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍###"></a>介绍###</h3><p>对应用代码基进行分层可以帮助降低复杂度和提高代码复用性，这已经成为广为接受的技巧。为了实现分层的架构，ABP遵循以下<strong>DDD（领域驱动模型）</strong>的原则。在DDD中，有四个基础层：</p>
<ul>
<li><strong>表现层</strong>：用户访问的接口，使用应用层实现用户交互。</li>
<li><strong>应用层</strong>：表现层和领域层之间的媒介。负责组织业务对象，以执行特定的应用任务。</li>
<li><strong>领域层</strong>：包括业务对象和原则。这是应用的核心。</li>
<li><strong>基础设施层</strong>：为支持更高层提供了广泛的技术能力。基础设施层的一个例子是仓储，它可以通过ORM框架和数据库进行交互。</li>
</ul>
<p>也可能会加入额外必要的层。以下就是一个例子：</p>
<ul>
<li><strong>分布式服务层</strong>：将应用的功能暴露给远程客户端。可以提供这个层的工具包括Asp.Net Web API和WCF。</li>
</ul>
<p>这些都是以领域为中心的架构的通用层次。基于实现的话，可能还会稍有不同。</p>
<h3 id="ABP架构"><a href="#ABP架构" class="headerlink" title="ABP架构###"></a>ABP架构###</h3><p>层次和结构的概览如下图所示：<br> <img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211005057090-801424200.png" alt="img"><br> 实际解决方案中的项目分层如下：<br> <img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211005342715-1812391209.png" alt="img"></p>
<p>一层可以为一个或多个程序集。对于第三方依赖创建不止一个程序集可能会特别好（比如NHibernate）。</p>
<h4 id="领域层"><a href="#领域层" class="headerlink" title="领域层"></a>领域层</h4><p>领域层是所有的业务规则实现的地方。</p>
<p>实体代表了业务领域的数据和操作。在实践中，它们一般会映射到数据库的表中。</p>
<p>仓储式跟集合很像的对象，使用仓储可以检索数据源（数据库）上的实体，并将实体持久化到数据源上。领域层只是定义了仓储，但是并没有实现它们，它们是在基础设施层实现的。</p>
<p><strong>领域事件</strong>定义了领域特定的事件，也包括触发和处理这些事件。领域服务借助实体运行，并实现了不属于单个实体的业务规则。</p>
<p><strong>工作单元</strong>是一种管理实体的设计模式，这些实体受业务逻辑影响，并将状态持久化到数据存储中。</p>
<p>领域层应该尽可能地独立于第三方的库。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层包含了展现层使用的应用服务。应用服务方法接收一个DTO（数据传输对象）作为输入参数，使用这个输入对象执行一些特定的领域层操作，然后，如果需要的话，可能返回另一个DTO。一般而言，应用服务方法不接收或者返回一个实体对象，这样做的好处就是可以允许展现层可以从领域层中将实体抽象出来，而不受实体的约束。一个应用服务方法一般被看作是一个工作单元。用户输入验证也是在这一层实现的。ABP提供了一个基础设施，因此可以很容易地实现验证。建议使用一个将实体映射为DTO的工具，比如AutoMapper,TinyMapper等。要学习AutoMapper的使用，请查看我的**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/AutoMapperContent.html">AutoMapper系列博客</a>**吧！</p>
<h4 id="基础设施层"><a href="#基础设施层" class="headerlink" title="基础设施层"></a>基础设施层</h4><p>虽然领域层定义了仓储接口，但是基础设施层使用诸如NHibernate或者EntityFramework的ORM工具实现了那些仓储接口。ABP提供了使用这两种ORM框架的基类。基础设施层用于抽象来自其他层的第三方类库，数据库迁移（Database Migration）也可以用在这一层。</p>
<h4 id="Web和展现层"><a href="#Web和展现层" class="headerlink" title="Web和展现层"></a>Web和展现层</h4><p>Web层使用ASP.NET MVC和Web API实现的。这里可以使用两种不同的方式来实现：单页面应用和多页面应用。</p>
<p>在单页面应用中（SPA）,所有的资源都会一次性加载到客户端（或者只加载核心资源，懒加载其他资源），所有的后续和服务器的交互都是通过Ajax调用。Html代码是使用从服务端接收到的数据在客户端生成的。整个页面不会刷新，视图只是在必要时换入换出。有许多的Javascript SPA框架，比如AngularJs，DurandalJs,BackboneJs和EmberJs。ABP可以使用它们中的任何一个，但是提供了使用 AngularJs和DurandalJs的样例。</p>
<p>在多页面（经典）应用中(MPA)，客户端向服务端发送请求，服务端代码（ASP.NET MVC 控制器）从数据库中获取数据，然后Razor视图引擎生成html 代码。这些编译后的页面发回给客户端显示。每个新的页面都会导致完整页面的刷新。</p>
<p>SPA和MPA涉及了完全不同的架构。对于后台管理系统来说，SPA是最好的候选者，另一方面，博客更适合MPA模型，因为博客渴望被搜索引擎抓取数据。虽然有很多工具可以使SPA对于搜索引擎可见，但是目前的一般做法就是使用MPA。</p>
<p><strong>SignalR</strong>是发送服务端到客户端的推送通知的最好工具，也可以给用户提供一个丰富而且实时的体验。</p>
<p>在客户端还有很多javascript库和框架。**<a target="_blank" rel="noopener" href="http://jquery.com/">jQuery</a><strong>是这个领域最流行的，并伴有成千上万的插件。也有很多很容易就能使用Html和CSS的框架或工具。比如，</strong><a target="_blank" rel="noopener" href="http://getbootstrap.com/">Twitter Bootstrap</a>**是非常流行的HTML/CSS框架。</p>
<p>ABP提供了使用应用服务层自动创建Web API层的基础设施，使用Javascript可以轻松地调用Web API（**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/4949679.html">看文档</a>**）。而且，还提供了管理管理应用菜单，本地化以及语言切换的基础设施，还包含了统一的Javascript API来简化显示系统的信息和通知。</p>
<p>ABP自动处理服务端的异常，并给客户端返回一个合适的响应。</p>
<h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><p>ABP通过**<a target="_blank" rel="noopener" href="http://docs.castleproject.org/Windsor.MainPage.ashx">Castle Windsor</a>**使用并支持依赖注入，也使用了Log4Net来记录服务端的日志，然而，通过使用Castle的日志设备无需改变代码就可以切换到其他的日志库。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结###"></a>总结###</h3><p>ABP平衡了一些最好的框架或者类库，除此之外，ABP自己的类和系统也提供了一个很好的用于N层架构Web应用构建的基础设施，也提供了很轻松地创建分层的解决方案的**<a target="_blank" rel="noopener" href="http://www.aspnetboilerplate.com/Templates">模板</a>**，用作应用的起点</p>
<h1 id="ABP理论学习之模块系统"><a href="#ABP理论学习之模块系统" class="headerlink" title="ABP理论学习之模块系统"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html">ABP理论学习之模块系统</a></h1><p><strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPTheory.html">返回总目录</a></strong></p>
<hr>
<h2 id="本篇目录-2"><a href="#本篇目录-2" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html#intro">模块介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html#events">生命周期事件</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html#yilai">模块依赖</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html#custom">自定义模块方法</a></strong></li>
</ul>
<h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍###"></a>模块介绍###</h3><p>ABP提供了构建模块并将这些模块组合起来创建应用的基础设施。一个模块可以依赖另一个模块。一般来说，一个程序集可以认为是一个模块。一个模块是由一个派生了<strong>AbpModule</strong>的类定义的。比如说我们在开发一个可以用在不同的应用中的博客模块。最简单的模块定义如下：</p>
<pre class=" language-C#"><code class="language-C#">public class MyBlogApplicationModule : AbpModule
{
    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}
</code></pre>
<p>ABP扫描所有的程序集，并找出所有的派生自AbpModule基类的类。如果你创建了不止一个程序集的应用，那么建议为每个程序集创建一个模块定义。</p>
<h3 id="生命周期事件"><a href="#生命周期事件" class="headerlink" title="生命周期事件###"></a>生命周期事件###</h3><p>ABP在应用启动和关闭的时候会调用一些特定的模块方法。你可以重写这些方法来执行特定的任务。</p>
<p>ABP<strong>按照依赖的顺序</strong>调用这些方法。如果模块A依赖于模块B，那么模块B在模块A之前初始化。方法执行的正确顺序是：<strong>PreInitialize-B, PreInitialize-A, Initialize-B, Initialize-A, PostInitialize-B and PostInitialize-A</strong>。这对于所有的依赖图都是成立的。Shutdown方法也是类似的，但顺序相反。</p>
<h4 id="PreInitialize"><a href="#PreInitialize" class="headerlink" title="PreInitialize"></a>PreInitialize</h4><p>该方法会在应用启动时首先调用。你可以在该方法里面写一些特定的代码，这些代码会在依赖注入注册之前执行。比如，如果你创建了一个传统的注册类，那么你应该把它在这里注册（使用locManager.AddConventionalRegister方法）。你也可以注册到IOC容器的事件…等等。</p>
<h4 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h4><p>该方法通常是依赖注入注册的地方。一般使用IocManager.RegisterAssemblyByConvention方法完成。如果你想要定义自定义的依赖注册，请看后面的依赖注入文档。</p>
<h4 id="PostInitialize"><a href="#PostInitialize" class="headerlink" title="PostInitialize"></a>PostInitialize</h4><p>该方法在应用启动的最后调用。在这里可以安全地解析一个依赖。</p>
<h4 id="Shutdown"><a href="#Shutdown" class="headerlink" title="Shutdown"></a>Shutdown</h4><p>该方法在应用关闭的时候调用。</p>
<h3 id="模块依赖"><a href="#模块依赖" class="headerlink" title="模块依赖###"></a>模块依赖###</h3><p>一个模块可以独立于另一个模块。ABP会自动地尝试解析这些依赖，但是建议通过重写GetDependencies方法来显式声明依赖，正如下面那样：</p>
<pre class=" language-C#"><code class="language-C#">[DependsOn(typeof(MyBlogCoreModule))]
public class MyBlogApplicationModule : AbpModule
{
    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}
</code></pre>
<p>这样，我们声明ABP：MyBlogApplicationModule依赖于MyBlogCoreModule,因而该核心模块MyBlogCoreModule会在应用模块MyBlogApplicationModule之前进行初始化。</p>
<h3 id="自定义模块方法"><a href="#自定义模块方法" class="headerlink" title="自定义模块方法###"></a>自定义模块方法###</h3><p>你的模块也可以有一些自定义的方法，这些方法可以被依赖于该模块的其他模块所使用。假设MyModule2依赖于MyModule1，且MyModule2想要在PreInitialize事件中调用一个MyModule1的方法。</p>
<pre class=" language-C#"><code class="language-C#">public class MyModule1 : AbpModule
{
    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }

    public void MyModuleMethod1()
    {
        //这是该模块的自定义方法
    }
}

[DependsOn(typeof(MyModule1))]
public class MyModule2 : AbpModule
{
    private readonly MyModule1 _myModule1;

    public MyModule2(MyModule1 myModule1)
    {
        _myModule1 = myModule1;
    }

    public override void PreInitialize()
    {
        _myModule1.MyModuleMethod1(); //Call MyModule1's method
    }

    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}
</code></pre>
<p>这里，我们通过构造函数将MyModule1z注入到了MyModule2，因此MyModule2可以调用MyModule1的自定义方法</p>
<h1 id="ABP理论学习之启动配置"><a href="#ABP理论学习之启动配置" class="headerlink" title="     ABP理论学习之启动配置         "></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPStartupConfig.html">     ABP理论学习之启动配置         </a></h1><p><strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPTheory.html">返回总目录</a></strong></p>
<hr>
<h2 id="本篇目录-3"><a href="#本篇目录-3" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPStartupConfig.html#abp">配置ABP</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPStartupConfig.html#module">配置模块</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPStartupConfig.html#createSetting">为模块创建配置</a></strong></li>
</ul>
<p>为了在应用启动时配置ABP和模块，ABP提供了一个基础设施。</p>
<h3 id="配置ABP"><a href="#配置ABP" class="headerlink" title="配置ABP###"></a>配置ABP###</h3><p>配置ABP是在模块的<strong>PreInitialize</strong>事件中完成的。下面的代码摘自Github上的Taskever（一个任务系统Demo）:</p>
<pre class=" language-C#"><code class="language-C#">public class SimpleTaskSystemModule : AbpModule
{
    public override void PreInitialize()
    {
        //为应用添加语言
        Configuration.Localization.Languages.Add(new LanguageInfo("en", "English", "famfamfam-flag-england", true));
        Configuration.Localization.Languages.Add(new LanguageInfo("tr", "Türkçe", "famfamfam-flag-tr"));

        //添加本地化资源
        Configuration.Localization.Sources.Add(
            new XmlLocalizationSource(
                "SimpleTaskSystem",
                HttpContext.Current.Server.MapPath("~/Localization/SimpleTaskSystem")
                )
            );

        //配置导航菜单
        Configuration.Navigation.Providers.Add<SimpleTaskSystemNavigationProvider>();
    }

    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}
</code></pre>
<p>ABP是基于模块化设计的。不同的模块都可以配置ABP。比如，不同的模块可以通过添加导航提供者来给主菜单添加自己的菜单选项。</p>
<h3 id="配置模块"><a href="#配置模块" class="headerlink" title="配置模块###"></a>配置模块###</h3><p>除了ABP框架自身的启动配置之外，模块也可以实现<strong>IAbpModuleConfigurations</strong>接口来为模块提供配置点。比如：</p>
<pre class=" language-C#"><code class="language-C#">...
using Abp.Web.Configuration;
...
public override void PreInitialize() 
{
    Configuration.Modules.AbpWeb().SendAllExceptionsToClients = true;
}
...
</code></pre>
<p>在本例中，我们配置了AbpWeb模块，目的是将所有的异常发送到客户端。</p>
<p>并不是每一个模块都应该定义这种类型的配置。一般是当一个模块需要在不同的应用中重用的时候，才需要在启动时进行配置。</p>
<h3 id="为模块创建配置"><a href="#为模块创建配置" class="headerlink" title="为模块创建配置###"></a>为模块创建配置###</h3><p>假设我们有一个叫做“MyModule”的模块，它有一些配置属性。首先，我们为这些配置属性创建一个类MyModuleConfig：</p>
<pre class=" language-C#"><code class="language-C#">public class MyModuleConfig
{
    public bool SampleConfig1 { get; set; }

    public string SampleConfig2 { get; set; }
}
</code></pre>
<p>然后，我们在MyModule的PreInitialize事件中将这个类MyModuleConfig注册到DI中（这样，MyModuleConfig就成为了可注册的类）：</p>
<pre><code>IocManager.Register&lt;MyModuleConfig&gt;();
</code></pre>
<p>最后，我们创建IModuleConfiguration的扩展方法来获得MyModuleConfig的引用。</p>
<pre class=" language-C#"><code class="language-C#">public static class MyModuleConfigurationExtensions
{
    public static MyModuleConfig MyModule(this IModuleConfigurations moduleConfigurations)
    {
        return moduleConfigurations.AbpConfiguration
            .GetOrCreate("MyModuleConfig",
                () => moduleConfigurations.AbpConfiguration.IocManager.Resolve<MyModuleConfig>()
            );
    }
}
</code></pre>
<p>现在，在应用启动时，其他的模块就可以配置这个模块了（在需要配置MyModule的模块的PreInitialize事件中）：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Modules.MyModule().SampleConfig1 = false;
Configuration.Modules.MyModule().SampleConfig2 = "test";
</code></pre>
<p>有时候，MyModule需要这样的配置。你可以注册MyModuleConfig，并使用配置的值。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class MyService : ITransientDependency
{
    private readonly MyModuleConfig _configuration;

    public MyService(MyModuleConfig configuration)
    {
        _configuration = configuration;
    }

    public void DoIt()
    {
        if (_configuration.SampleConfig2 == "test")
        {
            //...
        }
    }
}
</code></pre>
<p>这样，在ABP系统中，模块就可以创建集中配置点了，也就是说模块可以集中起来配置了。</p>
<h1 id="ABP理论学习之多租户"><a href="#ABP理论学习之多租户" class="headerlink" title="     ABP理论学习之多租户         "></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMultiTenancy.html">     ABP理论学习之多租户         </a></h1><h1 id><a href="#" class="headerlink" title="         "></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMultiTenancy.html">         </a></h1><p><strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPTheory.html">返回总目录</a></strong></p>
<hr>
<h2 id="本篇目录-4"><a href="#本篇目录-4" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMultiTenancy.html#what">什么是多租户</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMultiTenancy.html#abpMultiTenancy">ABP中的多租户</a></strong></li>
</ul>
<h3 id="什么是多租户"><a href="#什么是多租户" class="headerlink" title="什么是多租户###"></a>什么是多租户###</h3><p>维基百科：“软件<strong>多租户</strong>是指一种软件架构，在这种软件架构中，软件的<strong>一个实例</strong>运行在服务器上并且为多个租户服务”。一个租户是一组共享该软件实例特定权限的用户。有了多租户架构，软件应用被设计成为每个租户提供一个 <strong>专用的实例包括该实例的数据的共享</strong>，还可以共享配置，用户管理，租户自己的功能和非功能属性。多租户和多实例架构相比，多租户分离了代表不同的租户操作的多个实例。</p>
<p>多租户用于创建<strong>Saas（Software as-a service）</strong>应用（云处理）。有几种类型的多租户：</p>
<h4 id="多部署-多数据库"><a href="#多部署-多数据库" class="headerlink" title="多部署-多数据库"></a>多部署-多数据库</h4><p>这实际上不是多租户。但是，如果我们为<strong>每个</strong>具有<strong>分开数据库的</strong>客户（租户）运行该应用的一个实例，那么我们可以在单个服务器上为<strong>多个租户</strong>提供服务。我们可以确定该应用的多个实例在相同的服务器环境不会相互<strong>冲突</strong>。</p>
<p>这个对于一个不是为多租户设计的<strong>已存在应用</strong>也是可能的。创建这么一个应用更容易，因为该应用不需要了解多租户。但这种方式存在安装，使用和维护问题。</p>
<h4 id="单部署-多数据库"><a href="#单部署-多数据库" class="headerlink" title="单部署-多数据库"></a>单部署-多数据库</h4><p>在这种情况下，我们可以在一个服务器上运行应用的<strong>单个实例</strong>。对于每个登录用户，我们从<strong>master database</strong>中检测该用户的租户，并获得该租户的数据库信息（<strong>连接字符串</strong>）。然后我们可以将连接字符串存储到<strong>像session</strong>一样的变量中，同时，使用这个<strong>租户特定的</strong>连接字符串执行所有的数据库操作。</p>
<p>某种程度上，这样的应用应该设计成多租户。但是大多数的应用都独立于多租户。这种方式也存在一些安装，使用和维护问题。我们应该为每个租户创建并维护一个<strong>分离的数据库</strong>。</p>
<h4 id="单部署-单数据库"><a href="#单部署-单数据库" class="headerlink" title="单部署-单数据库"></a>单部署-单数据库</h4><p>这是最<strong>真实的多租户</strong>架构：我们只将具有<strong>单个数据库</strong>应用的<strong>单个实例</strong>部署到<strong>单个服务器</strong>上。在（RDBMS）每个表中，都存在一个<strong>TenantId</strong>（或相似）字段，该字段用于分离每个租户之间的数据。</p>
<p>这种方法安装和维护都很简单，但唯独创建这么一个应用很难，因为我们必须要阻止一个租户读取或写入其他租户的数据。我们可以为每个数据库的读取（select）操作添加一个<strong>TenantId过滤器</strong>。而且，我们可以在每次写入的时候检查一下该实体是否和<strong>当前的租户</strong>相关。这是乏味而易于出错的，但ABP通过使用<strong>自动的数据过滤</strong>帮助我们处理这个事情。</p>
<p>如果我们有很多具有大量数据的租户，那么这种方法可能会有性能问题。我们可以使用关系型数据库的表分割特征或者将租户按组分到不同的服务器上。</p>
<h3 id="ABP中的多租户"><a href="#ABP中的多租户" class="headerlink" title="ABP中的多租户###"></a>ABP中的多租户###</h3><p>ABP提供了创建<strong>单部署，单数据库，多租户</strong>架构的基础设施。</p>
<h4 id="开启多租户"><a href="#开启多租户" class="headerlink" title="开启多租户"></a>开启多租户</h4><p>多租户默认是关闭的。我们可以在模块的PreInitialize方法中开启，如下所示：</p>
<pre><code>Configuration.MultiTenancy.IsEnabled = true; 
</code></pre>
<h4 id="租主vs租户"><a href="#租主vs租户" class="headerlink" title="租主vs租户"></a>租主vs租户</h4><p>首先，我们应该定义多租户系统中的两个条目：</p>
<ul>
<li><strong>租主（Host）</strong>:租主是单例的（只有一个租主）。租主会对创建和管理租户负责。因此，一个“<strong>租主用户</strong>”比所有的租户等级更高，并独立于所有租户，同时还能控制他们。</li>
<li><strong>租户（Tenant）</strong>:租主的一个客户，具有自己的用户角色，权限，设置等。每个租户都可以完全独立于其他租户使用应用。一个多租户应用会有一个或多个租户。如果是一个CRM应用，那么不同的租户也有它们自己的账户，契约，产品和订单。因此，当我们说“**租户用户”的时候，意思就是一个租户拥有的用户。</li>
</ul>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>ABP定义了一个获取当前<strong>用户</strong>和<strong>租户</strong>id的<strong>IAbpSession</strong>接口。该接口用于多租户获取当前的租户id。因此，它可以基于当前的租户id过滤数据。ABP中有以下规则：</p>
<ul>
<li>如果UserId和TenantId都是null，那么当前的用户没有登录到系统。因此，我们可以不知道当前用户是否是一个租主用户还是一个租户用户。在这种情况下，用户不能访问授权的内容。</li>
<li>如果UserId不是null，TenantId是null，那么当前用户是一个租主用户。</li>
<li>如果UserId不是null，TenantId也不是null，那么当前用户是租户用户。</li>
</ul>
<p>更多关于session的信息请看后面的Session一节。</p>
<h4 id="数据过滤器"><a href="#数据过滤器" class="headerlink" title="数据过滤器"></a>数据过滤器</h4><p>当从数据库中检索实体时，我们必须添加一个TenantId过滤器来只获得当前的租户实体。当你为实体实现了<strong>IMustHaveTenant和IMayHaveTenant</strong>两个接口之一时，ABP会自动地完成数据过滤。</p>
<h4 id="IMustHaveTenant接口"><a href="#IMustHaveTenant接口" class="headerlink" title="IMustHaveTenant接口"></a>IMustHaveTenant接口</h4><p>该接口通过定义<strong>TenantId</strong>属性来区分不同租户的实体。一个实现了IMustHaveTenant的实体例子如下：</p>
<pre class=" language-C#"><code class="language-C#">public class Product : Entity, IMustHaveTenant
{
    public int TenantId { get; set; }
        
    public string Name { get; set; }
    
    //...其他属性
}
</code></pre>
<p>这样，ABP知道这是一个特定租户的实体，并且会自动地将一个租户的实体从其他实体中分离出来。</p>
<h4 id="IMayHaveTenant接口"><a href="#IMayHaveTenant接口" class="headerlink" title="IMayHaveTenant接口"></a>IMayHaveTenant接口</h4><p>我们可能需要在租户和租户之间共享一个<strong>实体类型</strong>。因此，一个实体可能会被一个租户或租主拥有。IMayHaveTenant接口也定义了<strong>TenantId</strong>(类似于IMustHaveTenant)，但在这种情况下是<strong>nullable</strong>。实现了IMayHaveTenant的一个实体例子：</p>
<pre class=" language-C#"><code class="language-C#">public class Role : Entity, IMayHaveTenant
{
    public int? TenantId { get; set; }
        
    public string RoleName { get; set; }
    
    //...其他属性
}
</code></pre>
<p>我们可能会使用相同的Role类来存储租主角色和租户角色。这种情况下，TenantId表明这是一个租户实体还是一个租主实体。null值表示这是一个<strong>租主</strong>实体，<strong>非null</strong>值表示这被一个<strong>租户</strong>拥有，该租户的Id是<strong>TenantId</strong>。</p>
<p>IMayHaveTenant不像IMustHaveTenant一样常用。比如，一个Product类可以不实现IMayHaveTenant接口，因为Product和实际的应用功能相关，和管理租户不相干。因此，要小心使用IMayHaveTenant接口，因为它更难维护租户和租主共享的代码。</p>
<h4 id="保存实体"><a href="#保存实体" class="headerlink" title="保存实体"></a>保存实体</h4><p>一个租户用户不应该创建或编辑其他租户的实体。如果相关的数据过滤器开启了，那么ABP会检查该实体相对于数据库的改变。</p>
<p>想要获得更多关于数据过滤器的信息，请看后面关于数据过滤器的博客。</p>
<h1 id="ABP理论学习之依赖注入"><a href="#ABP理论学习之依赖注入" class="headerlink" title="ABP理论学习之依赖注入"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html">ABP理论学习之依赖注入</a></h1><p><strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPTheory.html">录</a></strong></p>
<hr>
<h2 id="本篇目录-5"><a href="#本篇目录-5" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#what">什么是依赖注入</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#problem">传统方式产生的问题</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#solution">解决办法</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#framework">依赖注入框架</a></strong></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#infra">ABP中的依赖注入基础设施</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#register">注册</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#resolve">解析</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#extra">其他</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#integration">ASP.NET MVC和ASP.NET Web API集成</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#tips">最后提示</a></strong></li>
</ul>
</li>
</ul>
<h3 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入###"></a>什么是依赖注入###</h3><blockquote>
<p>维基百科说：“依赖注入是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分。该模式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循了依赖反转和单一职责原则。与服务定位器模式形成直接对比的是，它允许客户端了解客户端如何使用该系统找到依赖”。</p>
</blockquote>
<p>不使用依赖注入技巧来管理依赖，并开发一个模块化的，结构友好的应用是非常困难的。</p>
<h4 id="传统方式产生的问题"><a href="#传统方式产生的问题" class="headerlink" title="传统方式产生的问题"></a>传统方式产生的问题</h4><p>在一个应用中，类相互依赖。假设我们有个应用服务，该应用服务使用了仓储将实体插入数据库。在这种情况下，此应用服务类依赖于仓储类。看下面这个例子：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService
{
    private IPersonRepository _personRepository;

    public PersonAppService()
    {
        _personRepository = new PersonRepository();            
    }

    public void CreatePerson(string name, int age)
    {
        var person = new Person { Name = name, Age = age };
        _personRepository.Insert(person);
    }
}
</code></pre>
<p><strong>PersonAppService</strong>使用了<strong>PersonRepository</strong>将一个 <strong>Person</strong>插入到数据库中。此处代码的问题在于：</p>
<ul>
<li>PersonAppService在<strong>CreatePerson</strong>方法中使用了<strong>IPersonRepository</strong>的引用，因此该方法依赖于IPersonRepository,而不是具体的PersonRepository类。但是在PersonAppService的构造函数中仍旧依赖于PersonRepository。而组件应该依赖于接口而不是实现，这就是依赖反转原则。</li>
<li>如果PersonAppService创建了PersonRepository本身，那么它会依赖于IPersonRepository接口的一个具体实现，这样就造成可能不会和其他实现一起工作。因此，从实现中分离接口就会变得毫无意义。硬依赖使得代码基变得紧耦合，可复用性降低。</li>
<li>在未来我们可能需要改变PersonRepository的创建。比如，我们可能想要它是单例的（单一公用的实例而不是每次使用都创建一个对象）。或者我们可能不止会创建实现了IPersonRepository的一个类，也可能想要有条件地创建这些实现类中的一个。这种情况下，我们就要改变依赖IPersonRepository的所有类，这样太不方便了，或者说维护难度太大了。</li>
<li>测试方面，有了这么个依赖，对于PersonAppService的单元测试非常难（或者根本不可能）。</li>
</ul>
<p>为了克服这些问题，可以使用工厂模式。因此，仓储类的创建时抽象的。看下面的代码：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService
{
    private IPersonRepository _personRepository;

    public PersonAppService()
    {
        _personRepository = PersonRepositoryFactory.Create();            
    }

    public void CreatePerson(string name, int age)
    {
        var person = new Person { Name = name, Age = age };
        _personRepository.Insert(person);
    }
}
</code></pre>
<p>PersonRepositoryFactory是一个创建并返回一个IPersonRepository的静态类。这就是所谓的<strong>服务定位器模式</strong>。这样创建问题是解决了，因为PersonAppService不知道如何创建一个IPersonRepository的实现，而且它独立于PersonRepository的实现。但是，仍然有下面这些问题：</p>
<ul>
<li>这次，PersonAppService依赖于PersonRepositoryFactory。这个较为可接受，但是仍然有硬依赖。</li>
<li>为每个仓储或者依赖写一个工厂类或方法太繁琐了。</li>
<li>还是不太好测试，因为让PersonAppService使用一些IPersonRepository的伪造实现还是很困难。</li>
</ul>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>要依赖其他的类有一些最佳实践（模式）。</p>
<h5 id="构造函数注入模式"><a href="#构造函数注入模式" class="headerlink" title="构造函数注入模式"></a>构造函数注入模式</h5><p>上面的例子可以重写为下面的代码：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService
{
    private IPersonRepository _personRepository;

    public PersonAppService(IPersonRepository personRepository)
    {
        _personRepository = personRepository;
    }

    public void CreatePerson(string name, int age)
    {
        var person = new Person { Name = name, Age = age };
        _personRepository.Insert(person);
    }
}
</code></pre>
<p>这就是所谓的<strong>构造函数注入</strong>。现在，PersonAppService不知道哪一个类实现了IPersonRepository,也不知道如何创建的它。谁要使用PersonAppService，首先要创建一个IPersonRepository,并将它传给PersonAppService的构造函数，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">var repository = new PersonRepository();
var personService = new PersonAppService(repository);
personService.CreatePerson("Yunus Emre", 19);
</code></pre>
<p>构造函数注入是使类独立于依赖对象创建的一种完美方式，但是，上面的代码存在一些问题：</p>
<ul>
<li>创建一个PersonAppService变得更加困难。试想如果它有4个依赖，那么我们必须创建这4个依赖的对象，然后把它们传入PersonAppService的构造函数中。</li>
<li>依赖的类可能有其它的依赖（这里，PersonRepository可能有依赖）。因此，我们必须创建PersonAppService的所有依赖，依赖的所有依赖等等。这样的话，我们甚至可能不再创建单一对象，因为依赖图太复杂了。</li>
</ul>
<p>幸运的是，ABP有依赖注入框架自动管理依赖。</p>
<h5 id="属性注入模式"><a href="#属性注入模式" class="headerlink" title="属性注入模式"></a>属性注入模式</h5><p>构造函数注入是提供一个类的依赖的完美模式。用这种方式，你可以不需要提供依赖就能创建一个类的实例，它也是显示声明该类需要满足什么要求才能正确工作的强大方式。</p>
<p>但在某些情况下，该类依赖于其他的类而且其他的类没有它也能工作。这对于关注度分离（比如日志记录）来说经常是成立的。一个类可以离开logging工作，但如果提供了logger，那它就能记录日志。这种情况下，你可以定义将依赖定义为公共的属性而不是在构造函数中获得这些依赖。试想如果我们要在PersonAppService中记录日志，那么我们可以重写该类为：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService
{
    public ILogger Logger { get; set; }

    private IPersonRepository _personRepository;

    public PersonAppService(IPersonRepository personRepository)
    {
        _personRepository = personRepository;
        Logger = NullLogger.Instance;
    }

    public void CreatePerson(string name, int age)
    {
        Logger.Debug("Inserting a new person to database with name = " + name);
        var person = new Person { Name = name, Age = age };
        _personRepository.Insert(person);
        Logger.Debug("Successfully inserted!");
    }
}
</code></pre>
<p>NullLogger.Instance是一个实现了ILogger的单例对象，但实际上什么都没做（没有记录日志，它使用了空的方法体实现了ILogger）。因此，如果你在创建PersonAppService对象之后，并像下面那样设置了Logger，PersonAppService就可以记录日志了：</p>
<pre class=" language-C#"><code class="language-C#">var personService = new PersonAppService(new PersonRepository());
personService.Logger = new Log4NetLogger();
personService.CreatePerson("Yunus Emre", 19);
</code></pre>
<p>假设Log4NetLogger实现了ILogger并使用Log4Net类库记录日志。这样，PersonAppService实际上就可以记录日志了。如果没有设置Logger，那么它就不会记录日志。因此，我们可以说ILogger是PersonAppService的一个<strong>可选依赖</strong>。</p>
<p>几乎所有的依赖注入框架都支持属性注入模式。</p>
<h4 id="依赖注入框架"><a href="#依赖注入框架" class="headerlink" title="依赖注入框架"></a>依赖注入框架</h4><p>有很多自动解析依赖的依赖注入框架。它们能够使用所有的依赖（包括依赖的依赖）创建对象。因此，你只需要使用构造和属性注入模式编写你的类，DI框架会处理剩下的事情。在一个优秀的应用中，你的类甚至独立于DI框架。在整个应用中，有许多显式和DI框架交互的代码行或者类。</p>
<p>ABP使用Castle Windsor框架处理依赖注入。它是最成熟的DI框架之一。还有很多其他的框架，如Unity，Ninject,StructureMap，Autofac等等。</p>
<p>在依赖注入框架中，你首先要将你的接口或者类注册到其中，然后才可以解析（创建）一个对象。在Castle Windsor中，有点像下面那样：</p>
<pre class=" language-C#"><code class="language-C#">var container = new WindsorContainer();

container.Register(
        Component.For<IPersonRepository>().ImplementedBy<PersonRepository>().LifestyleTransient(),
        Component.For<IPersonAppService>().ImplementedBy<PersonAppService>().LifestyleTransient()
    );

var personService = container.Resolve<IPersonAppService>();
personService.CreatePerson("Yunus Emre", 19);
</code></pre>
<p>上面的代码中，首先创建了<strong>WindsorContainer</strong>，然后使用PersonRepository和PersonAppService的接口注册了它们，再然后我们要求容器创建一个IPersonAppService。容器使用依赖创建了PersonAppService并返回，也许在这个简单的例子中使用DI框架的优势不是很明显，但是想象一下你在一个真实的企业应用中会有很多类和依赖。当然，也会在别的地方使用对象来注册依赖，这个在应用启动时只会做一次。</p>
<p>注意，我们也将对象的<strong>生命周期</strong>声明为<strong>transient</strong>。这意味着，无论何时解析这些类型的一个对象，都会创建一个新的实例。当然还有很多不同的生命周期（像singleton）。</p>
<h3 id="ABP中的依赖注入基础设施"><a href="#ABP中的依赖注入基础设施" class="headerlink" title="ABP中的依赖注入基础设施###"></a>ABP中的依赖注入基础设施###</h3><p>当你通过下面的最佳实践和一些惯例编写你的应用时，ABP几乎让使用DI框架变得不可见了。</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>在ABP中，将你的类注册到DI系统有几种不同的方式。大多数情况下，按照惯例注册已经足够了。</p>
<h5 id="惯例注册"><a href="#惯例注册" class="headerlink" title="惯例注册"></a>惯例注册</h5><p>ABP会按照惯例自动注册所有的仓储，领域服务，应用服务，MVC控制器和Web API控制器。比如，你可能有一个IPersonAppService接口和一个实现了该接口的PersonAppService类：</p>
<pre class=" language-C#"><code class="language-C#">public interface IPersonAppService : IApplicationService
{
    //...
}

public class PersonAppService : IPersonAppService
{
    //...
}
</code></pre>
<p>因为它实现了<strong>IApplicationService</strong>接口（只是一个空接口），所以ABP会自动注册它，并注册为<strong>transient</strong>（每次使用创建一个实例）。当你使用构造函数注入IPersonAppService接口到一个类中时，一个PersonAppService对象会自动地创建并传入该类的构造函数中。</p>
<p><strong>命名规范</strong>在ABP中非常重要。比如，你可以将PersonAppService更名为MyPersonAppService或是其他包含了“PersonAppService”后缀的名字，因为IPersonAppService接口有这个后缀。但你不能将它命名为PeopleService。如果你没有按照这种命名规范来操作的话，那么IPersonAppService不会自动地注册（但是它已经以自注册的方式注入到DI框架，而不是接口方式），因此如果你想要以接口方式注册的话，那么你应该手动注册。</p>
<p>ABP按照惯例注册程序集。因此，你应该按照惯例告诉ABP注册你的程序集。这个相当简单：</p>
<pre><code>IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
</code></pre>
<p>Assembly.GetExecutingAssembly()会获得包含这句代码的程序集的引用。你也可以将其他的程序集传入RegisterAssemblyByConvention 方法中。这个操作通常在你的模块初始化的时候完成的。查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPModuleSystem.html">《模块系统》</a>**博文获得更多信息。</p>
<p>通过实现<strong>IConventionalRegister</strong>接口和调用<strong>IocManager.AddConventionalRegister</strong>方法，你可以用你的类编写你自己的惯例注册类。你要做的就是在模块的PreInitialize方法中加入它。</p>
<h5 id="帮助接口"><a href="#帮助接口" class="headerlink" title="帮助接口"></a>帮助接口</h5><p>你可能想要注册一个特殊的类，但是它不符合惯例注册的原则。为此，ABP提供了<strong>ITransientDependency</strong> 和 <strong>ISingletonDependency</strong>接口。比如：</p>
<pre class=" language-C#"><code class="language-C#">public interface IPersonManager
{
    //...
}

public class MyPersonManager : IPersonManager, ISingletonDependency
{
    //...
}
</code></pre>
<p>用这种方式，你可以轻松地注册MyPersonManager。当需要注入IPersonManager的时候，就会使用MyPersonManager。注意依赖声明为<strong>Singleton</strong>。这样，MyPersonManager的单例就被创建了，并且相同的对象也被传入到所有的类中。只有在第一次使用时才会创建，以后再整个应用的生命周期都会使用相同的实例。</p>
<h5 id="自定义-直接注册"><a href="#自定义-直接注册" class="headerlink" title="自定义/直接注册"></a>自定义/直接注册</h5><p>如果之前描述的方法还不能满足你，那么你可以直接使用<strong>Castle Windsor</strong>来注册你的类和依赖。这样，你就在Castle Windsor中注册任何东西。</p>
<p>Castle Windsor有一个为了注册而要实现的接口<strong>IWindsorInstaller</strong>。你可以在应用中创建实现了IWindsorInstaller接口的类：</p>
<pre class=" language-C#"><code class="language-C#">public class MyInstaller : IWindsorInstaller
{
    public void Install(IWindsorContainer container, IConfigurationStore store)
    {
        container.Register(Classes.FromThisAssembly().BasedOn<IMySpecialInterface>().LifestylePerThread().WithServiceSelf());
    }
}
</code></pre>
<p>ABP会自动找到并执行这个类。最后，可以使用<strong>IIocManager.IocContainer</strong>属性到达WindsorContainer。获取更多Windsor信息，请查看**<a target="_blank" rel="noopener" href="http://docs.castleproject.org/Default.aspx?Page=MainPage">官方文档</a>**。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>注册会将你的类，类的依赖和生命周期通知给IOC（控制反转）容器。接下来，你需要在应用中的某些地方使用IOC容器创建对象。ABP针对依赖的解析提供了很多选项。</p>
<h5 id="构造函数-amp-属性注入"><a href="#构造函数-amp-属性注入" class="headerlink" title="构造函数&amp;属性注入"></a>构造函数&amp;属性注入</h5><p>你可以将使用构造函数和属性注入获得类的依赖作为最佳实践。无论在哪里，你都应该这样做。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService
{
    public ILogger Logger { get; set; }

    private IPersonRepository _personRepository;

    public PersonAppService(IPersonRepository personRepository)
    {
        _personRepository = personRepository;
        Logger = NullLogger.Instance;
    }

    public void CreatePerson(string name, int age)
    {
        Logger.Debug("Inserting a new person to database with name = " + name);
        var person = new Person { Name = name, Age = age };
        _personRepository.Insert(person);
        Logger.Debug("Successfully inserted!");
    }
}
</code></pre>
<p>IPersonRepository从构造函数注入，ILogger使用公共属性注入。这样的话，你的代码根本意识不到依赖注入系统的存在，也就是说，依赖系统对于我们开发者完全是透明的，我们可以不考虑依赖系统内部的实现细节。这是使用DI系统最合适的方式。</p>
<p>IIocResolver和IIocManager</p>
<p>有时，你可能必须要直接解析依赖而不是通过构造函数和属性注入。这种情况要尽可能地避免，但这种情况也是有可能的。ABP提供了很多可以轻松注入并使用的服务。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class MySampleClass : ITransientDependency
{
    private readonly IIocResolver _iocResolver;

    public MySampleClass(IIocResolver iocResolver)
    {
        _iocResolver = iocResolver;
    }

    public void DoIt()
    {
        //手动解析
        var personService1 = _iocResolver.Resolve<PersonAppService>();
        personService1.CreatePerson(new CreatePersonInput { Name = "Yunus", Surname = "Emre" });
        _iocResolver.Release(personService1);

        //安全地解析并使用
        using (var personService2 = _iocResolver.ResolveAsDisposable<PersonAppService>())
        {
            personService2.Object.CreatePerson(new CreatePersonInput { Name = "Yunus", Surname = "Emre" });
        }
    }
}
</code></pre>
<p>在以上例子中的MySampleClass通过构造函数注入<strong>IIocResolver</strong>并用它来解析和释放对象。<strong>Resolve</strong>方法有许多重载可供使用。<strong>Release</strong>方法用来释放组件（对象）。调用Release来手动解析一个对象是很关键的，否则，应用会有内存泄漏问题。为了确保释放对象，要尽可能使用<strong>ResolveAsDisPosable</strong>(如例子中演示的那样)。在using块的末尾会自动地调用Release。</p>
<p>如果你想要直接使用IOC容器（Castle Windor）来解析依赖，那么你可以构造函数注入<strong>IIocManager</strong>并使用IIocManager.IocContainer属性。如果你处于静态上下文或者不能注入IIocManager，那么最后的机会就是，你可以使用单例对象<strong>IocManager.Instance</strong>。但是，这种情况不容易测试。</p>
<h4 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h4><h5 id="IShouldInitialize接口"><a href="#IShouldInitialize接口" class="headerlink" title="IShouldInitialize接口"></a>IShouldInitialize接口</h5><p>某些类在第一次使用前就要初始化。IShouldInitialize接口有一个Initialize方法。如果实现了该接口，那么在创建对象之后（使用前）就会自动地调用Initialize方法。当然，为了使该功能有效，你应该注入/解析该对象。</p>
<h4 id="ASP-NET-MVC和ASP-NET-Web-API集成"><a href="#ASP-NET-MVC和ASP-NET-Web-API集成" class="headerlink" title="ASP.NET MVC和ASP.NET Web API集成"></a>ASP.NET MVC和ASP.NET Web API集成</h4><p>当然，为了解析依赖图中的根对象，我们必须调用依赖注入系统。在ASP.NET MVC应用中，根对象一般是一个<strong>Controller</strong>类。我们也可以在控制器中使用构造函数注入和属性注入模式。当一个请求到达应用时，IOC容器创建了控制器对象，然后所有的依赖递归地解析出来。那么，谁处理的这个呢？这是ABP通过扩展了ASP.NET MVC默认的控制器工厂自动完成的。相似地，对于ASP.Net Web API也是如此。你不必关心创建和释放对象的事情。</p>
<h4 id="最后提示"><a href="#最后提示" class="headerlink" title="最后提示"></a>最后提示</h4><p>只要你遵循规则并使用上面的结构，ABP就能简化并自动化依赖注入的使用。大多数情况下，这些已经够用了。但是，如果你需要的话，你可以直接使用所有Castle Windsor的能力来执行任何任务（如自定义注册，注入钩子，拦截器等等）</p>
<h1 id="ABP理论学习之Abp-Session"><a href="#ABP理论学习之Abp-Session" class="headerlink" title="ABP理论学习之Abp Session"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSession.html">ABP理论学习之Abp Session</a></h1><hr>
<h2 id="本篇目录-6"><a href="#本篇目录-6" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSession.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSession.html#injection">注入Session</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSession.html#property">使用Session属性</a></strong></li>
</ul>
<h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍###"></a>介绍###</h3><p>当应用程序要求用户登录时，那么应用程序也需要知道当前用户正在执行的操作。虽然ASP.NET本身在展现层提供了Session对象，但ABP也提供了在任何需要获得当前用户和租户的地方都可以使用的<strong>IAbpSession</strong>接口。</p>
<blockquote>
<h4 id="关于IAbpSession"><a href="#关于IAbpSession" class="headerlink" title="关于IAbpSession"></a>关于IAbpSession</h4><p>为了获得实际的session信息，必须要实现IAbpSession接口。虽然你可以用自己的方式实现它，但在<strong>module-zero</strong>项目中已经完全实现。</p>
</blockquote>
<p>IAbpSession已经完全集成到ABP（实例的设置系统和授权系统）中。</p>
<h3 id="注入Session"><a href="#注入Session" class="headerlink" title="注入Session###"></a>注入Session###</h3><p>IAbpSession一般<strong>属性注入</strong>到需要的类中，除非没有Session信息导致IAbpSession不可能工作。如果我们使用了属性注入，那么我们可以使用<strong>NullAbpSession.Instance</strong>作为默认值，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class MyClass : ITransientDependency
{
    public IAbpSession AbpSession { get; set; }

    public MyClass()
    {
        AbpSession = NullAbpSession.Instance;
    }

    public void MyMethod()
    {
        var currentUserId = AbpSession.UserId;
        //...
    }
}
</code></pre>
<p>因为授权是应用层的事儿，所以建议<strong>在应用层和更高的层使用IAbpSession</strong>(一般我们不再领域层使用)。<strong>ApplicationService，AbpController，AbpApiController</strong>已经注入了 <strong>AbpSession</strong>。因此，你可以直接在应用层服务方法中为实例使用AbpSession属性。</p>
<h3 id="使用Session属性"><a href="#使用Session属性" class="headerlink" title="使用Session属性###"></a>使用Session属性###</h3><p>AbpSession定义了一些key属性：</p>
<ul>
<li><strong>UserId</strong>:当前用户的Id。值为null，表示当前的用户不存在。如果调用的代码授权给某个用户的话，那么值不为null。</li>
<li><strong>TenantId</strong>:当前租户的Id。如果当前的租户不存在，值就为null。</li>
<li><strong>MultiTenancySide</strong>:可能是Host（租主）或者Tenant（租户）。</li>
</ul>
<p>UserId和TenantId是<strong>nullable(可空的)**，也存在不可空的</strong>GetUserId()**和 **GetTenantId()**方法。如果你确定当前的用户存在，那么你可以调用GetUserId()。如果当前的用户为null，那么该方法就会抛异常。GetTanantId()也是类似的。</p>
<h1 id="ABP理论学习之缓存Caching"><a href="#ABP理论学习之缓存Caching" class="headerlink" title="ABP理论学习之缓存Caching"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPCaching.html">ABP理论学习之缓存Caching</a></h1><hr>
<h2 id="本篇目录-7"><a href="#本篇目录-7" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPCaching.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPCaching.html#ICacheManager">ICacheManager</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPCaching.html#ICache">ICache</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPCaching.html#ITypedCache">ITypedCache</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPCaching.html#config">配置</a></strong></li>
</ul>
<h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍###"></a>介绍###</h3><p>ABP提供了缓存的抽象，它内部使用了这个缓存抽象。虽然默认的实现使用了MemoryCache，但是也可以为其他的缓存提供者进行实现和改变。</p>
<h3 id="ICacheManager"><a href="#ICacheManager" class="headerlink" title="ICacheManager###"></a>ICacheManager###</h3><p>缓存的主要接口是<strong>ICacheManager</strong>。我们可以注入该接口，然后使用该接口获得一个缓存对象。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class TestAppService : ApplicationService
{
    private readonly ICacheManager _cacheManager;

    public TestAppService(ICacheManager cacheManager)
    {
        _cacheManager = cacheManager;
    }

    public Item GetItem(int id)
    {
        //从缓存中获取
        return _cacheManager
                .GetCache("MyCache")
                .Get(id.ToString(), () => GetFromDatabase(id)) as Item;
    }

    public Item GetFromDatabase(int id)
    {
        //... 从数据库中检索
    }
}
</code></pre>
<p>在这个例子中，我们注入了<strong>ICacheManager</strong>，并获取了一个叫做<strong>MyCache</strong>的缓存对象。</p>
<blockquote>
<h4 id="警告：GetCache方法"><a href="#警告：GetCache方法" class="headerlink" title="警告：GetCache方法"></a>警告：GetCache方法</h4><p>不要在构造函数中使用GetCache方法。如果你的类是transient（每次使用都会创建）的，那么这可能会释放缓存，因为第二次创建类的对象时，会再次调用构造函数，之前的第一次的缓存可能会被释放。</p>
</blockquote>
<h3 id="ICache"><a href="#ICache" class="headerlink" title="ICache###"></a>ICache###</h3><p>ICacheManager.GetCache方法返回一个<strong>ICache</strong>。缓存对象是单例的，第一次请求时会创建缓存，以后都是返回相同的缓存对象。因此，我们可以在不同的类（客户端）中共享具有相同名字的相同缓存。</p>
<p>在样例代码中，我们看到了ICache.Get方法的简单使用。它有两个参数：</p>
<ul>
<li><strong>key</strong>：缓存中一个条目的唯一字符串键。</li>
<li><strong>工厂</strong>：没有找到给定key的缓存条目时调用的action。工厂方法应该创建并返回实际的条目。如果给定的key在缓存中找到了，那么不会调用该action。</li>
</ul>
<p>ICache接口也有像<strong>GetOrDefault,Set,Remove,Clear</strong>的方法。同时，这些方法也有<strong>异步（async）</strong>版本。</p>
<h3 id="ITypedCache"><a href="#ITypedCache" class="headerlink" title="ITypedCache###"></a>ITypedCache###</h3><p><strong>ICache</strong>接口的key为string类型，value为object类型。<strong>ITypeCache</strong>是ICache的包装器，提供<strong>类型安全</strong>、泛型的cache。为了将ICache转为ITypedCache，我们可以使用<strong>AsTyped</strong>扩展方法，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">ITypedCache<int, Item> myCache = _cacheManager.GetCache("MyCache").AsTyped<int, Item>();
</code></pre>
<p>这样，我们不需要转换就可以使用Get方法。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置###"></a>配置###</h3><p>默认的缓存有效期是60min。因此，如果你在60min内都没有使用缓存中的元素，那么它会自动从缓存中移除。对于所有的缓存或者特定的某个缓存，你都可以配置有效期。</p>
<pre class=" language-C#"><code class="language-C#">//为所有缓存配置有效期
Configuration.Caching.ConfigureAll(cache =>
{
    cache.DefaultSlidingExpireTime = TimeSpan.FromHours(2);
});

//为特定的缓存配置有效期
Configuration.Caching.Configure("MyCache", cache =>
{
    cache.DefaultSlidingExpireTime = TimeSpan.FromHours(8);
});
</code></pre>
<p>这些代码应该放到模块中的<strong>PreInitialize</strong>方法中。有了这样的配置，MyCache会有8小时的有效期，而其他cache会有2小时有效期。</p>
<p>一旦cache首次创建（第一次请求时），就会调用配置的action。配置并不只局限于DefaultSlidingExpireTime（默认滚动有效期），因为cache对象是一个ICache，你可以使用它的属性和方法自由地配置并初始化。</p>
<h1 id="ABP理论学习之日志记录"><a href="#ABP理论学习之日志记录" class="headerlink" title="ABP理论学习之日志记录"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLogging.html">ABP理论学习之日志记录</a></h1><hr>
<h2 id="本篇目录-8"><a href="#本篇目录-8" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLogging.html#server">服务端</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLogging.html#get">获取Logger</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLogging.html#base">基类中的Logger</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLogging.html#config">配置</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLogging.html#client">客户端</a></strong></li>
</ul>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端###"></a>服务端###</h3><p>ABP使用的是Castle Windsor的**<a target="_blank" rel="noopener" href="http://docs.castleproject.org/Windsor.Logging-Facility.ashx">日志记录设备</a><strong>。它可以和不同的日志类库一起工作，比如</strong>Log4Net,NLog，Serilog等等<strong>。Castle为所有的日志类库提供了一个</strong>公共的接口**。因此，你完全独立于特定的日志记录类库，而且，如果需要的话，你可以轻松地改变应用程序的日志类库。</p>
<p>**<a target="_blank" rel="noopener" href="http://logging.apache.org/log4net/">Log4Net</a>**是.Net中最流行的日志类库之一。ABP模板中自带了经过合适配置的Log4Net。但是，只存在一行log4net的依赖（看下面），因此，你可以将它改为你最喜欢的类库。</p>
<h4 id="获取Logger"><a href="#获取Logger" class="headerlink" title="获取Logger"></a>获取Logger</h4><p>无论你选择了什么日志类库，最终要记录的日志代码都是相同的（这得感谢Castle公共的ILogger接口）。</p>
<p>一开始，我们要处理一下记录日志的Logger对象。因为ABP强烈推荐使用依赖注入，所以我们可以使用属性注入模式轻松地注入一个Logger对象。如下所示：</p>
<pre class=" language-C#"><code class="language-C#">using Castle.Core.Logging; //1: 导入 Logging 命名空间

public class TaskAppService : ITaskAppService
{    
    //2: 使用属性注入获得 logger
    public ILogger Logger { get; set; }
    
    public TaskAppService()
    {
        //3: 如果没有提供Logger，就不能记录日志
        Logger = NullLogger.Instance;
    }

    public void CreateTask(CreateTaskInput input)
    {
        //4: 记录日志
        Logger.Info("Creating a new task with description: " + input.Description);

        //TODO: 保存到数据库...
    }
}
</code></pre>
<ol>
<li>导入Castle的ILogger接口的命名空间。</li>
<li>定义一个公有的叫做Logger的<strong>ILogger</strong>对象。这是记录日志的对象。创建TaskAppService对象之后，依赖注入系统会设置（注入）这个属性。这就是所谓的属性注入模式。</li>
<li>将Logger设置为<strong>NullLogger.Instance</strong>。即使没有这行代码，系统也会工作地很好。但是这是属性注入模式的最佳实践。如果没给Logger设置任何值，那么当我们使用它的时候会因为它是null而抛出“空指针”异常。这个保证了它不为null。因此，如果没有给Logger设置值，那么它是NullLogger。这就是所谓的null对象模式。NullLogger实际上什么都没做，也没有记录任何日志。因此，我们的类要不要一个实际的logger都能工作。</li>
<li>最后，我们记录了一个<strong>info</strong>等级的日志文本。存在多种不同的等级（看下面）。</li>
</ol>
<p>如果我们调用了CreateTask方法，并检查日志文件，就会看到像下面一样的一长行字符串。</p>
<pre><code>INFO  2014-07-13 13:40:23,360 [8    ] SimpleTaskSystem.Tasks.TaskAppService    - Creating a new task with description: Remember to drink milk before sleeping!
</code></pre>
<h4 id="基类中的Logger"><a href="#基类中的Logger" class="headerlink" title="基类中的Logger"></a>基类中的Logger</h4><p>ABP为MVC控制器，Web API控制器和应用服务类提供了基类。比如，Web层对应的基类是XXXControllerBase(后缀为ControllerBase)。这些基类中都声明了<strong>Logger</strong>属性。因此你可以直接使用Logger来记录日志，无需注入。例子：</p>
<pre class=" language-C#"><code class="language-C#">public class HomeController : SimpleTaskSystemControllerBase
{
    public ActionResult Index()
    { 
        Logger.Debug("A sample log message...");
        return View();
    }
}
</code></pre>
<p>注意，SimpleTaskSystemControllerBase是继承了<strong>AbpController</strong>的应用基类控制器。因此，可以在控制器中直接使用Logger。Logger也存在于Web Api控制器的<strong>AbpApiController</strong>基类，以及应用服务层的基类（后缀为AppServiceBase的类）。你也可以为其他的类编写自己的公共基类，这样，你就不需要每次注入logger了。</p>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>当你从ABP模板创建应用程序时，Log4Net的所有配置已经完成了。</p>
<p>默认的日志格式配置如下：</p>
<ul>
<li><strong>日志级别</strong>：DEBUG, INFO, WARN, ERROR或者FATAL。</li>
<li><strong>日期和时间</strong>：记录日志的时间。</li>
<li><strong>线程号</strong>:记录日志的线程号码。</li>
<li><strong>Logger名称</strong>：通常是记录日志的类名。</li>
<li><strong>日志文本</strong>：实际记录的日志文本。</li>
</ul>
<p>配置定义在应用的<strong>log4net.config</strong>文件中，如下所示：</p>
<pre class=" language-web.config"><code class="language-web.config"><?xml version="1.0" encoding="utf-8" ?>
<log4net>
  <appender name="RollingFileAppender" type="log4net.Appender.RollingFileAppender" >
    <file value="Logs/Logs.txt" />
    <appendToFile value="true" />
    <rollingStyle value="Size" />
    <maxSizeRollBackups value="10" />
    <maximumFileSize value="10000KB" />
    <staticLogFileName value="true" />
    <layout type="log4net.Layout.PatternLayout">
        <conversionPattern value="%-5level %date [%-5.5thread] %-40.40logger - %message%newline" />
    </layout>
  </appender>
  <root>
    <appender-ref ref="RollingFileAppender" />
    <level value="DEBUG" />
  </root>
  <logger name="NHibernate">
    <level value="WARN" />
  </logger>
</log4net>
</code></pre>
<p>Log4Net是高度可配置的、健壮的日志记录类库。你可以使用不同的格式将日志记录到不同的目标上（文本文件，数据库等）。你也可以设置最小日志等级（正如此配置中为NHibernate配置的那样）。你也可以记录不同的日志到不同的文件中。当到达一个指定的大小时，它会自动备份并创建一个新的日志文件等等（本例中，滚动文件适配器的每个文件大小是10MB）。为了更好配置你的log4net，请查看**<a target="_blank" rel="noopener" href="http://logging.apache.org/log4net/release/config-examples.html">官方文档</a>**。</p>
<p>最后，我们在Global.asax文件中，声明了要使用log4net.config文件中的Log4Net。</p>
<pre class=" language-C#"><code class="language-C#">public class MvcApplication : AbpWebApplication
{
    protected override void Application_Start(object sender, EventArgs e)
    {
        IocManager.Instance.IocContainer.AddFacility<LoggingFacility>(f => f.UseLog4Net().WithConfig("log4net.config"));
        base.Application_Start(sender, e);
    }
}
</code></pre>
<p>这是<strong>我们直接依赖log4net的唯一代码行</strong>。而且，只有web项目依赖log4net类库的nuget包。因此，你可以轻松地切换到其他日志类库，而且不需要改变记录日志的代码。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端###"></a>客户端###</h3><p>ABP为客户端定义了一个javascript日志记录API。默认会将日志记录到浏览器的控制台。记录日志的javascript代码样例如下：</p>
<h1 id="ABP理论学习之设置管理"><a href="#ABP理论学习之设置管理" class="headerlink" title="ABP理论学习之设置管理"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html">ABP理论学习之设置管理</a></h1><hr>
<h2 id="本篇目录-9"><a href="#本篇目录-9" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#defSetting">定义设置</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#getSetting">获取设置值</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#changeSetting">更改设置</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#aboutCache">关于缓存</a></strong></li>
</ul>
<h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍###"></a>介绍###</h3><p>每个应用程序都需要存储一些设置信息，然后在应用程序中的某个地方使用这些设置。ABP提供了健壮的基础设施来存储或检索服务端和客户端的<strong>应用程序，租户，用户</strong>级别的可用设置。</p>
<p>一个设置一般是存储在数据库（或其他源）的<strong>name-value</strong>字符串对。我们可以将非字符串的值转换成字符串。</p>
<blockquote>
<h4 id="关于ISettingStore"><a href="#关于ISettingStore" class="headerlink" title="关于ISettingStore"></a>关于ISettingStore</h4><p>为了使用设置系统，必须要实现<strong>ISettingStore</strong>。虽然你可以用自己的方式实现，但是它已完全实现在<strong>module-zero</strong>中了。</p>
</blockquote>
<h3 id="定义设置"><a href="#定义设置" class="headerlink" title="定义设置###"></a>定义设置###</h3><p>一个设置使用前必须先定义。ABP是模块化设计的，因此，不同的模块可以有不同的设置。要定义一个设置，一个模块应该创建一个派生于<strong>SettingProvider</strong>（设置提供器）的类。设置提供器的一个例子如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class MySettingProvider : SettingProvider
{
    public override IEnumerable<SettingDefinition> GetSettingDefinitions(SettingDefinitionProviderContext context)
    {
        return new[]
                {
                    new SettingDefinition(
                        "SmtpServerAddress",
                        "127.0.0.1"
                        ),

                    new SettingDefinition(
                        "PassiveUsersCanNotLogin",
                        "true",
                        scopes: SettingScopes.Application | SettingScopes.Tenant
                        ),

                    new SettingDefinition(
                        "SiteColorPreference",
                        "red",
                        scopes: SettingScopes.User,
                        isVisibleToClients: true
                        )

                };
    }
}
</code></pre>
<p><strong>GetSettingDefinitions</strong>方法应该返回<strong>SettingDefinition</strong>集合。SettingDefinition类的构造函数有一些参数：</p>
<ul>
<li><strong>Name</strong>(必须)：一个设置的名称，在系统中名称必须唯一。最好为每个设置名定义一个常量字符串。</li>
<li><strong>Default值</strong>：设置的默认值。可以为null或空字符串。</li>
<li><strong>Scopes</strong>：一个设置应该定义它的范围（看下面）。</li>
<li><strong>Dispaly name</strong>：在UI上显示的本地化的设置名。</li>
<li><strong>Description</strong>：在UI上显示的本地化的设置描述。</li>
<li><strong>Group</strong>：用于组合设置。这个用于UI而不是设置管理。</li>
<li><strong>IsVisibleToClients</strong>：客户端是否可见。</li>
</ul>
<p>创建一个设置提供器之后，我们应该在模块的PreInitialize方法中注册。</p>
<pre><code>Configuration.Settings.Providers.Add&lt;MySettingProvider&gt;();
</code></pre>
<p>这样，设置提供器就自动注册到依赖注入系统中了。因此，设置提供器可以使用一些其他的资源注入任何依赖（如仓储）来生成设置定义。</p>
<h4 id="设置范围"><a href="#设置范围" class="headerlink" title="设置范围"></a>设置范围</h4><p>在<strong>SettingScope</strong>枚举类中定义了三种<strong>设置范围（或者说等级）</strong>：</p>
<ul>
<li><strong>Application</strong>：一个应用范围的setting对象用于用户或者租户独立的设置。比如，我们可以定义一个叫做“SmtpServerAddress”的设置来获取发送邮件时服务端的IP地址。如果该setting有一个单一值（基于用户不会改变），那么我们可以把它定义为应用范围的。</li>
<li><strong>Tenant</strong>：如果应用程序时多租户的，那么我们可以定义租户特定的setting。</li>
<li><strong>User</strong>：我们可以定义存储或者获取特定用户的设置。</li>
</ul>
<p>SettingScopes枚举类型有<strong>Flags</strong>特性，因此我们可以定义一个<strong>不止一个范围</strong>的setting。</p>
<p>设置范围是有层次的，比如，如果我们定义的设置范围是“Application | Tenant | User”，并尝试获取该设置<strong>当前的值</strong>，那么：</p>
<ul>
<li>如果已定义了该用户的setting，那么就会获得该用户特定的值。</li>
<li>如果上面的条件不成立，并且已经定义了该用户所属租户的setting，那么会获得该租户特定的值。</li>
<li>如果上面的条件还不成立，如果定义了应用的值，那么会获得该应用的值。</li>
<li>最后，我们会获得<strong>默认值</strong>。</li>
</ul>
<p>默认值可能是null或者空字符串。如果可能的话，建议为setting的默认值提供默认值。</p>
<h3 id="获取设置值"><a href="#获取设置值" class="headerlink" title="获取设置值###"></a>获取设置值###</h3><p>定义了一个setting之后，我们就可以在客户端和服务端获得它当前的值。</p>
<h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><p><strong>ISettingManager</strong>用于执行setting操作。我们可以在应用中的任何地方注入并使用它。ISettingManager定义了许多获取一个setting值的方法。</p>
<p>用的最多的方法是<strong>GetSettingValue</strong>(或者异步调用GetSettingValueAsync)。它会返回基于默认值，应用程序，租户和用户setting的当前的值（正如上面提到的）。例如：</p>
<pre class=" language-C#"><code class="language-C#">//获取一个bool值（异步调用）
var value1 = await SettingManager.GetSettingValueAsync<bool>("PassiveUsersCanNotLogin");

//获取一个string值（同步调用）
var value2 = SettingManager.GetSettingValue("SmtpServerAddress");
</code></pre>
<p>GetSettingValue有泛型和异步版本，如上面所示。也有获得特定租户或者用户的setting值或者所有setting值的列表的方法。</p>
<p>因为ISettingManager使用广泛，所以一些特殊的基类（如ApplicationService，DomainService和AbpController）就有了一个叫做<strong>SettingManager</strong>的属性。如果我们从这些类中派生，那么就不需要显式注入它了。</p>
<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p>当定义一个setting时，如果将<strong>IsVisibleToClients</strong>设置为true，那么可以使用javascript在客户端获得当前的值。<strong>abp.setting</strong>命名空间定义了一些用得到的函数和对象。例如：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> currentColor <span class="token operator">=</span> abp<span class="token punctuation">.</span>setting<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"SiteColorPreference"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>也有<strong>getInt</strong>和 <strong>getBoolean</strong> 方法。你可以使用<strong>abp.setting.values</strong>获得所有的值。注意：如果在服务端更改了一个setting，那么如果页面没有更新，setting没有重新加载或者通过代码手动更新的话，那么客户端就不知道该setting是否发生了变化。</p>
<h3 id="更改设置"><a href="#更改设置" class="headerlink" title="更改设置###"></a>更改设置###</h3><p>ISettingManager为应用程序，租户和用户分别定义了<strong>ChangeSettingForApplicationAsync, ChangeSettingForTenantAsync和ChangeSettingForUserAsync</strong>方法来更改setting。</p>
<h3 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存###"></a>关于缓存###</h3><p>Setting Manager(管理者)缓存到了服务端的setting了。因此，我们不应该使用仓储或者数据库更新来直接更改一个setting的值。</p>
<h1 id="领域层-1"><a href="#领域层-1" class="headerlink" title="领域层"></a>领域层</h1><h1 id="ABP理论学习之实体类"><a href="#ABP理论学习之实体类" class="headerlink" title="ABP理论学习之实体类"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntity.html">ABP理论学习之实体类</a></h1><hr>
<h2 id="本篇目录-10"><a href="#本篇目录-10" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntity.html#entity">实体类</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntity.html#guanli">惯例接口</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntity.html#Auditing">审计</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntity.html#softDelete">软删除</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntity.html#active">激活/未激活</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntity.html#IEntity">IEntity接口</a></strong></li>
</ul>
<blockquote>
<p>实体是DDD（领域驱动设计）的核心概念之一。Eirc Evans是这样描述的实体的：“它根本上不是通过属性定义的，而是通过一系列连续性和标识定义的”。因此，实体都有Id属性并且都存储到数据库中。一个实体一般会映射到数据库的一张表。</p>
</blockquote>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类###"></a>实体类###</h3><p>在ABP中，实体派生自<strong>Entity</strong>类，看下面的例子：</p>
<pre class=" language-C#"><code class="language-C#">public class Person : Entity
{
    public virtual string Name { get; set; }

    public virtual DateTime CreationTime { get; set; }

    public Person()
    {
        CreationTime = DateTime.Now;
    }
}
</code></pre>
<p>上面定义了一个<strong>Person</strong>实体类，而且在Entity类中定义了一个<strong>Id</strong>属性，它是该Entity类的 <strong>主键</strong>。因此，所有实体的主键名都是相同的，都是<strong>Id</strong>。</p>
<p>Id（主键）的类型是可以改变的，默认是int(int32)的。如果你想将Id定义为其他类型，可以像下面那样显示声明：</p>
<pre class=" language-C#"><code class="language-C#">public class Person : Entity<long>
{
    public virtual string Name { get; set; }

    public virtual DateTime CreationTime { get; set; }

    public Person()
    {
        CreationTime = DateTime.Now;
    }
}
</code></pre>
<p>而且，你也可以把它设置为string,Guid或其他类型的。</p>
<p>Entity类重写了<strong>等号</strong>运算符（==），可以轻松地检查两个实体是否相同了（实体的Id相同则认为它们相同）。它也定义了<strong>IsTransient</strong>方法来检测它是否有Id。</p>
<h3 id="惯例接口"><a href="#惯例接口" class="headerlink" title="惯例接口###"></a>惯例接口###</h3><p>在许多应用中，使用了相似的实体属性（和数据表中的字段），如CreationTime表明该实体是何时创建的。ABP提供了很多有用的接口来使得这些通用的属性变得明确并富有表现力。此外，这也为实现了这些接口的实体类提供了一种编写通用代码的方式。</p>
<h4 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h4><p><strong>IHasCreationTime</strong>使得使用一个通用的属性来描述一个实体的<strong>“创建时间”</strong>信息成为可能。当实现了该接口的实体类插入到数据库中时，ABP会自动地将<strong>当前的时间</strong>设置给CreationTime。</p>
<pre class=" language-C#"><code class="language-C#">public interface IHasCreationTime
{
    DateTime CreationTime { get; set; }
}
</code></pre>
<p>Person类可以通过实现<strong>IHasCreationTime</strong>接口来重写，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class Person : Entity<long>, IHasCreationTime
{
    public virtual string Name { get; set; }

    public virtual DateTime CreationTime { get; set; }

    public Person()
    {
        CreationTime = DateTime.Now;
    }
}
</code></pre>
<p><strong>ICreationAudited</strong>通过增加了<strong>CreatorUserId</strong>扩展了IHasCreationTime:</p>
<pre class=" language-C#"><code class="language-C#">public interface ICreationAudited : IHasCreationTime
{
    long? CreatorUserId { get; set; }
}
</code></pre>
<p>当保存一个新的实体时，ABP会自动地将<strong>当前的用户Id</strong>设置为CreatorUserId。</p>
<p>你也可以通过从<strong>CreationAuditedEntity</strong>类派生实体，从而轻易地实现ICreationAudited。</p>
<p>对于修改也有相似的接口：</p>
<pre class=" language-C#"><code class="language-C#">public interface IModificationAudited
{
    DateTime? LastModificationTime { get; set; }

    long? LastModifierUserId { get; set; }
}
</code></pre>
<p>当更新一个实体的时候，ABP也会自动地设置这些属性。你只需要为你的实体实现这些接口即可。</p>
<p>如果你想实现所有的审计属性，那么你可以直接实现<strong>IAudited</strong>接口：</p>
<pre class=" language-C#"><code class="language-C#">public interface IAudited : ICreationAudited, IModificationAudited
{
        
}
</code></pre>
<p>作为一个快捷方式，你可以从<strong>AuditedEntity</strong>类派生，而不需要直接实现<strong>IAudited</strong>。AuditedEntity类对于不同类型的Id属性也有泛型的版本。</p>
<h4 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h4><p>软删除是将一个实体标记为已删除的通常使用的模式，而不是直接从数据库中删除。比如，你可能不想从数据库中硬删除一个User，因为它可能关联其他的表。<strong>ISoftDelete</strong>接口用于下面的目的：</p>
<pre class=" language-C#"><code class="language-C#">public interface ISoftDelete
{
    bool IsDeleted { get; set; }
}
</code></pre>
<p>ABP实现了开箱即用的软删除模式。当一个软删除实体被删除后，ABP检测到之后，会阻止删除，将IsDeleted设置为true并更新数据库中的实体。而且，它会自动地过滤数据库中软删除的实体，不会检索（select）它们。</p>
<p>如果使用了软删除，那么你可能想存储一些信息，比如何时删除以及谁删除了一个实体等等。你可以实现下面演示的<strong>IDeletionAudited</strong>接口：</p>
<pre class=" language-C#"><code class="language-C#">public interface IDeletionAudited : ISoftDelete
{
    long? DeleterUserId { get; set; }

    DateTime? DeletionTime { get; set; }
}
</code></pre>
<p>IDeletionAudited扩展了ISoftDelete，当删除一个实体时，ABP会自动设置这些属性。</p>
<p>如果你想为一个实体实现所有的审计接口（创建，修改和删除），那么可以直接实现<strong>IFullAudited</strong>,因为它继承了所有的这些接口：</p>
<pre class=" language-C#"><code class="language-C#">public interface IFullAudited : IAudited, IDeletionAudited
{
        
}
</code></pre>
<p>同样的，作为一个快捷方式，你可以从<strong>FullAuditedEntity</strong>类派生你的实体类从而实现所有的审计接口。</p>
<p>注意：所有的审计接口和类都有一个定义导航属性到<strong>User</strong>实体的泛型版本（比如ICreationAudited和FullAuditedEntity&lt;TPrimaryKey,TUser&gt;）。</p>
<h4 id="激活-未激活"><a href="#激活-未激活" class="headerlink" title="激活/未激活"></a>激活/未激活</h4><p>一些实体需要标记为激活的或未激活的。这样，你就可以根据实体的激活或者未激活状态来采取行动。你可以实现<strong>IPassivable</strong>接口来达到目的。该接口定义了<strong>IsActive</strong>属性。</p>
<p>如果实体在第一次创建时是激活的，那么你可以在构造函数中将IsActive设置为true。</p>
<p>这与软删除（IsDeleted）是不同的。如果一个实体是软删除的，那么它就不会从数据库中检索到了（ABP默认会阻止），但是，对于激活或者未激活的实体，控制获取实体完全取决于你。</p>
<h3 id="IEntity接口"><a href="#IEntity接口" class="headerlink" title="IEntity接口###"></a>IEntity接口###</h3><p>实际上，<strong>Entity</strong>类实现了<strong>IEntity</strong>接口（且<strong>Entity</strong>实现了<strong>IEntity</strong>）。如果不想从Entity类中派生，那么可以直接实现这些接口。但是，除非你有一个好的原因不从Entity类派生，否则，不建议这么做。</p>
<h1 id="ABP理论学习之仓储"><a href="#ABP理论学习之仓储" class="headerlink" title="ABP理论学习之仓储"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html">ABP理论学习之仓储</a></h1><hr>
<h2 id="本篇目录-11"><a href="#本篇目录-11" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#IRepository">IRepository接口</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#query">查询</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#insert">插入</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#update">更新</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#delete">删除</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#others">其他</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#async">关于异步方法</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#repository">仓储实现</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#mdbcon">管理数据库连接</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#repositoryLife">仓储的生命周期</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#repositoryBestDo">仓储最佳实践</a></strong></li>
</ul>
<blockquote>
<h4 id="Martin-Fowler对仓储的定义"><a href="#Martin-Fowler对仓储的定义" class="headerlink" title="Martin Fowler对仓储的定义"></a>Martin Fowler对仓储的定义</h4><p>位于领域层和数据映射层之间，使用类似集合的接口来访问领域对象。</p>
</blockquote>
<p>在实践中，仓储是执行领域对象（实体和值对象）的数据库操作。一般地，一个分离的仓储用于一个实体（或者聚合根）。</p>
<h3 id="IRepository接口"><a href="#IRepository接口" class="headerlink" title="IRepository接口###"></a>IRepository接口###</h3><p>在ABP中，一个仓储类应该实现一个<strong>IRepository</strong>接口。为每一个仓储定义一个接口是一个好的做法。</p>
<p>一个Person实体的仓储定义如下：</p>
<pre class=" language-C#"><code class="language-C#">public interface IPersonRepository : IRepository<Person>
{
}
</code></pre>
<p>IPersonRepository扩展了<strong>IRepository</strong>，它用于定义拥有主键类型为int32的实体。如果你的实体不是int，那么可以扩展**IRepository&lt;TEntity,TPrimaryKey&gt;**接口，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public interface IPersonRepository : IRepository<Person, long>
{
}
</code></pre>
<p>IRepository为仓储类定义了最通用的方法，如select，insert，update和delete方法（CRUD操作）。大多数情况下，这些方法对于简单的实体是足够了。如果这些方法对于一个实体来说已经足够了，那么就没有必要为这个实体创建仓储接口和仓储类了。看下面。</p>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>IRepository定义了通用的方法，从数据库中检索实体。</p>
<h5 id="获得单个实体"><a href="#获得单个实体" class="headerlink" title="获得单个实体"></a>获得单个实体</h5><pre class=" language-C#"><code class="language-C#">TEntity Get(TPrimaryKey id);
Task<TEntity> GetAsync(TPrimaryKey id);
TEntity Single(Expression<Func<TEntity, bool>> predicate);
Task<TEntity> SingleAsync(Expression<Func<TEntity, bool>> predicate);
TEntity FirstOrDefault(TPrimaryKey id);
Task<TEntity> FirstOrDefaultAsync(TPrimaryKey id);
TEntity FirstOrDefault(Expression<Func<TEntity, bool>> predicate);
Task<TEntity> FirstOrDefaultAsync(Expression<Func<TEntity, bool>> predicate);
TEntity Load(TPrimaryKey id);
</code></pre>
<p><strong>Get</strong>方法用于获得一个给定主键（Id）的实体。如果在数据库中没有找到这个实体，就会抛出异常。<strong>Single</strong>方法和Get类似，但是它的参数是一个表达式而不是一个Id。因此，你可以使用Lambda表达式获得一个实体。样例用法：</p>
<pre class=" language-C#"><code class="language-C#">var person = _personRepository.Get(42);
var person = _personRepository.Single(p => p.Name == "Halil İbrahim Kalkan");
</code></pre>
<p>注意：如果根据给定的条件没有查找出实体或者查出不止一个实体，那么<strong>Single</strong>方法会抛出异常。</p>
<p><strong>FirstOrDefault</strong>是相似的，但是如果根据给的的Id或者表达式没有找到实体，那么就会返回<strong>null</strong>。如果对于给定的条件存在不止一个实体，那么会返回找到的第一个实体。</p>
<p><strong>Load</strong>方法不会从数据库中检索实体，但是会创建一个用于懒加载的代理对象。如果你只用了Id属性，那么Entity实际上并没有检索到。只有你访问实体的其他属性，才会从数据库中检索。考虑到性能因素，这个就可以替换Get方法。这在NHiberbate中也实现了。如果ORM提供者没有实现它，那么Load方法会和Get方法一样地工作。</p>
<p>一些方法有用于async编程模型的<strong>异步（async）</strong>版本。</p>
<p>获得实体的列表</p>
<pre class=" language-C#"><code class="language-C#">List<TEntity> GetAllList();
Task<List<TEntity>> GetAllListAsync();
List<TEntity> GetAllList(Expression<Func<TEntity, bool>> predicate);
Task<List<TEntity>> GetAllListAsync(Expression<Func<TEntity, bool>> predicate);
IQueryable<TEntity> GetAll();
</code></pre>
<p><strong>GetAllList</strong>从数据库中检索所有的实体。该方法的重载可以用于过滤实体。例子如下：</p>
<pre class=" language-C#"><code class="language-C#">var allPeople = _personRepository.GetAllList();
var somePeople = _personRepository.GetAllList(person => person.IsActive && person.Age > 42);
</code></pre>
<p><strong>GetAll</strong>返回的类型是IQueryable。因此，你可以在此方法之后添加Linq方法。例子如下：</p>
<pre class=" language-C#"><code class="language-C#">//Example 1
var query = from person in _personRepository.GetAll()
            where person.IsActive
            orderby person.Name
            select person;
var people = query.ToList();

//Example 2:
List<Person> personList2 = _personRepository.GetAll().Where(p => p.Name.Contains("H")).OrderBy(p => p.Name).Skip(40).Take(20).ToList();
</code></pre>
<p>有了GetAll方法，几乎所有的查询都可以使用Linq重写。甚至可以用在一个连接表达式中。</p>
<blockquote>
<h4 id="关于IQueryable"><a href="#关于IQueryable" class="headerlink" title="关于IQueryable"></a>关于IQueryable</h4><p>脱离了仓储方法调用GetAll()方法时，数据库连接必须要打开。这是因为IQueryable的延迟执行。直到调用ToList()方法或者在foreach循环中使用IQueryable(或者访问查询到的元素)时，才会执行数据库查询操作。因此，当调用ToList()方法时。数据库连接必须打开。这可以通过ABP中的<strong>UnitOfWork</strong>特性标记调用者方法来实现。注意：应用服务方法默认已经是UnitOfWork，因此，即使没有为应用服务层方法添加UnitOfWork特性，GetAll()方法也会正常工作。</p>
</blockquote>
<p>这些方法也存在用于异步编程模型的asyn版本。</p>
<h5 id="自定义返回值"><a href="#自定义返回值" class="headerlink" title="自定义返回值"></a>自定义返回值</h5><p>也存在提供了IQueryable的额外方法，在调用的方法中不需要使用UnitOfWork。</p>
<pre><code>T Query&lt;T&gt;(Func&lt;IQueryable&lt;TEntity&gt;, T&gt; queryMethod);
</code></pre>
<p>Query方法接受一个接收IQueryable的lambda(或方法)，并返回任何对象的类型。例子如下：</p>
<pre class=" language-C#"><code class="language-C#">var people = _personRepository.Query(q => q.Where(p => p.Name.Contains("H")).OrderBy(p => p.Name).ToList());
</code></pre>
<p>在该仓储方法中，因为执行了给定的lambda(或方法)，它是在数据库连接打开的时候执行的。你可以返回实体列表，单个实体，一个投影或者执行了该查询的其他东西。</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>IRepository接口定义了将一个实体插入数据库的简单方法：</p>
<pre class=" language-C#"><code class="language-C#">TEntity Insert(TEntity entity);
Task<TEntity> InsertAsync(TEntity entity);
TPrimaryKey InsertAndGetId(TEntity entity);
Task<TPrimaryKey> InsertAndGetIdAsync(TEntity entity);
TEntity InsertOrUpdate(TEntity entity);
Task<TEntity> InsertOrUpdateAsync(TEntity entity);
TPrimaryKey InsertOrUpdateAndGetId(TEntity entity);
Task<TPrimaryKey> InsertOrUpdateAndGetIdAsync(TEntity entity);
</code></pre>
<p><strong>Insert</strong>方法简化了将一个实体插入数据库，并将刚刚插入的实体返回。<strong>InsertAndGetId</strong>方法返回了新插入实体的Id。如果实体的Id是自动增长的并且需要最新插入实体的Id，那么该方法很有用。<strong>InsertOrUpdate</strong>方法通过检查Id的值插入或更新给定的实体。最后，当插入或者更新之后，<strong>InsertOrUpdateAndGetId</strong>返回该实体的值。</p>
<p>所有的方法都存在用于异步编程模型的async版本。</p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>IRepository定义了一个方法来更新数据库中已存在的实体。它可以获得要更新的实体并返回相同的实体对象。</p>
<pre class=" language-C#"><code class="language-C#">TEntity Update(TEntity entity);
Task<TEntity> UpdateAsync(TEntity entity);
</code></pre>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>IRepository定义了从数据库中删除一个已存在的实体的方法。</p>
<pre class=" language-C#"><code class="language-C#">void Delete(TEntity entity);
Task DeleteAsync(TEntity entity);
void Delete(TPrimaryKey id);
Task DeleteAsync(TPrimaryKey id);
void Delete(Expression<Func<TEntity, bool>> predicate);
Task DeleteAsync(Expression<Func<TEntity, bool>> predicate);
</code></pre>
<p>第一个方法接受一个已存在的实体，第二个方法接受一个要删除的实体的Id。</p>
<p>最后一个方法接受一个删除符合给定条件的所有实体的方法。注意，匹配给定谓词的所有实体都会从数据库中检索到然后被删除。因此，小心使用它，如果给定的条件存在太多的实体，那么可能会造成性能问题。</p>
<h4 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h4><p>IRepository也提供了获得表中实体数量的方法。</p>
<pre class=" language-C#"><code class="language-C#">int Count();
Task<int> CountAsync();
int Count(Expression<Func<TEntity, bool>> predicate);
Task<int> CountAsync(Expression<Func<TEntity, bool>> predicate);
long LongCount();
Task<long> LongCountAsync();
long LongCount(Expression<Func<TEntity, bool>> predicate);
Task<long> LongCountAsync(Expression<Func<TEntity, bool>> predicate);
</code></pre>
<h4 id="关于异步方法"><a href="#关于异步方法" class="headerlink" title="关于异步方法"></a>关于异步方法</h4><p>ABP支持异步编程模型（APM）。因此，仓储方法有异步版本。下面是一个使用了异步模型的应用服务方法样例：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService : AbpWpfDemoAppServiceBase, IPersonAppService
{
    private readonly IRepository<Person> _personRepository;

    public PersonAppService(IRepository<Person> personRepository)
    {
        _personRepository = personRepository;
    }

    public async Task<GetPeopleOutput> GetAllPeople()
    {
        var people = await _personRepository.GetAllListAsync();
            
        return new GetPeopleOutput
        {
            People = Mapper.Map<List<PersonDto>>(people)
        };
    }
}
</code></pre>
<p>GetAllPeople方法是异步的，并使用了具有await关键字的GetAllListAsync方法。</p>
<p>也许不是所有的ORM框架都支持Async，但是EntityFramework支持。如果不支持，异步仓储方法就会同步进行。比如，在EF中，InsertAsync和Insert是等效的，因为直到工作单元完成（Dbcontext.SaveChanges），EF才会将新的实体写入数据库。</p>
<h3 id="仓储实现"><a href="#仓储实现" class="headerlink" title="仓储实现###"></a>仓储实现###</h3><p>ABP的设计独立于一个特定的ORM(对象/关系映射)框架或者访问数据库的其他技术。通过实现仓储接口，可以使用任何框架。</p>
<p>ABP使用<strong>NHibernate</strong>和 <strong>EntityFramework</strong>实现了开箱即用的仓储。关于这两个ORM框架可以关注后面的文档。</p>
<p>当使用NHibernate或EntityFramework时，如果标准方法是足够使用的话，那么不必为实体类创建仓储了。你可以直接注入<strong>IRepository</strong>(或IRepository&lt;TEntity，TPrimaryKey&gt;)。下面是使用了一个仓储将一个实体插入数据库的应用服务例子：</p>
<pre class=" language-c#"><code class="language-c#">public class PersonAppService : IPersonAppService
{
    private readonly IRepository<Person> _personRepository;

    public PersonAppService(IRepository<Person> personRepository)
    {
        _personRepository = personRepository;
    }

    public void CreatePerson(CreatePersonInput input)
    {        
        person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };
        
        _personRepository.Insert(person);
    }
}
</code></pre>
<p>PersonAppService构造注入了<strong>IRepository</strong>，并使用了<strong>Insert</strong>方法。这样，当你需要为一个实体创建一个自定义仓储方法时，你才应该为该实体创建一个仓储类。</p>
<h3 id="管理数据库连接"><a href="#管理数据库连接" class="headerlink" title="管理数据库连接###"></a>管理数据库连接###</h3><p>在仓储方法中，数据库连接是没有打开的或是关闭的。ABP对于数据库连接的管理是自动处理的。</p>
<p>当将要进入一个仓储方法时，数据库连接会自动打开，并且<strong>事务</strong>自动开始。当仓储方法结束并返回的时候，ABP会自动完成：保存所有的更改，完成事务的提交和关闭数据库连接。如果仓储方法抛出任何类型的异常，那么事务会自动<strong>回滚</strong>并关闭数据库。这对于所有的实现了IRepository接口的类的公共方法都是成立的。</p>
<p>如果一个仓储方法调用了其他的仓储方法，那么它们会共享相同的连接和事务。进入仓储的第一个方法会管理数据库的连接。更多信息，请留意后面博客的工作单元。</p>
<p>一篇不错的数据库连接博客：**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/liuhaorain/archive/2012/02/19/2353110.html">细说数据库连接</a>**</p>
<h3 id="仓储的生命周期"><a href="#仓储的生命周期" class="headerlink" title="仓储的生命周期###"></a>仓储的生命周期###</h3><p>所有的仓储实例都是<strong>Transient</strong>(每次使用时都会实例化)的。ABP强烈推荐使用依赖注入技术。当一个仓储类需要注入时，依赖注入的容器会自动创建该类的新实例。</p>
<h3 id="仓储最佳实践"><a href="#仓储最佳实践" class="headerlink" title="仓储最佳实践###"></a>仓储最佳实践###</h3><ul>
<li>对于一个T类型的实体，使用IRepository仓储接口。除非真的需要，否则不要创建自定义的仓储。预定义的仓储方法对于很多情况足够用了。</li>
<li>如果你正在创建一个自定义的仓储（通过扩展IRepository）： 仓储类应该是无状态的。这意味着，你不应该定义仓储级别的状态对象，而且一个仓储方法调用不应该影响其他的调用。 自定义仓储方法不应该包含业务逻辑或者应用逻辑，而应该只执行数据相关的或者orm特定的任务。 当仓储使用依赖注入时，给其他服务定义更少的或者不要定义依赖。</li>
</ul>
<h1 id="ABP理论学习之领域服务"><a href="#ABP理论学习之领域服务" class="headerlink" title="ABP理论学习之领域服务"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html">ABP理论学习之领域服务</a></h1><hr>
<h2 id="本篇目录-12"><a href="#本篇目录-12" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#IDomain">IDomainService接口和DomainService类</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#sample">样例</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#create">创建一个接口</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#service">服务实现</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#call">调用应用服务</a></strong></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#discussion">一些讨论</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#whynot">何不只使用应用服务</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#forceUse">如何强制使用领域服务</a></strong></li>
</ul>
</li>
</ul>
<h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍###"></a>介绍###</h3><p>领域服务（或DDD中的服务）用于执行领域操作和业务规则。Eric Evans描述了一个好的服务应该具备下面三个特征：</p>
<ol>
<li>和领域概念相关的操作不是一个实体或者值对象的本质部分。</li>
<li>接口定义在领域模型其他元素的条款中。</li>
<li>操作是无状态的。</li>
</ol>
<p>跟获得或返回一个数据传输对象的应用服务方法（DTO）不同，领域服务获得或者返回一个<strong>领域对象</strong>（比如实体或值类型）。</p>
<p>一个领域服务可以用于应用服务，也可以用于其他的领域服务，但不能直接用于展现层，服务层才直接用于展现层。</p>
<h3 id="IDomainService接口和DomainService类"><a href="#IDomainService接口和DomainService类" class="headerlink" title="IDomainService接口和DomainService类###"></a>IDomainService接口和DomainService类###</h3><p>ABP定义了<strong>IDomainService</strong>接口，所有的领域服务都按照惯例实现了该接口。当实现时，领域服务会以<strong>transient自动注册</strong>到依赖注入系统。</p>
<p>此外，领域服务（可选地）可以从<strong>DomainService类</strong>继承。因此，它可以使用一些继承的属性，比如logging，本地化等等。当然，如果没有继承，如果需要的话也可以注入这些属性。</p>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例###"></a>样例###</h3><p>假设我们有一个任务管理系统并且有将一个任务派给一个人的业务规则。</p>
<h4 id="创建一个接口"><a href="#创建一个接口" class="headerlink" title="创建一个接口"></a>创建一个接口</h4><p>首先我们为该服务定义一个接口（不是必须的，但是这样是一个好的实践）：</p>
<pre class=" language-C#"><code class="language-C#">public interface ITaskManager : IDomainService
{
    void AssignTaskToPerson(Task task, Person person);
}
</code></pre>
<p>可以看到，<strong>TaskManager</strong>服务使用领域对象工作：一个<strong>Task</strong> 和一个<strong>Person</strong>。命名领域服务时存在一些惯例。它可以是TaskManager，TaskService或者TaskDomainService…</p>
<h4 id="服务实现"><a href="#服务实现" class="headerlink" title="服务实现"></a>服务实现</h4><p>先来看看下面这个实现：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskManager : DomainService, ITaskManager
{
    public const int MaxActiveTaskCountForAPerson = 3;

    private readonly ITaskRepository _taskRepository;

    public TaskManager(ITaskRepository taskRepository)
    {
        _taskRepository = taskRepository;
    }

    public void AssignTaskToPerson(Task task, Person person)
    {
        if (task.AssignedPersonId == person.Id)
        {
            return;
        }

        if (task.State != TaskState.Active)
        {
            throw new ApplicationException("Can not assign a task to a person when task is not active!");
        }

        if (HasPersonMaximumAssignedTask(person))
        {
            throw new UserFriendlyException(L("MaxPersonTaskLimitMessage", person.Name));
        }

        task.AssignedPersonId = person.Id;
    }

    private bool HasPersonMaximumAssignedTask(Person person)
    {
        var assignedTaskCount = _taskRepository.Count(t => t.State == TaskState.Active && t.AssignedPersonId == person.Id);
        return assignedTaskCount >= MaxActiveTaskCountForAPerson;
    }
}
</code></pre>
<p>上面的代码定义了两个业务规则：</p>
<ul>
<li>一个任务为了能够派给一个新人，它应该是<strong>Active（激活）的状态</strong></li>
<li>一个人可以<strong>最多可以有3个</strong>激活的任务。</li>
</ul>
<p>你可能想知道为啥第一次检测时抛出了一个<strong>ApplicationException</strong>，而第二次检查时抛出了<strong>UserFriendlyException</strong>，请关注后面博客的异常处理。这根领域服务根本无关。这里这样处理的想法是这样的，UI必须先要检查一个任务的状态，否则不应该允许我们将它派给一个人。这是一个应用程序的错误，并且我们可以向用户隐藏这个错误。对于第二个友好的异常信息，UI检查更加困难，而且我们可以向用户显示一个可读的错误信息。这只是一个例子而已。</p>
<h4 id="调用应用服务"><a href="#调用应用服务" class="headerlink" title="调用应用服务"></a>调用应用服务</h4><p>现在，来看看如何在一个应用服务中使用TaskManager:</p>
<pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService, ITaskAppService
{
    private readonly IRepository<Task, long> _taskRepository;
    private readonly IRepository<Person> _personRepository;
    private readonly ITaskManager _taskManager;

    public TaskAppService(IRepository<Task, long> taskRepository, IRepository<Person> personRepository , ITaskManager taskManager)
    {
        _taskRepository = taskRepository;
        _personRepository = personRepository;
        _taskManager = taskManager;
    }

    public void AssignTaskToPerson(AssignTaskToPersonInput input)
    {
        var task = _taskRepository.Get(input.TaskId);
        var person = _personRepository.Get(input.PersonId);

        _taskManager.AssignTaskToPerson(task, person);
    }
}
</code></pre>
<p>Task<strong>应用服务</strong>使用给定的<strong>DTO</strong>(输入)和<strong>仓储</strong>来检索相关的<strong>task</strong>和 <strong>person</strong>，并将它们传给 <strong>TaskManager</strong>(领域服务)。</p>
<h3 id="一些讨论"><a href="#一些讨论" class="headerlink" title="一些讨论###"></a>一些讨论###</h3><p>基于上面的例子，你可能会存在下面的疑问。</p>
<h4 id="何不只使用应用服务"><a href="#何不只使用应用服务" class="headerlink" title="何不只使用应用服务"></a>何不只使用应用服务</h4><p>你可能会问，为什么不使用应用服务实现领域服务中的逻辑呢？</p>
<p>我们可以简单地说，它不是应用服务要干的活。因为领域逻辑不是一个<strong>用例（use-case）</strong>，而是一个 <strong>业务操作</strong>。我们可以在不同的用例中使用相同的“将一个任务派给一个人”的逻辑。比如说我们以后会更新这个任务，并且将这个任务派给其他人。因此，我们可以使用相同的领域逻辑，这个逻辑就是“将一个任务派给一个人”，我们不用考虑这个具体的人和具体的任务。此外，我们可能有两个不同的UI（一个移动端应用和一个web应用）来共享相同的领域。</p>
<p>下面根据个人的理解来画个图：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151222234720249-1003510440.png" alt="img"></p>
<p>如上图，应用服务层中有一个应用服务方法，但却使用到了领域层的三个业务逻辑，因为在领域层中，获取单个task和person都各自为一个业务逻辑，将一个任务派给一个人又是一个业务逻辑。在应用服务层，我们只需要获得一个人和一个任务就行，然后将该任务派给这个人，根本不需要考虑这个人和这个任务的获取细节，也不用考虑任务派发的细节，因为这完全不是应用层考虑的事儿。</p>
<p>如果你的领域很简单，只有一个UI并且将一个任务派发给一个人在单点处就可以完成，那么你可以跳过领域服务，然后在应用服务层实现该逻辑。虽然这不是DDD的最佳实践，但是ABP不会强制你这么设计。</p>
<h4 id="如何强制使用领域服务"><a href="#如何强制使用领域服务" class="headerlink" title="如何强制使用领域服务"></a>如何强制使用领域服务</h4><p>你可以看到，应用服务只能做下面的事情：</p>
<pre class=" language-C#"><code class="language-C#">public void AssignTaskToPerson(AssignTaskToPersonInput input)
{
    var task = _taskRepository.Get(input.TaskId);

    task.AssignedPersonId = input.PersonId;
}
</code></pre>
<p>开发这个应用服务的开发者可能不知道存在一个<strong>TaskManager</strong>，而且可以直接将给定的 <strong>PersonId</strong>设置给任务的 <strong>AssignedPersonId</strong>。那么，如何阻止他这样做呢？基于这些，在DDD领域中存在很多讨论和使用到的模式。我们不会涉及得很深，但是可以提供<br> 一种简单的方式。</p>
<p>我们可以将<strong>Task</strong>改成下面这样：</p>
<pre class=" language-C#"><code class="language-C#">public class Task : Entity<long>
{
    public virtual int? AssignedPersonId { get; protected set; }

    //...其他成员

    public void AssignToPerson(Person person, ITaskPolicy taskPolicy)
    {
        taskPolicy.CheckIfCanAssignTaskToPerson(this, person);

        AssignedPersonId = person.Id;
    }
}
</code></pre>
<p>可以将<strong>AssignedPersonId</strong>的setter改成protected。这样，它就不能在Task实体类之外改变了。添加一个需要一个Person和ITaskPolicy的参数。<strong>CheckIfCanAssignTaskToPerson</strong>方法检查这是否是一个有效的派发，如果无效就抛出一个适当的异常。最后，应用服务方法应该是这个样子的：</p>
<pre class=" language-C#"><code class="language-C#">public void AssignTaskToPerson(AssignTaskToPersonInput input)
{
    var task = _taskRepository.Get(input.TaskId);
    var person = _personRepository.Get(input.PersonId);

    task.AssignToPerson(person, _taskPolicy);
}
</code></pre>
<p>现在，不存在将一个任务派给一个人的第二种方法了。我们应该总是要使用AssignToPerson方法，而且不能跳过业务规则了。</p>
<h1 id="ABP理论学习之工作单元-Unit-of-Work"><a href="#ABP理论学习之工作单元-Unit-of-Work" class="headerlink" title="ABP理论学习之工作单元(Unit of Work)"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html">ABP理论学习之工作单元(Unit of Work)</a></h1><hr>
<h2 id="本篇目录-13"><a href="#本篇目录-13" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#ways">公共连接和事务管理方法</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#abpConn">ABP中的连接和事务管理</a></strong><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#repo">仓储类</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#appService">应用服务</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#uow">工作单元</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#uowDetail">工作单元详解</a></strong><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#disable">关闭工作单元</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#nonTrans">非事务的工作单元</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#callAnother">工作单元方法调用其它</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#scope">工作单元作用域</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#autoSaving">自动保存</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#getAll">IRepository.GetAll()方法</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#restrictions">UnitOfWork特性的限制</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#options">选项</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#methods">方法</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#events">事件</a></strong></li>
</ul>
<h3 id="公共连接和事务管理方法"><a href="#公共连接和事务管理方法" class="headerlink" title="公共连接和事务管理方法"></a>公共连接和事务管理方法</h3><p>在使用了数据库的应用中，连接和事务管理是最重要的概念之一。何时打开一个连接,何时开始一个事务，如何释放连接等等。</p>
<p>你可能已经知道，Net使用了连接池。因此，创建一个连接实际上是从连接池中获取一个连接，因为因为创建一个连接是有消耗的。如果在连接池中没有可用的连接，那么会创建一个新的连接，并将该连接加入连接池。当你释放连接时，实际上是将该连接发送回给连接池，并没有完全释放。这种机制是.Net提供的立即可用的功能。因此，在我们使用完一个连接后应该立即释放，在需要的时候才创建一个新的连接。总之，最佳实践记住这八个字足矣：<strong>尽晚打开，尽早释放</strong>。</p>
<p>这里我推荐一篇关于数据库连接的文章，写得很浅显易懂：**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/liuhaorain/archive/2012/02/19/2353110.html">《细说数据库连接》</a>**</p>
<p>在一个应用中创建或者释放一个数据库连接，通常有2种方法。</p>
<p><strong>第一种方法</strong>：当Web请求开始（在Global.asax的Application_BeginRequest事件中）的时候创建一个连接，在所有的数据库操作时使用相同的连接，并且在请求结束（Application_EndRequest）时关闭或者释放该连接。这种方法很简单但是不够高效。为啥呢？</p>
<ul>
<li>在一个请求中也许没有数据库操作，但是连接已经打开了。这造成了连接池的无效使用。</li>
<li>在一次请求中，可能请求需要消耗很长的时间而数据库操作只花费很短的时间，这也会造成连接池的无效使用。</li>
<li>这只在Web应用中是可行的。如果应用是一个Windows服务，那么可能不会实现。</li>
</ul>
<p>以<strong>事务</strong>的方式执行数据库操作已被认为是一种最佳实践。如果一个操作失败了，那么所有的操作都会回滚。因为一个事务可以锁定数据库中的一些行（甚至表），所以它必须是短暂存活的。</p>
<p><strong>第二种方法</strong>：当需要时（仅在使用前）创建一个连接，使用后立即关闭。这是最有效的，但是到处创建或者释放连接是一项重复乏味的工作。</p>
<h3 id="ABP中的连接和事务管理"><a href="#ABP中的连接和事务管理" class="headerlink" title="ABP中的连接和事务管理"></a>ABP中的连接和事务管理</h3><p>ABP兼备了这两种方法并且提供了一个简单而又有效的模型。</p>
<h4 id="仓储类"><a href="#仓储类" class="headerlink" title="仓储类"></a>仓储类</h4><p>仓储式执行数据库操作主要的类。当进入一个仓储方法时，ABP会打开一个数据库连接（可能不是立即打开，但是在第一次使用数据库时肯定是打开的，取决于ORM提供者的实现）并开始一个事务。因此，在一个仓储方法中可以安全地使用连接。在方法的结束，事务被提交并且连接被释放。如果仓储方法抛出任何异常，那么事务都会<strong>回滚</strong>且连接被释放。这样一来，仓储方法就是<strong>原子的（一个工作单元）</strong>。ABP对于这些会自动处理。这里是一个简单的仓储：</p>
<pre class=" language-C#"><code class="language-C#">public class ContentRepository : NhRepositoryBase<Content>, IContentRepository
{
    public List<Content> GetActiveContents(string searchCondition)
    {
        var query = from content in Session.Query<Content>()
                    where content.IsActive && !content.IsDeleted
                    select content;

        if (!string.IsNullOrEmpty(searchCondition))
        {
            query = query.Where(content => content.Text.Contains(searchCondition));
        }

        return query.ToList();
    }
}
</code></pre>
<p>这个例子使用了NHibernate作为ORM。正如上面演示的，没有编写数据库连接（在NHibernate中是Session）打开或者关闭的代码。</p>
<p>如果一个仓储方法调用了其他的仓储方法（一般而言，如果一个工作单元调用了其他的工作单元方法），那么它们共享相同的连接和事务。第一个进入的方法管理连接和事务，其他方法使用相同的连接和事务。</p>
<h4 id="应用服务"><a href="#应用服务" class="headerlink" title="应用服务"></a>应用服务</h4><p>一个应用服务也被认为是一个工作单元。假设我们有一个像下面的应用服务：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService : IPersonAppService
{
    private readonly IPersonRepository _personRepository;
    private readonly IStatisticsRepository _statisticsRepository;

    public PersonAppService(IPersonRepository personRepository, IStatisticsRepository statisticsRepository)
    {
        _personRepository = personRepository;
        _statisticsRepository = statisticsRepository;
    }

    public void CreatePerson(CreatePersonInput input)
    {
        var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };
        _personRepository.Insert(person);
        _statisticsRepository.IncrementPeopleCount();
    }
}
</code></pre>
<p>在CreatePerson方法中，我们使用了person仓储插入了一个person，而且使用statistics仓储增加总人数。在这里例子中，这两个仓储共享相同的连接和事务，因为它们在一个应用服务方法中。ABP在进入CreatePerson方法时打开一个数据库连接并开始一个事务，如果没有抛出异常事务会在方法结尾时提交，如果有任何异常发生，将会回滚。这样一来，在CreatePerson方法中的所有数据库操作都成了<strong>原子的（工作单元）</strong>。</p>
<h4 id="工作单元"><a href="#工作单元" class="headerlink" title="工作单元"></a>工作单元</h4><p>工作单元对于仓储和应用服务方法<strong>隐式</strong>有效。如果你想在其他地方控制数据库连接和事务，那么可以<strong>显式</strong>使用它。</p>
<h5 id="UnitOfWork特性"><a href="#UnitOfWork特性" class="headerlink" title="UnitOfWork特性"></a>UnitOfWork特性</h5><p>最受人欢迎的方法是使用<strong>UnitOfWorkAttribute</strong>。例如：</p>
<pre class=" language-C#"><code class="language-C#">[UnitOfWork]
public void CreatePerson(CreatePersonInput input)
{
    var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };
    _personRepository.Insert(person);
    _statisticsRepository.IncrementPeopleCount();
}
</code></pre>
<p>这样，CreatePerson方法变成了工作单元并且管理数据库连接和事务，两个仓储使用相同的工作单元，注意的是，如果这是一个应用服务方法，就不需要UnitOfWork特性。</p>
<h5 id="IUnitOfWorkManager"><a href="#IUnitOfWorkManager" class="headerlink" title="IUnitOfWorkManager"></a>IUnitOfWorkManager</h5><p>第二种方法是使用**IUnitOfWorkManager.Begin()**方法，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class MyService
{
    private readonly IUnitOfWorkManager _unitOfWorkManager;
    private readonly IPersonRepository _personRepository;
    private readonly IStatisticsRepository _statisticsRepository;

    public MyService(IUnitOfWorkManager unitOfWorkManager, IPersonRepository personRepository, IStatisticsRepository statisticsRepository)
    {
        _unitOfWorkManager = unitOfWorkManager;
        _personRepository = personRepository;
        _statisticsRepository = statisticsRepository;
    }

    public void CreatePerson(CreatePersonInput input)
    {
        var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };

        using (var unitOfWork = _unitOfWorkManager.Begin())
        {
            _personRepository.Insert(person);
            _statisticsRepository.IncrementPeopleCount();

            unitOfWork.Complete();
        }
    }
}
</code></pre>
<p>你可以注入然后使用IUnitOfWork，正如这里演示的这样（如果你的应用继承自ApplicationService类，那么你可以直接使用<strong>CurrentUnitOfWork</strong>属性。如果没有，你要先注入IUnitOfWorkManager）。这样，你就可以创建更多的<strong>限制作用域</strong>的工作单元。用这种方法，你应该手动调用<strong>Complete</strong>方法。如果没有调用，事务就会回滚，改变就不会保存。</p>
<p>Begin方法有很多重载来设置<strong>工作单元选项</strong>。</p>
<p>如果找不到一个很好的理由，建议还是使用<strong>UnitOfWork特性</strong>，因为代码越短越好。</p>
<h3 id="工作单元详解"><a href="#工作单元详解" class="headerlink" title="工作单元详解"></a>工作单元详解</h3><h4 id="关闭工作单元"><a href="#关闭工作单元" class="headerlink" title="关闭工作单元"></a>关闭工作单元</h4><p>有时候你可能想关闭应用服务方法的工作单元（因为默认是开启的），此时，可以使用UnitOfWorkAttribute的IsDisabled属性。用法如下：</p>
<pre class=" language-C#"><code class="language-C#">[UnitOfWork(IsDisabled = true)]
public virtual void RemoveFriendship(RemoveFriendshipInput input)
{
    _friendshipRepository.Delete(input.Id);
}
</code></pre>
<p>正常情况下，不需要关闭数据单元，因为应用服务方法应该是原子的且一般都会使用数据库。但也有些例外情况让你想要关闭应用服务方法的工作单元：</p>
<ul>
<li>方法不执行任何数据库操作而且你也不想打开一个没有必要的数据库连接。</li>
<li>如上面描述的，你想要在一个UnitOfWorkScope类的有限作用域内使用工作单元。</li>
</ul>
<p><strong>注意：</strong>如果一个工作单元方法调用了这个<em>RemoveFriendship</em>方法，那么后者的关闭工作单元的功能将会失效，并且也会使用和调用者方法相同的工作单元。因此，要小心使用工作单元的关闭功能。</p>
<h4 id="非事务的工作单元"><a href="#非事务的工作单元" class="headerlink" title="非事务的工作单元"></a>非事务的工作单元</h4><p>工作单元默认是事务的（本质如此）。因此，ABP会开始-&gt;提交-&gt;回滚一个显式的数据库级别的事务。在一些特殊场合，事务可能会造成问题，因为它可能会锁住数据库中的一些行或者表。在这种情况下，你可能想关闭数据库级别的事务。UnitOfWork特性可以在构造函数中获得一个布尔值，从而以非事务形式工作。用法如下：</p>
<pre class=" language-C#"><code class="language-C#">[UnitOfWork(isTransactional: false)]
public GetTasksOutput GetTasks(GetTasksInput input)
{
    var tasks = _taskRepository.GetAllWithPeople(input.AssignedPersonId, input.State);
    return new GetTasksOutput
            {
                Tasks = Mapper.Map<List<TaskDto>>(tasks)
            };
}
</code></pre>
<p>建议使用**[UnitOfWork(isTransactional: false)]**，因为它是更具可读性的，但你也可以使用[UnitOfWork(false)]。</p>
<p>注意ORM框架（如EF和NH）内部使用了一条单一命令来保存更改。假设你以非事务的UOW（工作单元）更新了一些实体的情景，甚至在这种情况下所有的更新都是在工作单元结束时以一个单一的数据库命令执行的。但是如果你直接执行一个SQL查询，它会立即执行。</p>
<p>非事务的UOW有一个限制。如果你已经处于一个事务的工作单元的作用域内，那么将isTransactional设置为false将会被忽略。</p>
<p>使用非事务的工作单元要小心，因为大多数时候对于数据的集成是事务的。如果你的方法只是读数据，不需要改变数据，当然该方法是可以为非事务的了。</p>
<h4 id="工作单元方法调用其它"><a href="#工作单元方法调用其它" class="headerlink" title="工作单元方法调用其它"></a>工作单元方法调用其它</h4><p>如果一个工作单元的方法（使用了UnitOfWork特性声明的方法）调用另一个工作单元的方法，那么它们共享相同的连接和事务。第一个方法管理连接，其他方法使用连接。这个对于运行在相同<strong>线程</strong>的方法是成立的（对于web应用则是相同的请求）。实际上，当一个工作单元作用域开始时，在同一线程执行的所有代码都共享同一个连接和事务，直到工作单元作用域结束。这对于UnitOfWork特性和UnitOfWorkScope类都是成立的。</p>
<h4 id="工作单元作用域"><a href="#工作单元作用域" class="headerlink" title="工作单元作用域"></a>工作单元作用域</h4><p>在其他事务中可以创建一个不同而又隔离的事务，或者可以在一个事务中创建一个非事务的作用域。.Net中定义了**<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/system.transactions.transactionscopeoption(v=vs.110).aspx">TransactionScopeOption</a>**，你可以为工作单元设置作用域选项。</p>
<h4 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h4><p>当我们为一个方法使用了工作单元时，ABP会在该方法结束时自动保存所有的更改。假设我们有一个更新person的name的方法：</p>
<pre class=" language-C#"><code class="language-C#">[UnitOfWork]
public void UpdateName(UpdateNameInput input)
{
    var person = _personRepository.Get(input.PersonId);
    person.Name = input.NewName;
}
</code></pre>
<p>你要做的就这么多，person的name就改变了。我们甚至不用调用<strong>_personRepository.Update</strong>方法。ORM框架会跟踪工作单元中实体的所有改变，并将改变反应给数据库。</p>
<p>注意没有必要为应用服务方法声明<strong>UnitOfWork</strong>特性，因为它们默认已经是工作单元了。</p>
<h4 id="IRepository-GetAll-方法"><a href="#IRepository-GetAll-方法" class="headerlink" title="IRepository.GetAll()方法"></a>IRepository.GetAll()方法</h4><p>当在一个仓储方法之外调用GetAll()时，必须存在一个打开的数据库连接，因为GetAll返回了<strong>IQueryable</strong>，而且IQueryable会延迟执行。直到调用ToList()方法或者在foreach循环中使用IQueryable,才会真正执行数据库查询。因此，调用ToList()方法时，数据库连接必须是活着的（alive）。</p>
<p>考虑一下下面的例子：</p>
<pre class=" language-C#"><code class="language-C#">[UnitOfWork]
public SearchPeopleOutput SearchPeople(SearchPeopleInput input)
{
    //返回IQueryable<Person>
    var query = _personRepository.GetAll();

    //添加一些过滤
    if (!string.IsNullOrEmpty(input.SearchedName))
    {
        query = query.Where(person => person.Name.StartsWith(input.SearchedName));
    }

    if (input.IsActive.HasValue)
    {
        query = query.Where(person => person.IsActive == input.IsActive.Value);
    }

    //获得分页结果列表
    var people = query.Skip(input.SkipCount).Take(input.MaxResultCount).ToList();

    return new SearchPeopleOutput { People = Mapper.Map<List<PersonDto>>(people) };
}
</code></pre>
<p>这里，SearchPeople方法必须是工作单元，因为IQueryable的ToList()在方法体内调用了，当执行IQueryable.ToList()执行时，数据库连接必须是打开的状态。</p>
<p>就像GetAll()方法一样，如果在仓储之外需要数据库连接，那么必须使用工作单元。注意，应用服务方法默认是工作单元。</p>
<h4 id="UnitOfWork特性的限制"><a href="#UnitOfWork特性的限制" class="headerlink" title="UnitOfWork特性的限制"></a>UnitOfWork特性的限制</h4><p>UnitOfWork可以用于以下几个条件：</p>
<ul>
<li>所有用于接口的类的<strong>public或public virtual</strong>方法（如用于用于服务接口的应用服务类的方法）。</li>
<li>自注入类的所有<strong>public virtual</strong>（如MVC 控制器和Web Api控制器）。</li>
<li>所有的<strong>protected virtual</strong>方法。</li>
</ul>
<p>建议总是将方法声明为<strong>virtual</strong>，但是<strong>不能用于private方法</strong>。因为ABP为virtual方法私有了动态代理，private方法不能被派生的类访问到。如果你没有使用依赖注入且实例化类，那么UnitOfWork特性（和任何代理）就不能工作。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>有很多可以用于改变工作单元行为的选项。</p>
<p>首先，我们可以在启动配置中更改所有工作单元的默认值。这通常是在模块的PreInitialize方法中处理的。</p>
<pre class=" language-C#"><code class="language-C#">public class SimpleTaskSystemCoreModule : AbpModule
{
    public override void PreInitialize()
    {
        Configuration.UnitOfWork.IsolationLevel = IsolationLevel.ReadCommitted;
        Configuration.UnitOfWork.Timeout = TimeSpan.FromMinutes(30);
    }

    //...其他模块方法
}
</code></pre>
<p>其次，我们可以为一个特定的工作单元重写默认值。比如，<strong>UnitOfWork</strong>特性的构造函数和IUnitOfWorkManager的<strong>Begin</strong>方法都有获得选项的重载。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>UnitOfWork系统无缝而不可见地工作。但是在某些场合，你需要调用它的方法。</p>
<h4 id="SaveChanges"><a href="#SaveChanges" class="headerlink" title="SaveChanges"></a>SaveChanges</h4><p>ABP会在工作单元结束时保存所有更改，我们根本不用做任何事情。但是有时候你可能想在工作单元操作的中间将更改保存到数据库中。在这种情况下，你可以注入IUnitOfWorkManager，然后调用IUnitOfWorkManager.Current.**SaveChanges()**方法。注意：如果当前的工作单元是事务的，那么如果有异常发生了，事务中的所有改变都会回滚，即使是已保存的改变。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>工作单元有<strong>Completed,Failed和Disposed</strong>事件。你可以注册这些事件，然后执行需要的操作。通过注入IUnitOfWorkManager然后使用IUnitOfWorkManager.Current属性来获得激活的工作单元，然后注册到它的事件。</p>
<p>在当前的工作单元成功完成时，你可能想运行一些代码，下面是一个例子：</p>
<pre class=" language-C#"><code class="language-C#">public void CreateTask(CreateTaskInput input)
{
    var task = new Task { Description = input.Description };

    if (input.AssignedPersonId.HasValue)
    {
        task.AssignedPersonId = input.AssignedPersonId.Value;

        _unitOfWorkManager.Current.Completed += (sender, args) => { /* TODO: 给派发的人发送邮件*/ };
    }

    _taskRepository.Insert(task);
}
</code></pre>
<h1 id="ABP理论学习之事件总线和领域事件"><a href="#ABP理论学习之事件总线和领域事件" class="headerlink" title="ABP理论学习之事件总线和领域事件"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEventBus.html">ABP理论学习之事件总线和领域事件</a></h1><hr>
<h2 id="本篇目录-14"><a href="#本篇目录-14" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEventBus.html#eventBus">事件总线</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEventBus.html#define">定义事件</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEventBus.html#trigger">触发事件</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEventBus.html#handle">处理事件</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEventBus.html#handler">句柄注册</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEventBus.html#unregister">取消注册</a></strong></li>
</ul>
<p>在C#中，我们可以在一个类中定义自己的事件，而其他的类可以注册该事件，当某些事情发生时，可以通知到该类。这对于桌面应用或者独立的windows服务来说是非常有用的。但对于一个web应用来说是有点问题的，因为对象都是在web请求中创建的，而且这些对象生命周期都很短，因而注册某些类的事件是很困难的。此外，注册其他类的事件会使得类紧耦合。</p>
<p>领域事件用于解耦并重复利用应用中的逻辑。</p>
<h3 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线###"></a>事件总线###</h3><p>事件总线是被所有触发并处理事件的其他类共享的单例对象。要使用事件总线，首先应该获得它的一个引用。下面有两种方法来处理：</p>
<h4 id="创建默认实例"><a href="#创建默认实例" class="headerlink" title="创建默认实例"></a>创建默认实例</h4><p>你可以直接使用 <strong>EventBus.Default</strong>。这是全局的事件总线，用法如下所示：</p>
<pre><code>EventBus.Default.Trigger(...); //触发一个事件
</code></pre>
<h4 id="注入IEventBus"><a href="#注入IEventBus" class="headerlink" title="注入IEventBus"></a>注入IEventBus</h4><p>不直接使用EventBus.Default，你也可以使用依赖注入来获得<strong>IEventBus</strong>的引用。这有利于单元测试。这里我们使用属性注入模式：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService
{
    public IEventBus EventBus { get; set; }
        
    public TaskAppService()
    {
        EventBus = NullEventBus.Instance;
    }
}
</code></pre>
<p>对于注入事件总线这件事，属性注入比构造函数注入更合适。这样，你的类离开事件总线还能工作。NullEventBus实现了**<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Null_Object_pattern">null对象模式</a>**。当你调用上面的构造函数时，实际上啥都没做。</p>
<h3 id="定义事件"><a href="#定义事件" class="headerlink" title="定义事件###"></a>定义事件###</h3><p>触发事件之前，应该先要定义该事件。事件是使用派生自<strong>EventData</strong>的类来表示的。假设我们想当一个任务task完成时触发一个事件：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskCompletedEventData : EventData
{
    public int TaskId { get; set; }
}
</code></pre>
<p>该类包含了类处理事件需要的属性。<strong>EventData</strong>类定义了 <strong>EventSource</strong>（事件源）和 <strong>EventTime</strong>(事件触发时间)属性。</p>
<h4 id="预定义事件"><a href="#预定义事件" class="headerlink" title="预定义事件"></a>预定义事件</h4><p>ABP定义了<strong>AbpHandleExceptionData</strong>，当自动处理任何异常时都会触发这个事件。如果你想要获得更多的关于异常的信息（甚至ABP会自动记录所有的异常），那么这是特别有用的。注册这个事件之后，异常发生时就会通知你。</p>
<p>对于实体的更改也有泛型的事件数据类：<strong>EntityCreatedEventData，EntityUpdateEventData</strong>和 <strong>EntityDeletedEventData</strong>。它们都定义在 <strong>Abp.Event.Bus.Entities</strong>命名空间中。当一个实体插入，更新或者删除时，ABP会自动地触发这些事件。比如，如果你有一个Person实体，将它注册到EntityCreatedEventData，那么当创建的新的Person实体对象插入数据库时，会收到通知。这些事件也支持继承。如果Student类派生自Person类，而且你将它注册到EntityCreatedEventData，那么当一个Person或者Student插入时，你会收到通知。</p>
<h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件###"></a>触发事件###</h3><p>触发一个事件很简单，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService
{
    public IEventBus EventBus { get; set; }
        
    public TaskAppService()
    {
        EventBus = NullEventBus.Instance;
    }

    public void CompleteTask(CompleteTaskInput input)
    {
        //TODO: 完成task的数据库操作...
        EventBus.Trigger(new TaskCompletedEventData {TaskId = 42});
    }
}
</code></pre>
<p>下面是Trigger方法的一些重载：</p>
<pre class=" language-C#"><code class="language-C#">EventBus.Trigger<TaskCompletedEventData>(new TaskCompletedEventData { TaskId = 42 }); //显示声明为泛型参数
EventBus.Trigger(this, new TaskCompletedEventData { TaskId = 42 }); //将 '事件源'设置为'this'
EventBus.Trigger(typeof(TaskCompletedEventData), this, new TaskCompletedEventData { TaskId = 42 });//调用非泛型版本（第一个参数是事件类的类型）
</code></pre>
<h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件###"></a>处理事件###</h3><p>要处理一个事件，应该要实现<strong>IEventHandler</strong>接口，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class ActivityWriter : IEventHandler<TaskCompletedEventData>, ITransientDependency
{
    public void HandleEvent(TaskCompletedEventData eventData)
    {
        WriteActivity("A task is completed by id = " + eventData.TaskId);
    }
}
</code></pre>
<p>事件总线（EventBus）已经集成到ABP的依赖注入系统中。正如上面实现ITransientDependency一样，当TaskCompleted事件发生时，它会创建ActivityWriter类的一个新实例，然后调用HandleEvent方法，最后释放它。更多知识请查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPDependencyInjection.html">依赖注入</a>**。</p>
<h4 id="处理基事件"><a href="#处理基事件" class="headerlink" title="处理基事件"></a>处理基事件</h4><p>事件总线支持事件的<strong>继承</strong>。比如，你创建了一个<strong>TaskEventData</strong>和它的两个子类： <strong>TaskCompletedEventData</strong>和 <strong>TaskCreatedEventData</strong>:</p>
<pre class=" language-C#"><code class="language-C#">public class TaskEventData : EventData
{
    public Task Task { get; set; }
}

public class TaskCreatedEventData : TaskEventData
{
    public User CreatorUser { get; set; }
}

public class TaskCompletedEventData : TaskEventData
{
    public User CompletorUser { get; set; }
}
</code></pre>
<p>然后你可以实现<strong>IEventHandler</strong>来处理这两个事件：</p>
<pre class=" language-C#"><code class="language-C#">public class ActivityWriter : IEventHandler<TaskEventData>, ITransientDependency
{
    public void HandleEvent(TaskEventData eventData)
    {
        if (eventData is TaskCreatedEventData)
        {
            //...
        }
        else if (eventData is TaskCompletedEventData)
        {
            //...
        }
    }
}
</code></pre>
<p>当然了，你可以实现IEventHandler来处理所有你想要处理的事件。</p>
<h4 id="处理多事件"><a href="#处理多事件" class="headerlink" title="处理多事件"></a>处理多事件</h4><p>在一个单一的处理句柄中，可以处理多个事件。这时，你应该为每个事件实现IEventHandler。比如：</p>
<pre class=" language-C#"><code class="language-C#">public class ActivityWriter : 
    IEventHandler<TaskCompletedEventData>, 
    IEventHandler<TaskCreatedEventData>, 
    ITransientDependency
{
    public void HandleEvent(TaskCompletedEventData eventData)
    {
        //TODO: 处理事件...
    }

    public void HandleEvent(TaskCreatedEventData eventData)
    {
        //TODO: 处理事件...
    }
}
</code></pre>
<h3 id="句柄注册"><a href="#句柄注册" class="headerlink" title="句柄注册###"></a>句柄注册###</h3><p>为了处理事件，我们必须将事件句柄注册给事件总线。</p>
<h4 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h4><p>ABP会自动扫描所有的实现了IEventHandler的类，并<strong>自动</strong>将它们注册到事件总线上。当一个事件发生时，它会使用依赖注入获得该句柄的一个引用，而且在处理该事件之后就会释放该句柄。建议这样使用ABP中的事件总线。</p>
<h4 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h4><p>也可能会手动注册到事件，但是要小心使用。在一个web应用中，事件注册应该在应用启动时完成。在web请求时注册到一个事件不是一个好的方法，因为请求完成之后注册的类仍旧是注册的，而且对于每个请求继续再次注册。这可能会对你的应用造成问题，因为注册的类可能被调用多次。而且要记住手动注册不会使用依赖注入系统。</p>
<p>这里有一些事件总线的方法的重载。最简单的一个等待了一个委托（或者一个lambda）：</p>
<pre class=" language-C#"><code class="language-C#">EventBus.Register<TaskCompletedEventData>(eventData =>
    {
        WriteActivity("A task is completed by id = " + eventData.TaskId);
    });
</code></pre>
<p>这样，当“一个task完成”事件发生时，这个lambda方法就会调用。第二个等待一个实现了IEventHandler的对象：</p>
<pre class=" language-C#"><code class="language-C#">EventBus.Register<TaskCompletedEventData>(new ActivityWriter());
</code></pre>
<p>事件会调用ActivityWriter的相同实例。该方法也有一个非泛型的重载。另一个重载接受两个泛型的参数：</p>
<pre class=" language-C#"><code class="language-C#">EventBus.Register<TaskCompletedEventData, ActivityWriter>();
</code></pre>
<p>此时，事件总线会为每个事件创建一个新的ActivityWriter。如果它是可释放的，那么会调用ActivityWriter.Dispose方法。</p>
<p>最后，为了处理句柄的创建，你可以注册一个<strong>事件句柄工厂</strong>。句柄工厂有两个方法：<strong>GetHandler和ReleaseHandler</strong>。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class ActivityWriterFactory : IEventHandlerFactory
{
    public IEventHandler GetHandler()
    {
        return new ActivityWriter();
    }

    public void ReleaseHandler(IEventHandler handler)
    {
        //TODO:释放ActivityWriter实例 (handler)
    }
}
</code></pre>
<p>还有一个特殊的工厂类<strong>IocHandlerFactory</strong>，它可以使用依赖注入系统创建或者释放句柄。ABP在自动注册模式中使用了这个类。因此，如果你想使用依赖注入系统，直接使用自动注册。</p>
<h3 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册###"></a>取消注册###</h3><p>手动注册到事件总线时，你可能会在以后想要取消注册该事件。取消注册一个事件的最简单方法是释放该<strong>注册</strong>方法的返回值。如下所示：</p>
<pre class=" language-C#"><code class="language-C#">//注册到一个事件...
var registration = EventBus.Register<TaskCompletedEventData>(eventData => WriteActivity("A task is completed by id = " + eventData.TaskId) );

//取消注册事件
registration.Dispose();
</code></pre>
<p>当然了，注销注册会在某个地方和某个时间。保留注册对象并在想要取消注册时释放它。所有注册方法的重载都会返回一个可释放的对象以取消注册该事件。</p>
<p>事件总线也提供了<strong>Unregister</strong>方法。样例用法：</p>
<pre class=" language-C#"><code class="language-C#">//创建一个句柄
var handler = new ActivityWriter();
            
//注册到事件
EventBus.Register<TaskCompletedEventData>(handler);

//从事件取消注册
EventBus.Unregister<TaskCompletedEventData>(handler);
</code></pre>
<p>它也提供了重载来注销委托和工厂，注销句柄对象必须是之前注册的相同对象。</p>
<p>最后，事件总线提供了<strong>UnregisterAll</strong>方法来注销一个事件的所有句柄，**RegisterAll()**方法会注销所有事件的所有句柄</p>
<h1 id="ABP理论学习之数据过滤器"><a href="#ABP理论学习之数据过滤器" class="headerlink" title="ABP理论学习之数据过滤器"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html">ABP理论学习之数据过滤器</a></h1><hr>
<h2 id="本篇目录-15"><a href="#本篇目录-15" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#predefined">预定义过滤器</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#disable">关闭过滤器</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#enable">开启过滤器</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#set">设置过滤器参数</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#custom">定义自定义过滤器</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#other">其他ORM</a></strong></li>
</ul>
<h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍###"></a>介绍###</h3><p><strong>软删除</strong>模式通常用于不会真正从数据库删除一个实体而是仅仅将它标记为”已删除的”。这样，如果一个实体是软删除的，那么它不应该在应用中检索到。为了实现这个目的，我们应该在每一个select实体查询操作中添加一个SQL <strong>where</strong>条件，如“IsDeleted=false”。这是乏味但是很重要的一项容易忘记的任务。因此，这项工作应该自动完成。</p>
<p>ABP提供了<strong>数据过滤器</strong>，它们可以基于某些规则自动过滤查询。有很多预定义的过滤器，但你也可以创建自己的过滤器。</p>
<h3 id="预定义过滤器"><a href="#预定义过滤器" class="headerlink" title="预定义过滤器###"></a>预定义过滤器###</h3><h4 id="ISoftDelete"><a href="#ISoftDelete" class="headerlink" title="ISoftDelete"></a>ISoftDelete</h4><p>软删除过滤器用于当查询数据库时自动过滤（从结果中提取）已经删除的实体。如果实体应该是软删除的，那么它必须实现只定义了<strong>IsDelete</strong>属性的 <strong>ISoftDelete</strong>接口，例如：</p>
<pre class=" language-C#"><code class="language-C#">public class Person : Entity, ISoftDelete
{
    public virtual string Name { get; set; }

    public virtual bool IsDeleted { get; set; }
}
</code></pre>
<p>实际上，<strong>Person</strong>实体并没有从数据库中删除，只是当要删除它时将它的 <strong>IsDelete</strong>属性设置成了true。当使用 <strong>IRepository.Delete</strong>方法时，ABP会自动处理（你可以手动设置IsDelete为true，但是Delete方法更自然且更受人欢迎）。</p>
<p>实现了ISoftDelete之后，当从数据库获取Person的列表时，已经软删除的person是不会检索到的。这里有一个使用了person仓储获得所有person的例子：</p>
<pre class=" language-C#"><code class="language-C#">public class MyService
{
    private readonly IRepository<Person> _personRepository;

    public MyService(IRepository<Person> personRepository)
    {
        _personRepository = personRepository;
    }

    public List<Person> GetPeople()
    {
        return _personRepository.GetAllList();
    }
}
</code></pre>
<p>GetPeople方法只会获得IsDeleted=false（没有删除）的Person实体。所有的仓储方法和导航属性都会正确工作。我们也可以添加一些其他的Where条件，连接等等。它会自动将IsDeleted=false添加到生成的Sql查询中。</p>
<blockquote>
<h4 id="何时开启ISoftDelete呢？"><a href="#何时开启ISoftDelete呢？" class="headerlink" title="何时开启ISoftDelete呢？"></a>何时开启ISoftDelete呢？</h4><p>ISoftDelete过滤器始终是开启的，除非你显式关闭了它。</p>
</blockquote>
<p>额外注意：如果实现了<strong>IDeletionAudited</strong>(它继承了ISoftDelete)，那么ABP会自动设置删除时间和删除者的id。</p>
<h4 id="IMustHaveTenant"><a href="#IMustHaveTenant" class="headerlink" title="IMustHaveTenant"></a>IMustHaveTenant</h4><p>如果你生成的是多租户应用（在一个数据库中存储所有租户的数据），那么你肯定不想一个租户意外地看到了其他租户的数据。这种情况你可以实现<strong>IMustHaveTenant</strong>。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class Product : Entity, IMustHaveTenant
{
    public int TenantId { get; set; }
        
    public string Name { get; set; }
}
</code></pre>
<p><strong>IMustHaveTenant</strong>定义了 <strong>TenantId</strong>来区分不同的租户实体。ABP使用了 <strong>IAbpSession</strong>来获得当前的TenantId，而且自动过滤当前租户的查询。</p>
<blockquote>
<h4 id="何时开启IMustHaveTenant呢？"><a href="#何时开启IMustHaveTenant呢？" class="headerlink" title="何时开启IMustHaveTenant呢？"></a>何时开启IMustHaveTenant呢？</h4><p>IMustHaveTenant默认是开启的。<br> 如果当前的用户没有登录到系统或者当前的用户是一个租主用户（租主用户是可以管理租户和租户数据的更高级用户），ABP会自动关闭IMustHaveTenant过滤器。因此，所有租户的所有数据都可以被检索到。注意这是没有涉及到安全的情况，你应该总是要对敏感的数据进行授权。</p>
</blockquote>
<h4 id="IMayHaveTenant"><a href="#IMayHaveTenant" class="headerlink" title="IMayHaveTenant"></a>IMayHaveTenant</h4><p>如果一个实体类是租户和租主共享的（这意味着一个实体对象可能被一个租户或者租主拥有），那么你可以使用IMayHaveTenant过滤器。<strong>IMayHaveTenant</strong>接口定义了<strong>ITenantId</strong>但是它是 <strong>nullable</strong>。</p>
<pre class=" language-C#"><code class="language-C#">public class Role : Entity, IMayHaveTenant
{
    public int? TenantId { get; set; }
        
    public string RoleName { get; set; }
}
</code></pre>
<p>如果TenantId的值是<strong>null</strong>，就意味着这是一个 <strong>租主</strong>实体；如果值不为null，就意味着该实体被一个 <strong>租户</strong>拥有，该租户的Id就是该TenantId。ABP使用了IAbpSession来获得当前的TenantId。IMayHaveTenant过滤器不像IMustHaveTenant过滤器那样常用，但是，对于租户和租户公用的结构，你可能需要它。</p>
<blockquote>
<h4 id="何时开启IMayHaveTenant呢？"><a href="#何时开启IMayHaveTenant呢？" class="headerlink" title="何时开启IMayHaveTenant呢？"></a>何时开启IMayHaveTenant呢？</h4><p>IMayHaveTenant总是开启的，除非你显式关闭了它。</p>
</blockquote>
<h3 id="关闭过滤器"><a href="#关闭过滤器" class="headerlink" title="关闭过滤器###"></a>关闭过滤器###</h3><p>你可以通过调用<strong>DisableFilter</strong>方法来为每个工作单元关闭过滤器，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">var people1 = _personRepository.GetAllList();

using (_unitOfWorkManager.Current.DisableFilter(AbpDataFilters.SoftDelete))
{
    var people2 = _personRepository.GetAllList();                
}

var people3 = _personRepository.GetAllList();
</code></pre>
<p>DisableFilter方法以字符串获得一个或更多的过滤器。AbpDataFilters.SoftDelete包含了ABP标准软删除过滤器的名称的常量字符串。</p>
<p><strong>people2</strong>可以获得已经删除的person实体，然而people1和people3只会获得没有删除的实体。使用 <strong>using</strong>语句，你可以在一个 <strong>作用域（scope）</strong>中关闭过滤器。如果你没有使用using语句，那么过滤器在当前工作单元结束前都是关闭的，除非你显式再次开启它。</p>
<p>你可以像上面的例子那样注入<strong>IUnitOfWorkManager</strong>使用。此外，你也可以在应用服务（它派生自ApplicationService类）中使用<strong>CurrentUnitOfWork</strong>属性作为快捷方式。</p>
<blockquote>
<h4 id="关于using语句"><a href="#关于using语句" class="headerlink" title="关于using语句"></a>关于using语句</h4><p>如果过滤器是开启的，当你在using语句中调用DisableFilter方法时，那么过滤器会关闭，然后，当using语句结束时，它会自动再次开启。但是如果在使用using语句之前过滤器已经关闭了，那么DisableFilter实际上什么都不会做，而且在using语句结束后仍然是关闭的。</p>
</blockquote>
<h3 id="开启过滤器"><a href="#开启过滤器" class="headerlink" title="开启过滤器###"></a>开启过滤器###</h3><p>你可以在工作单元中使用<strong>EnableFilter</strong>方法来开启一个过滤器，和DisableFilter很相似。EnableFilter也返回disable来自动再次关闭该过滤器。</p>
<h3 id="设置过滤器参数"><a href="#设置过滤器参数" class="headerlink" title="设置过滤器参数###"></a>设置过滤器参数###</h3><p>过滤器是可以带参数的。IMustHaveTenant过滤器就是这些过滤器类型的一个例子，因为当前的租户Id要在运行时确定。对于这些过滤器，如果需要的话，我们可以改变过滤器的值。例如：</p>
<pre class=" language-C#"><code class="language-C#">CurrentUnitOfWork.SetFilterParameter("PersonFilter", "personId", 42);
</code></pre>
<p>另一个例子：为IMayHaveTenant过滤器设置tenantId值：</p>
<pre><code>CurrentUnitOfWork.SetFilterParameter(AbpDataFilters.MayHaveTenant, AbpDataFilters.Parameters.TenantId, 42);
</code></pre>
<p>SetFilterParameter方法也返回一个IDisposable。因此，我们可以在一个using语句中使用它，在using语句结束时自动<strong>还原旧值</strong>。</p>
<h3 id="定义自定义过滤器"><a href="#定义自定义过滤器" class="headerlink" title="定义自定义过滤器###"></a>定义自定义过滤器###</h3><p>要创建一个自定义过滤器并集成到ABP中，我们首先应该定义一个接口，该接口会被使用这个过滤器的实体实现。假设我们想要通过PersonId自动过滤实体。例如：</p>
<pre class=" language-C#"><code class="language-C#">public interface IHasPerson
{
    int PersonId { get; set; }
}
</code></pre>
<p>然后，为需要的实体实现该接口。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class Phone : Entity, IHasPerson
{
    [ForeignKey("PersonId")]
    public virtual Person Person { get; set; }
    public virtual int PersonId { get; set; }

    public virtual string Number { get; set; }
}
</code></pre>
<p>因为ABP使用了**<a href="https://github.com/jcachat/EntityFramework.DynamicFilters">EntityFramework.DynamicFilters</a><strong>，因此我们可以使用它的规则来定义该过滤器。在我们的 **DbContext</strong>类中，我们重写了 <strong>OnModelCreating</strong>，而且定义过滤器如下所示：</p>
<pre class=" language-C#"><code class="language-C#">protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);

    modelBuilder.Filter("PersonFilter", (IHasPerson entity, int personId) => entity.PersonId == personId, 0);
}
</code></pre>
<p>这里，“PersonFilter”是过滤器唯一的名字。第二个参数定义了过滤器接口和personId过滤器参数（如果过滤器没有参数那么就不需要了）。最后一个参数是personId的默认值。</p>
<p>最后一件事，我们应该在模块的PreInitialize方法中将该过滤器注册到ABP的工作单元系统中。</p>
<pre class=" language-c#"><code class="language-c#">Configuration.UnitOfWork.RegisterFilter("PersonFilter", false);
</code></pre>
<p>第一个参数是我们上面定义的过滤器的唯一的名字。第二个参数表明默认是开启的还是关闭的。声明这么一个参数化的过滤器之后，我们可以通过在运行时给它提供值来使用了。</p>
<pre class=" language-C#"><code class="language-C#">using (CurrentUnitOfWork.EnableFilter("PersonFilter"))
{
    CurrentUnitOfWork.SetFilterParameter("PersonFilter", "personId", 42);
    var phones = _phoneRepository.GetAllList();
    //...
}
</code></pre>
<p>我们可以从一些源中获得personId而不是静态代码中。上面的例子是对于参数化的过滤器来说的。过滤器可以有零个或更多的参数。如果它没有参数，就不需要设置过滤器的值了。此外，如果它默认是开启的，它就不需要手动开启了（当然，我们还可以关闭它）。</p>
<blockquote>
<h4 id="EntityFramework-DynamicFilters文档"><a href="#EntityFramework-DynamicFilters文档" class="headerlink" title="EntityFramework.DynamicFilters文档"></a>EntityFramework.DynamicFilters文档</h4><p>关于动态数据过滤器的更多信息，请看**<a href="https://github.com/jcachat/EntityFramework.DynamicFilters">github上的文档</a>**。</p>
</blockquote>
<p>我们也可以为安全，激活/未激活的实体等创建自定义的过滤器。</p>
<h3 id="其他ORM"><a href="#其他ORM" class="headerlink" title="其他ORM###"></a>其他ORM###</h3><p>ABP已经实现了EF和NH的数据过滤。对于其他的ORM还不可用。但是实际上，只要你使用<strong>仓储</strong>获得数据，你就可以为绝大多数情况模拟数据过滤。对于这种情况，如果需要的话，你可以创建自定义的仓储，然后重写   <strong>GetAll</strong>和其他的数据检索方法。</p>
<h1 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h1><h1 id="ABP理论学习之应用服务"><a href="#ABP理论学习之应用服务" class="headerlink" title="ABP理论学习之应用服务"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html">ABP理论学习之应用服务</a></h1><hr>
<h2 id="本篇目录-16"><a href="#本篇目录-16" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#IApplicationService">IApplicationService接口</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#ApplicationService">ApplicationService类</a></strong></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#Uow">工作单元</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#sbConn">数据库连接和事务管理</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#saving">自动保存更改</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#more">更多</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#lifecycle">应用服务的生命周期</a></strong></li>
</ul>
<p>应用服务用于将领域逻辑暴露给展现层。展现层调用具有DTO参数的应用服务，使用领域对象来执行一些特定的业务逻辑并返回给展现层一个DTO。这样，展现层就完全独立于领域层了。在一个理想的分层应用中，展现层永远不直接和领域对象打交道。</p>
<h3 id="IApplicationService接口"><a href="#IApplicationService接口" class="headerlink" title="IApplicationService接口###"></a>IApplicationService接口###</h3><p>在ABP中，应用服务<strong>应该</strong>实现 <strong>IApplicationService</strong>接口。建议为每个应用服务创建一个接口。这样一来，我们先要为一个应用定义一个接口，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public interface IPersonAppService : IApplicationService
{
    void CreatePerson(CreatePersonInput input);
}
</code></pre>
<p><strong>IPersonAppService</strong>只有一个方法。展现层用它来创建一个新的person。<strong>CreatePersonInput</strong>是如下所示的一个DTO对象：</p>
<pre class=" language-C#"><code class="language-C#">public class CreatePersonInput : IInputDto
{
    [Required]
    public string Name { get; set; }

    public string EmailAddress { get; set; }
}
</code></pre>
<p>然后我可以实现IPersonAppService:</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService : IPersonAppService
{
    private readonly IRepository<Person> _personRepository;

    public PersonAppService(IRepository<Person> personRepository)
    {
        _personRepository = personRepository;
    }

    public void CreatePerson(CreatePersonInput input)
    {
        var person = _personRepository.FirstOrDefault(p => p.EmailAddress == input.EmailAddress);
        if (person != null)
        {
            throw new UserFriendlyException("There is already a person with given email address");
        }

        person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };
        _personRepository.Insert(person);
    }
}
</code></pre>
<p>这里是一些重点：</p>
<ul>
<li>PersonAppService使用<strong>IRepository</strong>执行数据库操作。这里使用了依赖注入，而且使用了 <strong>构造函数注入</strong>的模式。</li>
<li>PersonAppService实现了<strong>IApplicationService</strong>，它是通过ABP自动注册到依赖注入系统的，然后被其他的类注入并使用。</li>
<li><strong>CreatePerson</strong>方法以 <strong>CreatePersonInput</strong>作为参数。它是一个输入DTO，会被ABP自动验证。</li>
</ul>
<h4 id="ApplicationService类"><a href="#ApplicationService类" class="headerlink" title="ApplicationService类"></a>ApplicationService类</h4><p>应用服务类应该实现应用服务接口（IApplicationService）。此外，还可以选择从<strong>ApplicationService</strong>基类派生。这样，IApplicationService也被继承实现了。而且，ApplicationService有一些基本功能，使得<strong>logging</strong>和 <strong>本土化</strong>更加简单。建议为你的继承了ApplicationService的应用服务创建一个特殊的基类。这样，你就可以为所有的应用服务添加一些通用功能。一个应用服务类的例子如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService, ITaskAppService
{
    public TaskAppService()
    {
        LocalizationSourceName = "SimpleTaskSystem";
    }

    public void CreateTask(CreateTaskInput input)
    {
        //记录日志 (Logger 定义在 ApplicationService 类中)
        Logger.Info("Creating a new task with description: " + input.Description);

        //获取本地化文本 (L 是LocalizationHelper.GetString(...)的简写, 定义在 ApplicationService类中)
        var text = L("SampleLocalizableTextKey");

        //TODO: Add new task to database...
    }
}
</code></pre>
<p>你可以定义一个基类，在该基类中的构造函数中定义LocalizationSourceName。这样，就不用为所有的服务类重复定义了。</p>
<h3 id="工作单元-1"><a href="#工作单元-1" class="headerlink" title="工作单元###"></a>工作单元###</h3><p>在ABP中，应用服务方法默认是一个工作单元。</p>
<h4 id="数据库连接和事务管理"><a href="#数据库连接和事务管理" class="headerlink" title="数据库连接和事务管理"></a>数据库连接和事务管理</h4><p>假如说我们想要在一个必须是事务的应用服务方法中调用两个仓储方法。例如：</p>
<pre class=" language-C#"><code class="language-C#">public void CreatePerson(CreatePersonInput input)
{
    var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };    
    _personRepository.Insert(person);
    _statisticsRepository.IncrementPeopleCount();
}
</code></pre>
<p>我们将一个person实体插入到People表中，然后总人数自增，并保存到另一个表的字段中。这个方法都是用不同的仓储实现的，但是共享了相同的连接和事务。</p>
<p>在CreatePerson方法开始时，ABP会自动打开数据库连接并开始事务。在方法结束时，如果没有异常发生，会自动提交事务并关闭数据库连接。这样，在CreatePerson方法中的所有数据库操作都是<strong>事务的（原子的）</strong>，如果有任何异常抛出，操作就会回滚。因此，在这个方法中的两个仓储共享相同的连接和事务。</p>
<p>当调用仓储的**GetAll()**方法时，会返回一个IQueryable。数据库连接应该在调用该方法后打开。这是因为IQueryable和Linq会延迟执行。数据库真正查询是在调用 **ToList()**方法时发生的。看下面的例子：</p>
<pre class=" language-C#"><code class="language-C#">public SearchPeopleOutput SearchPeople(SearchPeopleInput input)
{
    //获得 IQueryable<Person>
    var query = _personRepository.GetAll();

    //添加过滤
    if (!string.IsNullOrEmpty(input.SearchedName))
    {
        query = query.Where(person => person.Name.StartsWith(input.SearchedName));
    }

    if (input.IsActive.HasValue)
    {
        query = query.Where(person => person.IsActive == input.IsActive.Value);
    }

    //获取分页结果list
    var people = query.Skip(input.SkipCount).Take(input.MaxResultCount).ToList();

    return new SearchPeopleOutput {People = Mapper.Map<List<PersonDto>>(people)};
}
</code></pre>
<p>因为一个应用服务方法是一个工作单元，所以在执行这个方法期间数据库连接是打开的。如果在一个不是应用服务的类中调用了GetAll()方法，那么应该显式使用<strong>工作单元</strong>。</p>
<p>注意这里使用了AutoMapper类库将 List转成List。更多细节请看下一篇DTO博客。</p>
<h4 id="自动保存更改"><a href="#自动保存更改" class="headerlink" title="自动保存更改"></a>自动保存更改</h4><p>对于工作单元方法，ABP会在方法结束时自动保存所有的更改。假设我们有一个更新一个人的名字的应用服务方法：</p>
<pre class=" language-C#"><code class="language-C#">public void UpdateName(UpdateNameInput input)
{
    var person = _personRepository.Get(input.PersonId);
    person.Name = input.NewName;
}
</code></pre>
<p>只需要这样，name字段就改变了。我们甚至都不要调用_personRepository.Update方法。ORM框架会跟踪工作单元内的实体的所有更改，并将更改反映给数据库。</p>
<h1 id="ABP理论学习之数据传输对象-DTO"><a href="#ABP理论学习之数据传输对象-DTO" class="headerlink" title="ABP理论学习之数据传输对象(DTO)"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html">ABP理论学习之数据传输对象(DTO)</a></h1><hr>
<h2 id="本篇目录-17"><a href="#本篇目录-17" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#whyDTO">为何需要DTO</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#abstraction">领域层抽象</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#dataHide">数据隐藏</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#lazyLoading">序列化和懒加载问题</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#validation">DTO惯例和验证</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#autoMapping">DTO和实体的自动映射</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#attribute">使用特性和扩展方法进行映射</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#helper">帮助接口</a></strong></li>
</ul>
<p>DTO用于<strong>应用层</strong>和 <strong>展现层</strong>间的数据传输。</p>
<p>展现层调用具有DTO参数的**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPApplicationService.html">应用服务</a>**方法，然后应用服务使用领域对象来执行一些特定的业务逻辑，最后返回给展现层一个DTO。因此，展现层完全独立于领域层。在一个理想的分层应用中，展现层不直接和领域对象打交道（仓储，实体…）。</p>
<h3 id="为何需要DTO"><a href="#为何需要DTO" class="headerlink" title="为何需要DTO###"></a>为何需要DTO###</h3><p>为每个应用服务方法创建一个DTO起初可能被看作是一项乏味而又耗时的事情。但如果正确地使用它，那么DTOs可能会拯救你应用。为啥呢？</p>
<h4 id="领域层抽象"><a href="#领域层抽象" class="headerlink" title="领域层抽象"></a>领域层抽象</h4><p>DTO为展现层抽象领域对象提供了一种有效方式。这样，层与层之间就正确分离了。即使你想完全分离展现层，仍然可以使用已存在的应用层和领域层。相反，只要领域服务的契约（方法签名和DTOs）保持不变，即使重写领域层，完全改变数据库模式，实体和ORM框架，也不需要在展现层做任何改变。</p>
<h4 id="数据隐藏"><a href="#数据隐藏" class="headerlink" title="数据隐藏"></a>数据隐藏</h4><p>试想你有一个User实体，包含Id，Name，EmailAddress和Password字段。如果UserAppService的GetAllUsers()方法返回一个List，即使你没有在屏幕上显示它，那么任何人也都能看到所有user的密码。它不是涉及安全的，而是与数据隐藏相关的。应用服务都应该返回给展现层需要的，不要更多，也不很少，要的是恰到好处。</p>
<h4 id="序列化和懒加载问题"><a href="#序列化和懒加载问题" class="headerlink" title="序列化和懒加载问题"></a>序列化和懒加载问题</h4><p>当返回给展现层一个对象时，它很可能在某个地方序列化。比如，一个MVC方法返回JSON，一个对象会被序列化成JSON，然后发送到客户端。在那种情况，将一个实体返回到展现层是有问题的。这是怎么回事呢？</p>
<p>在一个真实应用中，实体之间是相互引用的。User实体可能有一个Role的引用。因此，如果你想序列化User，那么Role也会序列化。而且，如果Role有一个List且Permission类有一个PermissionGroup类的引用等等。你能想象所有的对象都会被序列化的那种场景吗？你可能会意外地序列化整个数据库。那么解决方案是什么呢？把属性标记为NonSerilized吗?不，你可能不知道它何时应该序列化，何时不应该。它可能在一个应用方法中需要，可能在另一个就不需要了。因此，在这种情景中，设计一个可安全序列化的，特别设计的DTOs是一种好的选择。</p>
<p>几乎所有的ORM框架都支持懒加载。它的特征是当需要时才从数据库中加载实体。假如说User类有一个Role类的引用。当从数据库中获得一个User时，此时Role属性还没有填充，当第一次读该Role属性时，它才从数据库中加载。因此，不要将这样的一个实体直接返回给展现层，它可能会轻易造成从数据库检索额外的实体。如果序列化工具读到了该实体，它会递归地读取所有属性，最终整个数据库可能会被检索（如果实体间有合适的关系）。</p>
<p>在展现层使用实体还会有更多的问题。最好压根不要在将包含领域（业务）层的程序集引用到展现层上。</p>
<h3 id="DTO惯例和验证"><a href="#DTO惯例和验证" class="headerlink" title="DTO惯例和验证###"></a>DTO惯例和验证###</h3><p>ABP高度支持DTOs，它提供了一些符合惯例的类和接口，并且对于DTO的命名和用法提出了一些建议。当按照下面描述的那样编写代码时，ABP会轻易地自动处理一些事情。</p>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>让我们看一个完整的例子。假如我们想要开发一个应用服务方法，作用是使用一个名字来搜索人，并返回一个人的集合。这种情况下，我们可能会有一个如下的Person实体：</p>
<pre class=" language-C#"><code class="language-C#">public class Person : Entity
{
    public virtual string Name { get; set; }
    public virtual string EmailAddress { get; set; }
    public virtual string Password { get; set; }
}
</code></pre>
<p>首先，我们定义一个应用服务的接口：</p>
<pre class=" language-C#"><code class="language-C#">public interface IPersonAppService : IApplicationService
{
    SearchPeopleOutput SearchPeople(SearchPeopleInput input);
}
</code></pre>
<p>ABP建议将input/output参数命名为MethodName<strong>Input</strong>和   MethodName<strong>Output</strong>，并为每个应用服务方法定义一个单独的input和output DTO。即使你的方法只需要或返回一个参数，最好也创建一个DTO类。这样，你的代码回更具有扩展性。以后你可以添加更多的属性而不用改变方法的签名，而且也不用使已存在的客户端应用发生重大变化。</p>
<p>当然，如果你的方法没有返回值，那么方法可以返回<strong>void</strong>。如果以后添加了一个返回值，也不会打破已存在的应用。如果你的方法不需要任何参数，那么你也不必定义一个输入DTO。但是如果未来很可能添加参数，那么也许最好还是编写一个输入DTO。这取决于你。</p>
<p>让我们看一下为这个例子定义的输入和输出的DTO：</p>
<pre class=" language-C#"><code class="language-C#">public class SearchPeopleInput : IInputDto
{
    [StringLength(40, MinimumLength = 1)]
    public string SearchedName { get; set; }
}

public class SearchPeopleOutput : IOutputDto
{
    public List<PersonDto> People { get; set; }
}

public class PersonDto : EntityDto
{
    public string Name { get; set; }
    public string EmailAddress { get; set; }
}
</code></pre>
<p><strong>验证：</strong>按照惯例，输入DTO实现了 <strong>IInputDto</strong>接口，输出DTO实现了 <strong>IOutputDto</strong>接口。当实现了IInputDto时，ABP会在方法执行前自动验证输入。这和ASP.NET MVC的验证很相似，但是注意应用服务不是控制器，它是纯粹的C#类。ABP使用拦截来自动检查输入。关于更多的验证，请看下篇DTO验证。</p>
<p><strong>EntityDto</strong>是一个声明了Id属性的简单类。因为这对于所有的实体都是公用的。如果你的实体的主键不是int的，那么还有一个泛型版本。PersonDto不包含Password属性，因为表现层不需要。甚至将所有人的密码都发送到展现层可能是很危险的。想象一下，如果Javascript客户端发送请求，任何人就会轻易地抓取到所有的密码。</p>
<p>接下来进一步实现之前的<strong>IPersonAppService</strong>。</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService : IPersonAppService
{
    private readonly IPersonRepository _personRepository;

    public PersonAppService(IPersonRepository personRepository)
    {
        _personRepository = personRepository;
    }

    public SearchPeopleOutput SearchPeople(SearchPeopleInput input)
    {
        //Get entities
        var peopleEntityList = _personRepository.GetAllList(person => person.Name.Contains(input.SearchedName));

        //Convert to DTOs
        var peopleDtoList = peopleEntityList
            .Select(person => new PersonDto
                                {
                                    Id = person.Id,
                                    Name = person.Name,
                                    EmailAddress = person.EmailAddress
                                }).ToList();

        return new SearchPeopleOutput { People = peopleDtoList };
    }
}
</code></pre>
<p>我们从数据库中获得实体，再将它们转成DTOs，然后返回到输出。注意我们没有验证输入，因为ABP会自动验证。ABP甚至会检查输入参数是否为null，如果为null，就会抛出异常。</p>
<p>但是很可能你不喜欢从一个Person实体到一个PersonDto对象的转换代码。这是相当无聊的事情，而且，Person实体可能会有更多的属性。</p>
<h3 id="DTO和实体的自动映射"><a href="#DTO和实体的自动映射" class="headerlink" title="DTO和实体的自动映射###"></a>DTO和实体的自动映射###</h3><p>幸好，我们有工具可以让这个变得很简单。<strong>AutoMapper</strong>就是之一（要学习AutoMapper，请看我的**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/AutoMapperContent.html">AutoMapper系列教程</a>**。它已经发布到Nuget上了，你可以轻松地将它添加到项目中。让我们再次写一下SearchPeople方法，但是这次是用AutoMapper：</p>
<pre class=" language-C#"><code class="language-C#">public SearchPeopleOutput SearchPeople(SearchPeopleInput input)
{
    var peopleEntityList = _personRepository.GetAllList(person => person.Name.Contains(input.SearchedName));
    return new SearchPeopleOutput { People = Mapper.Map<List<PersonDto>>(peopleEntityList) };
}
</code></pre>
<p>这样就ok了。你可以给实体和DTO添加更多的属性而不需要转换代码做任何改变。唯一要做的事情就是在使用前定义一个映射：</p>
<pre class=" language-C#"><code class="language-C#">Mapper.CreateMap<Person, PersonDto>();
</code></pre>
<p>AutoMapper创建了映射代码。这样，动态映射就不会成为性能问题了。它既快速又容易。AutoMapper为Person实体创建了PersonDto，并使用命名规范赋予DTO属性。命名规范可能是复杂的且可配置的。此外，你还可以定义自定义映射以及更多。</p>
<h4 id="使用特性和扩展方法进行映射"><a href="#使用特性和扩展方法进行映射" class="headerlink" title="使用特性和扩展方法进行映射"></a>使用特性和扩展方法进行映射</h4><p>ABP提供了若干特性和扩展方法来定义映射。首先，要将Abp.AutoMapper nuget包添加到项目中。然后，<strong>AutoMap</strong>特性是双向映射方式， <strong>AutoMapFrom</strong>和 <strong>AutoMapTo</strong>是单向映射方式。最后，使用<strong>MapTo</strong>扩展方法将一个对象映射到另一个对象。映射定义的例子如下：</p>
<pre class=" language-C#"><code class="language-C#">[AutoMap(typeof(MyClass2))] //定义双向映射
public class MyClass1
{
    public string TestProp { get; set; }
}

public class MyClass2
{
    public string TestProp { get; set; }
}
</code></pre>
<p>定义了上面的代码之后，就可以使用MapTo扩展方法映射它们了：</p>
<pre class=" language-C#"><code class="language-C#">var obj1 = new MyClass1 { TestProp = "Test value" };
var obj2 = obj1.MapTo<MyClass2>(); //从obj1的副本创建一个新的MyClass2对象
</code></pre>
<p>上面的代码从MyClass1的对象创建了MyClass2一个新的对象。此外，你可以像下面那样，映射到一个已存在的对象：</p>
<pre class=" language-C#"><code class="language-C#">var obj1 = new MyClass1 { TestProp = "Test value" };
var obj2 = new MyClass2();
obj1.MapTo(obj2);
</code></pre>
<h3 id="帮助接口-1"><a href="#帮助接口-1" class="headerlink" title="帮助接口###"></a>帮助接口###</h3><p>ASP.NET 提供了一些实现标准化公共DTO属性名称的帮助接口。</p>
<p><strong>ILimitedResultRequest</strong>定义了 <strong>MaxResultCount</strong>属性。这样你就可以在你的输入DTO中实现它来标准化有限的结果集。</p>
<p><strong>IPagedResultRequest</strong>通过添加了 <strong>SkipCount</strong>扩展了 <strong>ILimitedResultRequest</strong>。这样，我们可以在SearchPeopleInput中为分页显示实现这个接口：</p>
<pre class=" language-C#"><code class="language-C#">public class SearchPeopleInput : IInputDto, IPagedResultRequest
{
    [StringLength(40, MinimumLength = 1)]
    public string SearchedName { get; set; }

    public int MaxResultCount { get; set; }
    public int SkipCount { get; set; }
}
</code></pre>
<p>对于一个分页请求的结果，你可以返回一个实现了<strong>IHasTotalCount</strong>的输出DTO。命名标准化帮助我们创建可重复使用的代码和惯例。你也可以在 <strong>Abp.Application.Services.Dto</strong>命名空间下看到其他的接口和类。</p>
<h1 id="ABP理论学习之验证DTO"><a href="#ABP理论学习之验证DTO" class="headerlink" title="ABP理论学习之验证DTO"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html">ABP理论学习之验证DTO</a></h1><hr>
<h2 id="本篇目录-18"><a href="#本篇目录-18" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html#intro">验证介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html#annotaion">使用数据注解</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html#custom">自定义验证</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html#normalization">标准化</a></strong></li>
</ul>
<h3 id="验证介绍"><a href="#验证介绍" class="headerlink" title="验证介绍###"></a>验证介绍###</h3><p>首先应该验证应用的输入。用户或者其它应用都可以向该应用发送输入。在一个web应用中，验证通常要实现两次：在客户端和服务器端。客户端的验证大多数情况下是为用户体验而实现的。在客户端最好先检查一下表单，并向用户展示不合法的字段。但是服务端的验证更关键且不可避免。</p>
<p>服务端的验证通常实现在应用服务层。应用服务方法应首先检查（验证）输入然后再使用它。ABP提供了一个很好的基础设施来验证应用服务方法的输入。</p>
<p>应用服务方法接收一个DTO（数据传输对象）作为输入。ABP有一个<strong>IValidate</strong>接口，凡是实现了该接口的DTO都可以自动地进行验证。因为<strong>IInputDto</strong>继承了IValidate，因此只要为输入DTOs实现IInputDto就可以确保验证了。</p>
<h3 id="使用数据注解"><a href="#使用数据注解" class="headerlink" title="使用数据注解###"></a>使用数据注解###</h3><p>ABP支持数据注解特性。假设我们要开发一个任务（Task）应用服务，该服务用于创建一个任务，它的输入参数类型如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class CreateTaskInput : IInputDto
{
    public int? AssignedPersonId { get; set; }

    [Required]
    public string Description { get; set; }
}
</code></pre>
<p>这里，<strong>Description</strong>属性标记为 <strong>Required</strong>。AssignedPersonId是可选的。在 <strong>System.ComponentModel.DataAnnotations</strong>命名空间中也有很多特性（如MaxLength,MinLength,RegularExpression等等）。来看一下任务应用服务的实现：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskAppService : ITaskAppService
{
    private readonly ITaskRepository _taskRepository;
    private readonly IPersonRepository _personRepository;

    public TaskAppService(ITaskRepository taskRepository, IPersonRepository personRepository)
    {
        _taskRepository = taskRepository;
        _personRepository = personRepository;
    }

    public void CreateTask(CreateTaskInput input)
    {
        var task = new Task { Description = input.Description };

        if (input.AssignedPersonId.HasValue)
        {
            task.AssignedPerson = _personRepository.Load(input.AssignedPersonId.Value);
        }

        _taskRepository.Insert(task);
    }
}
</code></pre>
<p>正如你所看到的，这里没写验证代码，因为ABP会自动进行验证。ABP也会检查输入是否为<strong>null</strong>。如果为null，就会抛出 <strong>AbpValidationException</strong>。因此，你也不用写检测null的代码（保卫语句）。如果输入的属性有任何一个是非法的，那么就会抛出相同的异常。</p>
<p>该机制和ASP.NET MVC的验证相似，但是注意的是应用服务类不是派生自Controller，而只是一个纯粹的类并且在web应用之外工作。</p>
<h3 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证###"></a>自定义验证###</h3><p>如果数据注解还不能满足你的情况，那么你可以实现<strong>ICustomValidate</strong>接口，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class CreateTaskInput : IInputDto, ICustomValidate
{
    public int? AssignedPersonId { get; set; }

    public bool SendEmailToAssignedPerson { get; set; }

    [Required]
    public string Description { get; set; }

    public void AddValidationErrors(List<ValidationResult> results)
    {
        if (SendEmailToAssignedPerson && (!AssignedPersonId.HasValue || AssignedPersonId.Value <= 0))
        {
            results.Add(new ValidationResult("AssignedPersonId must be set if SendEmailToAssignedPerson is true!"));
        }
    }
}
</code></pre>
<p>ICustomValidate接口声明了要实现的<strong>AddValidationErrors</strong>方法。这里，我们有一个 <strong>SendEmailToAssignedPerson</strong>属性。如果它的值是true， 而且没有提供<strong>AssignedPersonId</strong>或值是负数，那么我们就认为这里发生了验证错误，我们必须将<strong>ValidationResult</strong>对象添加到 <strong>results</strong>集合中。</p>
<h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化###"></a>标准化###</h3><p>我们可能在验证之后执行一个额外的操作来排列DTO参数。ABP定义了<strong>IShouldNormalize</strong>接口， 该接口中定义了<strong>Normalize</strong>方法来达到排列DTO参数的目的。如果你实现了该接口，那么就应该在验证之后（方法调用之前）调用Normalize方法。假如我们的DTO要有一个排序（Sorting）方向，如果没有提供的话，我们就要设置一个默认值：</p>
<pre class=" language-C#"><code class="language-C#">public class GetTasksInput : IInputDto, IShouldNormalize
{
    public string Sorting { get; set; }
        
    public void Normalize()
    {
        if (string.IsNullOrWhiteSpace(Sorting))
        {
            Sorting = "Name ASC";
        }
    }
}
</code></pre>
<h1 id="ABP理论学习之授权（Authorization）"><a href="#ABP理论学习之授权（Authorization）" class="headerlink" title="ABP理论学习之授权（Authorization）"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html">ABP理论学习之授权（Authorization）</a></h1><hr>
<h2 id="本篇目录-19"><a href="#本篇目录-19" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#define">定义权限</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#check">检查权限</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#AbpAuthorize">使用AbpAuthorize特性</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#IPermissionChecker">使用IPermissionChecker</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#Razor">Razor视图</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#Javascript">客户端（Javascript）</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#permissionManager">权限管理者</a></strong></li>
</ul>
<h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍###"></a>介绍###</h3><p>几乎所有的企业应用都在不同程度使用了授权。授权的目的在于检查是否允许用户在应用程序中执行特定的操作。ABP定义了一个<strong>基于权限的</strong>基础设施来实现授权。</p>
<blockquote>
<h4 id="关于IPermissionChecker"><a href="#关于IPermissionChecker" class="headerlink" title="关于IPermissionChecker"></a>关于IPermissionChecker</h4><p>授权系统使用了<strong>IPermissionChecker</strong>来检查权限。虽然你可以用自己的方式实现该接口，但是它已完全实现在了 <strong>module-zero</strong>项目中。如果没有实现该接口，那么系统会默认使用NullPermissionChecker将所有的权限授予给每个人。</p>
</blockquote>
<h3 id="定义权限"><a href="#定义权限" class="headerlink" title="定义权限###"></a>定义权限###</h3><p>一个唯一的权限是为需要授权的每个操作定义的。我们应该在使用权限之前定义一个权限。ABP的设计是模块化的，因此不同的模块可以有不同的权限。为了定义模块的权限，应该创建一个派生自<strong>AuthorizationProvider（以下翻译为授权提供者）</strong>的类。一个授权提供者的例子如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class MyAuthorizationProvider : AuthorizationProvider
{
    public override void SetPermissions(IPermissionDefinitionContext context)
    {
        var administration = context.CreatePermission("Administration");

        var userManagement = administration.CreateChildPermission("Administration.UserManagement");
        userManagement.CreateChildPermission("Administration.UserManagement.CreateUser");

        var roleManagement = administration.CreateChildPermission("Administration.RoleManagement");
    }
}
</code></pre>
<p><strong>IPermissionDefinitionContext</strong>有创建和获取权限的方法。</p>
<p>一个权限定义了一些属性：</p>
<ul>
<li><strong>Name：</strong>系统中 <strong>唯一的</strong>名字。最好为权限的名字定义一个const字符串而不是变量字符串。我们偏向使用“.”符号用于有层次的名字，但这不是强制的。你可以设置任何你喜欢的名字，唯一的一点是保证它必须是唯一的。</li>
<li>**DisplayName:**用于以后在UI上显示权限的本地化字符串。</li>
<li><strong>Description：</strong>用于以后在UI上显示权限定义的本地化字符串。</li>
<li><strong>IsGrantedByDefault：</strong>表示该权限是否授予给所有登录的用户，除非该权限显式禁止未授予给用户。该值一般默认为false。</li>
<li><strong>MultiTenancySides：</strong>对于多租户应用，租户或者租主可以使用同一个权限。这是一个<strong>Flags</strong>枚举，因此一个权限可以用于租户和租主。</li>
<li><strong>dependedFeature：</strong>可以用于声明一个功能的依赖。因此，只有功能依赖满足了，该权限才会被授予。</li>
</ul>
<p>一个权限可以有父权限和子权限。虽然这不会影响权限检查，但是在UI上组合权限有所帮助。</p>
<p>当创建了授权提供者之后，我们应该在模块的PreIntialize方法中注册它：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Authorization.Providers.Add<MyAuthorizationProvider>();
</code></pre>
<p>因为授权提供者会自动地注册到依赖注入系统中，所以，授权提供者通过一些其他资源，可以注入任何依赖（比如仓储）来生成权限定义。</p>
<h3 id="检查权限"><a href="#检查权限" class="headerlink" title="检查权限###"></a>检查权限###</h3><h4 id="使用AbpAuthorize特性"><a href="#使用AbpAuthorize特性" class="headerlink" title="使用AbpAuthorize特性"></a>使用AbpAuthorize特性</h4><p><strong>AbpAuthorize</strong>（MVC控制器是AbpMvcAuthorize，Web API控制器是AbpApiAuthorize）是最简单也是最普通的检查权限的方式。思考一下下面的应用服务方法：</p>
<pre class=" language-C#"><code class="language-C#">[AbpAuthorize("Administration.UserManagement.CreateUser")]
public void CreateUser(CreateUserInput input)
{
    //如果一个用户没有被授予 "Administration.UserManagement.CreateUser" 权限，那么ta就不能执行此方法
}
</code></pre>
<p>AbpAuthorize特性也会检查当前的用户是否已经登录（使用**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPSession.html">IAbpSession.UserId</a>**）。因此，如果我们为一个方法声明了AbpAuthorize，它至少会检查登录情况：</p>
<pre class=" language-C#"><code class="language-C#">[AbpAuthorize]
public void SomeMethod(SomeMethodInput input)
{
    //如果用户没有登录，那么ta就不能执行此方法
}
</code></pre>
<p><strong>AbpAuthorize特性需要注意的地方</strong></p>
<p>ABP对于授权使用了强大的动态方法拦截（interception）。因此，使用AbpAuthorize特性有一些限制：</p>
<ul>
<li>不能用于私有方法。</li>
<li>不能用于静态方法。</li>
<li>不能用于非注入类的方法（我们必须要使用依赖注入）。</li>
</ul>
<p>此外，</p>
<ul>
<li>可以用于任何 <strong>public</strong>方法，如果该方法是通过接口调用的（比如应用服务通过接口使用）。</li>
<li>方法应该是<strong>virtual</strong>的，如果它是从类的引用直接调用的（比如ASP.Net MVC或者Web API的控制器）。</li>
<li>如果方法是<strong>protected</strong>的，那么它应该是 <strong>virtual</strong>的。</li>
</ul>
<p><strong>注意：</strong>AbpAuthorize特性有三个：</p>
<p>在应用服务中（应用层），我们使用<strong>Abp.Authorization.AbpAuthorize</strong>类。<br> 在MVC控制器中（Web层），我们使用 <strong>Abp.Web.Mvc.Authorization.AbpMvcAuthorize</strong>类。<br> 在ASP.NET Web API中，我们使用 <strong>Abp.WebApi.Authorization.AbpApiAuthorize</strong>特性。<br> 这写特性的差异来自继承。在MVC端，派生自MVC自己的Authorize类。在Web API端，它派生自Web API的Authorize类。因此，它已经很好地集成到了MVC和Web API。但是在应用层，它完全是ABP自己的实现而没有扩展任何类。</p>
<h4 id="使用IPermissionChecker"><a href="#使用IPermissionChecker" class="headerlink" title="使用IPermissionChecker"></a>使用IPermissionChecker</h4><p>虽然AbpAuthorize特性对于大多数情况相当够用了，但是肯定存在我们会在一个方法体内检查权限的情况。我们可以注入并使用<strong>IPermissionChecker</strong>，如下面的例子所示：</p>
<pre class=" language-C#"><code class="language-C#">public void CreateUser(CreateOrUpdateUserInput input)
{
    if (!PermissionChecker.IsGranted("Administration.UserManagement.CreateUser"))
    {
        throw new AbpAuthorizationException("You are not authorized to create user!");
    }
    
    //如果一个用户没有"Administration.UserManagement.CreateUser" 权限，那么ta不能到达该点。
}
</code></pre>
<p>当然，你可以编写任何逻辑代码，因为<strong>IsGranted</strong>仅仅返回true或者false（也有Async版本）。如果你只是检查一个权限然后抛出一个如上所示的异常，那么你可以使用 <strong>Authorize</strong>方法：</p>
<pre class=" language-C#"><code class="language-C#">public void CreateUser(CreateOrUpdateUserInput input)
{
    PermissionChecker.Authorize("Administration.UserManagement.CreateUser");

    //如果一个用户没有"Administration.UserManagement.CreateUser" 权限，那么ta不能到达该点。
}
</code></pre>
<p>因为授权一般在应用层实现，所以<strong>ApplicationService</strong>基类注入并定义了PermissionChecker属性。这样，权限检查者不需要在应用服务类中注入就可以使用了。</p>
<h4 id="Razor视图"><a href="#Razor视图" class="headerlink" title="Razor视图"></a>Razor视图</h4><p>视图基类定义了IsGranted方法来检查当前用户是否具有权限。因此，我们可以有条件地渲染该视图。例子：</p>
<pre class=" language-C#"><code class="language-C#">@if (IsGranted("Administration.UserManagement.CreateUser"))
{
    <button id="CreateNewUserButton" class="btn btn-primary"><i class="fa fa-plus"></i> @L("CreateNewUser")</button>
}
</code></pre>
<h4 id="客户端（Javascript）"><a href="#客户端（Javascript）" class="headerlink" title="客户端（Javascript）"></a>客户端（Javascript）</h4><p>在客户端，我们可以使用定义在<strong>abp.auth</strong>命名空间下的API。在大多数情况，我们需要检查当前的用户是否具有特定的权限（使用权限名字）。例子：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>auth<span class="token punctuation">.</span><span class="token function">hasPermission</span><span class="token punctuation">(</span><span class="token string">'Administration.UserManagement.CreateUser'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>你也可以使用<strong>abp.auth.grantedPermissions</strong>来获得所有授权的权限或者使用 <strong>abp.auth.allPermissions</strong>来获取所有应用中可用的权限名。</p>
<p>注意：自ABP 0.7.8版本开始，<strong>将javascript端的abp.auth.hasPermission更名为abp.auth.isGranted。hasPermission已经过时了。在新的项目中不要使用abp.auth.hasPermission</strong>。</p>
<h1 id="ABP理论学习之功能管理"><a href="#ABP理论学习之功能管理" class="headerlink" title="ABP理论学习之功能管理"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPFeatures.html">ABP理论学习之功能管理</a></h1><hr>
<h2 id="本篇目录-20"><a href="#本篇目录-20" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPFeatures.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPFeatures.html#funcType">功能类型</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPFeatures.html#defineFunc">定义功能</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPFeatures.html#checkFunc">检查功能</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPFeatures.html#manager">功能管理者</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPFeatures.html#edition">版本说明</a></strong></li>
</ul>
<h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍###"></a>介绍###</h3><p>大多数的<strong>Saas</strong>(多租户)应用都有不同 <strong>功能</strong>的 <strong>版本</strong>（包）。因此，他们可以给租户（客户）提供不同的 <strong>价格和功能选项</strong>。</p>
<p>ABP提供了<strong>功能系统</strong>使得这个更简单。我们可以 <strong>定义</strong>功能，然后检查某个功能是否对一个租户 <strong>开启</strong>了，最后将功能系统 <strong>集成</strong>到其他的ABP概念中（如权限和菜单）。</p>
<blockquote>
<h4 id="关于IFeatureValueStore"><a href="#关于IFeatureValueStore" class="headerlink" title="关于IFeatureValueStore"></a>关于IFeatureValueStore</h4><p>功能系统使用了<strong>IFeatureValueStore</strong>来获得功能的值。虽然你可以用自己的方式实现该接口，但是它已经完全实现在了 <strong>module-zero</strong>项目中。如果没有实现该接口，那么默认会使用NullFeatureValueStore对所有的功能返回null（此时使用默认的功能值）。</p>
</blockquote>
<h3 id="功能类型"><a href="#功能类型" class="headerlink" title="功能类型###"></a>功能类型###</h3><p>有两种基本功能类型。</p>
<h4 id="布尔功能"><a href="#布尔功能" class="headerlink" title="布尔功能"></a>布尔功能</h4><p>可以是”true”或”false”。这种类型的功能（对于一个版本或者一个租户）可能是<strong>开启的</strong>或者 <strong>关闭的</strong>。</p>
<h4 id="值功能"><a href="#值功能" class="headerlink" title="值功能"></a>值功能</h4><p>可以是<strong>任意值</strong>。虽然它是以字符串存储和检索的，但是数值也可以轻松地存储为字符串。</p>
<p>比如，我们的应用程序可能是一个任务管理应用，我们可能在一个月内对于创建任务会有限制。假如说我们有两个不同的版本：一个版本每个月允许创建1000个任务，但是另一个每个月允许创建5000个任务。因此，这个功能应该存储为值，而不是简单的true或false。</p>
<h3 id="定义功能"><a href="#定义功能" class="headerlink" title="定义功能###"></a>定义功能###</h3><p>在检查功能之前应该先定义功能。一个模块可以通过从<strong>FeatureProvider</strong>类派生来定义自己的功能。这里有一个定义了3个功能的非常简单的功能提供者：</p>
<pre class=" language-c#"><code class="language-c#">public class AppFeatureProvider : FeatureProvider
{
    public override void SetFeatures(IFeatureDefinitionContext context)
    {
        var sampleBooleanFeature = context.Create("SampleBooleanFeature", defaultValue: "false");
        sampleBooleanFeature.CreateChildFeature("SampleNumericFeature", defaultValue: "10");
        context.Create("SampleSelectionFeature", defaultValue: "B");
    }
}
</code></pre>
<p>创建功能提供者之后，我们应该在模块的PreInitialize方法中注册，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Features.Providers.Add<AppFeatureProvider>();
</code></pre>
<h4 id="基本功能属性"><a href="#基本功能属性" class="headerlink" title="基本功能属性"></a>基本功能属性</h4><p>一个功能的定义至少要求两个属性：</p>
<ul>
<li><strong>Name：</strong>识别该功能唯一的名字（字符串）。</li>
<li>**DefaultValue:**默认值。当我们需要该功能的值时会用到该属性，而且对于当前的租户不可用。</li>
</ul>
<p>上面的代码样例中，我们定义了一个名为”SampleBooleanFeature”布尔功能，它的默认值是”false”（不可用）。我们也定义了两个值功能（SampleNumericFeature定义为SampleBooleanFeature的孩子）。</p>
<p>提示：为功能名称创建一个常量字符串，然后在任何地方使用时会防止拼写失误。</p>
<h4 id="其他功能属性"><a href="#其他功能属性" class="headerlink" title="其他功能属性"></a>其他功能属性</h4><p>虽然对于ABP来说一个唯一的名称和默认值属性已经足够了，但是对于细节的控制还有许多其他的功能属性。</p>
<ul>
<li><strong>Scope：</strong>FeatureScope枚举值之一。它可以是<strong>Edition</strong>（如果只为版本级别设置该功能）， <strong>Tenant</strong>（如果只为租户级别设置该功能），或者 <strong>All</strong>(如果为版本和租户都可以设置该功能，这种情况下，租户的设置会覆盖版本的设置)。默认值是All。</li>
<li>**DisplayName:**给用户显示该功能名称的本地化字符串。</li>
<li><strong>Description：</strong>给用户显示该功能细节描述的本地化字符串。</li>
<li>**InputType:**该功能的UI输入类型。</li>
<li>**Attributes:**任意的自定义键值对字典，可以和该功能关联起来。</li>
</ul>
<p>让我们看一下该功能的细节定义：</p>
<pre class=" language-C#"><code class="language-C#">public class AppFeatureProvider : FeatureProvider
{
    public override void SetFeatures(IFeatureDefinitionContext context)
    {
        var sampleBooleanFeature = context.Create(
            AppFeatures.SampleBooleanFeature,
            defaultValue: "false",
            displayName: L("Sample boolean feature"),
            inputType: new CheckboxInputType()
            );

        sampleBooleanFeature.CreateChildFeature(
            AppFeatures.SampleNumericFeature,
            defaultValue: "10",
            displayName: L("Sample numeric feature"),
            inputType: new SingleLineStringInputType(new NumericValueValidator(1, 1000000))
            );

        context.Create(
            AppFeatures.SampleSelectionFeature,
            defaultValue: "B",
            displayName: L("Sample selection feature"),
            inputType: new ComboboxInputType(
                new StaticLocalizableComboboxItemSource(
                    new LocalizableComboboxItem("A", L("Selection A")),
                    new LocalizableComboboxItem("B", L("Selection B")),
                    new LocalizableComboboxItem("C", L("Selection C"))
                    )
                )
            );
    }

    private static ILocalizableString L(string name)
    {
        return new LocalizableString(name, AbpZeroTemplateConsts.LocalizationSourceName);
    }
}
</code></pre>
<p>注意：ABP没有使用这里的InputType。当为功能创建输入时，应用程序会使用它们。ABP只是提供了这些选项使得它更容易。</p>
<h4 id="功能层次"><a href="#功能层次" class="headerlink" title="功能层次"></a>功能层次</h4><p>正如样例功能提供者所示，一个功能可以有<strong>子功能</strong>。一个父母功能一般定义为 <strong>布尔</strong>功能。只有父母功能可用时，孩子功能才可用。ABP不强制这样做，但是建议这样做。</p>
<h3 id="检查功能"><a href="#检查功能" class="headerlink" title="检查功能###"></a>检查功能###</h3><h4 id="使用RequireFeature特性"><a href="#使用RequireFeature特性" class="headerlink" title="使用RequireFeature特性"></a>使用RequireFeature特性</h4><p>我们可以为方法或类使用<strong>RequiredFeature</strong>特性，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">[RequiresFeature("ExportToExcel")]
public async Task<FileDto> GetReportToExcel(...)
{
    ...
}
</code></pre>
<p>该方法只有在”ExportToExcel”功能对<strong>当前租户</strong>开启时才会执行（当前租户从IAbpSession中获得）。如果没有开启该功能，那么就会自动抛出 <strong>AbpAuthorizationException</strong>。</p>
<p>当然，RequiresFeature特性应该用于<strong>布尔类型功能</strong>。否则，你会得到异常。</p>
<p><strong>RequiresFeature特性注意点</strong><br> ABP对于功能检查使用了强大的动态方法拦截（interception）。因此，为方法使用RequiresFeature特性时有一些限制条件：</p>
<ul>
<li>不能用于私有方法。</li>
<li>不能用于静态方法。</li>
<li>不能用于非注入类的方法（我们必须使用DI）。</li>
</ul>
<p>此外，</p>
<ul>
<li>如果该方法是通过一个<strong>接口</strong>（如应用服务通过接口调用）调用的，那么我们可以将它用于任何  <strong>public</strong>的方法。</li>
<li>如果一个方法直接从类的引用调用（如MVC或Web API控制器），那么它应该是<strong>virtual</strong>的。</li>
<li>如果一个方法是<strong>protected</strong>，那么该方法应该是 <strong>virtual</strong>。</li>
</ul>
<h4 id="使用IFeatureChecker"><a href="#使用IFeatureChecker" class="headerlink" title="使用IFeatureChecker"></a>使用IFeatureChecker</h4><p>我们可以注入并使用IFeatureChecker来手动检查一个功能（对于应用服务，MVC和Web API控制器，它会自动注入而且直接可以使用）。</p>
<p><strong>IsEnabled</strong></p>
<p>用于简单地检查给定的功能是否开启。例子：</p>
<pre class=" language-C#"><code class="language-C#">public async Task<FileDto> GetReportToExcel(...)
{
    if (await FeatureChecker.IsEnabledAsync("ExportToExcel"))
    {
        throw new AbpAuthorizationException("You don't have this feature: ExportToExcel");
    }
    
    ...
}
</code></pre>
<p>IsEnabledAsync和其他方法都有同步版本。</p>
<p>当然，IsEnabled方法应该用于<strong>布尔类型功能</strong>。否则可能会抛异常。</p>
<p>如果你只想检查一个功能，然后抛出例子中的异常，那么你只需要使用<strong>CheckEnabled</strong>方法就行了。</p>
<p><strong>GetValue</strong></p>
<p>用于获得值类型功能的当前值，例子：</p>
<pre class=" language-C#"><code class="language-C#">var createdTaskCountInThisMonth = GetCreatedTaskCountInThisMonth();
if (createdTaskCountInThisMonth >= FeatureChecker.GetValue("MaxTaskCreationLimitPerMonth").To<int>())
{
    throw new AbpAuthorizationException("You exceed task creation limit for this month, sorry :(");
}
</code></pre>
<p>FeatureChecker方法也有对于特定租户的重载，不仅仅只对于当前的租户。</p>
<h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><p>在客户端，我们使用<strong>abp.features</strong>命名空间来获得该功能的当前值。</p>
<p><strong>isEnabled</strong></p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> isEnabled <span class="token operator">=</span> abp<span class="token punctuation">.</span>features<span class="token punctuation">.</span><span class="token function">isEnabled</span><span class="token punctuation">(</span><span class="token string">'SampleBooleanFeature'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>getValue</strong></p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> value <span class="token operator">=</span> abp<span class="token punctuation">.</span>features<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token string">'SampleNumericFeature'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="功能管理者"><a href="#功能管理者" class="headerlink" title="功能管理者###"></a>功能管理者###</h3><p>如果需要定义功能，可以注入并使用<strong>IFeatureManager</strong>。</p>
<h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明###"></a>版本说明###</h3><p>ABP没有内置的版本系统，因为这么个系统要求数据库（存储版本，版本功能，租户-版本映射等等）。因此，版本系统实现在了module-zero中了。使用它你可以轻松地拥有一个版本系统，要不然你可以自己实现。</p>
<h1 id="ABP理论学习之审计日志"><a href="#ABP理论学习之审计日志" class="headerlink" title="ABP理论学习之审计日志"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuditLog.html">ABP理论学习之审计日志</a></h1><hr>
<h2 id="本篇目录-21"><a href="#本篇目录-21" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#config">配置</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#attribute">通过特性开启/关闭</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#notes">注意</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#sample">我项目中的例子</a></strong></li>
</ul>
<hr>
<h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>维基百科说： “审计跟踪（也叫审计日志）是与安全相关的按照时间顺序的记录，记录集或者记录源，它们提供了活动序列的文档证据，这些活动序列可以在任何时间影响一个特定的操作，步骤或其他”。</p>
</blockquote>
<p>ABP提供了一个基础设施，它可以自动记录所有和应用程序交互的日志。它可以记录具有调用者信息和参数的方法调用。</p>
<p>一般地，要保存的字段是：相关的<strong>租户Id</strong>，调用者的<strong>用户Id</strong>，调用的 <strong>服务名称</strong>（调用方法的类名），调用的<strong>方法名</strong> ， 执行<strong>方法名</strong>（序列化成Json） ， <strong>执行时间</strong> ， 执行<strong>时长</strong>（单位毫秒），客户端<strong>IP地址</strong> ，客户端<strong>计算机名称</strong>和<strong>异常</strong>（抛出异常的情况下）。</p>
<p>有了这些信息，我们不仅知道谁进行了该操作，而且可以测量应用的<strong>性能</strong>以及观察抛出的异常。甚至，你可以获得应用使用情况的<strong>统计数据（statistics）</strong>。</p>
<p>审计系统使用**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPSession.html">IAbpSession</a>**来获得当前的UserId和TenantId。</p>
<blockquote>
<h4 id="关于-IAuditingStore"><a href="#关于-IAuditingStore" class="headerlink" title="关于 IAuditingStore"></a>关于 IAuditingStore</h4><p>审计系统使用了IAuditingStore来存储信息。虽然你可以用你自己的方式来实现该接口，但是它已经完全实现在<strong>module-zero</strong>项目中。如果你没有实现该接口，那么默认会使用SimpleLogAuditingStore，并且它会将审计信息记录到日志中（log）。</p>
</blockquote>
<h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p>要配置审计，可以在模块的PreInitialize方法中使用<strong>Configuration.Auditing</strong>属性。审计是<strong>默认开启的</strong>。可以像下面那样关闭它：</p>
<pre class=" language-C#"><code class="language-C#">public class MyModule : AbpModule
{
    public override void PreInitialize()
    {
        Configuration.Auditing.IsEnabled = false;
    }

    //...
}
</code></pre>
<p>这儿是审计配置属性的列表：</p>
<ul>
<li><p><strong>IsEnabled</strong>:用于完全开启或关闭审计系统。默认为true。</p>
</li>
<li><p><strong>IsEnabledForAnonymousUsers</strong>:如果此值为true,那么没有登录到系统的用户的审计日志也会保存。默认为false。</p>
</li>
<li><p>MvcControllers</p>
<p>:用于为ASP.NET MVC控制器配置审计。</p>
<ul>
<li><strong>IsEnabled</strong>:用于为MVC控制器开启或关闭审计。默认为true</li>
<li><strong>IsEnabledForChildActions</strong>:用于为子MVC action开启或关闭审计。默认为false。</li>
</ul>
</li>
<li><p><strong>Selectors</strong>:用于选择其他的类保存审计日志。</p>
</li>
</ul>
<p>可以看到，对于MVC控制器的审计是单独配置的，因为它用到了不同的技术。</p>
<p><strong>Selectors</strong>是选择其他的类型来保存审计日志的谓词列表。一个选择器有一个唯一的名字和一个谓词。这个列表中唯一的默认选择器用于选择<strong>应用服务类</strong>。它是如下定义的：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Auditing.Selectors.Add(
    new NamedTypeSelector(
        "Abp.ApplicationServices",
        type => typeof (IApplicationService).IsAssignableFrom(type)
    )
);
</code></pre>
<p>你可以将你的选择器添加到模块的PreInitialize方法中。而且，如果你不喜欢为应用服务保存审计日志，那么你可以通过名称移除选择器。那就是为什么要有一个唯一名称的原因（使用简单的linq找出该选择器，然后可以移除它）。</p>
<h3 id="通过特性开启-关闭"><a href="#通过特性开启-关闭" class="headerlink" title="通过特性开启/关闭"></a>通过特性开启/关闭</h3><p>虽然可以通过配置选择审计类，但是也可以为一个单独的类或方法使用<strong>Audited</strong>和 <strong>DisableAuditing</strong>特性。举个例子：</p>
<pre class=" language-C#"><code class="language-C#">[Audited]
public class MyClass
{
    public void MyMethod1(int a)
    {
        //...
    }

    [DisableAuditing]
    public void MyMethod2(string b)
    {
        //...
    }

    public void MyMethod3(int a, int b)
    {
        //...
    }
}
</code></pre>
<p>除了MyMethod2方法之外，MyClass的所有方法都参与审计了，因为MyMethod2显式关闭了。审计特性可以用于想要参与审计的方法保存审计日志。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>为了保存审计日志，方法必须是<strong>public</strong>的。私有的和受保护的方法会被忽略。</li>
<li>如果方法是通过类的引用调用的，那么该方法必须是<strong>virtual</strong>的。因为ABP使用了动态代理和拦截，所以需要满足该条件。如果使用了接口（比如注入IPersonService接口使用PersonService类）注入，就不必满足“virtual”的条件了。对于MVC控制器的action不一定要满足，它们可以不是“virtual”的。</li>
</ul>
<h3 id="我项目中的例子"><a href="#我项目中的例子" class="headerlink" title="我项目中的例子"></a>我项目中的例子</h3><p>下面的代码是点击登录按钮提交表单数据的action方法：</p>
<pre class=" language-C#"><code class="language-C#">[HttpPost]
[UnitOfWork]
[DisableAuditing]
public virtual async Task<JsonResult> Login(LoginViewModel loginModel, string returnUrl = "")
{
    CheckModelState();

    _unitOfWorkManager.Current.DisableFilter(AbpDataFilters.MayHaveTenant);
    var loginResult = await GetLoginResultAsync(
        loginModel.UsernameOrEmailAddress,
        loginModel.Password,
        loginModel.TenancyName
        );
    await SignInAsync(loginResult.User, loginResult.Identity, loginModel.RememberMe);

    if (string.IsNullOrWhiteSpace(returnUrl))
    {
        returnUrl = Request.ApplicationPath;
    }
    return Json(new MvcAjaxResponse { TargetUrl = returnUrl });
}
</code></pre>
<p>下面的截图是数据库中的审计日志信息，大家可以看到今天还没有数据，最晚的数据是2015-12-18的数据：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151221133123781-741090354.png" alt="img"></p>
<p>登录系统之后，依然没有记录审计日志，下面统一截图。</p>
<p>下面我将上面的代码的特性**[DisableAuditing]**去掉，再次登录系统，可以看到有了审计记录，截图如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151221133942234-1080323149.png" alt="img"></p>
<p>分别按序号解释一下：</p>
<ol>
<li>首次到达登录页面；</li>
<li>登录成功，到达系统首页Index;</li>
<li>去掉**[DisableAuditing]**特性后，到达登陆页面；</li>
<li>将数据post提交到Login方法，记录了审计日志，包含各种登录参数；</li>
<li>登录成功，返回系统首页Index。</li>
</ol>
<p>从我的例子可以很明显地看出，默认情况下，ABP会自动记录所有的控制器，除非你给它加上**[DisableAuditing]**特性，否则，始终会记录审计日志。</p>
<h1 id="分布式服务层"><a href="#分布式服务层" class="headerlink" title="分布式服务层"></a>分布式服务层</h1><hr>
<h2 id="本篇目录-22"><a href="#本篇目录-22" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#intro">介绍</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#base">AbpApiController基类</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#localization">本地化</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#auditLogging">审计日志</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#authorization">授权</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#uow">工作单元</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#others">其他</a></strong></li>
</ul>
</li>
</ul>
<h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍###"></a>介绍###</h3><p>ABP通过<strong>Abp.Web.Api</strong>Nuget包集成了 <strong>ASP.NET Web API</strong>控制器。你可以像以往创建Asp.Net Web API控制器那样创建Web API控制器。依赖注入对于有规律的ApiController（其实就是继承自AbpApiController的控制器）是有效的。</p>
<p>但是你应该从<strong>AbpApiController</strong>派生控制器，它提供了许多有用的东西，并且更好地集成到了ABP中。</p>
<h3 id="AbpApiController基类"><a href="#AbpApiController基类" class="headerlink" title="AbpApiController基类###"></a>AbpApiController基类###</h3><p>下面是一个派生于AbpApiController的简单api控制器：</p>
<pre class=" language-C#"><code class="language-C#">public class UsersController : AbpApiController
{
        
}
</code></pre>
<h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>AbpApiController定义了<strong>L</strong>方法使得本地化更为简单。例子：</p>
<pre class=" language-C#"><code class="language-C#">public class UsersController : AbpApiController
{
    public UsersController()
    {
        LocalizationSourceName = "MySourceName";
    }

    public UserDto Get(long id)
    {
        var helloWorldText = L("HelloWorld");

        //...
    }
}
</code></pre>
<p>要使L方法生效，必须设置<strong>LocalizationSourceName</strong>。你可以在自己的api控制器基类中设置而不用在每个api控制器中都重复设置。</p>
<h4 id="审计日志"><a href="#审计日志" class="headerlink" title="审计日志"></a>审计日志</h4><p>审计日志不会为api控制器自动记录。如果你要为api控制器记录日志的话，应该在控制器或者它的action方法上声明<strong>Audited</strong>特性。请查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPAuditLog.html">审计日志</a>**获取更多信息。</p>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>你可以为api控制器或者action方法使用<strong>AbpApiAuthorize</strong>特性来阻止未授权的用户使用控制器和action方法。例子：</p>
<pre class=" language-C#"><code class="language-C#">public class UsersController : AbpApiController
{
    [AbpApiAuthorize("MyPermissionName")]
    public UserDto Get(long id)
    {
        //...
    }
}
</code></pre>
<p>AbpApiController也定义了检查权限的<strong>IsGranted方法</strong>作为快捷方式。请查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPAuthorization.html">授权</a>**一节获取更多信息。</p>
<h4 id="工作单元-2"><a href="#工作单元-2" class="headerlink" title="工作单元"></a>工作单元</h4><p>Web API的action方法默认不是工作单元。例如，如果你需要在action方法中打开数据库连接，就需要像下面那样声明<strong>UnitOfWork</strong>特性：</p>
<pre class=" language-C#"><code class="language-C#">public class UsersController : AbpApiController
{
    private readonly IRepository<User, long> _userRepository;

    public UsersController(IRepository<User, long> userRepository)
    {
        _userRepository = userRepository;
    }

    [UnitOfWork]
    public virtual List<UserDto> Users(string filter)
    {
        var users = _userRepository
            .GetAll()
            .Where(u => u.UserName.StartsWith(filter))
            .ToList();

        //...
    }
}
</code></pre>
<p>这里我们声明了<strong>UnitOfWork</strong>特性。因为仓储的 <strong>GetAll()**方法返回了 **IQueryable</strong>，而当它使用 <strong>ToList()**方法（由于IQueryable的延迟执行）时需要一个打开的数据库连接，所以这里需要声明该特性。注意该action方法应该声明为</strong>virtual**（否则拦截无法工作）。</p>
<p>请查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPUnitofWork.html">工作单元</a>**获取更多。</p>
<h4 id="其他-4"><a href="#其他-4" class="headerlink" title="其他"></a>其他</h4><p>你还可以使用预注入的 <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPSession.html">AbpSession</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPEventBus.html">EventBus</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ModuleZeroPermissonManagement.html">PermissionManager</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ModuleZeroPermissonManagement.html">PermissionChecker</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPSettingManagement.html#getSetting">SettingManager</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPFeatures.html#manager">FeatureManager</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPFeatures.html#checkFunc">FeatureChecker</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPLocalization.html#text">LocalizationManager</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPLogging.html">Logger</a></strong>, **<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPUnitofWork.html#uow">CurrentUnitOfWork</a>**等基属性以及更多。</p>
<h1 id="动态Web-API层"><a href="#动态Web-API层" class="headerlink" title="动态Web API层"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html">动态Web API层</a></h1><h2 id="本篇目录-23"><a href="#本篇目录-23" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#build">构建动态Web API控制器</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#ForAll">ForAll 方法</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#OverrideForAll">重写ForAll 方法</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#httpVerbs">Http动词</a></strong></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#proxy">动态Javascript代理</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#ajax">Ajax参数</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#single">单一服务脚本</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#angular">Angular支持</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#Durandal">Durandal支持</a></strong></li>
<li>**<a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#wrap">返回结果封装</a>**【2016/3/28 更新】</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#paramBinding">关于参数绑定</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#FromUri">FromUri和FromBody特性</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#DTOs">DTOs vs 原始类型</a></strong></li>
</ul>
</li>
</ul>
<h3 id="构建动态Web-API控制器"><a href="#构建动态Web-API控制器" class="headerlink" title="构建动态Web API控制器"></a>构建动态Web API控制器</h3><p>ABP可以自动地为应用层生成<strong>Web API 层</strong>。比如说我们有一个应用层如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public interface ITaskAppService : IApplicationService
{
    GetTasksOutput GetTasks(GetTasksInput input);
    void UpdateTask(UpdateTaskInput input);
    void CreateTask(CreateTaskInput input);
}
</code></pre>
<p>我们想把这个服务作为Web API控制器暴露给客户端。ABP只需要一行配置就可以为该应用服务创建一个Web API控制器：</p>
<pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder.For<ITaskAppService>("tasksystem/task").Build();
</code></pre>
<p>OK了！在地址为**’/api/services/tasksystem/task’**的地方就创建了一个API控制器，现在客户端可以使用该应用服务的所有方法。这个配置应该在模块的Initlize方法中完成。</p>
<p>我们使用一个API控制器封装的<strong>ITaskAppService</strong>是一个应用服务。使用API控制器对应用服务进行封装不是强制的，但是这是传统推荐的方式。 <strong>“tasksystem/task”**一个具有随机命名空间的API控制器的名字。你应该至少定义一级的命名空间，但是你也可以定义更深层次的命名空间，比如 <em>“myCompany/myApplication/myNamespace1/myNamespace2/myServiceName”*。 *</em>‘/api/services’**是所有动态生成的Web API控制器的前缀。因此，该API控制器的地址将会是这个样子的 <em>‘/api/services/tasksystem/task’*，而GetTasks方法的地址将会是 *’/api/services/tasksystem/task/getTasks’*。因为在javascript中惯例遵循 *</em>camelCase</strong>规则，所以方法名都转成了camelCase格式。</p>
<h4 id="ForAll-方法"><a href="#ForAll-方法" class="headerlink" title="ForAll 方法"></a>ForAll 方法</h4><p>在应用服务层可能会有很多的应用服务，如果要为这些应用服务都构建API控制器的话，一个一个地构建简直是费时费力的事情。没关系，ABP中的DynamicApiControllerBuilder提供了一个为所有应用服务构建Web API控制器的方法，这样我们只需要调用一次就行了。例如：</p>
<pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder
    .ForAll<IApplicationService>(Assembly.GetAssembly(typeof(SimpleTaskSystemApplicationModule)), "tasksystem")
    .Build();
</code></pre>
<p>ForAll方法是接收接口类型的泛型方法。第一个参数是一个程序集，该程序集中含有派生自给定接口的类。最后一个参数是服务前缀的命名空间。比如说我们在给定的程序集中有ITaskAppService和IPersonAppService，对于这个配置的话，服务地址将会是 ‘/api/services/tasksystem/task’ 和  ‘/api/services/tasksystem/person’。计算服务名称的方法是：移除Service或者AppService后缀，以及I前缀（对于接口来说）。此外，服务名称会转成camel  Case(驼峰命名)的格式。如果你不喜欢这种转换，那么使用’WithServiceName’来决定服务发名称。此外，还有一个过滤服务的Where方法。除了个别应用服务之外，这个方法在你为其他所有的应用服务构建API控制器时很有用。</p>
<h4 id="重写ForAll-方法"><a href="#重写ForAll-方法" class="headerlink" title="重写ForAll 方法"></a>重写ForAll 方法</h4><p>在ForAll方法之后我们可以重写配置。例如：</p>
<pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder
    .ForAll<IApplicationService>(Assembly.GetAssembly(typeof(SimpleTaskSystemApplicationModule)), "tasksystem")
    .Build();

DynamicApiControllerBuilder
    .For<ITaskAppService>("tasksystem/task")
    .ForMethod("CreateTask").DontCreateAction()
    .Build();
</code></pre>
<p>在上面的代码中，我们为一个程序集中所有的应用服务构建了动态的Web API控制器。然后又为一个应用服务（ITaskAppService）重写了配置，目的是忽略该应用服务中的CreateTask方法。</p>
<h4 id="Http动词"><a href="#Http动词" class="headerlink" title="Http动词"></a>Http动词</h4><p>默认情况下，创建的方法都只能<strong>POST</strong>请求。我们也可以使用不同的方法来改变这种行为。<br> <strong>WithVerb方法</strong></p>
<p>我们可以为一个方法使用WithVerb，像下面那样：</p>
<pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder
    .For<ITaskAppService>("tasksystem/task")
    .ForMethod("GetTasks").WithVerb(HttpVerb.Get)
    .Build();
</code></pre>
<p><strong>HTTP特性</strong></p>
<p>我们可以在应用服务的接口的方法上添加HttpGet，HttpPost等特性。</p>
<pre class=" language-C#"><code class="language-C#">public interface ITaskAppService : IApplicationService
{
    [HttpGet]
    GetTasksOutput GetTasks(GetTasksInput input);

    [HttpPut]
    void UpdateTask(UpdateTaskInput input);

    [HttpPost]
    void CreateTask(CreateTaskInput input);
}
</code></pre>
<p>使用这些特性之前，应该在项目中添加**<a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Core">Microsoft.AspNet.WebApi.Core</a>**Nuget包的引用。</p>
<p><strong>命名规范</strong></p>
<p>不用为每个方法都声明HTTP动词，你可以使用如下所示的<strong>WithConventionalVerbs</strong>方法：</p>
<pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder
    .ForAll<IApplicationService>(Assembly.GetAssembly(typeof(SimpleTaskSystemApplicationModule)), "tasksystem")
    .WithConventionalVerbs()
    .Build();
</code></pre>
<p>在这种情况下，Http动词会由方法名的前缀决定：</p>
<ul>
<li><strong>Get</strong>：方法名以Get开头。</li>
<li><strong>Put</strong>：方法名以Put或Update开头。</li>
<li><strong>Delete</strong>：方法名以Delete或Remove开头。</li>
<li><strong>Post</strong>：方法名以Post或Create开头。</li>
<li>其他情况，Post是HTTP动词的默认值</li>
</ul>
<p>我们可以通过对特定的方法使用WithVerb方法或者HTTP特性来覆盖上述惯例。</p>
<h3 id="动态Javascript代理"><a href="#动态Javascript代理" class="headerlink" title="动态Javascript代理"></a>动态Javascript代理</h3><p>在Javascript中，可以经由Ajax使用动态创建的web api控制器。ABP通过为动态的web  api控制器创建动态的Javascript代理简化了这个。因此，可以在Javascript中像调用一个function一样来调用一个动态的web api 控制器action：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>services<span class="token punctuation">.</span>tasksystem<span class="token punctuation">.</span>task<span class="token punctuation">.</span><span class="token function">getTasks</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    state<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//use result.tasks here...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Javascript代理是动态创建的。使用之前应该将下面动态的脚本包括在页面上。</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/api/AbpServiceProxies/GetAll<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre>
<p>服务方法返回了promise（查看**<a target="_blank" rel="noopener" href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</a>**）。可以在返回的promise后面继续注册done，fail，then等回调函数。服务方法内部使用了abp.ajax。如果需要的话，它们会处理错误并显示错误信息。</p>
<h4 id="Ajax参数"><a href="#Ajax参数" class="headerlink" title="Ajax参数"></a>Ajax参数</h4><p>你可以把一个自定义的ajax参数作为第二个参数传给代理方法。</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>services<span class="token punctuation">.</span>tasksystem<span class="token punctuation">.</span>task<span class="token punctuation">.</span><span class="token function">createTask</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    assignedPersonId<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
    description<span class="token punctuation">:</span> <span class="token string">'a new task description...'</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//override jQuery's ajax parameters</span>
    <span class="token keyword">async</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    timeout<span class="token punctuation">:</span> <span class="token number">30000</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">'successfully created a task!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>**<a target="_blank" rel="noopener" href="http://api.jquery.com/jQuery.ajax/">jQuery.ajax</a>**的所有参数在这里都是有效的。</p>
<h4 id="单一服务脚本"><a href="#单一服务脚本" class="headerlink" title="单一服务脚本"></a>单一服务脚本</h4><p>‘/api/AbpServiceProxies/GetAll’会在一个文件中生成所有的服务代理。使用’/api/AbpServiceProxies/Get?name=serviceName’也可以生成一个单独的服务代理，只需要在页面中包括下面的代码：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/api/AbpServiceProxies/Get?name<span class="token punctuation">=</span>tasksystem/task<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre>
<h4 id="Angular支持"><a href="#Angular支持" class="headerlink" title="Angular支持"></a>Angular支持</h4><p>ABP可以将动态的API控制器暴露给AngularJs服务。思考下面的例子：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    angular<span class="token punctuation">.</span><span class="token function">module</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">controller</span><span class="token punctuation">(</span><span class="token string">'TaskListController'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
        <span class="token string">'$scope'</span><span class="token punctuation">,</span> <span class="token string">'abp.services.tasksystem.task'</span><span class="token punctuation">,</span>
        <span class="token keyword">function</span><span class="token punctuation">(</span>$scope<span class="token punctuation">,</span> taskService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
            vm<span class="token punctuation">.</span>tasks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            taskService<span class="token punctuation">.</span><span class="token function">getTasks</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                state<span class="token punctuation">:</span> <span class="token number">0</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                vm<span class="token punctuation">.</span>tasks <span class="token operator">=</span> result<span class="token punctuation">.</span>tasks<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>我们可以使用服务的名字（包含命名空间）注射一个服务。然后，可以作为正常的Javascript函数调用它的function。注意，我们注册到了success句柄上（而不是done），因为它就像在angular的$http服务中。ABP使用AngularJs的$http服务。如果</p>
<p>你想要传递$http配置，可以作为服务方法的最后一个参数传递一个配置对象。</p>
<p>要使用自动生成的服务，应该在页面中包含需要的脚本：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>~/Abp/Framework/scripts/libs/angularjs/abp.ng.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>~/api/AbpServiceProxies/GetAll?type<span class="token punctuation">=</span>angular<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre>
<h4 id="Durandal支持"><a href="#Durandal支持" class="headerlink" title="Durandal支持"></a>Durandal支持</h4><p>ABP可以在一个**<a target="_blank" rel="noopener" href="http://durandaljs.com/">Durandal</a>**应用的模块中注入服务代理。看下面的viewmodel:</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'service!tasksystem/task'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token keyword">function</span> <span class="token punctuation">(</span>taskService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//taskService can be used here</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>ABP配置Durandal(实际上是Require.js)来理解这个’service!’前缀，然后注入合适的javascript服务代理。</p>
<h4 id="返回结果封装"><a href="#返回结果封装" class="headerlink" title="返回结果封装"></a>返回结果封装</h4><p>ABP通过 <strong>AjaxResponse</strong>封装了动态Web  API的action的返回值。查看《**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#Ajax">Ajax文档</a>**》获取更多关于封装的信息。你可以为每个应用服务或者每个方法开启或者禁用封装。看下面这个应用服务的例子：</p>
<pre class=" language-C#"><code class="language-C#">public interface ITestAppService : IApplicationService
{
    [DontWrapResult]
    DoItOutput DoIt(DoItInput input);
}
</code></pre>
<p>这里我们为DoIt方法禁用了封装。这个特性应该为接口声明而不是实现类。</p>
<p>如果你想更好地控制客户端的返回值，那么不封装返回的结果可能是很有用的。特别地，当使用不能和ABP标准的AjaxResponse协作的<strong>第三方客户端库</strong>时，可能需要禁用封装。这种情况下，你要自己处理异常。</p>
<p>注意：动态javascript代理可以理解返回的结果是否封装和运行正常。</p>
<h3 id="关于参数绑定"><a href="#关于参数绑定" class="headerlink" title="关于参数绑定"></a>关于参数绑定</h3><p>ABP在运行时创建了API控制器。因此，ASP.NET Web API的**<a target="_blank" rel="noopener" href="http://www.asp.net/web-api/overview/formats-and-model-binding/parameter-binding-in-aspnet-web-api">模型和参数绑定</a>**可以用于绑定模型和参数。</p>
<h4 id="FromUri和FromBody特性"><a href="#FromUri和FromBody特性" class="headerlink" title="FromUri和FromBody特性"></a>FromUri和FromBody特性</h4><p>为了在绑定时进行高级控制，可以在服务接口上使用FromUri和FromBody特性。</p>
<h4 id="DTOs-vs原始类型"><a href="#DTOs-vs原始类型" class="headerlink" title="DTOs vs原始类型"></a>DTOs vs原始类型</h4><p>我们强烈建议为应用服务和Web  API控制器的方法使用DTO作为参数类型，但是你也可以使用原始类型（如string，int，bool或者可空的类型如int?，bool?）作为参数类型。虽然可以在应用服务中使用不止一个参数，但是最好用一个复杂的类型将多个参数整合起来，否则客户端就不会生成动态代理服务。在日志记录中就会看到如下图所示的错误：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160107164212918-348748482.png" alt="img"></p>
<h2 id="ABP理论学习之OData集成-新增"><a href="#ABP理论学习之OData集成-新增" class="headerlink" title="ABP理论学习之OData集成(新增)"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html">ABP理论学习之OData集成(新增)</a></h2><hr>
<h2 id="本篇目录-24"><a href="#本篇目录-24" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#setup">安装</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#controller">创建控制器</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#example">例子</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#sample">样例项目</a></strong></li>
</ul>
<h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍###"></a>介绍###</h3><blockquote>
<p><strong>OData</strong>在**<a target="_blank" rel="noopener" href="http://www.odata.org/">其官网</a><strong>的定义是：<br> 允许以一种 **简单且标准</strong>的方式创建和使用<strong>可查询的、可互操作的</strong>RESTful APIs。</p>
</blockquote>
<p>在ABP中也可以使用OData。**<a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Abp.Web.Api.OData">Abp.Web.Api.OData</a>** nuget包简化了它的使用。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装###"></a>安装###</h3><h4 id="安装Nuget包"><a href="#安装Nuget包" class="headerlink" title="安装Nuget包"></a>安装Nuget包</h4><p>我们应该首先将Abp.Web.Api.OData nuget包安装到WebApi项目中：<br> <code>Install-Package Abp.Web.Api.OData</code></p>
<h4 id="设置模块依赖"><a href="#设置模块依赖" class="headerlink" title="设置模块依赖"></a>设置模块依赖</h4><p>给我们的WebApi项目设置的模块设置AbpWebApiODataModule的依赖。例如：</p>
<pre class=" language-C#"><code class="language-C#">[DependsOn(typeof(AbpWebApiODataModule))]
public class MyProjectWebApiModule : AbpModule
{
    ...
}
</code></pre>
<p>请查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPModuleSystem.html">模块系统</a>**来理解模块依赖。</p>
<h4 id="配置实体类"><a href="#配置实体类" class="headerlink" title="配置实体类"></a>配置实体类</h4><p>OData要求声明那些可以用作OData资源的实体。我们应该在WebApi项目模块的PreInitialize方法中处理这件事，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">[DependsOn(typeof(AbpWebApiODataModule))]
public class MyProjectWebApiModule : AbpModule
{
    public override void PreInitialize()
    {
        var builder = Configuration.Modules.AbpWebApiOData().ODataModelBuilder;

        //Configure your entities here...
        builder.EntitySet<Person>("People");
    }

    ...
}
</code></pre>
<p>这里，我们得到了ODataModelBuilder的引用并设置了Person实体。类似地，你可以使用EntitySet来添加其他的实体。这里格外需要注意的是，括号里面的字符串People是指的控制器的前缀，这里我的控制器是PeopleController，当然你也可以设置为Persons等，我这里只是想说明要填的字符串更数据库的表名和自己定义的实体名没有关系。</p>
<p>查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ODataAspNetWebAPI.html">使用ASP.NET Web API 2创建OData v4 终结点</a>**获取更多关于builder的信息。</p>
<h3 id="创建控制器"><a href="#创建控制器" class="headerlink" title="创建控制器###"></a>创建控制器###</h3><p>Abp.Web.Api.OData nuget包 包括了<strong>AbpODataEntityController</strong>基类（它扩展了标准的ODataController），这样就可以更容易地创建控制器了。下面是一个为Person实体创建一个OData终端（endpoint）的例子：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonsController : AbpODataEntityController<Person>
{
    public PersonsController(IRepository<Person> repository)
        : base(repository)
    {
    }
}
</code></pre>
<p>就是这么简单，AbpODataEntityController的所有方法都是<strong>virtual</strong>声明的。这意味着你可以重写 ** Get, Post, Put, Patch, Delete**和其他的action方法以及添加自己的逻辑。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子###"></a>例子###</h3><p>下面看一个例子：<br> 我的应用的端口是：localhost:61759。这里我只演示一些基本的东西，因为OData是一个标准的协议，所以你可以在网上轻松地找到更高级的例子。</p>
<p>数据库中People表的数据如下图：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160121153817328-1398128883.png" alt="img"></p>
<h4 id="获取实体列表"><a href="#获取实体列表" class="headerlink" title="获取实体列表"></a>获取实体列表</h4><p>这里我来获取所有的Person:</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122174713984-423656261.png" alt="img"></p>
<h4 id="获取单个实体"><a href="#获取单个实体" class="headerlink" title="获取单个实体"></a>获取单个实体</h4><p>获取Id=2的那个Person的数据：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122174940953-254380383.png" alt="img"></p>
<h4 id="获取具有导航属性的单个实体"><a href="#获取具有导航属性的单个实体" class="headerlink" title="获取具有导航属性的单个实体"></a>获取具有导航属性的单个实体</h4><p>修改实体类的定义，重新定义如下：</p>
<p>Person实体的定义：</p>
<pre class=" language-C#"><code class="language-C#">namespace ABPMVCTest.Entities
{
    [Table("Persons")]
    public class Person:Entity
    {
        public virtual string Name { get; set; }
        public virtual bool Gender { get; set; }
        public virtual string UserName { get; set; }
        public virtual ICollection<Car> Cars { get; set; }

        public Person()
        {
        }

        public Person(string name, params Car[] cars)
        {
            Name = name;
            if (cars!=null)
            {
                Cars=new Collection<Car>();
                foreach (var car in cars)
                {
                    car.Person = this;
                    Cars.Add(car);
                }
            }
        }
    }
}
</code></pre>
<p>Car实体的定义：</p>
<pre class=" language-C#"><code class="language-C#">namespace ABPMVCTest.Entities
{
    [Table("Cars")]
    public class Car:Entity
    {
        public virtual Person Person{ get; set; }
        public virtual int PersonId { get; set; }
        public virtual CarBrand Brand { get; set; }
        public virtual int Price{ get; set; }

        public Car()
        {
        }

        public Car(CarBrand brand, int price)
        {
            Brand = brand;
            Price = price;
        }
    }
}
</code></pre>
<p>CarBrand（汽车品牌）实体的定义：</p>
<pre class=" language-C#"><code class="language-C#">namespace ABPMVCTest.Entities
{
    public enum CarBrand
    {
        Jeep,
        Buick,
        Lincoln,
        Kia,
        LandRover
    }
}
</code></pre>
<p>修改实体类之后，接下来给数据库填充数据。新增了3个人，Id分别是7，6，9；在Car表中分别给这三个人分配了汽车，如下图：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122183825828-1873120117.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122183922390-1076933148.png" alt="img"></p>
<p>比如获取小明（Id=7）的数据，它具有一个Car导航属性，该属性代表此人的汽车对象：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122183715906-1511156500.png" alt="img"></p>
<h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><p>下面将数据库的数据进行修改，如下图：<br> Persons表的数据：<br> <img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123182609422-9276329.png" alt="img"></p>
<p>Cars表的数据：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123180543562-2039656379.png" alt="img"></p>
<p>这里演示一个更高级的查询，包括过滤，排序和获取前2个结果，借助postman来演示：<br> 查询条件是：Id&lt;4，OrderBy UserName Desc，取前两条数据</p>
<p><strong>请求</strong><br> <code>http://localhost:61759/odata/People?$filter=Id lt 4&amp;$orderby=UserName&amp;$top=2</code></p>
<p><strong>响应</strong></p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123183405843-395742129.png" alt="img"></p>
<p>可以看到，只过滤出来了小红和小刚的数据。</p>
<p>OData支持分页，排序，过滤，投影以及更多。<br> 请查看**<a target="_blank" rel="noopener" href="http://www.odata.org/">官方文档</a>**获取更多信息。</p>
<h4 id="创建一个新实体"><a href="#创建一个新实体" class="headerlink" title="创建一个新实体"></a>创建一个新实体</h4><p>在这个例子中，我们将创建一个新的Person，借助postman，很容易发送一个post请求。</p>
<p><strong>请求</strong><br> 注意这里的报文头为Content-Type:”application/json”<br> <img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123185400562-1792073851.png" alt="img"></p>
<p><strong>响应</strong><br> <img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123185407437-1943751319.png" alt="img"></p>
<p>去数据库查看一下，发现已经多了一条刚才post的数据：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123185642172-1269839742.png" alt="img"></p>
<p>当然了，我们也可以更新和删除实体，这里就不再做演示了，大家自行练习。</p>
<h4 id="获取元数据【MetaData】"><a href="#获取元数据【MetaData】" class="headerlink" title="获取元数据【MetaData】"></a>获取元数据【MetaData】</h4><p>我们还可以获得实体的元数据，如下所示：</p>
<p><strong>请求</strong></p>
<pre><code>http://localhost:61759/odata/$metadata
</code></pre>
<p><strong>响应</strong></p>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">edmx:</span>Edmx</span> <span class="token attr-name">Version</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>edmx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://docs.oasis-open.org/odata/ns/edmx<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">edmx:</span>DataServices</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Schema</span> <span class="token attr-name">Namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ABPMVCTest.Entities<span class="token punctuation">"</span></span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://docs.oasis-open.org/odata/ns/edm<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EntityType</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Key</span><span class="token punctuation">></span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PropertyRef</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
        
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Key</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.String<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Gender<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Boolean<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UserName<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.String<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Int32<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>NavigationProperty</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Cars<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Collection(ABPMVCTest.Entities.Car)<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
      
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EntityType</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EntityType</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Car<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Key</span><span class="token punctuation">></span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PropertyRef</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
        
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Key</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>PersonId<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Int32<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Brand<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ABPMVCTest.Entities.CarBrand<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Price<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Int32<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Int32<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>NavigationProperty</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Person<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ABPMVCTest.Entities.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ReferentialConstraint</span> <span class="token attr-name">Property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>PersonId<span class="token punctuation">"</span></span> <span class="token attr-name">ReferencedProperty</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
        
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>NavigationProperty</span><span class="token punctuation">></span></span>
      
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EntityType</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EnumType</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CarBrand<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Jeep<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Buick<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Lincoln<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Kia<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>LandRover<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
      
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EnumType</span><span class="token punctuation">></span></span>
    
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Schema</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Schema</span> <span class="token attr-name">Namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Default<span class="token punctuation">"</span></span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://docs.oasis-open.org/odata/ns/edm<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EntityContainer</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EntitySet</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>People<span class="token punctuation">"</span></span> <span class="token attr-name">EntityType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ABPMVCTest.Entities.Person<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
      
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EntityContainer</span><span class="token punctuation">></span></span>
    
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Schema</span><span class="token punctuation">></span></span>
  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">edmx:</span>DataServices</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">edmx:</span>Edmx</span><span class="token punctuation">></span></span>
</code></pre>
<h3 id="样例项目"><a href="#样例项目" class="headerlink" title="样例项目###"></a>样例项目###</h3><p>你可以在Github上获得样例代码，**<a href="https://github.com/aspnetboilerplate/sample-odata">点击查看</a>**</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">蒋岳生</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://github.com/jiayueshe/jiayueshe.github.io/2021/03/22/abp/abp-bo-ke-shou-ji-00/">https://github.com/jiayueshe/jiayueshe.github.io/2021/03/22/abp/abp-bo-ke-shou-ji-00/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">蒋岳生</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/abp/">
                                    <span class="chip bg-color">abp</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2021/03/22/abp/abp-bo-ke-shou-ji-00/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/8.jpg" class="responsive-img" alt="abp学习博客（2016收录）">
                        
                        <span class="card-title">abp学习博客（2016收录）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            ABP理论学习
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-03-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/abp/" class="post-category">
                                    abp
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/abp/">
                        <span class="chip bg-color">abp</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/03/20/kaikeba/biao-dan-she-ji-qi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="低代码平台——可视化表单">
                        
                        <span class="card-title">低代码平台——可视化表单</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            低代码平台——可视化表单
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-03-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/" class="post-category">
                                    可视化
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0/">
                        <span class="chip bg-color">低代码平台</span>
                    </a>
                    
                    <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96%E8%A1%A8%E5%8D%95/">
                        <span class="chip bg-color">可视化表单</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">JiangYuesheng</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">169.8k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/jiayueshe/jiayueshe.github.io" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>
    

        
            <a href="mailto:732767079@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
                <i class="fas fa-envelope-open"></i>
            </a>
            

                <!-- 

 -->

                
                    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=732767079" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 732767079" data-position="top" data-delay="50">
                        <i class="fab fa-qq"></i>
                    </a>
                    
                        <!-- 


 -->

                        
                            <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
                                <i class="fas fa-rss"></i>
                            </a>
                            </div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
