<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="abp学习博客（2016收录）, IT 学习 资源站 C# CAD .net core EF Javascript Flutter TypeScript 数据结构 算法 网络 测试 产品">
    <meta name="description" content="IT 学习 资源站 C# CAD .net core EF Javascript Flutter TypeScript 数据结构 算法 网络 测试 产品">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>abp学习博客（2016收录） | IT 学习 资源</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="IT 学习 资源" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">IT 学习 资源</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">IT 学习 资源</div>
        <div class="logo-desc">
            
            IT 学习 资源站 C# CAD .net core EF Javascript Flutter TypeScript 数据结构 算法 网络 测试 产品
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/jiayueshe/jiayueshe.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/jiayueshe/jiayueshe.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/8.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">abp学习博客（2016收录）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="container content">

    
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/abp/">
                                <span class="chip bg-color">abp</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/abp/" class="post-category">
                                abp
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-03-22
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-03-21
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    67.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    254 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><strong>作者：<a target="_blank" rel="noopener" href="http://farb.cnblogs.com/">tkb至简</a>    来源：<a target="_blank" rel="noopener" href="http://farb.cnblogs.com/">http://farb.cnblogs.com/</a></strong></p>
<h1 id="ABP理论学习之开篇介绍"><a href="#ABP理论学习之开篇介绍" class="headerlink" title="     ABP理论学习之开篇介绍         "></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPIntro.html">     ABP理论学习之开篇介绍         </a></h1><p><strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPTheory.html">返回总目录</a></strong></p>
<hr>
<p>为了和2016年春节赛跑，完成该系列博客，我牺牲了今天中午的时间来完成该系列的第一篇————开篇介绍。开篇介绍嘛，读过大学教材的同学都知道，这玩意总是那么无聊，跟考试没关系，干脆直接跳过，呵呵，多么美好的大学时光啊！不过，现在想想，开篇介绍确实不怎么重要，它只是告诉我们今后我要开始讲什么了，主要讲什么，大概浏览下重点。<br> 哦了，不扯了，时间不多了，干活！</p>
<hr>
<h2 id="本篇目录"><a href="#本篇目录" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPIntro.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPIntro.html#sample">快速样例</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPIntro.html#others">其他</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPIntro.html#startup">启动模板</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPIntro.html#touse">如何使用</a></strong></li>
</ul>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍###"></a>介绍###</h3><p>我们总是基于不同的需求创建不同的应用，但是在一定程度上，总在反复地实现通用而相似的结构。这些通用的结构包括<strong>授权，验证，异常处理，日志，本地化，数据库连接管理，设置管理，审计日志等</strong>。而且，我们总是在构建体系结构和最佳实践，比如<strong>分层</strong>和<strong>模块化</strong>架构，<strong>领域驱动设计（DDD），依赖注入等等</strong>。同时也在尝试基于<strong>惯例</strong>开发应用。</p>
<p>因为这些都是非常耗时的，并且对于每个项目单独创建是很困难的，所以很多公司都会创建自己私有的框架。通过使用私有的框架，他们总是可以快速地开发新的应用，同时应用的bug又会更少。当然了，不是所有的公司都是那么幸运了，你以为中国所有的公司都是BAT啊？！大多数公司还是没有<strong>时间，预算和团队</strong>来开发他们自己的私人框架。即使他们有可能构建这么一个框架，<strong>写文档，培训开发者以及维护</strong>也是很难的。</p>
<p>ABP是一个<strong>开源的且文档友好的应用框架</strong>，起始的想法是，“开发一款为所有公司和开发者通用的框架！”。它不仅仅是一个框架，更提供了一个基于<strong>DDD</strong>和<strong>最佳实践</strong>的健壮的<strong>体系模型</strong>。</p>
<h3 id="快速样例"><a href="#快速样例" class="headerlink" title="快速样例###"></a>快速样例###</h3><p>一起来研究一个简单的类来看看ABP有哪些好处 ：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService, ITaskAppService
{
    private readonly IRepository<Task> _taskRepository;

    public TaskAppService(IRepository<Task> taskRepository)
    {
        _taskRepository = taskRepository;
    }

    [AbpAuthorize(MyPermissions.UpdatingTasks)]
    public async Task UpdateTask(UpdateTaskInput input)
    {
        Logger.Info("Updating a task for input: " + input);

        var task = await _taskRepository.FirstOrDefaultAsync(input.TaskId);
        if (task == null)
        {
            throw new UserFriendlyException(L("CouldNotFoundTheTaskMessage"));
        }

        input.MapTo(task);
    }
}
</code></pre>
<p>这里我们看到了一个简单的应用服务方法。在DDD中，表现层直接使用应用服务来执行该应用的<strong>用例</strong>（其实就是一些操作方法）。我们还可以考虑使用Ajax调用上面的<em>UpdateTask</em>方法。</p>
<p>下面让我们总结一下ABP的一些优点：</p>
<ul>
<li><strong>依赖注入</strong>：ABP使用并提供了一个健壮而又传统的DI基础设施。因为上面的类是在一个应用服务中定义的，所以它会按照惯例约定短暂地（每个请求创建一次）注册到DI容器中。它也简单地注入了所有依赖（本例中注入了<em>IRepository</em>）。</li>
<li><strong>仓储</strong>：ABP可以为每一个实体创建一个默认的仓储（本例中是<em>IRepository</em>）。默认的仓储有许多有用的方法，如本例中的 <em>FirstOrDefault</em>。我们也可以根据我们的需求轻易地扩展默认仓储。仓储抽象了DBMS和ORM，并简化了数据的访问逻辑。</li>
<li><strong>授权</strong>：ABP可以检测权限。如果当前的用户没有“updating task”的权限或者没登录，那么ta不能访问<em>UpdateTask</em>方法。它使用声明式的特性简化了授权，而且还有其他的授权方法。</li>
<li><strong>验证</strong>：ABP会自动检测输入是否为null。它也基于标准的数据注解特性和自定义的验证规则验证输入对象的所有属性。如果请求不合法，那么它会抛出一个合适的验证异常。</li>
<li><strong>审计日志</strong>：用户，浏览器，IP地址，调用服务，方法，参数，调用时间，执行时长和其他的一些信息也会基于惯例和配置为每个请求自动地保存。</li>
<li><strong>工作单元（Unit of Work）</strong>：在ABP中，每个应用服务方法默认视为一个工作单元。它会自动创建一个连接并在方法的开始位置开启一个事务。如果方法不报异常地成功完成了，那么事务会提交并且连接被释放。即使该方法使用了不同的仓储或者方法，它们全部也都是原子的（事务的）。当事务提交时，实体的所有改变都会自动保存。因此，正如这里展示的那样，我们甚至都不用调用**_repository.Update(task)**方法。</li>
<li><strong>异常处理</strong>：在一个使用了ABP框架的Web应用中，我们基本上不用处理异常。所有的异常都会默认自动处理。如果一个异常发生了，那么ABP会自动地记录它，然后返回给客户端一个合适的结果。比如，如果这是一个Ajax请求，那么它会返回一个JSON到客户端，指明发生了一个错误。本例中使用了一个<em>UserFriendlyException</em>，这样就隐藏了客户端实际的异常信息。它也理解并处理客户端的错误，最后将合适的信息呈现给用户。</li>
<li><strong>日志</strong>：我们可以使用在基类中定义的Logger来写日志。ABP默认使用了Log4Net，但是它是可改变的或可配置的。</li>
<li><strong>本地化（Localization）</strong>：注意当抛出异常的时候我们使用了L方法。因此，它会基于当前用户的文化自动进行本地化。当然，我们可以在某些地方定义<em>CouldNotFoundTheTaskMessage</em>。</li>
<li><strong>自动映射</strong>：上面的最后一行代码，我们使用了ABP的MapTo扩展方法将输入对象的属性映射到实体属性。它使用了AutoMapper库来执行映射。因此，我们可以基于命名惯例轻易地将属性从一个对象上映射到另一个对象上。我的AutoMapper系列学习博客：**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/AutoMapperContent.html">http://www.cnblogs.com/farb/p/AutoMapperContent.html</a> **。</li>
<li><strong>动态Web API层</strong>：实际上，<em>TaskAppService</em> 是一个简单的类（甚至不需要从<em>ApplicationService</em> 继承）。我们一般会写一个Web API Controller包装器来将方法暴露给javascript客户端。ABP在运行时会自动完成。这样，我们可以从客户端直接使用应用服务方法。</li>
<li><strong>动态Ajax代理</strong>：ABP创建了javascript代理方法，它们可以调用应用服务方法就像调用客户端的javascript方法一样简单。</li>
</ul>
<p>在这么一个简单的类中，我们看到了ABP的优势。所有的这些任务正常情况下都是要花费很多时间的，但是所有的这些ABP自动帮我们完成了。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他###"></a>其他###</h3><p>除了这个简单的例子，ABP也提供了一个健壮的基础设施和应用模型。下面是ABP的一下其他特征：</p>
<ul>
<li>模块化：提供了一个健壮的基础设施来生成可复用的模块。</li>
<li>数据过滤器：提供了自动的数据过滤来实现一些模式，比如软删除和多租户。</li>
<li>多租户：支持单数据库、多客户形式的多租户。</li>
<li>设置管理：提供了健壮的基础设施类获得或者更改应用，租户和用户级别的设置。</li>
<li>单元测试和集成测试：基于可测试性构建，也提供了一些基类来简化单元测试和集成测试。</li>
</ul>
<p>更多的特征，请认真阅读其他文档。</p>
<h3 id="启动模板"><a href="#启动模板" class="headerlink" title="启动模板###"></a>启动模板###</h3><p>开始一个新的解决方案，创建层，安装nuget包，创建一个简单的布局和菜单…所有的这些都是非常耗时的。</p>
<p>ABP提供了一个预生成的**<a target="_blank" rel="noopener" href="http://www.aspnetboilerplate.com/Templates">启动模板</a><strong>，有了它，创建一个新的解决方案更容易了。模板支持</strong>SPA（单页应用）<strong>和</strong>MPA（多页应用）**。而且，我们可以选择不同的ORM。</p>
<h1 id="ABP理论学习之N层架构"><a href="#ABP理论学习之N层架构" class="headerlink" title="     ABP理论学习之N层架构         "></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html">     ABP理论学习之N层架构         </a></h1><p>自从写这个系列博客之后，发现很多园友还是希望有个直接运行的demo，其实在github上就有官方的demo，我直接把这demo的链接放到这里吧，另外，我分析，这些找不到demo的同学，很可能是不怎么用github，可能的原因就是英文不好。所以还是希望程序员多看看英文文档，一开始看得很慢不要紧，时间久了，速度绝对能上去。因为都是技术性的文章，没有特别难的语法，能让大家退而却步的最多是些生词，这个就要靠大家积累常见的词汇了，一些生僻词的话查一下意思，理解了那句话就可以过了。</p>
<p>跟ABP相关的所有源码，包括zero，demo，都在这个目录下了，大家可以一个个点击看一下。下面做一稍微解释。</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211000853121-406694237.png" alt="img"><br> <img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211001224840-1457640679.png" alt="img"><br> <img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211001755105-1002490250.png" alt="img"></p>
<hr>
<h2 id="本篇目录-1"><a href="#本篇目录-1" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#intro">介绍</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#abp">ABP架构</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#domain">领域层</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#app">应用层</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#infra">基础设施层</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#ui">Web和展现层</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#other">其他</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNLayer.html#summary">总结</a></strong></li>
</ul>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍###"></a>介绍###</h3><p>对应用代码基进行分层可以帮助降低复杂度和提高代码复用性，这已经成为广为接受的技巧。为了实现分层的架构，ABP遵循以下<strong>DDD（领域驱动模型）</strong>的原则。在DDD中，有四个基础层：</p>
<ul>
<li><strong>表现层</strong>：用户访问的接口，使用应用层实现用户交互。</li>
<li><strong>应用层</strong>：表现层和领域层之间的媒介。负责组织业务对象，以执行特定的应用任务。</li>
<li><strong>领域层</strong>：包括业务对象和原则。这是应用的核心。</li>
<li><strong>基础设施层</strong>：为支持更高层提供了广泛的技术能力。基础设施层的一个例子是仓储，它可以通过ORM框架和数据库进行交互。</li>
</ul>
<p>也可能会加入额外必要的层。以下就是一个例子：</p>
<ul>
<li><strong>分布式服务层</strong>：将应用的功能暴露给远程客户端。可以提供这个层的工具包括Asp.Net Web API和WCF。</li>
</ul>
<p>这些都是以领域为中心的架构的通用层次。基于实现的话，可能还会稍有不同。</p>
<h3 id="ABP架构"><a href="#ABP架构" class="headerlink" title="ABP架构###"></a>ABP架构###</h3><p>层次和结构的概览如下图所示：<br> <img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211005057090-801424200.png" alt="img"><br> 实际解决方案中的项目分层如下：<br> <img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151211005342715-1812391209.png" alt="img"></p>
<p>一层可以为一个或多个程序集。对于第三方依赖创建不止一个程序集可能会特别好（比如NHibernate）。</p>
<h4 id="领域层"><a href="#领域层" class="headerlink" title="领域层"></a>领域层</h4><p>领域层是所有的业务规则实现的地方。</p>
<p>实体代表了业务领域的数据和操作。在实践中，它们一般会映射到数据库的表中。</p>
<p>仓储式跟集合很像的对象，使用仓储可以检索数据源（数据库）上的实体，并将实体持久化到数据源上。领域层只是定义了仓储，但是并没有实现它们，它们是在基础设施层实现的。</p>
<p><strong>领域事件</strong>定义了领域特定的事件，也包括触发和处理这些事件。领域服务借助实体运行，并实现了不属于单个实体的业务规则。</p>
<p><strong>工作单元</strong>是一种管理实体的设计模式，这些实体受业务逻辑影响，并将状态持久化到数据存储中。</p>
<p>领域层应该尽可能地独立于第三方的库。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层包含了展现层使用的应用服务。应用服务方法接收一个DTO（数据传输对象）作为输入参数，使用这个输入对象执行一些特定的领域层操作，然后，如果需要的话，可能返回另一个DTO。一般而言，应用服务方法不接收或者返回一个实体对象，这样做的好处就是可以允许展现层可以从领域层中将实体抽象出来，而不受实体的约束。一个应用服务方法一般被看作是一个工作单元。用户输入验证也是在这一层实现的。ABP提供了一个基础设施，因此可以很容易地实现验证。建议使用一个将实体映射为DTO的工具，比如AutoMapper,TinyMapper等。要学习AutoMapper的使用，请查看我的**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/AutoMapperContent.html">AutoMapper系列博客</a>**吧！</p>
<h4 id="基础设施层"><a href="#基础设施层" class="headerlink" title="基础设施层"></a>基础设施层</h4><p>虽然领域层定义了仓储接口，但是基础设施层使用诸如NHibernate或者EntityFramework的ORM工具实现了那些仓储接口。ABP提供了使用这两种ORM框架的基类。基础设施层用于抽象来自其他层的第三方类库，数据库迁移（Database Migration）也可以用在这一层。</p>
<h4 id="Web和展现层"><a href="#Web和展现层" class="headerlink" title="Web和展现层"></a>Web和展现层</h4><p>Web层使用ASP.NET MVC和Web API实现的。这里可以使用两种不同的方式来实现：单页面应用和多页面应用。</p>
<p>在单页面应用中（SPA）,所有的资源都会一次性加载到客户端（或者只加载核心资源，懒加载其他资源），所有的后续和服务器的交互都是通过Ajax调用。Html代码是使用从服务端接收到的数据在客户端生成的。整个页面不会刷新，视图只是在必要时换入换出。有许多的Javascript SPA框架，比如AngularJs，DurandalJs,BackboneJs和EmberJs。ABP可以使用它们中的任何一个，但是提供了使用 AngularJs和DurandalJs的样例。</p>
<p>在多页面（经典）应用中(MPA)，客户端向服务端发送请求，服务端代码（ASP.NET MVC 控制器）从数据库中获取数据，然后Razor视图引擎生成html 代码。这些编译后的页面发回给客户端显示。每个新的页面都会导致完整页面的刷新。</p>
<p>SPA和MPA涉及了完全不同的架构。对于后台管理系统来说，SPA是最好的候选者，另一方面，博客更适合MPA模型，因为博客渴望被搜索引擎抓取数据。虽然有很多工具可以使SPA对于搜索引擎可见，但是目前的一般做法就是使用MPA。</p>
<p><strong>SignalR</strong>是发送服务端到客户端的推送通知的最好工具，也可以给用户提供一个丰富而且实时的体验。</p>
<p>在客户端还有很多javascript库和框架。**<a target="_blank" rel="noopener" href="http://jquery.com/">jQuery</a><strong>是这个领域最流行的，并伴有成千上万的插件。也有很多很容易就能使用Html和CSS的框架或工具。比如，</strong><a target="_blank" rel="noopener" href="http://getbootstrap.com/">Twitter Bootstrap</a>**是非常流行的HTML/CSS框架。</p>
<p>ABP提供了使用应用服务层自动创建Web API层的基础设施，使用Javascript可以轻松地调用Web API（**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/4949679.html">看文档</a>**）。而且，还提供了管理管理应用菜单，本地化以及语言切换的基础设施，还包含了统一的Javascript API来简化显示系统的信息和通知。</p>
<p>ABP自动处理服务端的异常，并给客户端返回一个合适的响应。</p>
<h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><p>ABP通过**<a target="_blank" rel="noopener" href="http://docs.castleproject.org/Windsor.MainPage.ashx">Castle Windsor</a>**使用并支持依赖注入，也使用了Log4Net来记录服务端的日志，然而，通过使用Castle的日志设备无需改变代码就可以切换到其他的日志库。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结###"></a>总结###</h3><p>ABP平衡了一些最好的框架或者类库，除此之外，ABP自己的类和系统也提供了一个很好的用于N层架构Web应用构建的基础设施，也提供了很轻松地创建分层的解决方案的**<a target="_blank" rel="noopener" href="http://www.aspnetboilerplate.com/Templates">模板</a>**，用作应用的起点</p>
<h1 id="ABP理论学习之模块系统"><a href="#ABP理论学习之模块系统" class="headerlink" title="ABP理论学习之模块系统"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html">ABP理论学习之模块系统</a></h1><p><strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPTheory.html">返回总目录</a></strong></p>
<hr>
<h2 id="本篇目录-2"><a href="#本篇目录-2" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html#intro">模块介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html#events">生命周期事件</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html#yilai">模块依赖</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPModuleSystem.html#custom">自定义模块方法</a></strong></li>
</ul>
<h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍###"></a>模块介绍###</h3><p>ABP提供了构建模块并将这些模块组合起来创建应用的基础设施。一个模块可以依赖另一个模块。一般来说，一个程序集可以认为是一个模块。一个模块是由一个派生了<strong>AbpModule</strong>的类定义的。比如说我们在开发一个可以用在不同的应用中的博客模块。最简单的模块定义如下：</p>
<pre class=" language-C#"><code class="language-C#">public class MyBlogApplicationModule : AbpModule
{
    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}
</code></pre>
<p>ABP扫描所有的程序集，并找出所有的派生自AbpModule基类的类。如果你创建了不止一个程序集的应用，那么建议为每个程序集创建一个模块定义。</p>
<h3 id="生命周期事件"><a href="#生命周期事件" class="headerlink" title="生命周期事件###"></a>生命周期事件###</h3><p>ABP在应用启动和关闭的时候会调用一些特定的模块方法。你可以重写这些方法来执行特定的任务。</p>
<p>ABP<strong>按照依赖的顺序</strong>调用这些方法。如果模块A依赖于模块B，那么模块B在模块A之前初始化。方法执行的正确顺序是：<strong>PreInitialize-B, PreInitialize-A, Initialize-B, Initialize-A, PostInitialize-B and PostInitialize-A</strong>。这对于所有的依赖图都是成立的。Shutdown方法也是类似的，但顺序相反。</p>
<h4 id="PreInitialize"><a href="#PreInitialize" class="headerlink" title="PreInitialize"></a>PreInitialize</h4><p>该方法会在应用启动时首先调用。你可以在该方法里面写一些特定的代码，这些代码会在依赖注入注册之前执行。比如，如果你创建了一个传统的注册类，那么你应该把它在这里注册（使用locManager.AddConventionalRegister方法）。你也可以注册到IOC容器的事件…等等。</p>
<h4 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h4><p>该方法通常是依赖注入注册的地方。一般使用IocManager.RegisterAssemblyByConvention方法完成。如果你想要定义自定义的依赖注册，请看后面的依赖注入文档。</p>
<h4 id="PostInitialize"><a href="#PostInitialize" class="headerlink" title="PostInitialize"></a>PostInitialize</h4><p>该方法在应用启动的最后调用。在这里可以安全地解析一个依赖。</p>
<h4 id="Shutdown"><a href="#Shutdown" class="headerlink" title="Shutdown"></a>Shutdown</h4><p>该方法在应用关闭的时候调用。</p>
<h3 id="模块依赖"><a href="#模块依赖" class="headerlink" title="模块依赖###"></a>模块依赖###</h3><p>一个模块可以独立于另一个模块。ABP会自动地尝试解析这些依赖，但是建议通过重写GetDependencies方法来显式声明依赖，正如下面那样：</p>
<pre class=" language-C#"><code class="language-C#">[DependsOn(typeof(MyBlogCoreModule))]
public class MyBlogApplicationModule : AbpModule
{
    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}
</code></pre>
<p>这样，我们声明ABP：MyBlogApplicationModule依赖于MyBlogCoreModule,因而该核心模块MyBlogCoreModule会在应用模块MyBlogApplicationModule之前进行初始化。</p>
<h3 id="自定义模块方法"><a href="#自定义模块方法" class="headerlink" title="自定义模块方法###"></a>自定义模块方法###</h3><p>你的模块也可以有一些自定义的方法，这些方法可以被依赖于该模块的其他模块所使用。假设MyModule2依赖于MyModule1，且MyModule2想要在PreInitialize事件中调用一个MyModule1的方法。</p>
<pre class=" language-C#"><code class="language-C#">public class MyModule1 : AbpModule
{
    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }

    public void MyModuleMethod1()
    {
        //这是该模块的自定义方法
    }
}

[DependsOn(typeof(MyModule1))]
public class MyModule2 : AbpModule
{
    private readonly MyModule1 _myModule1;

    public MyModule2(MyModule1 myModule1)
    {
        _myModule1 = myModule1;
    }

    public override void PreInitialize()
    {
        _myModule1.MyModuleMethod1(); //Call MyModule1's method
    }

    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}
</code></pre>
<p>这里，我们通过构造函数将MyModule1z注入到了MyModule2，因此MyModule2可以调用MyModule1的自定义方法</p>
<h1 id="ABP理论学习之启动配置"><a href="#ABP理论学习之启动配置" class="headerlink" title="     ABP理论学习之启动配置         "></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPStartupConfig.html">     ABP理论学习之启动配置         </a></h1><p><strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPTheory.html">返回总目录</a></strong></p>
<hr>
<h2 id="本篇目录-3"><a href="#本篇目录-3" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPStartupConfig.html#abp">配置ABP</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPStartupConfig.html#module">配置模块</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPStartupConfig.html#createSetting">为模块创建配置</a></strong></li>
</ul>
<p>为了在应用启动时配置ABP和模块，ABP提供了一个基础设施。</p>
<h3 id="配置ABP"><a href="#配置ABP" class="headerlink" title="配置ABP###"></a>配置ABP###</h3><p>配置ABP是在模块的<strong>PreInitialize</strong>事件中完成的。下面的代码摘自Github上的Taskever（一个任务系统Demo）:</p>
<pre class=" language-C#"><code class="language-C#">public class SimpleTaskSystemModule : AbpModule
{
    public override void PreInitialize()
    {
        //为应用添加语言
        Configuration.Localization.Languages.Add(new LanguageInfo("en", "English", "famfamfam-flag-england", true));
        Configuration.Localization.Languages.Add(new LanguageInfo("tr", "Türkçe", "famfamfam-flag-tr"));

        //添加本地化资源
        Configuration.Localization.Sources.Add(
            new XmlLocalizationSource(
                "SimpleTaskSystem",
                HttpContext.Current.Server.MapPath("~/Localization/SimpleTaskSystem")
                )
            );

        //配置导航菜单
        Configuration.Navigation.Providers.Add<SimpleTaskSystemNavigationProvider>();
    }

    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}
</code></pre>
<p>ABP是基于模块化设计的。不同的模块都可以配置ABP。比如，不同的模块可以通过添加导航提供者来给主菜单添加自己的菜单选项。</p>
<h3 id="配置模块"><a href="#配置模块" class="headerlink" title="配置模块###"></a>配置模块###</h3><p>除了ABP框架自身的启动配置之外，模块也可以实现<strong>IAbpModuleConfigurations</strong>接口来为模块提供配置点。比如：</p>
<pre class=" language-C#"><code class="language-C#">...
using Abp.Web.Configuration;
...
public override void PreInitialize() 
{
    Configuration.Modules.AbpWeb().SendAllExceptionsToClients = true;
}
...
</code></pre>
<p>在本例中，我们配置了AbpWeb模块，目的是将所有的异常发送到客户端。</p>
<p>并不是每一个模块都应该定义这种类型的配置。一般是当一个模块需要在不同的应用中重用的时候，才需要在启动时进行配置。</p>
<h3 id="为模块创建配置"><a href="#为模块创建配置" class="headerlink" title="为模块创建配置###"></a>为模块创建配置###</h3><p>假设我们有一个叫做“MyModule”的模块，它有一些配置属性。首先，我们为这些配置属性创建一个类MyModuleConfig：</p>
<pre class=" language-C#"><code class="language-C#">public class MyModuleConfig
{
    public bool SampleConfig1 { get; set; }

    public string SampleConfig2 { get; set; }
}
</code></pre>
<p>然后，我们在MyModule的PreInitialize事件中将这个类MyModuleConfig注册到DI中（这样，MyModuleConfig就成为了可注册的类）：</p>
<pre><code>IocManager.Register&lt;MyModuleConfig&gt;();
</code></pre>
<p>最后，我们创建IModuleConfiguration的扩展方法来获得MyModuleConfig的引用。</p>
<pre class=" language-C#"><code class="language-C#">public static class MyModuleConfigurationExtensions
{
    public static MyModuleConfig MyModule(this IModuleConfigurations moduleConfigurations)
    {
        return moduleConfigurations.AbpConfiguration
            .GetOrCreate("MyModuleConfig",
                () => moduleConfigurations.AbpConfiguration.IocManager.Resolve<MyModuleConfig>()
            );
    }
}
</code></pre>
<p>现在，在应用启动时，其他的模块就可以配置这个模块了（在需要配置MyModule的模块的PreInitialize事件中）：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Modules.MyModule().SampleConfig1 = false;
Configuration.Modules.MyModule().SampleConfig2 = "test";
</code></pre>
<p>有时候，MyModule需要这样的配置。你可以注册MyModuleConfig，并使用配置的值。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class MyService : ITransientDependency
{
    private readonly MyModuleConfig _configuration;

    public MyService(MyModuleConfig configuration)
    {
        _configuration = configuration;
    }

    public void DoIt()
    {
        if (_configuration.SampleConfig2 == "test")
        {
            //...
        }
    }
}
</code></pre>
<p>这样，在ABP系统中，模块就可以创建集中配置点了，也就是说模块可以集中起来配置了。</p>
<p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321131332998.png" alt="image-20210321131332998"></p>
<p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321131519767.png" alt="image-20210321131519767"></p>
<h1 id="ABP理论学习之多租户"><a href="#ABP理论学习之多租户" class="headerlink" title="     ABP理论学习之多租户         "></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMultiTenancy.html">     ABP理论学习之多租户         </a></h1><h1 id><a href="#" class="headerlink" title="         "></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMultiTenancy.html">         </a></h1><p><strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPTheory.html">返回总目录</a></strong></p>
<hr>
<h2 id="本篇目录-4"><a href="#本篇目录-4" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMultiTenancy.html#what">什么是多租户</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMultiTenancy.html#abpMultiTenancy">ABP中的多租户</a></strong></li>
</ul>
<h3 id="什么是多租户"><a href="#什么是多租户" class="headerlink" title="什么是多租户###"></a>什么是多租户###</h3><p>维基百科：“软件<strong>多租户</strong>是指一种软件架构，在这种软件架构中，软件的<strong>一个实例</strong>运行在服务器上并且为多个租户服务”。一个租户是一组共享该软件实例特定权限的用户。有了多租户架构，软件应用被设计成为每个租户提供一个 <strong>专用的实例包括该实例的数据的共享</strong>，还可以共享配置，用户管理，租户自己的功能和非功能属性。多租户和多实例架构相比，多租户分离了代表不同的租户操作的多个实例。</p>
<p>多租户用于创建<strong>Saas（Software as-a service）</strong>应用（云处理）。有几种类型的多租户：</p>
<h4 id="多部署-多数据库"><a href="#多部署-多数据库" class="headerlink" title="多部署-多数据库"></a>多部署-多数据库</h4><p>这实际上不是多租户。但是，如果我们为<strong>每个</strong>具有<strong>分开数据库的</strong>客户（租户）运行该应用的一个实例，那么我们可以在单个服务器上为<strong>多个租户</strong>提供服务。我们可以确定该应用的多个实例在相同的服务器环境不会相互<strong>冲突</strong>。</p>
<p>这个对于一个不是为多租户设计的<strong>已存在应用</strong>也是可能的。创建这么一个应用更容易，因为该应用不需要了解多租户。但这种方式存在安装，使用和维护问题。</p>
<h4 id="单部署-多数据库"><a href="#单部署-多数据库" class="headerlink" title="单部署-多数据库"></a>单部署-多数据库</h4><p>在这种情况下，我们可以在一个服务器上运行应用的<strong>单个实例</strong>。对于每个登录用户，我们从<strong>master database</strong>中检测该用户的租户，并获得该租户的数据库信息（<strong>连接字符串</strong>）。然后我们可以将连接字符串存储到<strong>像session</strong>一样的变量中，同时，使用这个<strong>租户特定的</strong>连接字符串执行所有的数据库操作。</p>
<p>某种程度上，这样的应用应该设计成多租户。但是大多数的应用都独立于多租户。这种方式也存在一些安装，使用和维护问题。我们应该为每个租户创建并维护一个<strong>分离的数据库</strong>。</p>
<h4 id="单部署-单数据库"><a href="#单部署-单数据库" class="headerlink" title="单部署-单数据库"></a>单部署-单数据库</h4><p>这是最<strong>真实的多租户</strong>架构：我们只将具有<strong>单个数据库</strong>应用的<strong>单个实例</strong>部署到<strong>单个服务器</strong>上。在（RDBMS）每个表中，都存在一个<strong>TenantId</strong>（或相似）字段，该字段用于分离每个租户之间的数据。</p>
<p>这种方法安装和维护都很简单，但唯独创建这么一个应用很难，因为我们必须要阻止一个租户读取或写入其他租户的数据。我们可以为每个数据库的读取（select）操作添加一个<strong>TenantId过滤器</strong>。而且，我们可以在每次写入的时候检查一下该实体是否和<strong>当前的租户</strong>相关。这是乏味而易于出错的，但ABP通过使用<strong>自动的数据过滤</strong>帮助我们处理这个事情。</p>
<p>如果我们有很多具有大量数据的租户，那么这种方法可能会有性能问题。我们可以使用关系型数据库的表分割特征或者将租户按组分到不同的服务器上。</p>
<h3 id="ABP中的多租户"><a href="#ABP中的多租户" class="headerlink" title="ABP中的多租户###"></a>ABP中的多租户###</h3><p>ABP提供了创建<strong>单部署，单数据库，多租户</strong>架构的基础设施。</p>
<h4 id="开启多租户"><a href="#开启多租户" class="headerlink" title="开启多租户"></a>开启多租户</h4><p>多租户默认是关闭的。我们可以在模块的PreInitialize方法中开启，如下所示：</p>
<pre><code>Configuration.MultiTenancy.IsEnabled = true; 
</code></pre>
<h4 id="租主vs租户"><a href="#租主vs租户" class="headerlink" title="租主vs租户"></a>租主vs租户</h4><p>首先，我们应该定义多租户系统中的两个条目：</p>
<ul>
<li><strong>租主（Host）</strong>:租主是单例的（只有一个租主）。租主会对创建和管理租户负责。因此，一个“<strong>租主用户</strong>”比所有的租户等级更高，并独立于所有租户，同时还能控制他们。</li>
<li><strong>租户（Tenant）</strong>:租主的一个客户，具有自己的用户角色，权限，设置等。每个租户都可以完全独立于其他租户使用应用。一个多租户应用会有一个或多个租户。如果是一个CRM应用，那么不同的租户也有它们自己的账户，契约，产品和订单。因此，当我们说“**租户用户”的时候，意思就是一个租户拥有的用户。</li>
</ul>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>ABP定义了一个获取当前<strong>用户</strong>和<strong>租户</strong>id的<strong>IAbpSession</strong>接口。该接口用于多租户获取当前的租户id。因此，它可以基于当前的租户id过滤数据。ABP中有以下规则：</p>
<ul>
<li>如果UserId和TenantId都是null，那么当前的用户没有登录到系统。因此，我们可以不知道当前用户是否是一个租主用户还是一个租户用户。在这种情况下，用户不能访问授权的内容。</li>
<li>如果UserId不是null，TenantId是null，那么当前用户是一个租主用户。</li>
<li>如果UserId不是null，TenantId也不是null，那么当前用户是租户用户。</li>
</ul>
<p>更多关于session的信息请看后面的Session一节。</p>
<h4 id="数据过滤器"><a href="#数据过滤器" class="headerlink" title="数据过滤器"></a>数据过滤器</h4><p>当从数据库中检索实体时，我们必须添加一个TenantId过滤器来只获得当前的租户实体。当你为实体实现了<strong>IMustHaveTenant和IMayHaveTenant</strong>两个接口之一时，ABP会自动地完成数据过滤。</p>
<h4 id="IMustHaveTenant接口"><a href="#IMustHaveTenant接口" class="headerlink" title="IMustHaveTenant接口"></a>IMustHaveTenant接口</h4><p>该接口通过定义<strong>TenantId</strong>属性来区分不同租户的实体。一个实现了IMustHaveTenant的实体例子如下：</p>
<pre class=" language-C#"><code class="language-C#">public class Product : Entity, IMustHaveTenant
{
    public int TenantId { get; set; }
        
    public string Name { get; set; }
    
    //...其他属性
}
</code></pre>
<p>这样，ABP知道这是一个特定租户的实体，并且会自动地将一个租户的实体从其他实体中分离出来。</p>
<h4 id="IMayHaveTenant接口"><a href="#IMayHaveTenant接口" class="headerlink" title="IMayHaveTenant接口"></a>IMayHaveTenant接口</h4><p>我们可能需要在租户和租户之间共享一个<strong>实体类型</strong>。因此，一个实体可能会被一个租户或租主拥有。IMayHaveTenant接口也定义了<strong>TenantId</strong>(类似于IMustHaveTenant)，但在这种情况下是<strong>nullable</strong>。实现了IMayHaveTenant的一个实体例子：</p>
<pre class=" language-C#"><code class="language-C#">public class Role : Entity, IMayHaveTenant
{
    public int? TenantId { get; set; }
        
    public string RoleName { get; set; }
    
    //...其他属性
}
</code></pre>
<p>我们可能会使用相同的Role类来存储租主角色和租户角色。这种情况下，TenantId表明这是一个租户实体还是一个租主实体。null值表示这是一个<strong>租主</strong>实体，<strong>非null</strong>值表示这被一个<strong>租户</strong>拥有，该租户的Id是<strong>TenantId</strong>。</p>
<p>IMayHaveTenant不像IMustHaveTenant一样常用。比如，一个Product类可以不实现IMayHaveTenant接口，因为Product和实际的应用功能相关，和管理租户不相干。因此，要小心使用IMayHaveTenant接口，因为它更难维护租户和租主共享的代码。</p>
<h4 id="保存实体"><a href="#保存实体" class="headerlink" title="保存实体"></a>保存实体</h4><p>一个租户用户不应该创建或编辑其他租户的实体。如果相关的数据过滤器开启了，那么ABP会检查该实体相对于数据库的改变。</p>
<p>想要获得更多关于数据过滤器的信息，请看后面关于数据过滤器的博客。</p>
<h1 id="ABP理论学习之依赖注入"><a href="#ABP理论学习之依赖注入" class="headerlink" title="ABP理论学习之依赖注入"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html">ABP理论学习之依赖注入</a></h1><p><strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPTheory.html">录</a></strong></p>
<hr>
<h2 id="本篇目录-5"><a href="#本篇目录-5" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#what">什么是依赖注入</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#problem">传统方式产生的问题</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#solution">解决办法</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#framework">依赖注入框架</a></strong></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#infra">ABP中的依赖注入基础设施</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#register">注册</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#resolve">解析</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#extra">其他</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#integration">ASP.NET MVC和ASP.NET Web API集成</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDependencyInjection.html#tips">最后提示</a></strong></li>
</ul>
</li>
</ul>
<h3 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入###"></a>什么是依赖注入###</h3><blockquote>
<p>维基百科说：“依赖注入是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分。该模式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循了依赖反转和单一职责原则。与服务定位器模式形成直接对比的是，它允许客户端了解客户端如何使用该系统找到依赖”。</p>
</blockquote>
<p>不使用依赖注入技巧来管理依赖，并开发一个模块化的，结构友好的应用是非常困难的。</p>
<h4 id="传统方式产生的问题"><a href="#传统方式产生的问题" class="headerlink" title="传统方式产生的问题"></a>传统方式产生的问题</h4><p>在一个应用中，类相互依赖。假设我们有个应用服务，该应用服务使用了仓储将实体插入数据库。在这种情况下，此应用服务类依赖于仓储类。看下面这个例子：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService
{
    private IPersonRepository _personRepository;

    public PersonAppService()
    {
        _personRepository = new PersonRepository();            
    }

    public void CreatePerson(string name, int age)
    {
        var person = new Person { Name = name, Age = age };
        _personRepository.Insert(person);
    }
}
</code></pre>
<p><strong>PersonAppService</strong>使用了<strong>PersonRepository</strong>将一个 <strong>Person</strong>插入到数据库中。此处代码的问题在于：</p>
<ul>
<li>PersonAppService在<strong>CreatePerson</strong>方法中使用了<strong>IPersonRepository</strong>的引用，因此该方法依赖于IPersonRepository,而不是具体的PersonRepository类。但是在PersonAppService的构造函数中仍旧依赖于PersonRepository。而组件应该依赖于接口而不是实现，这就是依赖反转原则。</li>
<li>如果PersonAppService创建了PersonRepository本身，那么它会依赖于IPersonRepository接口的一个具体实现，这样就造成可能不会和其他实现一起工作。因此，从实现中分离接口就会变得毫无意义。硬依赖使得代码基变得紧耦合，可复用性降低。</li>
<li>在未来我们可能需要改变PersonRepository的创建。比如，我们可能想要它是单例的（单一公用的实例而不是每次使用都创建一个对象）。或者我们可能不止会创建实现了IPersonRepository的一个类，也可能想要有条件地创建这些实现类中的一个。这种情况下，我们就要改变依赖IPersonRepository的所有类，这样太不方便了，或者说维护难度太大了。</li>
<li>测试方面，有了这么个依赖，对于PersonAppService的单元测试非常难（或者根本不可能）。</li>
</ul>
<p>为了克服这些问题，可以使用工厂模式。因此，仓储类的创建时抽象的。看下面的代码：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService
{
    private IPersonRepository _personRepository;

    public PersonAppService()
    {
        _personRepository = PersonRepositoryFactory.Create();            
    }

    public void CreatePerson(string name, int age)
    {
        var person = new Person { Name = name, Age = age };
        _personRepository.Insert(person);
    }
}
</code></pre>
<p>PersonRepositoryFactory是一个创建并返回一个IPersonRepository的静态类。这就是所谓的<strong>服务定位器模式</strong>。这样创建问题是解决了，因为PersonAppService不知道如何创建一个IPersonRepository的实现，而且它独立于PersonRepository的实现。但是，仍然有下面这些问题：</p>
<ul>
<li>这次，PersonAppService依赖于PersonRepositoryFactory。这个较为可接受，但是仍然有硬依赖。</li>
<li>为每个仓储或者依赖写一个工厂类或方法太繁琐了。</li>
<li>还是不太好测试，因为让PersonAppService使用一些IPersonRepository的伪造实现还是很困难。</li>
</ul>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>要依赖其他的类有一些最佳实践（模式）。</p>
<h5 id="构造函数注入模式"><a href="#构造函数注入模式" class="headerlink" title="构造函数注入模式"></a>构造函数注入模式</h5><p>上面的例子可以重写为下面的代码：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService
{
    private IPersonRepository _personRepository;

    public PersonAppService(IPersonRepository personRepository)
    {
        _personRepository = personRepository;
    }

    public void CreatePerson(string name, int age)
    {
        var person = new Person { Name = name, Age = age };
        _personRepository.Insert(person);
    }
}
</code></pre>
<p>这就是所谓的<strong>构造函数注入</strong>。现在，PersonAppService不知道哪一个类实现了IPersonRepository,也不知道如何创建的它。谁要使用PersonAppService，首先要创建一个IPersonRepository,并将它传给PersonAppService的构造函数，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">var repository = new PersonRepository();
var personService = new PersonAppService(repository);
personService.CreatePerson("Yunus Emre", 19);
</code></pre>
<p>构造函数注入是使类独立于依赖对象创建的一种完美方式，但是，上面的代码存在一些问题：</p>
<ul>
<li>创建一个PersonAppService变得更加困难。试想如果它有4个依赖，那么我们必须创建这4个依赖的对象，然后把它们传入PersonAppService的构造函数中。</li>
<li>依赖的类可能有其它的依赖（这里，PersonRepository可能有依赖）。因此，我们必须创建PersonAppService的所有依赖，依赖的所有依赖等等。这样的话，我们甚至可能不再创建单一对象，因为依赖图太复杂了。</li>
</ul>
<p>幸运的是，ABP有依赖注入框架自动管理依赖。</p>
<h5 id="属性注入模式"><a href="#属性注入模式" class="headerlink" title="属性注入模式"></a>属性注入模式</h5><p>构造函数注入是提供一个类的依赖的完美模式。用这种方式，你可以不需要提供依赖就能创建一个类的实例，它也是显示声明该类需要满足什么要求才能正确工作的强大方式。</p>
<p>但在某些情况下，该类依赖于其他的类而且其他的类没有它也能工作。这对于关注度分离（比如日志记录）来说经常是成立的。一个类可以离开logging工作，但如果提供了logger，那它就能记录日志。这种情况下，你可以定义将依赖定义为公共的属性而不是在构造函数中获得这些依赖。试想如果我们要在PersonAppService中记录日志，那么我们可以重写该类为：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService
{
    public ILogger Logger { get; set; }

    private IPersonRepository _personRepository;

    public PersonAppService(IPersonRepository personRepository)
    {
        _personRepository = personRepository;
        Logger = NullLogger.Instance;
    }

    public void CreatePerson(string name, int age)
    {
        Logger.Debug("Inserting a new person to database with name = " + name);
        var person = new Person { Name = name, Age = age };
        _personRepository.Insert(person);
        Logger.Debug("Successfully inserted!");
    }
}
</code></pre>
<p>NullLogger.Instance是一个实现了ILogger的单例对象，但实际上什么都没做（没有记录日志，它使用了空的方法体实现了ILogger）。因此，如果你在创建PersonAppService对象之后，并像下面那样设置了Logger，PersonAppService就可以记录日志了：</p>
<pre class=" language-C#"><code class="language-C#">var personService = new PersonAppService(new PersonRepository());
personService.Logger = new Log4NetLogger();
personService.CreatePerson("Yunus Emre", 19);
</code></pre>
<p>假设Log4NetLogger实现了ILogger并使用Log4Net类库记录日志。这样，PersonAppService实际上就可以记录日志了。如果没有设置Logger，那么它就不会记录日志。因此，我们可以说ILogger是PersonAppService的一个<strong>可选依赖</strong>。</p>
<p>几乎所有的依赖注入框架都支持属性注入模式。</p>
<h4 id="依赖注入框架"><a href="#依赖注入框架" class="headerlink" title="依赖注入框架"></a>依赖注入框架</h4><p>有很多自动解析依赖的依赖注入框架。它们能够使用所有的依赖（包括依赖的依赖）创建对象。因此，你只需要使用构造和属性注入模式编写你的类，DI框架会处理剩下的事情。在一个优秀的应用中，你的类甚至独立于DI框架。在整个应用中，有许多显式和DI框架交互的代码行或者类。</p>
<p>ABP使用Castle Windsor框架处理依赖注入。它是最成熟的DI框架之一。还有很多其他的框架，如Unity，Ninject,StructureMap，Autofac等等。</p>
<p>在依赖注入框架中，你首先要将你的接口或者类注册到其中，然后才可以解析（创建）一个对象。在Castle Windsor中，有点像下面那样：</p>
<pre class=" language-C#"><code class="language-C#">var container = new WindsorContainer();

container.Register(
        Component.For<IPersonRepository>().ImplementedBy<PersonRepository>().LifestyleTransient(),
        Component.For<IPersonAppService>().ImplementedBy<PersonAppService>().LifestyleTransient()
    );

var personService = container.Resolve<IPersonAppService>();
personService.CreatePerson("Yunus Emre", 19);
</code></pre>
<p>上面的代码中，首先创建了<strong>WindsorContainer</strong>，然后使用PersonRepository和PersonAppService的接口注册了它们，再然后我们要求容器创建一个IPersonAppService。容器使用依赖创建了PersonAppService并返回，也许在这个简单的例子中使用DI框架的优势不是很明显，但是想象一下你在一个真实的企业应用中会有很多类和依赖。当然，也会在别的地方使用对象来注册依赖，这个在应用启动时只会做一次。</p>
<p>注意，我们也将对象的<strong>生命周期</strong>声明为<strong>transient</strong>。这意味着，无论何时解析这些类型的一个对象，都会创建一个新的实例。当然还有很多不同的生命周期（像singleton）。</p>
<h3 id="ABP中的依赖注入基础设施"><a href="#ABP中的依赖注入基础设施" class="headerlink" title="ABP中的依赖注入基础设施###"></a>ABP中的依赖注入基础设施###</h3><p>当你通过下面的最佳实践和一些惯例编写你的应用时，ABP几乎让使用DI框架变得不可见了。</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>在ABP中，将你的类注册到DI系统有几种不同的方式。大多数情况下，按照惯例注册已经足够了。</p>
<h5 id="惯例注册"><a href="#惯例注册" class="headerlink" title="惯例注册"></a>惯例注册</h5><p>ABP会按照惯例自动注册所有的仓储，领域服务，应用服务，MVC控制器和Web API控制器。比如，你可能有一个IPersonAppService接口和一个实现了该接口的PersonAppService类：</p>
<pre class=" language-C#"><code class="language-C#">public interface IPersonAppService : IApplicationService
{
    //...
}

public class PersonAppService : IPersonAppService
{
    //...
}
</code></pre>
<p>因为它实现了<strong>IApplicationService</strong>接口（只是一个空接口），所以ABP会自动注册它，并注册为<strong>transient</strong>（每次使用创建一个实例）。当你使用构造函数注入IPersonAppService接口到一个类中时，一个PersonAppService对象会自动地创建并传入该类的构造函数中。</p>
<p><strong>命名规范</strong>在ABP中非常重要。比如，你可以将PersonAppService更名为MyPersonAppService或是其他包含了“PersonAppService”后缀的名字，因为IPersonAppService接口有这个后缀。但你不能将它命名为PeopleService。如果你没有按照这种命名规范来操作的话，那么IPersonAppService不会自动地注册（但是它已经以自注册的方式注入到DI框架，而不是接口方式），因此如果你想要以接口方式注册的话，那么你应该手动注册。</p>
<p>ABP按照惯例注册程序集。因此，你应该按照惯例告诉ABP注册你的程序集。这个相当简单：</p>
<pre><code>IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
</code></pre>
<p>Assembly.GetExecutingAssembly()会获得包含这句代码的程序集的引用。你也可以将其他的程序集传入RegisterAssemblyByConvention 方法中。这个操作通常在你的模块初始化的时候完成的。查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPModuleSystem.html">《模块系统》</a>**博文获得更多信息。</p>
<p>通过实现<strong>IConventionalRegister</strong>接口和调用<strong>IocManager.AddConventionalRegister</strong>方法，你可以用你的类编写你自己的惯例注册类。你要做的就是在模块的PreInitialize方法中加入它。</p>
<h5 id="帮助接口"><a href="#帮助接口" class="headerlink" title="帮助接口"></a>帮助接口</h5><p>你可能想要注册一个特殊的类，但是它不符合惯例注册的原则。为此，ABP提供了<strong>ITransientDependency</strong> 和 <strong>ISingletonDependency</strong>接口。比如：</p>
<pre class=" language-C#"><code class="language-C#">public interface IPersonManager
{
    //...
}

public class MyPersonManager : IPersonManager, ISingletonDependency
{
    //...
}
</code></pre>
<p>用这种方式，你可以轻松地注册MyPersonManager。当需要注入IPersonManager的时候，就会使用MyPersonManager。注意依赖声明为<strong>Singleton</strong>。这样，MyPersonManager的单例就被创建了，并且相同的对象也被传入到所有的类中。只有在第一次使用时才会创建，以后再整个应用的生命周期都会使用相同的实例。</p>
<h5 id="自定义-直接注册"><a href="#自定义-直接注册" class="headerlink" title="自定义/直接注册"></a>自定义/直接注册</h5><p>如果之前描述的方法还不能满足你，那么你可以直接使用<strong>Castle Windsor</strong>来注册你的类和依赖。这样，你就在Castle Windsor中注册任何东西。</p>
<p>Castle Windsor有一个为了注册而要实现的接口<strong>IWindsorInstaller</strong>。你可以在应用中创建实现了IWindsorInstaller接口的类：</p>
<pre class=" language-C#"><code class="language-C#">public class MyInstaller : IWindsorInstaller
{
    public void Install(IWindsorContainer container, IConfigurationStore store)
    {
        container.Register(Classes.FromThisAssembly().BasedOn<IMySpecialInterface>().LifestylePerThread().WithServiceSelf());
    }
}
</code></pre>
<p>ABP会自动找到并执行这个类。最后，可以使用<strong>IIocManager.IocContainer</strong>属性到达WindsorContainer。获取更多Windsor信息，请查看**<a target="_blank" rel="noopener" href="http://docs.castleproject.org/Default.aspx?Page=MainPage">官方文档</a>**。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>注册会将你的类，类的依赖和生命周期通知给IOC（控制反转）容器。接下来，你需要在应用中的某些地方使用IOC容器创建对象。ABP针对依赖的解析提供了很多选项。</p>
<h5 id="构造函数-amp-属性注入"><a href="#构造函数-amp-属性注入" class="headerlink" title="构造函数&amp;属性注入"></a>构造函数&amp;属性注入</h5><p>你可以将使用构造函数和属性注入获得类的依赖作为最佳实践。无论在哪里，你都应该这样做。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService
{
    public ILogger Logger { get; set; }

    private IPersonRepository _personRepository;

    public PersonAppService(IPersonRepository personRepository)
    {
        _personRepository = personRepository;
        Logger = NullLogger.Instance;
    }

    public void CreatePerson(string name, int age)
    {
        Logger.Debug("Inserting a new person to database with name = " + name);
        var person = new Person { Name = name, Age = age };
        _personRepository.Insert(person);
        Logger.Debug("Successfully inserted!");
    }
}
</code></pre>
<p>IPersonRepository从构造函数注入，ILogger使用公共属性注入。这样的话，你的代码根本意识不到依赖注入系统的存在，也就是说，依赖系统对于我们开发者完全是透明的，我们可以不考虑依赖系统内部的实现细节。这是使用DI系统最合适的方式。</p>
<p>IIocResolver和IIocManager</p>
<p>有时，你可能必须要直接解析依赖而不是通过构造函数和属性注入。这种情况要尽可能地避免，但这种情况也是有可能的。ABP提供了很多可以轻松注入并使用的服务。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class MySampleClass : ITransientDependency
{
    private readonly IIocResolver _iocResolver;

    public MySampleClass(IIocResolver iocResolver)
    {
        _iocResolver = iocResolver;
    }

    public void DoIt()
    {
        //手动解析
        var personService1 = _iocResolver.Resolve<PersonAppService>();
        personService1.CreatePerson(new CreatePersonInput { Name = "Yunus", Surname = "Emre" });
        _iocResolver.Release(personService1);

        //安全地解析并使用
        using (var personService2 = _iocResolver.ResolveAsDisposable<PersonAppService>())
        {
            personService2.Object.CreatePerson(new CreatePersonInput { Name = "Yunus", Surname = "Emre" });
        }
    }
}
</code></pre>
<p>在以上例子中的MySampleClass通过构造函数注入<strong>IIocResolver</strong>并用它来解析和释放对象。<strong>Resolve</strong>方法有许多重载可供使用。<strong>Release</strong>方法用来释放组件（对象）。调用Release来手动解析一个对象是很关键的，否则，应用会有内存泄漏问题。为了确保释放对象，要尽可能使用<strong>ResolveAsDisPosable</strong>(如例子中演示的那样)。在using块的末尾会自动地调用Release。</p>
<p>如果你想要直接使用IOC容器（Castle Windor）来解析依赖，那么你可以构造函数注入<strong>IIocManager</strong>并使用IIocManager.IocContainer属性。如果你处于静态上下文或者不能注入IIocManager，那么最后的机会就是，你可以使用单例对象<strong>IocManager.Instance</strong>。但是，这种情况不容易测试。</p>
<h4 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h4><h5 id="IShouldInitialize接口"><a href="#IShouldInitialize接口" class="headerlink" title="IShouldInitialize接口"></a>IShouldInitialize接口</h5><p>某些类在第一次使用前就要初始化。IShouldInitialize接口有一个Initialize方法。如果实现了该接口，那么在创建对象之后（使用前）就会自动地调用Initialize方法。当然，为了使该功能有效，你应该注入/解析该对象。</p>
<h4 id="ASP-NET-MVC和ASP-NET-Web-API集成"><a href="#ASP-NET-MVC和ASP-NET-Web-API集成" class="headerlink" title="ASP.NET MVC和ASP.NET Web API集成"></a>ASP.NET MVC和ASP.NET Web API集成</h4><p>当然，为了解析依赖图中的根对象，我们必须调用依赖注入系统。在ASP.NET MVC应用中，根对象一般是一个<strong>Controller</strong>类。我们也可以在控制器中使用构造函数注入和属性注入模式。当一个请求到达应用时，IOC容器创建了控制器对象，然后所有的依赖递归地解析出来。那么，谁处理的这个呢？这是ABP通过扩展了ASP.NET MVC默认的控制器工厂自动完成的。相似地，对于ASP.Net Web API也是如此。你不必关心创建和释放对象的事情。</p>
<h4 id="最后提示"><a href="#最后提示" class="headerlink" title="最后提示"></a>最后提示</h4><p>只要你遵循规则并使用上面的结构，ABP就能简化并自动化依赖注入的使用。大多数情况下，这些已经够用了。但是，如果你需要的话，你可以直接使用所有Castle Windsor的能力来执行任何任务（如自定义注册，注入钩子，拦截器等等）<img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321131043687.png" alt="image-20210321131043687"></p>
<p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321131205896.png" alt="image-20210321131205896"></p>
<h1 id="ABP理论学习之Abp-Session"><a href="#ABP理论学习之Abp-Session" class="headerlink" title="ABP理论学习之Abp Session"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSession.html">ABP理论学习之Abp Session</a></h1><hr>
<h2 id="本篇目录-6"><a href="#本篇目录-6" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSession.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSession.html#injection">注入Session</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSession.html#property">使用Session属性</a></strong></li>
</ul>
<h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍###"></a>介绍###</h3><p>当应用程序要求用户登录时，那么应用程序也需要知道当前用户正在执行的操作。虽然ASP.NET本身在展现层提供了Session对象，但ABP也提供了在任何需要获得当前用户和租户的地方都可以使用的<strong>IAbpSession</strong>接口。</p>
<blockquote>
<h4 id="关于IAbpSession"><a href="#关于IAbpSession" class="headerlink" title="关于IAbpSession"></a>关于IAbpSession</h4><p>为了获得实际的session信息，必须要实现IAbpSession接口。虽然你可以用自己的方式实现它，但在<strong>module-zero</strong>项目中已经完全实现。</p>
</blockquote>
<p>IAbpSession已经完全集成到ABP（实例的设置系统和授权系统）中。</p>
<h3 id="注入Session"><a href="#注入Session" class="headerlink" title="注入Session###"></a>注入Session###</h3><p>IAbpSession一般<strong>属性注入</strong>到需要的类中，除非没有Session信息导致IAbpSession不可能工作。如果我们使用了属性注入，那么我们可以使用<strong>NullAbpSession.Instance</strong>作为默认值，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class MyClass : ITransientDependency
{
    public IAbpSession AbpSession { get; set; }

    public MyClass()
    {
        AbpSession = NullAbpSession.Instance;
    }

    public void MyMethod()
    {
        var currentUserId = AbpSession.UserId;
        //...
    }
}
</code></pre>
<p>因为授权是应用层的事儿，所以建议<strong>在应用层和更高的层使用IAbpSession</strong>(一般我们不再领域层使用)。<strong>ApplicationService，AbpController，AbpApiController</strong>已经注入了 <strong>AbpSession</strong>。因此，你可以直接在应用层服务方法中为实例使用AbpSession属性。</p>
<h3 id="使用Session属性"><a href="#使用Session属性" class="headerlink" title="使用Session属性###"></a>使用Session属性###</h3><p>AbpSession定义了一些key属性：</p>
<ul>
<li><strong>UserId</strong>:当前用户的Id。值为null，表示当前的用户不存在。如果调用的代码授权给某个用户的话，那么值不为null。</li>
<li><strong>TenantId</strong>:当前租户的Id。如果当前的租户不存在，值就为null。</li>
<li><strong>MultiTenancySide</strong>:可能是Host（租主）或者Tenant（租户）。</li>
</ul>
<p>UserId和TenantId是<strong>nullable(可空的)**，也存在不可空的</strong>GetUserId()**和 **GetTenantId()**方法。如果你确定当前的用户存在，那么你可以调用GetUserId()。如果当前的用户为null，那么该方法就会抛异常。GetTanantId()也是类似的。</p>
<p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321114918477.png" alt="image-20210321114918477"></p>
<h1 id="ABP理论学习之缓存Caching"><a href="#ABP理论学习之缓存Caching" class="headerlink" title="ABP理论学习之缓存Caching"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPCaching.html">ABP理论学习之缓存Caching</a></h1><hr>
<h2 id="本篇目录-7"><a href="#本篇目录-7" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPCaching.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPCaching.html#ICacheManager">ICacheManager</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPCaching.html#ICache">ICache</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPCaching.html#ITypedCache">ITypedCache</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPCaching.html#config">配置</a></strong></li>
</ul>
<h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍###"></a>介绍###</h3><p>ABP提供了缓存的抽象，它内部使用了这个缓存抽象。虽然默认的实现使用了MemoryCache，但是也可以为其他的缓存提供者进行实现和改变。</p>
<h3 id="ICacheManager"><a href="#ICacheManager" class="headerlink" title="ICacheManager###"></a>ICacheManager###</h3><p>缓存的主要接口是<strong>ICacheManager</strong>。我们可以注入该接口，然后使用该接口获得一个缓存对象。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class TestAppService : ApplicationService
{
    private readonly ICacheManager _cacheManager;

    public TestAppService(ICacheManager cacheManager)
    {
        _cacheManager = cacheManager;
    }

    public Item GetItem(int id)
    {
        //从缓存中获取
        return _cacheManager
                .GetCache("MyCache")
                .Get(id.ToString(), () => GetFromDatabase(id)) as Item;
    }

    public Item GetFromDatabase(int id)
    {
        //... 从数据库中检索
    }
}
</code></pre>
<p>在这个例子中，我们注入了<strong>ICacheManager</strong>，并获取了一个叫做<strong>MyCache</strong>的缓存对象。</p>
<blockquote>
<h4 id="警告：GetCache方法"><a href="#警告：GetCache方法" class="headerlink" title="警告：GetCache方法"></a>警告：GetCache方法</h4><p>不要在构造函数中使用GetCache方法。如果你的类是transient（每次使用都会创建）的，那么这可能会释放缓存，因为第二次创建类的对象时，会再次调用构造函数，之前的第一次的缓存可能会被释放。</p>
</blockquote>
<h3 id="ICache"><a href="#ICache" class="headerlink" title="ICache###"></a>ICache###</h3><p>ICacheManager.GetCache方法返回一个<strong>ICache</strong>。缓存对象是单例的，第一次请求时会创建缓存，以后都是返回相同的缓存对象。因此，我们可以在不同的类（客户端）中共享具有相同名字的相同缓存。</p>
<p>在样例代码中，我们看到了ICache.Get方法的简单使用。它有两个参数：</p>
<ul>
<li><strong>key</strong>：缓存中一个条目的唯一字符串键。</li>
<li><strong>工厂</strong>：没有找到给定key的缓存条目时调用的action。工厂方法应该创建并返回实际的条目。如果给定的key在缓存中找到了，那么不会调用该action。</li>
</ul>
<p>ICache接口也有像<strong>GetOrDefault,Set,Remove,Clear</strong>的方法。同时，这些方法也有<strong>异步（async）</strong>版本。</p>
<h3 id="ITypedCache"><a href="#ITypedCache" class="headerlink" title="ITypedCache###"></a>ITypedCache###</h3><p><strong>ICache</strong>接口的key为string类型，value为object类型。<strong>ITypeCache</strong>是ICache的包装器，提供<strong>类型安全</strong>、泛型的cache。为了将ICache转为ITypedCache，我们可以使用<strong>AsTyped</strong>扩展方法，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">ITypedCache<int, Item> myCache = _cacheManager.GetCache("MyCache").AsTyped<int, Item>();
</code></pre>
<p>这样，我们不需要转换就可以使用Get方法。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置###"></a>配置###</h3><p>默认的缓存有效期是60min。因此，如果你在60min内都没有使用缓存中的元素，那么它会自动从缓存中移除。对于所有的缓存或者特定的某个缓存，你都可以配置有效期。</p>
<pre class=" language-C#"><code class="language-C#">//为所有缓存配置有效期
Configuration.Caching.ConfigureAll(cache =>
{
    cache.DefaultSlidingExpireTime = TimeSpan.FromHours(2);
});

//为特定的缓存配置有效期
Configuration.Caching.Configure("MyCache", cache =>
{
    cache.DefaultSlidingExpireTime = TimeSpan.FromHours(8);
});
</code></pre>
<p>这些代码应该放到模块中的<strong>PreInitialize</strong>方法中。有了这样的配置，MyCache会有8小时的有效期，而其他cache会有2小时有效期。</p>
<p>一旦cache首次创建（第一次请求时），就会调用配置的action。配置并不只局限于DefaultSlidingExpireTime（默认滚动有效期），因为cache对象是一个ICache，你可以使用它的属性和方法自由地配置并初始化。</p>
<h1 id="ABP理论学习之日志记录"><a href="#ABP理论学习之日志记录" class="headerlink" title="ABP理论学习之日志记录"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLogging.html">ABP理论学习之日志记录</a></h1><hr>
<h2 id="本篇目录-8"><a href="#本篇目录-8" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLogging.html#server">服务端</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLogging.html#get">获取Logger</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLogging.html#base">基类中的Logger</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLogging.html#config">配置</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLogging.html#client">客户端</a></strong></li>
</ul>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端###"></a>服务端###</h3><p>ABP使用的是Castle Windsor的**<a target="_blank" rel="noopener" href="http://docs.castleproject.org/Windsor.Logging-Facility.ashx">日志记录设备</a><strong>。它可以和不同的日志类库一起工作，比如</strong>Log4Net,NLog，Serilog等等<strong>。Castle为所有的日志类库提供了一个</strong>公共的接口**。因此，你完全独立于特定的日志记录类库，而且，如果需要的话，你可以轻松地改变应用程序的日志类库。</p>
<p>**<a target="_blank" rel="noopener" href="http://logging.apache.org/log4net/">Log4Net</a>**是.Net中最流行的日志类库之一。ABP模板中自带了经过合适配置的Log4Net。但是，只存在一行log4net的依赖（看下面），因此，你可以将它改为你最喜欢的类库。</p>
<h4 id="获取Logger"><a href="#获取Logger" class="headerlink" title="获取Logger"></a>获取Logger</h4><p>无论你选择了什么日志类库，最终要记录的日志代码都是相同的（这得感谢Castle公共的ILogger接口）。</p>
<p>一开始，我们要处理一下记录日志的Logger对象。因为ABP强烈推荐使用依赖注入，所以我们可以使用属性注入模式轻松地注入一个Logger对象。如下所示：</p>
<pre class=" language-C#"><code class="language-C#">using Castle.Core.Logging; //1: 导入 Logging 命名空间

public class TaskAppService : ITaskAppService
{    
    //2: 使用属性注入获得 logger
    public ILogger Logger { get; set; }
    
    public TaskAppService()
    {
        //3: 如果没有提供Logger，就不能记录日志
        Logger = NullLogger.Instance;
    }

    public void CreateTask(CreateTaskInput input)
    {
        //4: 记录日志
        Logger.Info("Creating a new task with description: " + input.Description);

        //TODO: 保存到数据库...
    }
}
</code></pre>
<ol>
<li>导入Castle的ILogger接口的命名空间。</li>
<li>定义一个公有的叫做Logger的<strong>ILogger</strong>对象。这是记录日志的对象。创建TaskAppService对象之后，依赖注入系统会设置（注入）这个属性。这就是所谓的属性注入模式。</li>
<li>将Logger设置为<strong>NullLogger.Instance</strong>。即使没有这行代码，系统也会工作地很好。但是这是属性注入模式的最佳实践。如果没给Logger设置任何值，那么当我们使用它的时候会因为它是null而抛出“空指针”异常。这个保证了它不为null。因此，如果没有给Logger设置值，那么它是NullLogger。这就是所谓的null对象模式。NullLogger实际上什么都没做，也没有记录任何日志。因此，我们的类要不要一个实际的logger都能工作。</li>
<li>最后，我们记录了一个<strong>info</strong>等级的日志文本。存在多种不同的等级（看下面）。</li>
</ol>
<p>如果我们调用了CreateTask方法，并检查日志文件，就会看到像下面一样的一长行字符串。</p>
<pre><code>INFO  2014-07-13 13:40:23,360 [8    ] SimpleTaskSystem.Tasks.TaskAppService    - Creating a new task with description: Remember to drink milk before sleeping!
</code></pre>
<h4 id="基类中的Logger"><a href="#基类中的Logger" class="headerlink" title="基类中的Logger"></a>基类中的Logger</h4><p>ABP为MVC控制器，Web API控制器和应用服务类提供了基类。比如，Web层对应的基类是XXXControllerBase(后缀为ControllerBase)。这些基类中都声明了<strong>Logger</strong>属性。因此你可以直接使用Logger来记录日志，无需注入。例子：</p>
<pre class=" language-C#"><code class="language-C#">public class HomeController : SimpleTaskSystemControllerBase
{
    public ActionResult Index()
    { 
        Logger.Debug("A sample log message...");
        return View();
    }
}
</code></pre>
<p>注意，SimpleTaskSystemControllerBase是继承了<strong>AbpController</strong>的应用基类控制器。因此，可以在控制器中直接使用Logger。Logger也存在于Web Api控制器的<strong>AbpApiController</strong>基类，以及应用服务层的基类（后缀为AppServiceBase的类）。你也可以为其他的类编写自己的公共基类，这样，你就不需要每次注入logger了。</p>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>当你从ABP模板创建应用程序时，Log4Net的所有配置已经完成了。</p>
<p>默认的日志格式配置如下：</p>
<ul>
<li><strong>日志级别</strong>：DEBUG, INFO, WARN, ERROR或者FATAL。</li>
<li><strong>日期和时间</strong>：记录日志的时间。</li>
<li><strong>线程号</strong>:记录日志的线程号码。</li>
<li><strong>Logger名称</strong>：通常是记录日志的类名。</li>
<li><strong>日志文本</strong>：实际记录的日志文本。</li>
</ul>
<p>配置定义在应用的<strong>log4net.config</strong>文件中，如下所示：</p>
<pre class=" language-web.config"><code class="language-web.config"><?xml version="1.0" encoding="utf-8" ?>
<log4net>
  <appender name="RollingFileAppender" type="log4net.Appender.RollingFileAppender" >
    <file value="Logs/Logs.txt" />
    <appendToFile value="true" />
    <rollingStyle value="Size" />
    <maxSizeRollBackups value="10" />
    <maximumFileSize value="10000KB" />
    <staticLogFileName value="true" />
    <layout type="log4net.Layout.PatternLayout">
        <conversionPattern value="%-5level %date [%-5.5thread] %-40.40logger - %message%newline" />
    </layout>
  </appender>
  <root>
    <appender-ref ref="RollingFileAppender" />
    <level value="DEBUG" />
  </root>
  <logger name="NHibernate">
    <level value="WARN" />
  </logger>
</log4net>
</code></pre>
<p>Log4Net是高度可配置的、健壮的日志记录类库。你可以使用不同的格式将日志记录到不同的目标上（文本文件，数据库等）。你也可以设置最小日志等级（正如此配置中为NHibernate配置的那样）。你也可以记录不同的日志到不同的文件中。当到达一个指定的大小时，它会自动备份并创建一个新的日志文件等等（本例中，滚动文件适配器的每个文件大小是10MB）。为了更好配置你的log4net，请查看**<a target="_blank" rel="noopener" href="http://logging.apache.org/log4net/release/config-examples.html">官方文档</a>**。</p>
<p>最后，我们在Global.asax文件中，声明了要使用log4net.config文件中的Log4Net。</p>
<pre class=" language-C#"><code class="language-C#">public class MvcApplication : AbpWebApplication
{
    protected override void Application_Start(object sender, EventArgs e)
    {
        IocManager.Instance.IocContainer.AddFacility<LoggingFacility>(f => f.UseLog4Net().WithConfig("log4net.config"));
        base.Application_Start(sender, e);
    }
}
</code></pre>
<p>这是<strong>我们直接依赖log4net的唯一代码行</strong>。而且，只有web项目依赖log4net类库的nuget包。因此，你可以轻松地切换到其他日志类库，而且不需要改变记录日志的代码。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端###"></a>客户端###</h3><p>ABP为客户端定义了一个javascript日志记录API。默认会将日志记录到浏览器的控制台。记录日志的javascript代码样例如下：</p>
<p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321130900892.png" alt="image-20210321130900892"></p>
<h1 id="ABP理论学习之设置管理"><a href="#ABP理论学习之设置管理" class="headerlink" title="ABP理论学习之设置管理"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html">ABP理论学习之设置管理</a></h1><hr>
<h2 id="本篇目录-9"><a href="#本篇目录-9" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#defSetting">定义设置</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#getSetting">获取设置值</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#changeSetting">更改设置</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSettingManagement.html#aboutCache">关于缓存</a></strong></li>
</ul>
<h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍###"></a>介绍###</h3><p>每个应用程序都需要存储一些设置信息，然后在应用程序中的某个地方使用这些设置。ABP提供了健壮的基础设施来存储或检索服务端和客户端的<strong>应用程序，租户，用户</strong>级别的可用设置。</p>
<p>一个设置一般是存储在数据库（或其他源）的<strong>name-value</strong>字符串对。我们可以将非字符串的值转换成字符串。</p>
<blockquote>
<h4 id="关于ISettingStore"><a href="#关于ISettingStore" class="headerlink" title="关于ISettingStore"></a>关于ISettingStore</h4><p>为了使用设置系统，必须要实现<strong>ISettingStore</strong>。虽然你可以用自己的方式实现，但是它已完全实现在<strong>module-zero</strong>中了。</p>
</blockquote>
<h3 id="定义设置"><a href="#定义设置" class="headerlink" title="定义设置###"></a>定义设置###</h3><p>一个设置使用前必须先定义。ABP是模块化设计的，因此，不同的模块可以有不同的设置。要定义一个设置，一个模块应该创建一个派生于<strong>SettingProvider</strong>（设置提供器）的类。设置提供器的一个例子如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class MySettingProvider : SettingProvider
{
    public override IEnumerable<SettingDefinition> GetSettingDefinitions(SettingDefinitionProviderContext context)
    {
        return new[]
                {
                    new SettingDefinition(
                        "SmtpServerAddress",
                        "127.0.0.1"
                        ),

                    new SettingDefinition(
                        "PassiveUsersCanNotLogin",
                        "true",
                        scopes: SettingScopes.Application | SettingScopes.Tenant
                        ),

                    new SettingDefinition(
                        "SiteColorPreference",
                        "red",
                        scopes: SettingScopes.User,
                        isVisibleToClients: true
                        )

                };
    }
}
</code></pre>
<p><strong>GetSettingDefinitions</strong>方法应该返回<strong>SettingDefinition</strong>集合。SettingDefinition类的构造函数有一些参数：</p>
<ul>
<li><strong>Name</strong>(必须)：一个设置的名称，在系统中名称必须唯一。最好为每个设置名定义一个常量字符串。</li>
<li><strong>Default值</strong>：设置的默认值。可以为null或空字符串。</li>
<li><strong>Scopes</strong>：一个设置应该定义它的范围（看下面）。</li>
<li><strong>Dispaly name</strong>：在UI上显示的本地化的设置名。</li>
<li><strong>Description</strong>：在UI上显示的本地化的设置描述。</li>
<li><strong>Group</strong>：用于组合设置。这个用于UI而不是设置管理。</li>
<li><strong>IsVisibleToClients</strong>：客户端是否可见。</li>
</ul>
<p>创建一个设置提供器之后，我们应该在模块的PreInitialize方法中注册。</p>
<pre><code>Configuration.Settings.Providers.Add&lt;MySettingProvider&gt;();
</code></pre>
<p>这样，设置提供器就自动注册到依赖注入系统中了。因此，设置提供器可以使用一些其他的资源注入任何依赖（如仓储）来生成设置定义。</p>
<h4 id="设置范围"><a href="#设置范围" class="headerlink" title="设置范围"></a>设置范围</h4><p>在<strong>SettingScope</strong>枚举类中定义了三种<strong>设置范围（或者说等级）</strong>：</p>
<ul>
<li><strong>Application</strong>：一个应用范围的setting对象用于用户或者租户独立的设置。比如，我们可以定义一个叫做“SmtpServerAddress”的设置来获取发送邮件时服务端的IP地址。如果该setting有一个单一值（基于用户不会改变），那么我们可以把它定义为应用范围的。</li>
<li><strong>Tenant</strong>：如果应用程序时多租户的，那么我们可以定义租户特定的setting。</li>
<li><strong>User</strong>：我们可以定义存储或者获取特定用户的设置。</li>
</ul>
<p>SettingScopes枚举类型有<strong>Flags</strong>特性，因此我们可以定义一个<strong>不止一个范围</strong>的setting。</p>
<p>设置范围是有层次的，比如，如果我们定义的设置范围是“Application | Tenant | User”，并尝试获取该设置<strong>当前的值</strong>，那么：</p>
<ul>
<li>如果已定义了该用户的setting，那么就会获得该用户特定的值。</li>
<li>如果上面的条件不成立，并且已经定义了该用户所属租户的setting，那么会获得该租户特定的值。</li>
<li>如果上面的条件还不成立，如果定义了应用的值，那么会获得该应用的值。</li>
<li>最后，我们会获得<strong>默认值</strong>。</li>
</ul>
<p>默认值可能是null或者空字符串。如果可能的话，建议为setting的默认值提供默认值。</p>
<h3 id="获取设置值"><a href="#获取设置值" class="headerlink" title="获取设置值###"></a>获取设置值###</h3><p>定义了一个setting之后，我们就可以在客户端和服务端获得它当前的值。</p>
<h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><p><strong>ISettingManager</strong>用于执行setting操作。我们可以在应用中的任何地方注入并使用它。ISettingManager定义了许多获取一个setting值的方法。</p>
<p>用的最多的方法是<strong>GetSettingValue</strong>(或者异步调用GetSettingValueAsync)。它会返回基于默认值，应用程序，租户和用户setting的当前的值（正如上面提到的）。例如：</p>
<pre class=" language-C#"><code class="language-C#">//获取一个bool值（异步调用）
var value1 = await SettingManager.GetSettingValueAsync<bool>("PassiveUsersCanNotLogin");

//获取一个string值（同步调用）
var value2 = SettingManager.GetSettingValue("SmtpServerAddress");
</code></pre>
<p>GetSettingValue有泛型和异步版本，如上面所示。也有获得特定租户或者用户的setting值或者所有setting值的列表的方法。</p>
<p>因为ISettingManager使用广泛，所以一些特殊的基类（如ApplicationService，DomainService和AbpController）就有了一个叫做<strong>SettingManager</strong>的属性。如果我们从这些类中派生，那么就不需要显式注入它了。</p>
<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p>当定义一个setting时，如果将<strong>IsVisibleToClients</strong>设置为true，那么可以使用javascript在客户端获得当前的值。<strong>abp.setting</strong>命名空间定义了一些用得到的函数和对象。例如：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> currentColor <span class="token operator">=</span> abp<span class="token punctuation">.</span>setting<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"SiteColorPreference"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>也有<strong>getInt</strong>和 <strong>getBoolean</strong> 方法。你可以使用<strong>abp.setting.values</strong>获得所有的值。注意：如果在服务端更改了一个setting，那么如果页面没有更新，setting没有重新加载或者通过代码手动更新的话，那么客户端就不知道该setting是否发生了变化。</p>
<h3 id="更改设置"><a href="#更改设置" class="headerlink" title="更改设置###"></a>更改设置###</h3><p>ISettingManager为应用程序，租户和用户分别定义了<strong>ChangeSettingForApplicationAsync, ChangeSettingForTenantAsync和ChangeSettingForUserAsync</strong>方法来更改setting。</p>
<h3 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存###"></a>关于缓存###</h3><p>Setting Manager(管理者)缓存到了服务端的setting了。因此，我们不应该使用仓储或者数据库更新来直接更改一个setting的值。</p>
<p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321130753223.png" alt="image-20210321130753223"></p>
<h1 id="领域层-1"><a href="#领域层-1" class="headerlink" title="领域层"></a>领域层</h1><h1 id="ABP理论学习之实体类"><a href="#ABP理论学习之实体类" class="headerlink" title="ABP理论学习之实体类"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntity.html">ABP理论学习之实体类</a></h1><hr>
<h2 id="本篇目录-10"><a href="#本篇目录-10" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntity.html#entity">实体类</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntity.html#guanli">惯例接口</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntity.html#Auditing">审计</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntity.html#softDelete">软删除</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntity.html#active">激活/未激活</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntity.html#IEntity">IEntity接口</a></strong></li>
</ul>
<blockquote>
<p>实体是DDD（领域驱动设计）的核心概念之一。Eirc Evans是这样描述的实体的：“它根本上不是通过属性定义的，而是通过一系列连续性和标识定义的”。因此，实体都有Id属性并且都存储到数据库中。一个实体一般会映射到数据库的一张表。</p>
</blockquote>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类###"></a>实体类###</h3><p>在ABP中，实体派生自<strong>Entity</strong>类，看下面的例子：</p>
<pre class=" language-C#"><code class="language-C#">public class Person : Entity
{
    public virtual string Name { get; set; }

    public virtual DateTime CreationTime { get; set; }

    public Person()
    {
        CreationTime = DateTime.Now;
    }
}
</code></pre>
<p>上面定义了一个<strong>Person</strong>实体类，而且在Entity类中定义了一个<strong>Id</strong>属性，它是该Entity类的 <strong>主键</strong>。因此，所有实体的主键名都是相同的，都是<strong>Id</strong>。</p>
<p>Id（主键）的类型是可以改变的，默认是int(int32)的。如果你想将Id定义为其他类型，可以像下面那样显示声明：</p>
<pre class=" language-C#"><code class="language-C#">public class Person : Entity<long>
{
    public virtual string Name { get; set; }

    public virtual DateTime CreationTime { get; set; }

    public Person()
    {
        CreationTime = DateTime.Now;
    }
}
</code></pre>
<p>而且，你也可以把它设置为string,Guid或其他类型的。</p>
<p>Entity类重写了<strong>等号</strong>运算符（==），可以轻松地检查两个实体是否相同了（实体的Id相同则认为它们相同）。它也定义了<strong>IsTransient</strong>方法来检测它是否有Id。</p>
<h3 id="惯例接口"><a href="#惯例接口" class="headerlink" title="惯例接口###"></a>惯例接口###</h3><p>在许多应用中，使用了相似的实体属性（和数据表中的字段），如CreationTime表明该实体是何时创建的。ABP提供了很多有用的接口来使得这些通用的属性变得明确并富有表现力。此外，这也为实现了这些接口的实体类提供了一种编写通用代码的方式。</p>
<h4 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h4><p><strong>IHasCreationTime</strong>使得使用一个通用的属性来描述一个实体的<strong>“创建时间”</strong>信息成为可能。当实现了该接口的实体类插入到数据库中时，ABP会自动地将<strong>当前的时间</strong>设置给CreationTime。</p>
<pre class=" language-C#"><code class="language-C#">public interface IHasCreationTime
{
    DateTime CreationTime { get; set; }
}
</code></pre>
<p>Person类可以通过实现<strong>IHasCreationTime</strong>接口来重写，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class Person : Entity<long>, IHasCreationTime
{
    public virtual string Name { get; set; }

    public virtual DateTime CreationTime { get; set; }

    public Person()
    {
        CreationTime = DateTime.Now;
    }
}
</code></pre>
<p><strong>ICreationAudited</strong>通过增加了<strong>CreatorUserId</strong>扩展了IHasCreationTime:</p>
<pre class=" language-C#"><code class="language-C#">public interface ICreationAudited : IHasCreationTime
{
    long? CreatorUserId { get; set; }
}
</code></pre>
<p>当保存一个新的实体时，ABP会自动地将<strong>当前的用户Id</strong>设置为CreatorUserId。</p>
<p>你也可以通过从<strong>CreationAuditedEntity</strong>类派生实体，从而轻易地实现ICreationAudited。</p>
<p>对于修改也有相似的接口：</p>
<pre class=" language-C#"><code class="language-C#">public interface IModificationAudited
{
    DateTime? LastModificationTime { get; set; }

    long? LastModifierUserId { get; set; }
}
</code></pre>
<p>当更新一个实体的时候，ABP也会自动地设置这些属性。你只需要为你的实体实现这些接口即可。</p>
<p>如果你想实现所有的审计属性，那么你可以直接实现<strong>IAudited</strong>接口：</p>
<pre class=" language-C#"><code class="language-C#">public interface IAudited : ICreationAudited, IModificationAudited
{
        
}
</code></pre>
<p>作为一个快捷方式，你可以从<strong>AuditedEntity</strong>类派生，而不需要直接实现<strong>IAudited</strong>。AuditedEntity类对于不同类型的Id属性也有泛型的版本。</p>
<h4 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h4><p>软删除是将一个实体标记为已删除的通常使用的模式，而不是直接从数据库中删除。比如，你可能不想从数据库中硬删除一个User，因为它可能关联其他的表。<strong>ISoftDelete</strong>接口用于下面的目的：</p>
<pre class=" language-C#"><code class="language-C#">public interface ISoftDelete
{
    bool IsDeleted { get; set; }
}
</code></pre>
<p>ABP实现了开箱即用的软删除模式。当一个软删除实体被删除后，ABP检测到之后，会阻止删除，将IsDeleted设置为true并更新数据库中的实体。而且，它会自动地过滤数据库中软删除的实体，不会检索（select）它们。</p>
<p>如果使用了软删除，那么你可能想存储一些信息，比如何时删除以及谁删除了一个实体等等。你可以实现下面演示的<strong>IDeletionAudited</strong>接口：</p>
<pre class=" language-C#"><code class="language-C#">public interface IDeletionAudited : ISoftDelete
{
    long? DeleterUserId { get; set; }

    DateTime? DeletionTime { get; set; }
}
</code></pre>
<p>IDeletionAudited扩展了ISoftDelete，当删除一个实体时，ABP会自动设置这些属性。</p>
<p>如果你想为一个实体实现所有的审计接口（创建，修改和删除），那么可以直接实现<strong>IFullAudited</strong>,因为它继承了所有的这些接口：</p>
<pre class=" language-C#"><code class="language-C#">public interface IFullAudited : IAudited, IDeletionAudited
{
        
}
</code></pre>
<p>同样的，作为一个快捷方式，你可以从<strong>FullAuditedEntity</strong>类派生你的实体类从而实现所有的审计接口。</p>
<p>注意：所有的审计接口和类都有一个定义导航属性到<strong>User</strong>实体的泛型版本（比如ICreationAudited和FullAuditedEntity&lt;TPrimaryKey,TUser&gt;）。</p>
<h4 id="激活-未激活"><a href="#激活-未激活" class="headerlink" title="激活/未激活"></a>激活/未激活</h4><p>一些实体需要标记为激活的或未激活的。这样，你就可以根据实体的激活或者未激活状态来采取行动。你可以实现<strong>IPassivable</strong>接口来达到目的。该接口定义了<strong>IsActive</strong>属性。</p>
<p>如果实体在第一次创建时是激活的，那么你可以在构造函数中将IsActive设置为true。</p>
<p>这与软删除（IsDeleted）是不同的。如果一个实体是软删除的，那么它就不会从数据库中检索到了（ABP默认会阻止），但是，对于激活或者未激活的实体，控制获取实体完全取决于你。</p>
<h3 id="IEntity接口"><a href="#IEntity接口" class="headerlink" title="IEntity接口###"></a>IEntity接口###</h3><p>实际上，<strong>Entity</strong>类实现了<strong>IEntity</strong>接口（且<strong>Entity</strong>实现了<strong>IEntity</strong>）。如果不想从Entity类中派生，那么可以直接实现这些接口。但是，除非你有一个好的原因不从Entity类派生，否则，不建议这么做。</p>
<h1 id="ABP理论学习之仓储"><a href="#ABP理论学习之仓储" class="headerlink" title="ABP理论学习之仓储"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html">ABP理论学习之仓储</a></h1><hr>
<h2 id="本篇目录-11"><a href="#本篇目录-11" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#IRepository">IRepository接口</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#query">查询</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#insert">插入</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#update">更新</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#delete">删除</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#others">其他</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#async">关于异步方法</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#repository">仓储实现</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#mdbcon">管理数据库连接</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#repositoryLife">仓储的生命周期</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPRepository.html#repositoryBestDo">仓储最佳实践</a></strong></li>
</ul>
<blockquote>
<h4 id="Martin-Fowler对仓储的定义"><a href="#Martin-Fowler对仓储的定义" class="headerlink" title="Martin Fowler对仓储的定义"></a>Martin Fowler对仓储的定义</h4><p>位于领域层和数据映射层之间，使用类似集合的接口来访问领域对象。</p>
</blockquote>
<p>在实践中，仓储是执行领域对象（实体和值对象）的数据库操作。一般地，一个分离的仓储用于一个实体（或者聚合根）。</p>
<h3 id="IRepository接口"><a href="#IRepository接口" class="headerlink" title="IRepository接口###"></a>IRepository接口###</h3><p>在ABP中，一个仓储类应该实现一个<strong>IRepository</strong>接口。为每一个仓储定义一个接口是一个好的做法。</p>
<p>一个Person实体的仓储定义如下：</p>
<pre class=" language-C#"><code class="language-C#">public interface IPersonRepository : IRepository<Person>
{
}
</code></pre>
<p>IPersonRepository扩展了<strong>IRepository</strong>，它用于定义拥有主键类型为int32的实体。如果你的实体不是int，那么可以扩展**IRepository&lt;TEntity,TPrimaryKey&gt;**接口，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public interface IPersonRepository : IRepository<Person, long>
{
}
</code></pre>
<p>IRepository为仓储类定义了最通用的方法，如select，insert，update和delete方法（CRUD操作）。大多数情况下，这些方法对于简单的实体是足够了。如果这些方法对于一个实体来说已经足够了，那么就没有必要为这个实体创建仓储接口和仓储类了。看下面。</p>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>IRepository定义了通用的方法，从数据库中检索实体。</p>
<h5 id="获得单个实体"><a href="#获得单个实体" class="headerlink" title="获得单个实体"></a>获得单个实体</h5><pre class=" language-C#"><code class="language-C#">TEntity Get(TPrimaryKey id);
Task<TEntity> GetAsync(TPrimaryKey id);
TEntity Single(Expression<Func<TEntity, bool>> predicate);
Task<TEntity> SingleAsync(Expression<Func<TEntity, bool>> predicate);
TEntity FirstOrDefault(TPrimaryKey id);
Task<TEntity> FirstOrDefaultAsync(TPrimaryKey id);
TEntity FirstOrDefault(Expression<Func<TEntity, bool>> predicate);
Task<TEntity> FirstOrDefaultAsync(Expression<Func<TEntity, bool>> predicate);
TEntity Load(TPrimaryKey id);
</code></pre>
<p><strong>Get</strong>方法用于获得一个给定主键（Id）的实体。如果在数据库中没有找到这个实体，就会抛出异常。<strong>Single</strong>方法和Get类似，但是它的参数是一个表达式而不是一个Id。因此，你可以使用Lambda表达式获得一个实体。样例用法：</p>
<pre class=" language-C#"><code class="language-C#">var person = _personRepository.Get(42);
var person = _personRepository.Single(p => p.Name == "Halil İbrahim Kalkan");
</code></pre>
<p>注意：如果根据给定的条件没有查找出实体或者查出不止一个实体，那么<strong>Single</strong>方法会抛出异常。</p>
<p><strong>FirstOrDefault</strong>是相似的，但是如果根据给的的Id或者表达式没有找到实体，那么就会返回<strong>null</strong>。如果对于给定的条件存在不止一个实体，那么会返回找到的第一个实体。</p>
<p><strong>Load</strong>方法不会从数据库中检索实体，但是会创建一个用于懒加载的代理对象。如果你只用了Id属性，那么Entity实际上并没有检索到。只有你访问实体的其他属性，才会从数据库中检索。考虑到性能因素，这个就可以替换Get方法。这在NHiberbate中也实现了。如果ORM提供者没有实现它，那么Load方法会和Get方法一样地工作。</p>
<p>一些方法有用于async编程模型的<strong>异步（async）</strong>版本。</p>
<p>获得实体的列表</p>
<pre class=" language-C#"><code class="language-C#">List<TEntity> GetAllList();
Task<List<TEntity>> GetAllListAsync();
List<TEntity> GetAllList(Expression<Func<TEntity, bool>> predicate);
Task<List<TEntity>> GetAllListAsync(Expression<Func<TEntity, bool>> predicate);
IQueryable<TEntity> GetAll();
</code></pre>
<p><strong>GetAllList</strong>从数据库中检索所有的实体。该方法的重载可以用于过滤实体。例子如下：</p>
<pre class=" language-C#"><code class="language-C#">var allPeople = _personRepository.GetAllList();
var somePeople = _personRepository.GetAllList(person => person.IsActive && person.Age > 42);
</code></pre>
<p><strong>GetAll</strong>返回的类型是IQueryable。因此，你可以在此方法之后添加Linq方法。例子如下：</p>
<pre class=" language-C#"><code class="language-C#">//Example 1
var query = from person in _personRepository.GetAll()
            where person.IsActive
            orderby person.Name
            select person;
var people = query.ToList();

//Example 2:
List<Person> personList2 = _personRepository.GetAll().Where(p => p.Name.Contains("H")).OrderBy(p => p.Name).Skip(40).Take(20).ToList();
</code></pre>
<p>有了GetAll方法，几乎所有的查询都可以使用Linq重写。甚至可以用在一个连接表达式中。</p>
<blockquote>
<h4 id="关于IQueryable"><a href="#关于IQueryable" class="headerlink" title="关于IQueryable"></a>关于IQueryable</h4><p>脱离了仓储方法调用GetAll()方法时，数据库连接必须要打开。这是因为IQueryable的延迟执行。直到调用ToList()方法或者在foreach循环中使用IQueryable(或者访问查询到的元素)时，才会执行数据库查询操作。因此，当调用ToList()方法时。数据库连接必须打开。这可以通过ABP中的<strong>UnitOfWork</strong>特性标记调用者方法来实现。注意：应用服务方法默认已经是UnitOfWork，因此，即使没有为应用服务层方法添加UnitOfWork特性，GetAll()方法也会正常工作。</p>
</blockquote>
<p>这些方法也存在用于异步编程模型的asyn版本。</p>
<h5 id="自定义返回值"><a href="#自定义返回值" class="headerlink" title="自定义返回值"></a>自定义返回值</h5><p>也存在提供了IQueryable的额外方法，在调用的方法中不需要使用UnitOfWork。</p>
<pre><code>T Query&lt;T&gt;(Func&lt;IQueryable&lt;TEntity&gt;, T&gt; queryMethod);
</code></pre>
<p>Query方法接受一个接收IQueryable的lambda(或方法)，并返回任何对象的类型。例子如下：</p>
<pre class=" language-C#"><code class="language-C#">var people = _personRepository.Query(q => q.Where(p => p.Name.Contains("H")).OrderBy(p => p.Name).ToList());
</code></pre>
<p>在该仓储方法中，因为执行了给定的lambda(或方法)，它是在数据库连接打开的时候执行的。你可以返回实体列表，单个实体，一个投影或者执行了该查询的其他东西。</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>IRepository接口定义了将一个实体插入数据库的简单方法：</p>
<pre class=" language-C#"><code class="language-C#">TEntity Insert(TEntity entity);
Task<TEntity> InsertAsync(TEntity entity);
TPrimaryKey InsertAndGetId(TEntity entity);
Task<TPrimaryKey> InsertAndGetIdAsync(TEntity entity);
TEntity InsertOrUpdate(TEntity entity);
Task<TEntity> InsertOrUpdateAsync(TEntity entity);
TPrimaryKey InsertOrUpdateAndGetId(TEntity entity);
Task<TPrimaryKey> InsertOrUpdateAndGetIdAsync(TEntity entity);
</code></pre>
<p><strong>Insert</strong>方法简化了将一个实体插入数据库，并将刚刚插入的实体返回。<strong>InsertAndGetId</strong>方法返回了新插入实体的Id。如果实体的Id是自动增长的并且需要最新插入实体的Id，那么该方法很有用。<strong>InsertOrUpdate</strong>方法通过检查Id的值插入或更新给定的实体。最后，当插入或者更新之后，<strong>InsertOrUpdateAndGetId</strong>返回该实体的值。</p>
<p>所有的方法都存在用于异步编程模型的async版本。</p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>IRepository定义了一个方法来更新数据库中已存在的实体。它可以获得要更新的实体并返回相同的实体对象。</p>
<pre class=" language-C#"><code class="language-C#">TEntity Update(TEntity entity);
Task<TEntity> UpdateAsync(TEntity entity);
</code></pre>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>IRepository定义了从数据库中删除一个已存在的实体的方法。</p>
<pre class=" language-C#"><code class="language-C#">void Delete(TEntity entity);
Task DeleteAsync(TEntity entity);
void Delete(TPrimaryKey id);
Task DeleteAsync(TPrimaryKey id);
void Delete(Expression<Func<TEntity, bool>> predicate);
Task DeleteAsync(Expression<Func<TEntity, bool>> predicate);
</code></pre>
<p>第一个方法接受一个已存在的实体，第二个方法接受一个要删除的实体的Id。</p>
<p>最后一个方法接受一个删除符合给定条件的所有实体的方法。注意，匹配给定谓词的所有实体都会从数据库中检索到然后被删除。因此，小心使用它，如果给定的条件存在太多的实体，那么可能会造成性能问题。</p>
<h4 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h4><p>IRepository也提供了获得表中实体数量的方法。</p>
<pre class=" language-C#"><code class="language-C#">int Count();
Task<int> CountAsync();
int Count(Expression<Func<TEntity, bool>> predicate);
Task<int> CountAsync(Expression<Func<TEntity, bool>> predicate);
long LongCount();
Task<long> LongCountAsync();
long LongCount(Expression<Func<TEntity, bool>> predicate);
Task<long> LongCountAsync(Expression<Func<TEntity, bool>> predicate);
</code></pre>
<h4 id="关于异步方法"><a href="#关于异步方法" class="headerlink" title="关于异步方法"></a>关于异步方法</h4><p>ABP支持异步编程模型（APM）。因此，仓储方法有异步版本。下面是一个使用了异步模型的应用服务方法样例：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService : AbpWpfDemoAppServiceBase, IPersonAppService
{
    private readonly IRepository<Person> _personRepository;

    public PersonAppService(IRepository<Person> personRepository)
    {
        _personRepository = personRepository;
    }

    public async Task<GetPeopleOutput> GetAllPeople()
    {
        var people = await _personRepository.GetAllListAsync();
            
        return new GetPeopleOutput
        {
            People = Mapper.Map<List<PersonDto>>(people)
        };
    }
}
</code></pre>
<p>GetAllPeople方法是异步的，并使用了具有await关键字的GetAllListAsync方法。</p>
<p>也许不是所有的ORM框架都支持Async，但是EntityFramework支持。如果不支持，异步仓储方法就会同步进行。比如，在EF中，InsertAsync和Insert是等效的，因为直到工作单元完成（Dbcontext.SaveChanges），EF才会将新的实体写入数据库。</p>
<h3 id="仓储实现"><a href="#仓储实现" class="headerlink" title="仓储实现###"></a>仓储实现###</h3><p>ABP的设计独立于一个特定的ORM(对象/关系映射)框架或者访问数据库的其他技术。通过实现仓储接口，可以使用任何框架。</p>
<p>ABP使用<strong>NHibernate</strong>和 <strong>EntityFramework</strong>实现了开箱即用的仓储。关于这两个ORM框架可以关注后面的文档。</p>
<p>当使用NHibernate或EntityFramework时，如果标准方法是足够使用的话，那么不必为实体类创建仓储了。你可以直接注入<strong>IRepository</strong>(或IRepository&lt;TEntity，TPrimaryKey&gt;)。下面是使用了一个仓储将一个实体插入数据库的应用服务例子：</p>
<pre class=" language-c#"><code class="language-c#">public class PersonAppService : IPersonAppService
{
    private readonly IRepository<Person> _personRepository;

    public PersonAppService(IRepository<Person> personRepository)
    {
        _personRepository = personRepository;
    }

    public void CreatePerson(CreatePersonInput input)
    {        
        person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };
        
        _personRepository.Insert(person);
    }
}
</code></pre>
<p>PersonAppService构造注入了<strong>IRepository</strong>，并使用了<strong>Insert</strong>方法。这样，当你需要为一个实体创建一个自定义仓储方法时，你才应该为该实体创建一个仓储类。</p>
<h3 id="管理数据库连接"><a href="#管理数据库连接" class="headerlink" title="管理数据库连接###"></a>管理数据库连接###</h3><p>在仓储方法中，数据库连接是没有打开的或是关闭的。ABP对于数据库连接的管理是自动处理的。</p>
<p>当将要进入一个仓储方法时，数据库连接会自动打开，并且<strong>事务</strong>自动开始。当仓储方法结束并返回的时候，ABP会自动完成：保存所有的更改，完成事务的提交和关闭数据库连接。如果仓储方法抛出任何类型的异常，那么事务会自动<strong>回滚</strong>并关闭数据库。这对于所有的实现了IRepository接口的类的公共方法都是成立的。</p>
<p>如果一个仓储方法调用了其他的仓储方法，那么它们会共享相同的连接和事务。进入仓储的第一个方法会管理数据库的连接。更多信息，请留意后面博客的工作单元。</p>
<p>一篇不错的数据库连接博客：**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/liuhaorain/archive/2012/02/19/2353110.html">细说数据库连接</a>**</p>
<h3 id="仓储的生命周期"><a href="#仓储的生命周期" class="headerlink" title="仓储的生命周期###"></a>仓储的生命周期###</h3><p>所有的仓储实例都是<strong>Transient</strong>(每次使用时都会实例化)的。ABP强烈推荐使用依赖注入技术。当一个仓储类需要注入时，依赖注入的容器会自动创建该类的新实例。</p>
<h3 id="仓储最佳实践"><a href="#仓储最佳实践" class="headerlink" title="仓储最佳实践###"></a>仓储最佳实践###</h3><ul>
<li>对于一个T类型的实体，使用IRepository仓储接口。除非真的需要，否则不要创建自定义的仓储。预定义的仓储方法对于很多情况足够用了。</li>
<li>如果你正在创建一个自定义的仓储（通过扩展IRepository）： 仓储类应该是无状态的。这意味着，你不应该定义仓储级别的状态对象，而且一个仓储方法调用不应该影响其他的调用。 自定义仓储方法不应该包含业务逻辑或者应用逻辑，而应该只执行数据相关的或者orm特定的任务。 当仓储使用依赖注入时，给其他服务定义更少的或者不要定义依赖。</li>
</ul>
<h1 id="ABP理论学习之领域服务（重点）"><a href="#ABP理论学习之领域服务（重点）" class="headerlink" title="ABP理论学习之领域服务（重点）"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html">ABP理论学习之领域服务（重点）</a></h1><hr>
<h2 id="本篇目录-12"><a href="#本篇目录-12" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#IDomain">IDomainService接口和DomainService类</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#sample">样例</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#create">创建一个接口</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#service">服务实现</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#call">调用应用服务</a></strong></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#discussion">一些讨论</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#whynot">何不只使用应用服务</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDomainService.html#forceUse">如何强制使用领域服务</a></strong></li>
</ul>
</li>
</ul>
<h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍###"></a>介绍###</h3><p>领域服务（或DDD中的服务）用于执行领域操作和业务规则。Eric Evans描述了一个好的服务应该具备下面三个特征：</p>
<ol>
<li>和领域概念相关的操作不是一个实体或者值对象的本质部分。</li>
<li>接口定义在领域模型其他元素的条款中。</li>
<li>操作是无状态的。</li>
</ol>
<p>跟获得或返回一个数据传输对象的应用服务方法（DTO）不同，领域服务获得或者返回一个<strong>领域对象</strong>（比如实体或值类型）。</p>
<p>一个领域服务可以用于应用服务，也可以用于其他的领域服务，但不能直接用于展现层，服务层才直接用于展现层。</p>
<h3 id="IDomainService接口和DomainService类"><a href="#IDomainService接口和DomainService类" class="headerlink" title="IDomainService接口和DomainService类###"></a>IDomainService接口和DomainService类###</h3><p>ABP定义了<strong>IDomainService</strong>接口，所有的领域服务都按照惯例实现了该接口。当实现时，领域服务会以<strong>transient自动注册</strong>到依赖注入系统。</p>
<p>此外，领域服务（可选地）可以从<strong>DomainService类</strong>继承。因此，它可以使用一些继承的属性，比如logging，本地化等等。当然，如果没有继承，如果需要的话也可以注入这些属性。</p>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例###"></a>样例###</h3><p>假设我们有一个任务管理系统并且有将一个任务派给一个人的业务规则。</p>
<h4 id="创建一个接口"><a href="#创建一个接口" class="headerlink" title="创建一个接口"></a>创建一个接口</h4><p>首先我们为该服务定义一个接口（不是必须的，但是这样是一个好的实践）：</p>
<pre class=" language-C#"><code class="language-C#">public interface ITaskManager : IDomainService
{
    void AssignTaskToPerson(Task task, Person person);
}
</code></pre>
<p>可以看到，<strong>TaskManager</strong>服务使用领域对象工作：一个<strong>Task</strong> 和一个<strong>Person</strong>。命名领域服务时存在一些惯例。它可以是TaskManager，TaskService或者TaskDomainService…</p>
<h4 id="服务实现"><a href="#服务实现" class="headerlink" title="服务实现"></a>服务实现</h4><p>先来看看下面这个实现：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskManager : DomainService, ITaskManager
{
    public const int MaxActiveTaskCountForAPerson = 3;

    private readonly ITaskRepository _taskRepository;

    public TaskManager(ITaskRepository taskRepository)
    {
        _taskRepository = taskRepository;
    }

    public void AssignTaskToPerson(Task task, Person person)
    {
        if (task.AssignedPersonId == person.Id)
        {
            return;
        }

        if (task.State != TaskState.Active)
        {
            throw new ApplicationException("Can not assign a task to a person when task is not active!");
        }

        if (HasPersonMaximumAssignedTask(person))
        {
            throw new UserFriendlyException(L("MaxPersonTaskLimitMessage", person.Name));
        }

        task.AssignedPersonId = person.Id;
    }

    private bool HasPersonMaximumAssignedTask(Person person)
    {
        var assignedTaskCount = _taskRepository.Count(t => t.State == TaskState.Active && t.AssignedPersonId == person.Id);
        return assignedTaskCount >= MaxActiveTaskCountForAPerson;
    }
}
</code></pre>
<p>上面的代码定义了两个业务规则：</p>
<ul>
<li>一个任务为了能够派给一个新人，它应该是<strong>Active（激活）的状态</strong></li>
<li>一个人可以<strong>最多可以有3个</strong>激活的任务。</li>
</ul>
<p>你可能想知道为啥第一次检测时抛出了一个<strong>ApplicationException</strong>，而第二次检查时抛出了<strong>UserFriendlyException</strong>，请关注后面博客的异常处理。这根领域服务根本无关。这里这样处理的想法是这样的，UI必须先要检查一个任务的状态，否则不应该允许我们将它派给一个人。这是一个应用程序的错误，并且我们可以向用户隐藏这个错误。对于第二个友好的异常信息，UI检查更加困难，而且我们可以向用户显示一个可读的错误信息。这只是一个例子而已。</p>
<h4 id="调用应用服务"><a href="#调用应用服务" class="headerlink" title="调用应用服务"></a>调用应用服务</h4><p>现在，来看看如何在一个应用服务中使用TaskManager:</p>
<pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService, ITaskAppService
{
    private readonly IRepository<Task, long> _taskRepository;
    private readonly IRepository<Person> _personRepository;
    private readonly ITaskManager _taskManager;

    public TaskAppService(IRepository<Task, long> taskRepository, IRepository<Person> personRepository , ITaskManager taskManager)
    {
        _taskRepository = taskRepository;
        _personRepository = personRepository;
        _taskManager = taskManager;
    }

    public void AssignTaskToPerson(AssignTaskToPersonInput input)
    {
        var task = _taskRepository.Get(input.TaskId);
        var person = _personRepository.Get(input.PersonId);

        _taskManager.AssignTaskToPerson(task, person);
    }
}
</code></pre>
<p>Task<strong>应用服务</strong>使用给定的<strong>DTO</strong>(输入)和<strong>仓储</strong>来检索相关的<strong>task</strong>和 <strong>person</strong>，并将它们传给 <strong>TaskManager</strong>(领域服务)。</p>
<h3 id="一些讨论"><a href="#一些讨论" class="headerlink" title="一些讨论###"></a>一些讨论###</h3><p>基于上面的例子，你可能会存在下面的疑问。</p>
<h4 id="何不只使用应用服务"><a href="#何不只使用应用服务" class="headerlink" title="何不只使用应用服务"></a>何不只使用应用服务</h4><p>你可能会问，为什么不使用应用服务实现领域服务中的逻辑呢？</p>
<p>我们可以简单地说，它不是应用服务要干的活。因为领域逻辑不是一个<strong>用例（use-case）</strong>，而是一个 <strong>业务操作</strong>。我们可以在不同的用例中使用相同的“将一个任务派给一个人”的逻辑。比如说我们以后会更新这个任务，并且将这个任务派给其他人。因此，我们可以使用相同的领域逻辑，这个逻辑就是“将一个任务派给一个人”，我们不用考虑这个具体的人和具体的任务。此外，我们可能有两个不同的UI（一个移动端应用和一个web应用）来共享相同的领域。</p>
<p>下面根据个人的理解来画个图：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151222234720249-1003510440.png" alt="img"></p>
<p>如上图，应用服务层中有一个应用服务方法，但却使用到了领域层的三个业务逻辑，因为在领域层中，获取单个task和person都各自为一个业务逻辑，将一个任务派给一个人又是一个业务逻辑。在应用服务层，我们只需要获得一个人和一个任务就行，然后将该任务派给这个人，根本不需要考虑这个人和这个任务的获取细节，也不用考虑任务派发的细节，因为这完全不是应用层考虑的事儿。</p>
<p>如果你的领域很简单，只有一个UI并且将一个任务派发给一个人在单点处就可以完成，那么你可以跳过领域服务，然后在应用服务层实现该逻辑。虽然这不是DDD的最佳实践，但是ABP不会强制你这么设计。</p>
<h4 id="如何强制使用领域服务"><a href="#如何强制使用领域服务" class="headerlink" title="如何强制使用领域服务"></a>如何强制使用领域服务</h4><p>你可以看到，应用服务只能做下面的事情：</p>
<pre class=" language-C#"><code class="language-C#">public void AssignTaskToPerson(AssignTaskToPersonInput input)
{
    var task = _taskRepository.Get(input.TaskId);

    task.AssignedPersonId = input.PersonId;
}
</code></pre>
<p>开发这个应用服务的开发者可能不知道存在一个<strong>TaskManager</strong>，而且可以直接将给定的 <strong>PersonId</strong>设置给任务的 <strong>AssignedPersonId</strong>。那么，如何阻止他这样做呢？基于这些，在DDD领域中存在很多讨论和使用到的模式。我们不会涉及得很深，但是可以提供<br> 一种简单的方式。</p>
<p>我们可以将<strong>Task</strong>改成下面这样：</p>
<pre class=" language-C#"><code class="language-C#">public class Task : Entity<long>
{
    public virtual int? AssignedPersonId { get; protected set; }

    //...其他成员

    public void AssignToPerson(Person person, ITaskPolicy taskPolicy)
    {
        taskPolicy.CheckIfCanAssignTaskToPerson(this, person);

        AssignedPersonId = person.Id;
    }
}
</code></pre>
<p>可以将<strong>AssignedPersonId</strong>的setter改成protected。这样，它就不能在Task实体类之外改变了。添加一个需要一个Person和ITaskPolicy的参数。<strong>CheckIfCanAssignTaskToPerson</strong>方法检查这是否是一个有效的派发，如果无效就抛出一个适当的异常。最后，应用服务方法应该是这个样子的：</p>
<pre class=" language-C#"><code class="language-C#">public void AssignTaskToPerson(AssignTaskToPersonInput input)
{
    var task = _taskRepository.Get(input.TaskId);
    var person = _personRepository.Get(input.PersonId);

    task.AssignToPerson(person, _taskPolicy);
}
</code></pre>
<p>现在，不存在将一个任务派给一个人的第二种方法了。我们应该总是要使用AssignToPerson方法，而且不能跳过业务规则了。</p>
<h1 id="ABP理论学习之工作单元-Unit-of-Work-（重要）"><a href="#ABP理论学习之工作单元-Unit-of-Work-（重要）" class="headerlink" title="ABP理论学习之工作单元(Unit of Work)（重要）"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html">ABP理论学习之工作单元(Unit of Work)（重要）</a></h1><hr>
<h2 id="本篇目录-13"><a href="#本篇目录-13" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#ways">公共连接和事务管理方法</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#abpConn">ABP中的连接和事务管理</a></strong><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#repo">仓储类</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#appService">应用服务</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#uow">工作单元</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#uowDetail">工作单元详解</a></strong><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#disable">关闭工作单元</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#nonTrans">非事务的工作单元</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#callAnother">工作单元方法调用其它</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#scope">工作单元作用域</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#autoSaving">自动保存</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#getAll">IRepository.GetAll()方法</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#restrictions">UnitOfWork特性的限制</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#options">选项</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#methods">方法</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPUnitofWork.html#events">事件</a></strong></li>
</ul>
<h3 id="公共连接和事务管理方法"><a href="#公共连接和事务管理方法" class="headerlink" title="公共连接和事务管理方法"></a>公共连接和事务管理方法</h3><p>在使用了数据库的应用中，连接和事务管理是最重要的概念之一。何时打开一个连接,何时开始一个事务，如何释放连接等等。</p>
<p>你可能已经知道，Net使用了连接池。因此，创建一个连接实际上是从连接池中获取一个连接，因为因为创建一个连接是有消耗的。如果在连接池中没有可用的连接，那么会创建一个新的连接，并将该连接加入连接池。当你释放连接时，实际上是将该连接发送回给连接池，并没有完全释放。这种机制是.Net提供的立即可用的功能。因此，在我们使用完一个连接后应该立即释放，在需要的时候才创建一个新的连接。总之，最佳实践记住这八个字足矣：<strong>尽晚打开，尽早释放</strong>。</p>
<p>这里我推荐一篇关于数据库连接的文章，写得很浅显易懂：**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/liuhaorain/archive/2012/02/19/2353110.html">《细说数据库连接》</a>**</p>
<p>在一个应用中创建或者释放一个数据库连接，通常有2种方法。</p>
<p><strong>第一种方法</strong>：当Web请求开始（在Global.asax的Application_BeginRequest事件中）的时候创建一个连接，在所有的数据库操作时使用相同的连接，并且在请求结束（Application_EndRequest）时关闭或者释放该连接。这种方法很简单但是不够高效。为啥呢？</p>
<ul>
<li>在一个请求中也许没有数据库操作，但是连接已经打开了。这造成了连接池的无效使用。</li>
<li>在一次请求中，可能请求需要消耗很长的时间而数据库操作只花费很短的时间，这也会造成连接池的无效使用。</li>
<li>这只在Web应用中是可行的。如果应用是一个Windows服务，那么可能不会实现。</li>
</ul>
<p>以<strong>事务</strong>的方式执行数据库操作已被认为是一种最佳实践。如果一个操作失败了，那么所有的操作都会回滚。因为一个事务可以锁定数据库中的一些行（甚至表），所以它必须是短暂存活的。</p>
<p><strong>第二种方法</strong>：当需要时（仅在使用前）创建一个连接，使用后立即关闭。这是最有效的，但是到处创建或者释放连接是一项重复乏味的工作。</p>
<h3 id="ABP中的连接和事务管理"><a href="#ABP中的连接和事务管理" class="headerlink" title="ABP中的连接和事务管理"></a>ABP中的连接和事务管理</h3><p>ABP兼备了这两种方法并且提供了一个简单而又有效的模型。</p>
<h4 id="仓储类"><a href="#仓储类" class="headerlink" title="仓储类"></a>仓储类</h4><p>仓储式执行数据库操作主要的类。当进入一个仓储方法时，ABP会打开一个数据库连接（可能不是立即打开，但是在第一次使用数据库时肯定是打开的，取决于ORM提供者的实现）并开始一个事务。因此，在一个仓储方法中可以安全地使用连接。在方法的结束，事务被提交并且连接被释放。如果仓储方法抛出任何异常，那么事务都会<strong>回滚</strong>且连接被释放。这样一来，仓储方法就是<strong>原子的（一个工作单元）</strong>。ABP对于这些会自动处理。这里是一个简单的仓储：</p>
<pre class=" language-C#"><code class="language-C#">public class ContentRepository : NhRepositoryBase<Content>, IContentRepository
{
    public List<Content> GetActiveContents(string searchCondition)
    {
        var query = from content in Session.Query<Content>()
                    where content.IsActive && !content.IsDeleted
                    select content;

        if (!string.IsNullOrEmpty(searchCondition))
        {
            query = query.Where(content => content.Text.Contains(searchCondition));
        }

        return query.ToList();
    }
}
</code></pre>
<p>这个例子使用了NHibernate作为ORM。正如上面演示的，没有编写数据库连接（在NHibernate中是Session）打开或者关闭的代码。</p>
<p>如果一个仓储方法调用了其他的仓储方法（一般而言，如果一个工作单元调用了其他的工作单元方法），那么它们共享相同的连接和事务。第一个进入的方法管理连接和事务，其他方法使用相同的连接和事务。</p>
<h4 id="应用服务"><a href="#应用服务" class="headerlink" title="应用服务"></a>应用服务</h4><p>一个应用服务也被认为是一个工作单元。假设我们有一个像下面的应用服务：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService : IPersonAppService
{
    private readonly IPersonRepository _personRepository;
    private readonly IStatisticsRepository _statisticsRepository;

    public PersonAppService(IPersonRepository personRepository, IStatisticsRepository statisticsRepository)
    {
        _personRepository = personRepository;
        _statisticsRepository = statisticsRepository;
    }

    public void CreatePerson(CreatePersonInput input)
    {
        var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };
        _personRepository.Insert(person);
        _statisticsRepository.IncrementPeopleCount();
    }
}
</code></pre>
<p>在CreatePerson方法中，我们使用了person仓储插入了一个person，而且使用statistics仓储增加总人数。在这里例子中，这两个仓储共享相同的连接和事务，因为它们在一个应用服务方法中。ABP在进入CreatePerson方法时打开一个数据库连接并开始一个事务，如果没有抛出异常事务会在方法结尾时提交，如果有任何异常发生，将会回滚。这样一来，在CreatePerson方法中的所有数据库操作都成了<strong>原子的（工作单元）</strong>。</p>
<h4 id="工作单元"><a href="#工作单元" class="headerlink" title="工作单元"></a>工作单元</h4><p>工作单元对于仓储和应用服务方法<strong>隐式</strong>有效。如果你想在其他地方控制数据库连接和事务，那么可以<strong>显式</strong>使用它。</p>
<h5 id="UnitOfWork特性"><a href="#UnitOfWork特性" class="headerlink" title="UnitOfWork特性"></a>UnitOfWork特性</h5><p>最受人欢迎的方法是使用<strong>UnitOfWorkAttribute</strong>。例如：</p>
<pre class=" language-C#"><code class="language-C#">[UnitOfWork]
public void CreatePerson(CreatePersonInput input)
{
    var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };
    _personRepository.Insert(person);
    _statisticsRepository.IncrementPeopleCount();
}
</code></pre>
<p>这样，CreatePerson方法变成了工作单元并且管理数据库连接和事务，两个仓储使用相同的工作单元，注意的是，如果这是一个应用服务方法，就不需要UnitOfWork特性。</p>
<h5 id="IUnitOfWorkManager"><a href="#IUnitOfWorkManager" class="headerlink" title="IUnitOfWorkManager"></a>IUnitOfWorkManager</h5><p>第二种方法是使用**IUnitOfWorkManager.Begin()**方法，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class MyService
{
    private readonly IUnitOfWorkManager _unitOfWorkManager;
    private readonly IPersonRepository _personRepository;
    private readonly IStatisticsRepository _statisticsRepository;

    public MyService(IUnitOfWorkManager unitOfWorkManager, IPersonRepository personRepository, IStatisticsRepository statisticsRepository)
    {
        _unitOfWorkManager = unitOfWorkManager;
        _personRepository = personRepository;
        _statisticsRepository = statisticsRepository;
    }

    public void CreatePerson(CreatePersonInput input)
    {
        var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };

        using (var unitOfWork = _unitOfWorkManager.Begin())
        {
            _personRepository.Insert(person);
            _statisticsRepository.IncrementPeopleCount();

            unitOfWork.Complete();
        }
    }
}
</code></pre>
<p>你可以注入然后使用IUnitOfWork，正如这里演示的这样（如果你的应用继承自ApplicationService类，那么你可以直接使用<strong>CurrentUnitOfWork</strong>属性。如果没有，你要先注入IUnitOfWorkManager）。这样，你就可以创建更多的<strong>限制作用域</strong>的工作单元。用这种方法，你应该手动调用<strong>Complete</strong>方法。如果没有调用，事务就会回滚，改变就不会保存。</p>
<p>Begin方法有很多重载来设置<strong>工作单元选项</strong>。</p>
<p>如果找不到一个很好的理由，建议还是使用<strong>UnitOfWork特性</strong>，因为代码越短越好。</p>
<h3 id="工作单元详解"><a href="#工作单元详解" class="headerlink" title="工作单元详解"></a>工作单元详解</h3><h4 id="关闭工作单元"><a href="#关闭工作单元" class="headerlink" title="关闭工作单元"></a>关闭工作单元</h4><p>有时候你可能想关闭应用服务方法的工作单元（因为默认是开启的），此时，可以使用UnitOfWorkAttribute的IsDisabled属性。用法如下：</p>
<pre class=" language-C#"><code class="language-C#">[UnitOfWork(IsDisabled = true)]
public virtual void RemoveFriendship(RemoveFriendshipInput input)
{
    _friendshipRepository.Delete(input.Id);
}
</code></pre>
<p>正常情况下，不需要关闭数据单元，因为应用服务方法应该是原子的且一般都会使用数据库。但也有些例外情况让你想要关闭应用服务方法的工作单元：</p>
<ul>
<li>方法不执行任何数据库操作而且你也不想打开一个没有必要的数据库连接。</li>
<li>如上面描述的，你想要在一个UnitOfWorkScope类的有限作用域内使用工作单元。</li>
</ul>
<p><strong>注意：</strong>如果一个工作单元方法调用了这个<em>RemoveFriendship</em>方法，那么后者的关闭工作单元的功能将会失效，并且也会使用和调用者方法相同的工作单元。因此，要小心使用工作单元的关闭功能。</p>
<h4 id="非事务的工作单元"><a href="#非事务的工作单元" class="headerlink" title="非事务的工作单元"></a>非事务的工作单元</h4><p>工作单元默认是事务的（本质如此）。因此，ABP会开始-&gt;提交-&gt;回滚一个显式的数据库级别的事务。在一些特殊场合，事务可能会造成问题，因为它可能会锁住数据库中的一些行或者表。在这种情况下，你可能想关闭数据库级别的事务。UnitOfWork特性可以在构造函数中获得一个布尔值，从而以非事务形式工作。用法如下：</p>
<pre class=" language-C#"><code class="language-C#">[UnitOfWork(isTransactional: false)]
public GetTasksOutput GetTasks(GetTasksInput input)
{
    var tasks = _taskRepository.GetAllWithPeople(input.AssignedPersonId, input.State);
    return new GetTasksOutput
            {
                Tasks = Mapper.Map<List<TaskDto>>(tasks)
            };
}
</code></pre>
<p>建议使用**[UnitOfWork(isTransactional: false)]**，因为它是更具可读性的，但你也可以使用[UnitOfWork(false)]。</p>
<p>注意ORM框架（如EF和NH）内部使用了一条单一命令来保存更改。假设你以非事务的UOW（工作单元）更新了一些实体的情景，甚至在这种情况下所有的更新都是在工作单元结束时以一个单一的数据库命令执行的。但是如果你直接执行一个SQL查询，它会立即执行。</p>
<p>非事务的UOW有一个限制。如果你已经处于一个事务的工作单元的作用域内，那么将isTransactional设置为false将会被忽略。</p>
<p>使用非事务的工作单元要小心，因为大多数时候对于数据的集成是事务的。如果你的方法只是读数据，不需要改变数据，当然该方法是可以为非事务的了。</p>
<h4 id="工作单元方法调用其它"><a href="#工作单元方法调用其它" class="headerlink" title="工作单元方法调用其它"></a>工作单元方法调用其它</h4><p>如果一个工作单元的方法（使用了UnitOfWork特性声明的方法）调用另一个工作单元的方法，那么它们共享相同的连接和事务。第一个方法管理连接，其他方法使用连接。这个对于运行在相同<strong>线程</strong>的方法是成立的（对于web应用则是相同的请求）。实际上，当一个工作单元作用域开始时，在同一线程执行的所有代码都共享同一个连接和事务，直到工作单元作用域结束。这对于UnitOfWork特性和UnitOfWorkScope类都是成立的。</p>
<h4 id="工作单元作用域"><a href="#工作单元作用域" class="headerlink" title="工作单元作用域"></a>工作单元作用域</h4><p>在其他事务中可以创建一个不同而又隔离的事务，或者可以在一个事务中创建一个非事务的作用域。.Net中定义了**<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/system.transactions.transactionscopeoption(v=vs.110).aspx">TransactionScopeOption</a>**，你可以为工作单元设置作用域选项。</p>
<h4 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h4><p>当我们为一个方法使用了工作单元时，ABP会在该方法结束时自动保存所有的更改。假设我们有一个更新person的name的方法：</p>
<pre class=" language-C#"><code class="language-C#">[UnitOfWork]
public void UpdateName(UpdateNameInput input)
{
    var person = _personRepository.Get(input.PersonId);
    person.Name = input.NewName;
}
</code></pre>
<p>你要做的就这么多，person的name就改变了。我们甚至不用调用<strong>_personRepository.Update</strong>方法。ORM框架会跟踪工作单元中实体的所有改变，并将改变反应给数据库。</p>
<p>注意没有必要为应用服务方法声明<strong>UnitOfWork</strong>特性，因为它们默认已经是工作单元了。</p>
<h4 id="IRepository-GetAll-方法"><a href="#IRepository-GetAll-方法" class="headerlink" title="IRepository.GetAll()方法"></a>IRepository.GetAll()方法</h4><p>当在一个仓储方法之外调用GetAll()时，必须存在一个打开的数据库连接，因为GetAll返回了<strong>IQueryable</strong>，而且IQueryable会延迟执行。直到调用ToList()方法或者在foreach循环中使用IQueryable,才会真正执行数据库查询。因此，调用ToList()方法时，数据库连接必须是活着的（alive）。</p>
<p>考虑一下下面的例子：</p>
<pre class=" language-C#"><code class="language-C#">[UnitOfWork]
public SearchPeopleOutput SearchPeople(SearchPeopleInput input)
{
    //返回IQueryable<Person>
    var query = _personRepository.GetAll();

    //添加一些过滤
    if (!string.IsNullOrEmpty(input.SearchedName))
    {
        query = query.Where(person => person.Name.StartsWith(input.SearchedName));
    }

    if (input.IsActive.HasValue)
    {
        query = query.Where(person => person.IsActive == input.IsActive.Value);
    }

    //获得分页结果列表
    var people = query.Skip(input.SkipCount).Take(input.MaxResultCount).ToList();

    return new SearchPeopleOutput { People = Mapper.Map<List<PersonDto>>(people) };
}
</code></pre>
<p>这里，SearchPeople方法必须是工作单元，因为IQueryable的ToList()在方法体内调用了，当执行IQueryable.ToList()执行时，数据库连接必须是打开的状态。</p>
<p>就像GetAll()方法一样，如果在仓储之外需要数据库连接，那么必须使用工作单元。注意，应用服务方法默认是工作单元。</p>
<h4 id="UnitOfWork特性的限制"><a href="#UnitOfWork特性的限制" class="headerlink" title="UnitOfWork特性的限制"></a>UnitOfWork特性的限制</h4><p>UnitOfWork可以用于以下几个条件：</p>
<ul>
<li>所有用于接口的类的<strong>public或public virtual</strong>方法（如用于用于服务接口的应用服务类的方法）。</li>
<li>自注入类的所有<strong>public virtual</strong>（如MVC 控制器和Web Api控制器）。</li>
<li>所有的<strong>protected virtual</strong>方法。</li>
</ul>
<p>建议总是将方法声明为<strong>virtual</strong>，但是<strong>不能用于private方法</strong>。因为ABP为virtual方法私有了动态代理，private方法不能被派生的类访问到。如果你没有使用依赖注入且实例化类，那么UnitOfWork特性（和任何代理）就不能工作。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>有很多可以用于改变工作单元行为的选项。</p>
<p>首先，我们可以在启动配置中更改所有工作单元的默认值。这通常是在模块的PreInitialize方法中处理的。</p>
<pre class=" language-C#"><code class="language-C#">public class SimpleTaskSystemCoreModule : AbpModule
{
    public override void PreInitialize()
    {
        Configuration.UnitOfWork.IsolationLevel = IsolationLevel.ReadCommitted;
        Configuration.UnitOfWork.Timeout = TimeSpan.FromMinutes(30);
    }

    //...其他模块方法
}
</code></pre>
<p>其次，我们可以为一个特定的工作单元重写默认值。比如，<strong>UnitOfWork</strong>特性的构造函数和IUnitOfWorkManager的<strong>Begin</strong>方法都有获得选项的重载。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>UnitOfWork系统无缝而不可见地工作。但是在某些场合，你需要调用它的方法。</p>
<h4 id="SaveChanges"><a href="#SaveChanges" class="headerlink" title="SaveChanges"></a>SaveChanges</h4><p>ABP会在工作单元结束时保存所有更改，我们根本不用做任何事情。但是有时候你可能想在工作单元操作的中间将更改保存到数据库中。在这种情况下，你可以注入IUnitOfWorkManager，然后调用IUnitOfWorkManager.Current.**SaveChanges()**方法。注意：如果当前的工作单元是事务的，那么如果有异常发生了，事务中的所有改变都会回滚，即使是已保存的改变。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>工作单元有<strong>Completed,Failed和Disposed</strong>事件。你可以注册这些事件，然后执行需要的操作。通过注入IUnitOfWorkManager然后使用IUnitOfWorkManager.Current属性来获得激活的工作单元，然后注册到它的事件。</p>
<p>在当前的工作单元成功完成时，你可能想运行一些代码，下面是一个例子：</p>
<pre class=" language-C#"><code class="language-C#">public void CreateTask(CreateTaskInput input)
{
    var task = new Task { Description = input.Description };

    if (input.AssignedPersonId.HasValue)
    {
        task.AssignedPersonId = input.AssignedPersonId.Value;

        _unitOfWorkManager.Current.Completed += (sender, args) => { /* TODO: 给派发的人发送邮件*/ };
    }

    _taskRepository.Insert(task);
}
</code></pre>
<h2 id="事务与锁（补充：重要）"><a href="#事务与锁（补充：重要）" class="headerlink" title="事务与锁（补充：重要）"></a>事务与锁（补充：重要）</h2><h3 id="事务的级别"><a href="#事务的级别" class="headerlink" title="事务的级别"></a>事务的级别</h3><p>事务的隔离级别</p>
<p>事务的四大特性分别是：原子性、一致性、隔离性、持久性</p>
<p>幻读和不可重复读都是在同一个事务中多次读取了其他事务已经提交的事务的数据导致每次读取的数据不一致，所不同的是不可重复读读取的是同一条数据，而幻读针对的是一批数据整体的统计(比如数据的个数)</p>
<p>以MYSQL数据库来分析四种隔离级别</p>
<p>第一种隔离级别：Read uncommitted(读未提交)<br>如果一个事务已经开始写数据，则另外一个事务不允许同时进行写操作，但允许其他事务读此行数据，该隔离级别可以通过“排他写锁”，但是不排斥读线程实现。这样就避免了更新丢失，却可能出现脏读，也就是说事务B读取到了事务A未提交的数据</p>
<p>解决了更新丢失，但还是可能会出现脏读</p>
<p>第二种隔离级别：Read committed(读提交)<br>如果是一个读事务(线程)，则允许其他事务读写，如果是写事务将会禁止其他事务访问该行数据，该隔离级别避免了脏读，但是可能出现不可重复读。事务A事先读取了数据，事务B紧接着更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。</p>
<p>解决了更新丢失和脏读问题</p>
<p>第三种隔离级别：Repeatable read(可重复读取)<br>可重复读取是指在一个事务内，多次读同一个数据，在这个事务还没结束时，其他事务不能访问该数据(包括了读写)，这样就可以在同一个事务内两次读到的数据是一样的，因此称为是可重复读隔离级别，读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务(包括了读写)，这样避免了不可重复读和脏读，但是有时可能会出现幻读。(读取数据的事务)可以通过“共享读镜”和“排他写锁”实现。</p>
<p>解决了更新丢失、脏读、不可重复读、但是还会出现幻读</p>
<p>第四种隔离级别：Serializable(可序化)<br>提供严格的事务隔离，它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行，如果仅仅通过“行级锁”是无法实现序列化的，必须通过其他机制保证新插入的数据不会被执行查询操作的事务访问到。序列化是最高的事务隔离级别，同时代价也是最高的，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻读</p>
<p>解决了更新丢失、脏读、不可重复读、幻读(虚读)<br>————————————————<br>在这里插入图片描述<br>以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低，像Serializeble这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况来，在MYSQL数据库中默认的隔离级别是Repeatable read（可重复读）。</p>
<p>在MYSQL数据库中，支持上面四种隔离级别，默认的为Repeatable read(可重复读)；而在Oracle数据库中，只支持Serializeble(串行化)级别和Read committed(读已提交)这两种级别，其中默认的为Read committed级别</p>
<p>在MYSQL数据库中查看当前事务的隔离级别</p>
<p>SELECT @@tx_isolation;</p>
<pre><code>1
</code></pre>
<p>在MYSQL数据库中设置事务的隔离级别：<br>在这里插入图片描述<br>在这里插入图片描述<br>在这里插入图片描述<br>记住：设置数据库的隔离级别一定要是在开启事务之前：</p>
<p>如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connecton对象的setAutoCommit(false)方法之前，调用Connection对象的setTransactionIsolation(level)即可设置当前连接的隔离级别，至于参数level，可以使用Connection对象的字段：<br>在这里插入图片描述<br>在JDBC中设置隔离级别的部分代码：<br>在这里插入图片描述<br>隔离级别的设置只对当前连接有效，对于使用MYSQL命令窗口而言，一个窗口就相当于一个连接，当前窗口设置的隔离级别只对当前窗口中的事务有效，对于JDBC操作数据库来说，一个Connection对象相当与一个连接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他连接Connection对象无关<br>————————————————<br>版权声明：本文为CSDN博主「zhouym_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhouym_/article/details/90381606">https://blog.csdn.net/zhouym_/article/details/90381606</a></p>
<h3 id="什么时候事务会发生锁定事件"><a href="#什么时候事务会发生锁定事件" class="headerlink" title="什么时候事务会发生锁定事件"></a>什么时候事务会发生锁定事件</h3><h4 id="Mysql数据库锁定机制详细介绍"><a href="#Mysql数据库锁定机制详细介绍" class="headerlink" title="Mysql数据库锁定机制详细介绍"></a>Mysql数据库锁定机制详细介绍</h4><p>  更新时间：2014年12月01日 10:58:48  投稿：junjie  </p>
<p>这篇文章主要介绍了Mysql数据库锁定机制详细介绍,本文用大量内容讲解了Mysql中的锁定机制,例如MySQL锁定机制简介、合理利用锁机制优化MySQL等内容,需要的朋友可以参考下</p>
<p><strong>前言</strong></p>
<p>为了保证数据的一致完整性，任何一个数据库都存在锁定机制。锁定机制的优劣直接应想到一个数据库系统的并发处理能力和性能，所以锁定机制的实现也就成为了各种数据库的核心技术之一。本章将对MySQL中两种使用最为频繁的存储引擎MyISAM和Innodb各自的锁定机制进行较为详细的分析。</p>
<p><strong>MySQL锁定机制简介</strong></p>
<p>数据库锁定机制简单来说就是数据库为了保证数据的一致性而使各种共享资源在被并发访问访问变得有序所设计的一种规则。对于任何一种数据库来说都需要有相应的锁定机制，所以MySQL自然也不能例外。MySQL数据库由于其自身架构的特点，存在多种数据存储引擎，每种存储引擎所针对的应用场景特点都不太一样，为了满足各自特定应用场景的需求，每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别。</p>
<p>总的来说，MySQL各存储引擎使用了三种类型（级别）的锁定机制：行级锁定，页级锁定和表级锁定。下面我们先分析一下MySQL这三种锁定的特点和各自的优劣所在。</p>
<p><strong>行级锁定（row-level）</strong></p>
<p>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。</p>
<p>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。</p>
<p><strong>表级锁定（table-level）</strong></p>
<p>和行级锁定相反，表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。</p>
<p>当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。</p>
<p><strong>页级锁定（page-level）</strong></p>
<p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。</p>
<p>在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。</p>
<p>在MySQL数据库中，使用表级锁定的主要是MyISAM，Memory，CSV等一些非事务性存储引擎，而使用行级锁定的主要是Innodb存储引擎和NDBCluster存储引擎，页级锁定主要是BerkeleyDB存储引擎的锁定方式。</p>
<p>MySQL的如此的锁定机制主要是由于其最初的历史所决定的。在最初，MySQL希望设计一种完全独立于各种存储引擎的锁定机制，而且在早期的MySQL数据库中，MySQL的存储引擎（MyISAM和Momery）的设计是建立在“任何表在同一时刻都只允许单个线程对其访问（包括读）”这样的假设之上。但是，随着MySQL的不断完善，系统的不断改进，在MySQL3.23版本开发的时候，MySQL开发人员不得不修正之前的假设。因为他们发现一个线程正在读某个表的时候，另一个线程是可以对该表进行insert操作的，只不过只能INSERT到数据文件的最尾部。这也就是从MySQL从3.23版本开始提供的我们所说的Concurrent Insert。</p>
<p>当出现Concurrent  Insert之后，MySQL的开发人员不得不修改之前系统中的锁定实现功能，但是仅仅只是增加了对Concurrent  Insert的支持，并没有改动整体架构。可是在不久之后，随着BerkeleyDB存储引擎的引入，之前的锁定机制遇到了更大的挑战。因为BerkeleyDB存储引擎并没有MyISAM和Memory存储引擎同一时刻只允许单一线程访问某一个表的限制，而是将这个单线程访问限制的颗粒度缩小到了单个page，这又一次迫使MySQL开发人员不得不再一次修改锁定机制的实现。</p>
<p>由于新的存储引擎的引入，导致锁定机制不能满足要求，让MySQL的人意识到已经不可能实现一种完全独立的满足各种存储引擎要求的锁定实现机制。如果因为锁定机制的拙劣实现而导致存储引擎的整体性能的下降，肯定会严重打击存储引擎提供者的积极性，这是MySQL公司非常不愿意看到的，因为这完全不符合MySQL的战略发展思路。所以工程师们不得不放弃了最初的设计初衷，在锁定实现机制中作出修改，允许存储引擎自己改变MySQL通过接口传入的锁定类型而自行决定该怎样锁定数据。</p>
<p><strong>表级锁定</strong></p>
<p>MySQL的表级锁定主要分为两种类型，一种是读锁定，另一种是写锁定。在MySQL中，主要通过四个队列来维护这两种锁定：两个存放当前正在锁定中的读和写锁定信息，另外两个存放等待中的读写锁定信息，如下：</p>
<p>复制代码 代码如下:</p>
<p> Current read-lock queue (lock-&gt;read)<br> Pending read-lock queue (lock-&gt;read_wait)<br> Current write-lock queue (lock-&gt;write)<br> Pending write-lock queue (lock-&gt;write_wait)</p>
<p>当前持有读锁的所有线程的相关信息都能够在Currentread-lockqueue中找到，队列中的信息按照获取到锁的时间依序存放。而正在等待锁定资源的信息则存放在Pendingread-lockqueue里面，另外两个存放写锁信息的队列也按照上面相同规则来存放信息。</p>
<p>虽然对于我们这些使用者来说MySQL展现出来的锁定（表锁定）只有读锁定和写锁定这两种类型，但是在MySQL内部实现中却有多达11种锁定类型，由系统中一个枚举量（thr_lock_type）定义，各值描述如下：</p>
<table>
<thead>
<tr>
<th>锁定类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>IGNORE</td>
<td>当发生锁请求的时候内部交互使用，在锁定结构和队列中并不会有任何信息存储</td>
</tr>
<tr>
<td>UNLOCK</td>
<td>释放锁定请求的交互用所类型</td>
</tr>
<tr>
<td>READ</td>
<td>普通读锁定</td>
</tr>
<tr>
<td>WRITE</td>
<td>普通写锁定</td>
</tr>
<tr>
<td>READ_WITH_SHARED_LOCKS</td>
<td>在Innodb中使用到，由如下方式产生如：SELECT…LOCKINSHAREMODE</td>
</tr>
<tr>
<td>READ_HIGH_PRIORITY</td>
<td>高优先级读锁定</td>
</tr>
<tr>
<td>READ_NO_INSERT</td>
<td>不允许ConcurentInsert的锁定</td>
</tr>
<tr>
<td>WRITE_ALLOW_WRITE</td>
<td>这个类型实际上就是当由存储引擎自行处理锁定的时候，mysqld允许其他的线程再获取读或者写锁定，因为即使资源冲突，存储引擎自己也会知道怎么来处理</td>
</tr>
<tr>
<td>WRITE_ALLOW_READ</td>
<td>这种锁定发生在对表做DDL（ALTERTABLE…）的时候，MySQL可以允许其他线程获取读锁定，因为MySQL是通过重建整个表然后再RENAME而实现的该功能，所在整个过程原表仍然可以提供读服务</td>
</tr>
<tr>
<td>WRITE_CONCURRENT_INSERT</td>
<td>正在进行ConcurentInsert时候所使用的锁定方式，该锁定进行的时候，除了READ_NO_INSERT之外的其他任何读锁定请求都不会被阻塞</td>
</tr>
<tr>
<td>WRITE_DELAYED</td>
<td>在使用INSERTDELAYED时候的锁定类型</td>
</tr>
<tr>
<td>WRITE_LOW_PRIORITY</td>
<td>显示声明的低级别锁定方式，通过设置LOW_PRIORITY_UPDAT=1而产生</td>
</tr>
<tr>
<td>WRITE_ONLY</td>
<td>当在操作过程中某个锁定异常中断之后系统内部需要进行CLOSETABLE操作，在这个过程中出现的锁定类型就是WRITE_ONLY</td>
</tr>
</tbody></table>
<p><strong>读锁定</strong></p>
<p>一个新的客户端请求在申请获取读锁定资源的时候，需要满足两个条件：</p>
<p>1、请求锁定的资源当前没有被写锁定；<br> 2、写锁定等待队列（Pendingwrite-lockqueue）中没有更高优先级的写锁定等待；</p>
<p>如果满足了上面两个条件之后，该请求会被立即通过，并将相关的信息存入Currentread-lockqueue中，而如果上面两个条件中任何一个没有满足，都会被迫进入等待队列Pendingread-lockqueue中等待资源的释放。</p>
<p><strong>写锁定</strong></p>
<p>当客户端请求写锁定的时候，MySQL首先检查在Currentwrite-lockqueue是否已经有锁定相同资源的信息存在。</p>
<p>如果Currentwrite-lockqueue没有，则再检查Pendingwrite-lockqueue，如果在Pendingwrite-lockqueue中找到了，自己也需要进入等待队列并暂停自身线程等待锁定资源。反之，如果Pendingwrite-lockqueue为空，则再检测Currentread-lockqueue，如果有锁定存在，则同样需要进入Pendingwrite-lockqueue等待。当然，也可能遇到以下这两种特殊情况：</p>
<p>\1. 请求锁定的类型为WRITE_DELAYED;<br> \2. 请求锁定的类型为WRITE_CONCURRENT_INSERT或者是TL_WRITE_ALLOW_WRITE，同时Currentreadlock是READ_NO_INSERT的锁定类型。</p>
<p>当遇到这两种特殊情况的时候，写锁定会立即获得而进入Current write-lock queue 中</p>
<p>如果刚开始第一次检测就Currentwrite-lockqueue中已经存在了锁定相同资源的写锁定存在，那么就只能进入等待队列等待相应资源锁定的释放了。</p>
<p>读请求和写等待队列中的写锁请求的优先级规则主要为以下规则决定：</p>
<p>\1. 除了READ_HIGH_PRIORITY的读锁定之外，Pendingwrite-lockqueue中的WRITE写锁定能够阻塞所有其他的读锁定；<br> \2. READ_HIGH_PRIORITY读锁定的请求能够阻塞所有Pendingwrite-lockqueue中的写锁定；<br> \3. 除了WRITE写锁定之外，Pendingwrite-lockqueue中的其他任何写锁定都比读锁定的优先级低。</p>
<p>写锁定出现在Currentwrite-lockqueue之后，会阻塞除了以下情况下的所有其他锁定的请求：</p>
<p>\1. 在某些存储引擎的允许下，可以允许一个WRITE_CONCURRENT_INSERT写锁定请求<br> \2. 写锁定为WRITE_ALLOW_WRITE的时候，允许除了WRITE_ONLY之外的所有读和写锁定请求<br> \3. 写锁定为WRITE_ALLOW_READ的时候，允许除了READ_NO_INSERT之外的所有读锁定请求<br> \4. 写锁定为WRITE_DELAYED的时候，允许除了READ_NO_INSERT之外的所有读锁定请求<br> \5. 写锁定为WRITE_CONCURRENT_INSERT的时候，允许除了READ_NO_INSERT之外的所有读锁定请求</p>
<p>随着MySQL存储引擎的不断发展，目前MySQL自身提供的锁定机制已经没有办法满足需求了，很多存储引擎都在MySQL所提供的锁定机制之上做了存储引擎自己的扩展和改造。</p>
<p>MyISAM存储引擎基本上可以说是对MySQL所提供的锁定机制所实现的表级锁定依赖最大的一种存储引擎了，虽然MyISAM存储引擎自己并没有在自身增加其他的锁定机制，但是为了更好的支持相关特性，MySQL在原有锁定机制的基础上为了支持其ConcurrentInsert的特性而进行了相应的实现改造。</p>
<p>而其他几种支持事务的存储存储引擎，如Innodb，NDBCluster以及BerkeleyDB存储引擎则是让MySQL将锁定的处理直接交给存储引擎自己来处理，在MySQL中仅持有WRITE_ALLOW_WRITE类型的锁定。</p>
<p>由于MyISAM存储引擎使用的锁定机制完全是由MySQL提供的表级锁定实现，所以下面我们将以MyISAM存储引擎作为示例存储引擎，来实例演示表级锁定的一些基本特性。由于，为了让示例更加直观，我将使用显示给表加锁来演示：RITE_ALLOW_READ 类型的写锁定。</p>
<table>
<thead>
<tr>
<th>刻</th>
<th>Session a</th>
<th>Session b</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>行锁定基本演示</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>mysql&gt; set autocommit=0;      Query OK, 0 rows affected (0.00 sec)</td>
<td>mysql&gt; set autocommit=0;      Query OK, 0 rows affected (0.00 sec)</td>
</tr>
<tr>
<td></td>
<td>mysql&gt; update test_innodb_lock set b = ‘b1’ where a = 1;      Query OK, 1 row affected (0.00 sec)      Rows matched: 1 Changed: 1 Warnings: 0      更新，但是不提交</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>mysql&gt; update test_innodb_lock set b = ‘b1’ where a = 1;      被阻塞，等待</td>
</tr>
<tr>
<td>3</td>
<td>mysql&gt; commit; Query OK, 0 rows affected (0.05 sec) 提交</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>mysql&gt; update test_innodb_lock set b = ‘b1’ where a = 1;      Query OK, 0 rows affected (36.14 sec)      Rows matched: 1 Changed: 0 Warnings: 0      解除阻塞，更新正常进行</td>
</tr>
<tr>
<td></td>
<td>无索引升级为表锁演示</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>mysql&gt; update test_innodb_lock set b = ‘2’ where b = 2000;      Query OK, 1 row affected (0.02 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td>
<td>mysql&gt; update test_innodb_lock set b = ‘3’ where b = 3000;      被阻塞，等待</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>mysql&gt; commit; Query OK, 0 rows affected (0.10 sec)</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>mysql&gt; update test_innodb_lock set b = ‘3’ where b = 3000;      Query OK, 1 row affected (1 min 3.41 sec)      Rows matched: 1 Changed: 1 Warnings: 0      阻塞解除，完成更新</td>
</tr>
<tr>
<td></td>
<td>间隙锁带来的插入问题演示</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>mysql&gt; select * from test_innodb_lock;      +——+——+ | a | b |+——+——+      | 1 | b2 |      | 3 | 3 |      | 4 | 4000 |      | 5 | 5000 |      | 6 | 6000 |      | 7 | 7000 |      | 8 | 8000 |      | 9 | 9000 |      | 1 | b1 |      +——+——+      9 rows in set (0.00 sec)      mysql&gt; update test_innodb_lock set b = a * 100 where a &lt; 4 and a &gt; 1;      Query OK, 1 row affected (0.02 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td></td>
<td>mysql&gt; insert into test_innodb_lock values(2,’200’);      被阻塞，等待</td>
</tr>
<tr>
<td>11</td>
<td>mysql&gt; commit;      Query OK, 0 rows affected (0.02 sec)</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td></td>
<td>mysql&gt; insert into test_innodb_lock values(2,’200’);      Query OK, 1 row affected (38.68 sec)      阻塞解除，完成插入</td>
</tr>
<tr>
<td></td>
<td>使用共同索引不同数据的阻塞示例</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>mysql&gt; update test_innodb_lock set b = ‘bbbbb’ where a = 1 and b = ‘b2’;      Query OK, 1 row affected (0.00 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td></td>
<td>mysql&gt; update test_innodb_lock set b = ‘bbbbb’ where a = 1 and b = ‘b1’; 被阻塞</td>
</tr>
<tr>
<td>15</td>
<td>mysql&gt; commit;      Query OK, 0 rows affected (0.02 sec)</td>
<td></td>
</tr>
<tr>
<td>16</td>
<td></td>
<td>mysql&gt; update test_innodb_lock set b = ‘bbbbb’ where a = 1 and b = ‘b1’; Query OK, 1 row affected (42.89 sec)      Rows matched: 1 Changed: 1 Warnings: 0      session 提交事务，阻塞去除，更新完成</td>
</tr>
<tr>
<td></td>
<td>死锁示例</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>mysql&gt; update t1 set id = 110 where id = 11;      Query OK, 0 rows affected (0.00 sec)      Rows matched: 0 Changed: 0 Warnings: 0</td>
<td></td>
</tr>
<tr>
<td>18</td>
<td></td>
<td>mysql&gt; update t2 set id = 210 where id = 21;      Query OK, 1 row affected (0.00 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td>
</tr>
<tr>
<td>19</td>
<td>mysql&gt;update t2 set id=2100 where id=21;      等待sessionb释放资源，被阻塞</td>
<td></td>
</tr>
<tr>
<td>20</td>
<td></td>
<td>mysql&gt;update t1 set id=1100 where id=11;      Query OK,0 rows affected (0.39sec)      Rows matched: 0 Changed: 0 Warnings:0      等待sessiona释放资源，被阻塞</td>
</tr>
<tr>
<td></td>
<td>两个 session 互相等等待对方的资源释放之后才能释放自己的资源,造成了死锁</td>
<td></td>
</tr>
</tbody></table>
<p><strong>行级锁定</strong></p>
<p>行级锁定不是MySQL自己实现的锁定方式，而是由其他存储引擎自己所实现的，如广为大家所知的Innodb存储引擎，以及MySQL的分布式存储引擎NDBCluster等都是实现了行级锁定。</p>
<p><strong>Innodb 锁定模式及实现机制</strong></p>
<p>考虑到行级锁定君由各个存储引擎自行实现，而且具体实现也各有差别，而Innodb是目前事务型存储引擎中使用最为广泛的存储引擎，所以这里我们就主要分析一下Innodb的锁定特性。</p>
<p>总的来说，Innodb的锁定机制和Oracle数据库有不少相似之处。Innodb的行级锁定同样分为两种类型，共享锁和排他锁，而在锁定机制的实现过程中为了让行级锁定和表级锁定共存，Innodb也同样使用了意向锁（表级锁定）的概念，也就有了意向共享锁和意向排他锁这两种。</p>
<p>当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。所以，可以说Innodb的锁定模式实际上可以分为四种：共享锁（S），排他锁（X），意向共享锁（IS）和意向排他锁（IX），我们可以通过以下表格来总结上面这四种所的共存逻辑关系：</p>
<table>
<thead>
<tr>
<th>共享锁（S）</th>
<th>排他锁（X）</th>
<th>意向共享锁（IS）</th>
<th>意向排他锁（IX）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>共享锁（S）</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td>排他锁（X）</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>意向共享锁（IS）</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>意向排他锁（IX）</td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>虽然Innodb的锁定机制和Oracle有不少相近的地方，但是两者的实现确是截然不同的。总的来说就是Oracle锁定数据是通过需要锁定的某行记录所在的物理block上的事务槽上表级锁定信息，而Innodb的锁定则是通过在指向数据记录的第一个索引键之前和最后一个索引键之后的空域空间上标记锁定信息而实现的。Innodb的这种锁定实现方式被称为“NEXT-KEYlocking”（间隙锁），因为Query执行过程中通过过范围查找的华，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。</p>
<p>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。而Innodb给出的解释是为了组织幻读的出现，所以他们选择的间隙锁来实现锁定。</p>
<p>除了间隙锁给Innodb带来性能的负面影响之外，通过索引实现锁定的方式还存在其他几个较大的性能隐患：</p>
<p>当Query无法利用索引的时候，Innodb会放弃使用行级别锁定而改用表级别的锁定，造成并发性能的降低；</p>
<p>当Quuery使用的索引并不包含所有过滤条件的时候，数据检索使用到的索引键所只想的数据可能有部分并不属于该Query的结果集的行列，但是也会被锁定，因为间隙锁锁定的是一个范围，而不是具体的索引键；</p>
<p>当Query在使用索引定位数据的时候，如果使用的索引键一样但访问的数据行不同的时候（索引只是过滤条件的一部分），一样会被锁定</p>
<p><strong>Innodb 各事务隔离级别下锁定及死锁</strong></p>
<p>Innodb实现的在ISO／ANSISQL92规范中所定义的ReadUnCommited，ReadCommited，RepeatableRead和Serializable这四种事务隔离级别。同时，为了保证数据在事务中的一致性，实现了多版本数据访问。</p>
<p>之前在第一节中我们已经介绍过，行级锁定肯定会带来死锁问题，Innodb也不可能例外。至于死锁的产生过程我们就不在这里详细描述了，在后面的锁定示例中会通过一个实际的例子为大家爱展示死锁的产生过程。这里我们主要介绍一下，在Innodb中当系检测到死锁产生之后是如何来处理的。</p>
<p>在Innodb的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在。当Innodb检测到系统中产生了死锁之后，Innodb会通过相应的判断来选这产生死锁的两个事务中较小的事务来回滚，而让另外一个较大的事务成功完成。那Innodb是以什么来为标准判定事务的大小的呢？MySQL官方手册中也提到了这个问题，实际上在Innodb发现死锁之后，会计算出两个事务各自插入、更新或者删除的数据量来判定两个事务的大小。也就是说哪个事务所改变的记录条数越多，在死锁中就越不会被回滚掉。但是有一点需要注意的就是，当产生死锁的场景中涉及到不止Innodb存储引擎的时候，Innodb是没办法检测到该死锁的，这时候就只能通过锁定超时限制来解决该死锁了。另外，死锁的产生过程的示例将在本节最后的Innodb锁定示例中演示。</p>
<p><strong>Innodb 锁定机制示例</strong></p>
<p>复制代码 代码如下:</p>
<p> mysql&gt; create table test_innodb_lock (a int(11),b varchar(16)) engine=innodb;<br> Query OK, 0 rows affected (0.02 sec)</p>
<p>mysql&gt; create index test_innodb_a_ind on test_innodb_lock(a);<br> Query OK, 0 rows affected (0.05 sec)<br> Records: 0 Duplicates: 0 Warnings: 0</p>
<p>mysql&gt; create index test_innodb_lock_b_ind on test_innodb_lock(b);<br> Query OK, 11 rows affected (0.01 sec)<br> Records: 11 Duplicates: 0 Warnings: 0</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>Session a</th>
<th>Session b</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>行锁定基本演示</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>mysql&gt; set autocommit=0;      Query OK, 0 rows affected (0.00 sec)</td>
<td>mysql&gt; set autocommit=0;      Query OK, 0 rows affected (0.00 sec)</td>
</tr>
<tr>
<td></td>
<td>mysql&gt; update test_innodb_lock set b = ‘b1’ where a = 1;      Query OK, 1 row affected (0.00 sec)      Rows matched: 1 Changed: 1 Warnings: 0      更新，但是不提交</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>mysql&gt; update test_innodb_lock set b = ‘b1’ where a = 1;      被阻塞，等待</td>
</tr>
<tr>
<td>3</td>
<td>mysql&gt; commit; Query OK, 0 rows affected (0.05 sec) 提交</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>mysql&gt; update test_innodb_lock set b = ‘b1’ where a = 1;      Query OK, 0 rows affected (36.14 sec)      Rows matched: 1 Changed: 0 Warnings: 0      解除阻塞，更新正常进行</td>
</tr>
<tr>
<td></td>
<td>无索引升级为表锁演示</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>mysql&gt; update test_innodb_lock set b = ‘2’ where b = 2000;      Query OK, 1 row affected (0.02 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td>
<td>mysql&gt; update test_innodb_lock set b = ‘3’ where b = 3000;      被阻塞，等待</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>mysql&gt; commit; Query OK, 0 rows affected (0.10 sec)</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>mysql&gt; update test_innodb_lock set b = ‘3’ where b = 3000;      Query OK, 1 row affected (1 min 3.41 sec)      Rows matched: 1 Changed: 1 Warnings: 0      阻塞解除，完成更新</td>
</tr>
<tr>
<td></td>
<td>间隙锁带来的插入问题演示</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>mysql&gt; select * from test_innodb_lock;      +——+——+ | a | b |+——+——+      | 1 | b2 |      | 3 | 3 |      | 4 | 4000 |      | 5 | 5000 |      | 6 | 6000 |      | 7 | 7000 |      | 8 | 8000 |      | 9 | 9000 |      | 1 | b1 |      +——+——+      9 rows in set (0.00 sec)      mysql&gt; update test_innodb_lock set b = a * 100 where a &lt; 4 and a &gt; 1;      Query OK, 1 row affected (0.02 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td></td>
<td>mysql&gt; insert into test_innodb_lock values(2,’200’);      被阻塞，等待</td>
</tr>
<tr>
<td>11</td>
<td>mysql&gt; commit;      Query OK, 0 rows affected (0.02 sec)</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td></td>
<td>mysql&gt; insert into test_innodb_lock values(2,’200’);      Query OK, 1 row affected (38.68 sec)      阻塞解除，完成插入</td>
</tr>
<tr>
<td></td>
<td>使用共同索引不同数据的阻塞示例</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>mysql&gt; update test_innodb_lock set b = ‘bbbbb’ where a = 1 and b = ‘b2’;      Query OK, 1 row affected (0.00 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td></td>
<td>mysql&gt; update test_innodb_lock set b = ‘bbbbb’ where a = 1 and b = ‘b1’; 被阻塞</td>
</tr>
<tr>
<td>15</td>
<td>mysql&gt; commit;      Query OK, 0 rows affected (0.02 sec)</td>
<td></td>
</tr>
<tr>
<td>16</td>
<td></td>
<td>mysql&gt; update test_innodb_lock set b = ‘bbbbb’ where a = 1 and b = ‘b1’; Query OK, 1 row affected (42.89 sec)      Rows matched: 1 Changed: 1 Warnings: 0      session 提交事务，阻塞去除，更新完成</td>
</tr>
<tr>
<td></td>
<td>死锁示例</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>mysql&gt; update t1 set id = 110 where id = 11;      Query OK, 0 rows affected (0.00 sec)      Rows matched: 0 Changed: 0 Warnings: 0</td>
<td></td>
</tr>
<tr>
<td>18</td>
<td></td>
<td>mysql&gt; update t2 set id = 210 where id = 21;      Query OK, 1 row affected (0.00 sec)      Rows matched: 1 Changed: 1 Warnings: 0</td>
</tr>
<tr>
<td>19</td>
<td>mysql&gt;update t2 set id=2100 where id=21;      等待sessionb释放资源，被阻塞</td>
<td></td>
</tr>
<tr>
<td>20</td>
<td></td>
<td>mysql&gt;update t1 set id=1100 where id=11;      Query OK,0 rows affected (0.39sec)      Rows matched: 0 Changed: 0 Warnings:0      等待sessiona释放资源，被阻塞</td>
</tr>
<tr>
<td></td>
<td>两个 session 互相等等待对方的资源释放之后才能释放自己的资源,造成了死锁</td>
<td></td>
</tr>
</tbody></table>
<p><strong>合理利用锁机制优化MySQL</strong></p>
<p><strong>MyISAM 表锁优化建议</strong></p>
<p>对于MyISAM存储引擎，虽然使用表级锁定在锁定实现的过程中比实现行级锁定或者页级锁所带来的附加成本都要小，锁定本身所消耗的资源也是最少。但是由于锁定的颗粒度比较到，所以造成锁定资源的争用情况也会比其他的锁定级别都要多，从而在较大程度上会降低并发处理能力。</p>
<p>所以，在优化MyISAM存储引擎锁定问题的时候，最关键的就是如何让其提高并发度。由于锁定级别是不可能改变的了，所以我们首先需要尽可能让锁定的时间变短，然后就是让可能并发进行的操作尽可能的并发。</p>
<p> <strong>1、缩短锁定时间</strong></p>
<p>缩短锁定时间，短短几个字，说起来确实听容易的，但实际做起来恐怕就并不那么简单了。如何让锁定时间尽可能的短呢？唯一的办法就是让我们的Query执行时间尽可能的短。</p>
<p>尽两减少大的复杂Query，将复杂Query分拆成几个小的Query分布进行；</p>
<p>尽可能的建立足够高效的索引，让数据检索更迅速；</p>
<p>尽量让MyISAM存储引擎的表只存放必要的信息，控制字段类型；</p>
<p>利用合适的机会优化MyISAM表数据文件；</p>
<p><strong>2、分离能并行的操作</strong></p>
<p>说到MyISAM的表锁，而且是读写互相阻塞的表锁，可能有些人会认为在MyISAM存储引擎的表上就只能是完全的串行化，没办法再并行了。大家不要忘记了，MyISAM的存储引擎还有一个非常有用的特性，那就是ConcurrentInsert（并发插入）的特性。</p>
<p>MyISAM存储引擎有一个控制是否打开Concurrent Insert功能的参数选项：concurrent_insert，可以设置为0，1或者2。三个值的具体说明如下：</p>
<p>concurrent_insert=2，无论MyISAM存储引擎的表数据文件的中间部分是否存在因为删除数据而留下的空闲空间，都允许在数据文件尾部进行ConcurrentInsert;</p>
<p>concurrent_insert=1，当MyISAM存储引擎表数据文件中间不存在空闲空间的时候，可以从文件尾部进行ConcurrentInsert;</p>
<p>concurrent_insert=0，无论MyISAM存储引擎的表数据文件的中间部分是否存在因为删除数据而留下的空闲空间，都不允许ConcurrentInsert。</p>
<p><strong>3、合理利用读写优先级</strong></p>
<p>在本章各种锁定分析一节中我们了解到了MySQL的表级锁定对于读和写是有不同优先级设定的，默认情况下是写优先级要大于读优先级。所以，如果我们可以根据各自系统环境的差异决定读与写的优先级。如果我们的系统是一个以读为主，而且要优先保证查询性能的话，我们可以通过设置系统参数选项low_priority_updates=1，将写的优先级设置为比读的优先级低，即可让告诉MySQL尽量先处理读请求。当然，如果我们的系统需要有限保证数据写入的性能的话，则可以不用设置low_priority_updates参数了。</p>
<p>这里我们完全可以利用这个特性，将concurrent_insert参数设置为1，甚至如果数据被删除的可能性很小的时候，如果对暂时性的浪费少量空间并不是特别的在乎的话，将concurrent_insert参数设置为2都可以尝试。当然，数据文件中间留有空域空间，在浪费空间的时候，还会造成在查询的时候需要读取更多的数据，所以如果删除量不是很小的话，还是建议将concurrent_insert设置为1更为合适。</p>
<p><strong>Innodb 行锁优化建议</strong></p>
<p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p>
<p>要想合理利用Innodb的行级锁定，做到扬长避短，我们必须做好以下工作：</p>
<p>尽可能让所有的数据检索都通过索引来完成，从而避免Innodb因为无法通过索引键加锁而升级为表级锁定；</p>
<p>合理设计索引，让Innodb在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他Query的执行；</p>
<p>尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录；</p>
<p>尽量控制事务的大小，减少锁定的资源量和锁定时间长度；</p>
<p>在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少MySQL因为实现事务隔离级别所带来的附加成本；</p>
<p>由于Innodb的行级锁定和事务性，所以肯定会产生死锁，下面是一些比较常用的减少死锁产生概率</p>
<p>的的小建议，读者朋友可以根据各自的业务特点针对性的尝试：a)类似业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁；b)在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；c)对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p>
<p>系统锁定争用情况查询对于两种锁定级别，MySQL内部有两组专门的状态变量记录系统内部锁资源争用情况，我们先看看</p>
<p>MySQL 实现的表级锁定的争用状态变量：</p>
<p>复制代码 代码如下:</p>
<p> mysql&gt; show status like ‘table%’;<br> +———————–+——-+ | Variable_name | Value | +———————–+——-+<br> | Table_locks_immediate | 100 |<br> | Table_locks_waited | 0 |<br> +———————–+——-+</p>
<p>这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下：</p>
<p>Table_locks_immediate：产生表级锁定的次数；</p>
<p>Table_locks_waited：出现表级锁定争用而发生等待的次数；</p>
<p>两个状态值都是从系统启动后开始记录，没出现一次对应的事件则数量加1。如果这里的Table_locks_waited状态值比较高，那么说明系统中表级锁定争用现象比较严重，就需要进一步分析为什么会有较多的锁定资源争用了。</p>
<p>对于Innodb所使用的行级锁定，系统中是通过另外一组更为详细的状态变量来记录的，如下：</p>
<p>复制代码 代码如下:</p>
<p> mysql&gt;showstatuslike’innodb_row_lock%’;<br> +——————————-+——–+|Variable_name|Value|+——————————-+——–+<br> |Innodb_row_lock_current_waits|0|<br> |Innodb_row_lock_time|490578|<br> |Innodb_row_lock_time_avg|37736|<br> |Innodb_row_lock_time_max|121411|<br> |Innodb_row_lock_waits|13|<br> +——————————-+——–+</p>
<p>Innodb 的行级锁定状态变量不仅记录了锁定等待次数，还记录了锁定总时长，每次平均时长，以及最大时长，此外还有一个非累积状态量显示了当前正在等待锁定的等待数量。对各个状态量的说明如下：</p>
<p>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</p>
<p>Innodb_row_lock_time：从系统启动到现在锁定总时间长度；</p>
<p>Innodb_row_lock_time_avg：每次等待所花平均时间；</p>
<p>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</p>
<p>Innodb_row_lock_waits：系统启动后到现在总共等待的次数；</p>
<p>对于这5个状态变量，比较重要的主要是Innodb_row_lock_time_avg（等待平均时长），Innodb_row_lock_waits（等待总次数）以及Innodb_row_lock_time（等待总时长）这三项。尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。</p>
<p>此外，Innodb出了提供这五个系统状态变量之外，还提供的其他更为丰富的即时状态信息供我们分析使用。可以通过如下方法查看：</p>
<p><strong>1.通过创建InnodbMonitor表来打开Innodb的monitor功能：</strong></p>
<p>复制代码 代码如下:</p>
<p> mysql&gt; create table innodb_monitor(a int) engine=innodb;</p>
<p>Query OK, 0 rows affected (0.07 sec)</p>
<p><strong>2.然后通过使用“SHOWINNODBSTATUS”查看细节信息（由于输出内容太多就不在此记录了）；</strong></p>
<p>可能会有读者朋友问为什么要先创建一个叫innodb_monitor的表呢？因为创建该表实际上就是告诉Innodb我们开始要监控他的细节状态了，然后Innodb就会将比较详细的事务以及锁定信息记录进入MySQL的errorlog中，以便我们后面做进一步分析使用。</p>
<p><strong>小结</strong></p>
<p>本章以MySQLServer中的锁定简介开始，分析了当前MySQL中使用最为广泛的锁定方式表级锁定和行级锁定的基本实现机制，并通过MyISAM和Innodb这两大典型的存储引擎作为示例存储引擎所使用的表级锁定和行级锁定做了较为详细的分析和演示。然后，再通过分析两种锁定方式的特性，给出相应的优化建议和策略。最后了解了一下在MySQLServer中如何获得系统当前各种锁定的资源争用状况。希望本章内容能够对各位读者朋友在理解MySQL锁定机制方面有一定的帮助。</p>
<h4 id="SQLServer之数据库行锁"><a href="#SQLServer之数据库行锁" class="headerlink" title="SQLServer之数据库行锁"></a>SQLServer之数据库行锁</h4><p>行锁使用注意事项</p>
<p>1、ROWLOCK行级锁确保在用户取得被更新的行，到该行进行更新，这段时间内不被其它用户所修改。因而行级锁即可保证数据的一致性，又能提高数据操作的并发性。</p>
<p>2、ROWLOCK告诉SQL Server只使用行级锁，ROWLOCK语法可以使用在SELECT,UPDATE和DELETE语句中。</p>
<p>3、ROWLOCK指定通常采用页锁或表锁时，采用行锁。 在从 SNAPSHOT 隔离级别操作的事务中指定时，除非将 ROWLOCK 与需要锁的其他表提示（例如，UPDLOCK 和 HOLDLOCK）组合，否则不会取得行锁。</p>
<p>4、UPDLOCK指定采用更新锁并保持到事务完成。UPDLOCK 仅对行级别或页级别的读操作采用更新锁。 如果将 UPDLOCK 与  TABLOCK 组合使用或出于一些其他原因采用表级锁，将采用排他 (X) 锁。指定 UPDLOCK 时，忽略 READCOMMITTED 和  READCOMMITTEDLOCK 隔离级别提示。 例如，如果将会话的隔离级别设置为 SERIALIZABLE 且查询指定 (UPDLOCK,  READCOMMITTED)，则忽略 READCOMMITTED 提示且使用 SERIALIZABLE 隔离级别运行事务。</p>
<p>5、HOLDLOCK等同于SERIALIZABLE。HOLDLOCK 仅应用于那些为其指定了 HOLDLOCK  的表或视图，并且仅在使用了 HOLDLOCK 的语句定义的事务的持续时间内应用。 HOLDLOCK 不能被用于包含 FOR BROWSE 选项的 SELECT 语句。</p>
<h5 id="使用T-SQL脚本创建数据库表锁"><a href="#使用T-SQL脚本创建数据库表锁" class="headerlink" title="使用T-SQL脚本创建数据库表锁"></a>使用T-SQL脚本创建数据库表锁</h5><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p>第一步：在当前会话中锁定数据行。</p>
<p>–声明数据库引用</p>
<p>use testss;</p>
<p>go</p>
<p>–声明数据库行锁</p>
<p>begin tran tran1</p>
<p>select * from test1 with(rowlock,updlock) where id=’1’;</p>
<p>waitfor delay ‘00:00:10’;</p>
<p>commit tran;</p>
<p>go</p>
<p>第二步：开启新会话，进行更新锁定数据行。</p>
<p>update test1 set sex=’女’ where id=’1’;</p>
<h5 id="示例结果：事务延迟提交十秒，在事务未提交之前进行更新会发生进程阻塞，更新是失败的，事务提交完成后行锁被释放更新才能成功。"><a href="#示例结果：事务延迟提交十秒，在事务未提交之前进行更新会发生进程阻塞，更新是失败的，事务提交完成后行锁被释放更新才能成功。" class="headerlink" title="示例结果：事务延迟提交十秒，在事务未提交之前进行更新会发生进程阻塞，更新是失败的，事务提交完成后行锁被释放更新才能成功。"></a>示例结果：事务延迟提交十秒，在事务未提交之前进行更新会发生进程阻塞，更新是失败的，事务提交完成后行锁被释放更新才能成功。</h5><p>如何避免锁定的发生</p>
<h1 id="ABP理论学习之事件总线和领域事件"><a href="#ABP理论学习之事件总线和领域事件" class="headerlink" title="ABP理论学习之事件总线和领域事件"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEventBus.html">ABP理论学习之事件总线和领域事件</a></h1><hr>
<h2 id="本篇目录-14"><a href="#本篇目录-14" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEventBus.html#eventBus">事件总线</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEventBus.html#define">定义事件</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEventBus.html#trigger">触发事件</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEventBus.html#handle">处理事件</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEventBus.html#handler">句柄注册</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEventBus.html#unregister">取消注册</a></strong></li>
</ul>
<p>在C#中，我们可以在一个类中定义自己的事件，而其他的类可以注册该事件，当某些事情发生时，可以通知到该类。这对于桌面应用或者独立的windows服务来说是非常有用的。但对于一个web应用来说是有点问题的，因为对象都是在web请求中创建的，而且这些对象生命周期都很短，因而注册某些类的事件是很困难的。此外，注册其他类的事件会使得类紧耦合。</p>
<p>领域事件用于解耦并重复利用应用中的逻辑。</p>
<h3 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线###"></a>事件总线###</h3><p>事件总线是被所有触发并处理事件的其他类共享的单例对象。要使用事件总线，首先应该获得它的一个引用。下面有两种方法来处理：</p>
<h4 id="创建默认实例"><a href="#创建默认实例" class="headerlink" title="创建默认实例"></a>创建默认实例</h4><p>你可以直接使用 <strong>EventBus.Default</strong>。这是全局的事件总线，用法如下所示：</p>
<pre><code>EventBus.Default.Trigger(...); //触发一个事件
</code></pre>
<h4 id="注入IEventBus"><a href="#注入IEventBus" class="headerlink" title="注入IEventBus"></a>注入IEventBus</h4><p>不直接使用EventBus.Default，你也可以使用依赖注入来获得<strong>IEventBus</strong>的引用。这有利于单元测试。这里我们使用属性注入模式：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService
{
    public IEventBus EventBus { get; set; }
        
    public TaskAppService()
    {
        EventBus = NullEventBus.Instance;
    }
}
</code></pre>
<p>对于注入事件总线这件事，属性注入比构造函数注入更合适。这样，你的类离开事件总线还能工作。NullEventBus实现了**<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Null_Object_pattern">null对象模式</a>**。当你调用上面的构造函数时，实际上啥都没做。</p>
<h3 id="定义事件"><a href="#定义事件" class="headerlink" title="定义事件###"></a>定义事件###</h3><p>触发事件之前，应该先要定义该事件。事件是使用派生自<strong>EventData</strong>的类来表示的。假设我们想当一个任务task完成时触发一个事件：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskCompletedEventData : EventData
{
    public int TaskId { get; set; }
}
</code></pre>
<p>该类包含了类处理事件需要的属性。<strong>EventData</strong>类定义了 <strong>EventSource</strong>（事件源）和 <strong>EventTime</strong>(事件触发时间)属性。</p>
<h4 id="预定义事件"><a href="#预定义事件" class="headerlink" title="预定义事件"></a>预定义事件</h4><p>ABP定义了<strong>AbpHandleExceptionData</strong>，当自动处理任何异常时都会触发这个事件。如果你想要获得更多的关于异常的信息（甚至ABP会自动记录所有的异常），那么这是特别有用的。注册这个事件之后，异常发生时就会通知你。</p>
<p>对于实体的更改也有泛型的事件数据类：<strong>EntityCreatedEventData，EntityUpdateEventData</strong>和 <strong>EntityDeletedEventData</strong>。它们都定义在 <strong>Abp.Event.Bus.Entities</strong>命名空间中。当一个实体插入，更新或者删除时，ABP会自动地触发这些事件。比如，如果你有一个Person实体，将它注册到EntityCreatedEventData，那么当创建的新的Person实体对象插入数据库时，会收到通知。这些事件也支持继承。如果Student类派生自Person类，而且你将它注册到EntityCreatedEventData，那么当一个Person或者Student插入时，你会收到通知。</p>
<h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件###"></a>触发事件###</h3><p>触发一个事件很简单，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService
{
    public IEventBus EventBus { get; set; }
        
    public TaskAppService()
    {
        EventBus = NullEventBus.Instance;
    }

    public void CompleteTask(CompleteTaskInput input)
    {
        //TODO: 完成task的数据库操作...
        EventBus.Trigger(new TaskCompletedEventData {TaskId = 42});
    }
}
</code></pre>
<p>下面是Trigger方法的一些重载：</p>
<pre class=" language-C#"><code class="language-C#">EventBus.Trigger<TaskCompletedEventData>(new TaskCompletedEventData { TaskId = 42 }); //显示声明为泛型参数
EventBus.Trigger(this, new TaskCompletedEventData { TaskId = 42 }); //将 '事件源'设置为'this'
EventBus.Trigger(typeof(TaskCompletedEventData), this, new TaskCompletedEventData { TaskId = 42 });//调用非泛型版本（第一个参数是事件类的类型）
</code></pre>
<h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件###"></a>处理事件###</h3><p>要处理一个事件，应该要实现<strong>IEventHandler</strong>接口，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class ActivityWriter : IEventHandler<TaskCompletedEventData>, ITransientDependency
{
    public void HandleEvent(TaskCompletedEventData eventData)
    {
        WriteActivity("A task is completed by id = " + eventData.TaskId);
    }
}
</code></pre>
<p>事件总线（EventBus）已经集成到ABP的依赖注入系统中。正如上面实现ITransientDependency一样，当TaskCompleted事件发生时，它会创建ActivityWriter类的一个新实例，然后调用HandleEvent方法，最后释放它。更多知识请查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPDependencyInjection.html">依赖注入</a>**。</p>
<h4 id="处理基事件"><a href="#处理基事件" class="headerlink" title="处理基事件"></a>处理基事件</h4><p>事件总线支持事件的<strong>继承</strong>。比如，你创建了一个<strong>TaskEventData</strong>和它的两个子类： <strong>TaskCompletedEventData</strong>和 <strong>TaskCreatedEventData</strong>:</p>
<pre class=" language-C#"><code class="language-C#">public class TaskEventData : EventData
{
    public Task Task { get; set; }
}

public class TaskCreatedEventData : TaskEventData
{
    public User CreatorUser { get; set; }
}

public class TaskCompletedEventData : TaskEventData
{
    public User CompletorUser { get; set; }
}
</code></pre>
<p>然后你可以实现<strong>IEventHandler</strong>来处理这两个事件：</p>
<pre class=" language-C#"><code class="language-C#">public class ActivityWriter : IEventHandler<TaskEventData>, ITransientDependency
{
    public void HandleEvent(TaskEventData eventData)
    {
        if (eventData is TaskCreatedEventData)
        {
            //...
        }
        else if (eventData is TaskCompletedEventData)
        {
            //...
        }
    }
}
</code></pre>
<p>当然了，你可以实现IEventHandler来处理所有你想要处理的事件。</p>
<h4 id="处理多事件"><a href="#处理多事件" class="headerlink" title="处理多事件"></a>处理多事件</h4><p>在一个单一的处理句柄中，可以处理多个事件。这时，你应该为每个事件实现IEventHandler。比如：</p>
<pre class=" language-C#"><code class="language-C#">public class ActivityWriter : 
    IEventHandler<TaskCompletedEventData>, 
    IEventHandler<TaskCreatedEventData>, 
    ITransientDependency
{
    public void HandleEvent(TaskCompletedEventData eventData)
    {
        //TODO: 处理事件...
    }

    public void HandleEvent(TaskCreatedEventData eventData)
    {
        //TODO: 处理事件...
    }
}
</code></pre>
<h3 id="句柄注册"><a href="#句柄注册" class="headerlink" title="句柄注册###"></a>句柄注册###</h3><p>为了处理事件，我们必须将事件句柄注册给事件总线。</p>
<h4 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h4><p>ABP会自动扫描所有的实现了IEventHandler的类，并<strong>自动</strong>将它们注册到事件总线上。当一个事件发生时，它会使用依赖注入获得该句柄的一个引用，而且在处理该事件之后就会释放该句柄。建议这样使用ABP中的事件总线。</p>
<h4 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h4><p>也可能会手动注册到事件，但是要小心使用。在一个web应用中，事件注册应该在应用启动时完成。在web请求时注册到一个事件不是一个好的方法，因为请求完成之后注册的类仍旧是注册的，而且对于每个请求继续再次注册。这可能会对你的应用造成问题，因为注册的类可能被调用多次。而且要记住手动注册不会使用依赖注入系统。</p>
<p>这里有一些事件总线的方法的重载。最简单的一个等待了一个委托（或者一个lambda）：</p>
<pre class=" language-C#"><code class="language-C#">EventBus.Register<TaskCompletedEventData>(eventData =>
    {
        WriteActivity("A task is completed by id = " + eventData.TaskId);
    });
</code></pre>
<p>这样，当“一个task完成”事件发生时，这个lambda方法就会调用。第二个等待一个实现了IEventHandler的对象：</p>
<pre class=" language-C#"><code class="language-C#">EventBus.Register<TaskCompletedEventData>(new ActivityWriter());
</code></pre>
<p>事件会调用ActivityWriter的相同实例。该方法也有一个非泛型的重载。另一个重载接受两个泛型的参数：</p>
<pre class=" language-C#"><code class="language-C#">EventBus.Register<TaskCompletedEventData, ActivityWriter>();
</code></pre>
<p>此时，事件总线会为每个事件创建一个新的ActivityWriter。如果它是可释放的，那么会调用ActivityWriter.Dispose方法。</p>
<p>最后，为了处理句柄的创建，你可以注册一个<strong>事件句柄工厂</strong>。句柄工厂有两个方法：<strong>GetHandler和ReleaseHandler</strong>。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class ActivityWriterFactory : IEventHandlerFactory
{
    public IEventHandler GetHandler()
    {
        return new ActivityWriter();
    }

    public void ReleaseHandler(IEventHandler handler)
    {
        //TODO:释放ActivityWriter实例 (handler)
    }
}
</code></pre>
<p>还有一个特殊的工厂类<strong>IocHandlerFactory</strong>，它可以使用依赖注入系统创建或者释放句柄。ABP在自动注册模式中使用了这个类。因此，如果你想使用依赖注入系统，直接使用自动注册。</p>
<h3 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册###"></a>取消注册###</h3><p>手动注册到事件总线时，你可能会在以后想要取消注册该事件。取消注册一个事件的最简单方法是释放该<strong>注册</strong>方法的返回值。如下所示：</p>
<pre class=" language-C#"><code class="language-C#">//注册到一个事件...
var registration = EventBus.Register<TaskCompletedEventData>(eventData => WriteActivity("A task is completed by id = " + eventData.TaskId) );

//取消注册事件
registration.Dispose();
</code></pre>
<p>当然了，注销注册会在某个地方和某个时间。保留注册对象并在想要取消注册时释放它。所有注册方法的重载都会返回一个可释放的对象以取消注册该事件。</p>
<p>事件总线也提供了<strong>Unregister</strong>方法。样例用法：</p>
<pre class=" language-C#"><code class="language-C#">//创建一个句柄
var handler = new ActivityWriter();
            
//注册到事件
EventBus.Register<TaskCompletedEventData>(handler);

//从事件取消注册
EventBus.Unregister<TaskCompletedEventData>(handler);
</code></pre>
<p>它也提供了重载来注销委托和工厂，注销句柄对象必须是之前注册的相同对象。</p>
<p>最后，事件总线提供了<strong>UnregisterAll</strong>方法来注销一个事件的所有句柄，**RegisterAll()**方法会注销所有事件的所有句柄</p>
<h1 id="ABP理论学习之数据过滤器"><a href="#ABP理论学习之数据过滤器" class="headerlink" title="ABP理论学习之数据过滤器"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html">ABP理论学习之数据过滤器</a></h1><hr>
<h2 id="本篇目录-15"><a href="#本篇目录-15" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#predefined">预定义过滤器</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#disable">关闭过滤器</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#enable">开启过滤器</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#set">设置过滤器参数</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#custom">定义自定义过滤器</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDataFilters.html#other">其他ORM</a></strong></li>
</ul>
<h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍###"></a>介绍###</h3><p><strong>软删除</strong>模式通常用于不会真正从数据库删除一个实体而是仅仅将它标记为”已删除的”。这样，如果一个实体是软删除的，那么它不应该在应用中检索到。为了实现这个目的，我们应该在每一个select实体查询操作中添加一个SQL <strong>where</strong>条件，如“IsDeleted=false”。这是乏味但是很重要的一项容易忘记的任务。因此，这项工作应该自动完成。</p>
<p>ABP提供了<strong>数据过滤器</strong>，它们可以基于某些规则自动过滤查询。有很多预定义的过滤器，但你也可以创建自己的过滤器。</p>
<h3 id="预定义过滤器"><a href="#预定义过滤器" class="headerlink" title="预定义过滤器###"></a>预定义过滤器###</h3><h4 id="ISoftDelete"><a href="#ISoftDelete" class="headerlink" title="ISoftDelete"></a>ISoftDelete</h4><p>软删除过滤器用于当查询数据库时自动过滤（从结果中提取）已经删除的实体。如果实体应该是软删除的，那么它必须实现只定义了<strong>IsDelete</strong>属性的 <strong>ISoftDelete</strong>接口，例如：</p>
<pre class=" language-C#"><code class="language-C#">public class Person : Entity, ISoftDelete
{
    public virtual string Name { get; set; }

    public virtual bool IsDeleted { get; set; }
}
</code></pre>
<p>实际上，<strong>Person</strong>实体并没有从数据库中删除，只是当要删除它时将它的 <strong>IsDelete</strong>属性设置成了true。当使用 <strong>IRepository.Delete</strong>方法时，ABP会自动处理（你可以手动设置IsDelete为true，但是Delete方法更自然且更受人欢迎）。</p>
<p>实现了ISoftDelete之后，当从数据库获取Person的列表时，已经软删除的person是不会检索到的。这里有一个使用了person仓储获得所有person的例子：</p>
<pre class=" language-C#"><code class="language-C#">public class MyService
{
    private readonly IRepository<Person> _personRepository;

    public MyService(IRepository<Person> personRepository)
    {
        _personRepository = personRepository;
    }

    public List<Person> GetPeople()
    {
        return _personRepository.GetAllList();
    }
}
</code></pre>
<p>GetPeople方法只会获得IsDeleted=false（没有删除）的Person实体。所有的仓储方法和导航属性都会正确工作。我们也可以添加一些其他的Where条件，连接等等。它会自动将IsDeleted=false添加到生成的Sql查询中。</p>
<blockquote>
<h4 id="何时开启ISoftDelete呢？"><a href="#何时开启ISoftDelete呢？" class="headerlink" title="何时开启ISoftDelete呢？"></a>何时开启ISoftDelete呢？</h4><p>ISoftDelete过滤器始终是开启的，除非你显式关闭了它。</p>
</blockquote>
<p>额外注意：如果实现了<strong>IDeletionAudited</strong>(它继承了ISoftDelete)，那么ABP会自动设置删除时间和删除者的id。</p>
<h4 id="IMustHaveTenant"><a href="#IMustHaveTenant" class="headerlink" title="IMustHaveTenant"></a>IMustHaveTenant</h4><p>如果你生成的是多租户应用（在一个数据库中存储所有租户的数据），那么你肯定不想一个租户意外地看到了其他租户的数据。这种情况你可以实现<strong>IMustHaveTenant</strong>。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class Product : Entity, IMustHaveTenant
{
    public int TenantId { get; set; }
        
    public string Name { get; set; }
}
</code></pre>
<p><strong>IMustHaveTenant</strong>定义了 <strong>TenantId</strong>来区分不同的租户实体。ABP使用了 <strong>IAbpSession</strong>来获得当前的TenantId，而且自动过滤当前租户的查询。</p>
<blockquote>
<h4 id="何时开启IMustHaveTenant呢？"><a href="#何时开启IMustHaveTenant呢？" class="headerlink" title="何时开启IMustHaveTenant呢？"></a>何时开启IMustHaveTenant呢？</h4><p>IMustHaveTenant默认是开启的。<br> 如果当前的用户没有登录到系统或者当前的用户是一个租主用户（租主用户是可以管理租户和租户数据的更高级用户），ABP会自动关闭IMustHaveTenant过滤器。因此，所有租户的所有数据都可以被检索到。注意这是没有涉及到安全的情况，你应该总是要对敏感的数据进行授权。</p>
</blockquote>
<h4 id="IMayHaveTenant"><a href="#IMayHaveTenant" class="headerlink" title="IMayHaveTenant"></a>IMayHaveTenant</h4><p>如果一个实体类是租户和租主共享的（这意味着一个实体对象可能被一个租户或者租主拥有），那么你可以使用IMayHaveTenant过滤器。<strong>IMayHaveTenant</strong>接口定义了<strong>ITenantId</strong>但是它是 <strong>nullable</strong>。</p>
<pre class=" language-C#"><code class="language-C#">public class Role : Entity, IMayHaveTenant
{
    public int? TenantId { get; set; }
        
    public string RoleName { get; set; }
}
</code></pre>
<p>如果TenantId的值是<strong>null</strong>，就意味着这是一个 <strong>租主</strong>实体；如果值不为null，就意味着该实体被一个 <strong>租户</strong>拥有，该租户的Id就是该TenantId。ABP使用了IAbpSession来获得当前的TenantId。IMayHaveTenant过滤器不像IMustHaveTenant过滤器那样常用，但是，对于租户和租户公用的结构，你可能需要它。</p>
<blockquote>
<h4 id="何时开启IMayHaveTenant呢？"><a href="#何时开启IMayHaveTenant呢？" class="headerlink" title="何时开启IMayHaveTenant呢？"></a>何时开启IMayHaveTenant呢？</h4><p>IMayHaveTenant总是开启的，除非你显式关闭了它。</p>
</blockquote>
<h3 id="关闭过滤器"><a href="#关闭过滤器" class="headerlink" title="关闭过滤器###"></a>关闭过滤器###</h3><p>你可以通过调用<strong>DisableFilter</strong>方法来为每个工作单元关闭过滤器，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">var people1 = _personRepository.GetAllList();

using (_unitOfWorkManager.Current.DisableFilter(AbpDataFilters.SoftDelete))
{
    var people2 = _personRepository.GetAllList();                
}

var people3 = _personRepository.GetAllList();
</code></pre>
<p>DisableFilter方法以字符串获得一个或更多的过滤器。AbpDataFilters.SoftDelete包含了ABP标准软删除过滤器的名称的常量字符串。</p>
<p><strong>people2</strong>可以获得已经删除的person实体，然而people1和people3只会获得没有删除的实体。使用 <strong>using</strong>语句，你可以在一个 <strong>作用域（scope）</strong>中关闭过滤器。如果你没有使用using语句，那么过滤器在当前工作单元结束前都是关闭的，除非你显式再次开启它。</p>
<p>你可以像上面的例子那样注入<strong>IUnitOfWorkManager</strong>使用。此外，你也可以在应用服务（它派生自ApplicationService类）中使用<strong>CurrentUnitOfWork</strong>属性作为快捷方式。</p>
<blockquote>
<h4 id="关于using语句"><a href="#关于using语句" class="headerlink" title="关于using语句"></a>关于using语句</h4><p>如果过滤器是开启的，当你在using语句中调用DisableFilter方法时，那么过滤器会关闭，然后，当using语句结束时，它会自动再次开启。但是如果在使用using语句之前过滤器已经关闭了，那么DisableFilter实际上什么都不会做，而且在using语句结束后仍然是关闭的。</p>
</blockquote>
<h3 id="开启过滤器"><a href="#开启过滤器" class="headerlink" title="开启过滤器###"></a>开启过滤器###</h3><p>你可以在工作单元中使用<strong>EnableFilter</strong>方法来开启一个过滤器，和DisableFilter很相似。EnableFilter也返回disable来自动再次关闭该过滤器。</p>
<h3 id="设置过滤器参数"><a href="#设置过滤器参数" class="headerlink" title="设置过滤器参数###"></a>设置过滤器参数###</h3><p>过滤器是可以带参数的。IMustHaveTenant过滤器就是这些过滤器类型的一个例子，因为当前的租户Id要在运行时确定。对于这些过滤器，如果需要的话，我们可以改变过滤器的值。例如：</p>
<pre class=" language-C#"><code class="language-C#">CurrentUnitOfWork.SetFilterParameter("PersonFilter", "personId", 42);
</code></pre>
<p>另一个例子：为IMayHaveTenant过滤器设置tenantId值：</p>
<pre><code>CurrentUnitOfWork.SetFilterParameter(AbpDataFilters.MayHaveTenant, AbpDataFilters.Parameters.TenantId, 42);
</code></pre>
<p>SetFilterParameter方法也返回一个IDisposable。因此，我们可以在一个using语句中使用它，在using语句结束时自动<strong>还原旧值</strong>。</p>
<h3 id="定义自定义过滤器"><a href="#定义自定义过滤器" class="headerlink" title="定义自定义过滤器###"></a>定义自定义过滤器###</h3><p>要创建一个自定义过滤器并集成到ABP中，我们首先应该定义一个接口，该接口会被使用这个过滤器的实体实现。假设我们想要通过PersonId自动过滤实体。例如：</p>
<pre class=" language-C#"><code class="language-C#">public interface IHasPerson
{
    int PersonId { get; set; }
}
</code></pre>
<p>然后，为需要的实体实现该接口。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class Phone : Entity, IHasPerson
{
    [ForeignKey("PersonId")]
    public virtual Person Person { get; set; }
    public virtual int PersonId { get; set; }

    public virtual string Number { get; set; }
}
</code></pre>
<p>因为ABP使用了**<a href="https://github.com/jcachat/EntityFramework.DynamicFilters">EntityFramework.DynamicFilters</a><strong>，因此我们可以使用它的规则来定义该过滤器。在我们的 **DbContext</strong>类中，我们重写了 <strong>OnModelCreating</strong>，而且定义过滤器如下所示：</p>
<pre class=" language-C#"><code class="language-C#">protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);

    modelBuilder.Filter("PersonFilter", (IHasPerson entity, int personId) => entity.PersonId == personId, 0);
}
</code></pre>
<p>这里，“PersonFilter”是过滤器唯一的名字。第二个参数定义了过滤器接口和personId过滤器参数（如果过滤器没有参数那么就不需要了）。最后一个参数是personId的默认值。</p>
<p>最后一件事，我们应该在模块的PreInitialize方法中将该过滤器注册到ABP的工作单元系统中。</p>
<pre class=" language-c#"><code class="language-c#">Configuration.UnitOfWork.RegisterFilter("PersonFilter", false);
</code></pre>
<p>第一个参数是我们上面定义的过滤器的唯一的名字。第二个参数表明默认是开启的还是关闭的。声明这么一个参数化的过滤器之后，我们可以通过在运行时给它提供值来使用了。</p>
<pre class=" language-C#"><code class="language-C#">using (CurrentUnitOfWork.EnableFilter("PersonFilter"))
{
    CurrentUnitOfWork.SetFilterParameter("PersonFilter", "personId", 42);
    var phones = _phoneRepository.GetAllList();
    //...
}
</code></pre>
<p>我们可以从一些源中获得personId而不是静态代码中。上面的例子是对于参数化的过滤器来说的。过滤器可以有零个或更多的参数。如果它没有参数，就不需要设置过滤器的值了。此外，如果它默认是开启的，它就不需要手动开启了（当然，我们还可以关闭它）。</p>
<blockquote>
<h4 id="EntityFramework-DynamicFilters文档"><a href="#EntityFramework-DynamicFilters文档" class="headerlink" title="EntityFramework.DynamicFilters文档"></a>EntityFramework.DynamicFilters文档</h4><p>关于动态数据过滤器的更多信息，请看**<a href="https://github.com/jcachat/EntityFramework.DynamicFilters">github上的文档</a>**。</p>
</blockquote>
<p>我们也可以为安全，激活/未激活的实体等创建自定义的过滤器。</p>
<h3 id="其他ORM"><a href="#其他ORM" class="headerlink" title="其他ORM###"></a>其他ORM###</h3><p>ABP已经实现了EF和NH的数据过滤。对于其他的ORM还不可用。但是实际上，只要你使用<strong>仓储</strong>获得数据，你就可以为绝大多数情况模拟数据过滤。对于这种情况，如果需要的话，你可以创建自定义的仓储，然后重写   <strong>GetAll</strong>和其他的数据检索方法。</p>
<h1 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h1><h1 id="ABP理论学习之应用服务"><a href="#ABP理论学习之应用服务" class="headerlink" title="ABP理论学习之应用服务"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html">ABP理论学习之应用服务</a></h1><hr>
<h2 id="本篇目录-16"><a href="#本篇目录-16" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#IApplicationService">IApplicationService接口</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#ApplicationService">ApplicationService类</a></strong></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#Uow">工作单元</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#sbConn">数据库连接和事务管理</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#saving">自动保存更改</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#more">更多</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPApplicationService.html#lifecycle">应用服务的生命周期</a></strong></li>
</ul>
<p>应用服务用于将领域逻辑暴露给展现层。展现层调用具有DTO参数的应用服务，使用领域对象来执行一些特定的业务逻辑并返回给展现层一个DTO。这样，展现层就完全独立于领域层了。在一个理想的分层应用中，展现层永远不直接和领域对象打交道。</p>
<h3 id="IApplicationService接口"><a href="#IApplicationService接口" class="headerlink" title="IApplicationService接口###"></a>IApplicationService接口###</h3><p>在ABP中，应用服务<strong>应该</strong>实现 <strong>IApplicationService</strong>接口。建议为每个应用服务创建一个接口。这样一来，我们先要为一个应用定义一个接口，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public interface IPersonAppService : IApplicationService
{
    void CreatePerson(CreatePersonInput input);
}
</code></pre>
<p><strong>IPersonAppService</strong>只有一个方法。展现层用它来创建一个新的person。<strong>CreatePersonInput</strong>是如下所示的一个DTO对象：</p>
<pre class=" language-C#"><code class="language-C#">public class CreatePersonInput : IInputDto
{
    [Required]
    public string Name { get; set; }

    public string EmailAddress { get; set; }
}
</code></pre>
<p>然后我可以实现IPersonAppService:</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService : IPersonAppService
{
    private readonly IRepository<Person> _personRepository;

    public PersonAppService(IRepository<Person> personRepository)
    {
        _personRepository = personRepository;
    }

    public void CreatePerson(CreatePersonInput input)
    {
        var person = _personRepository.FirstOrDefault(p => p.EmailAddress == input.EmailAddress);
        if (person != null)
        {
            throw new UserFriendlyException("There is already a person with given email address");
        }

        person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };
        _personRepository.Insert(person);
    }
}
</code></pre>
<p>这里是一些重点：</p>
<ul>
<li>PersonAppService使用<strong>IRepository</strong>执行数据库操作。这里使用了依赖注入，而且使用了 <strong>构造函数注入</strong>的模式。</li>
<li>PersonAppService实现了<strong>IApplicationService</strong>，它是通过ABP自动注册到依赖注入系统的，然后被其他的类注入并使用。</li>
<li><strong>CreatePerson</strong>方法以 <strong>CreatePersonInput</strong>作为参数。它是一个输入DTO，会被ABP自动验证。</li>
</ul>
<h4 id="ApplicationService类"><a href="#ApplicationService类" class="headerlink" title="ApplicationService类"></a>ApplicationService类</h4><p>应用服务类应该实现应用服务接口（IApplicationService）。此外，还可以选择从<strong>ApplicationService</strong>基类派生。这样，IApplicationService也被继承实现了。而且，ApplicationService有一些基本功能，使得<strong>logging</strong>和 <strong>本土化</strong>更加简单。建议为你的继承了ApplicationService的应用服务创建一个特殊的基类。这样，你就可以为所有的应用服务添加一些通用功能。一个应用服务类的例子如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskAppService : ApplicationService, ITaskAppService
{
    public TaskAppService()
    {
        LocalizationSourceName = "SimpleTaskSystem";
    }

    public void CreateTask(CreateTaskInput input)
    {
        //记录日志 (Logger 定义在 ApplicationService 类中)
        Logger.Info("Creating a new task with description: " + input.Description);

        //获取本地化文本 (L 是LocalizationHelper.GetString(...)的简写, 定义在 ApplicationService类中)
        var text = L("SampleLocalizableTextKey");

        //TODO: Add new task to database...
    }
}
</code></pre>
<p>你可以定义一个基类，在该基类中的构造函数中定义LocalizationSourceName。这样，就不用为所有的服务类重复定义了。</p>
<h3 id="工作单元-1"><a href="#工作单元-1" class="headerlink" title="工作单元###"></a>工作单元###</h3><p>在ABP中，应用服务方法默认是一个工作单元。</p>
<h4 id="数据库连接和事务管理"><a href="#数据库连接和事务管理" class="headerlink" title="数据库连接和事务管理"></a>数据库连接和事务管理</h4><p>假如说我们想要在一个必须是事务的应用服务方法中调用两个仓储方法。例如：</p>
<pre class=" language-C#"><code class="language-C#">public void CreatePerson(CreatePersonInput input)
{
    var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };    
    _personRepository.Insert(person);
    _statisticsRepository.IncrementPeopleCount();
}
</code></pre>
<p>我们将一个person实体插入到People表中，然后总人数自增，并保存到另一个表的字段中。这个方法都是用不同的仓储实现的，但是共享了相同的连接和事务。</p>
<p>在CreatePerson方法开始时，ABP会自动打开数据库连接并开始事务。在方法结束时，如果没有异常发生，会自动提交事务并关闭数据库连接。这样，在CreatePerson方法中的所有数据库操作都是<strong>事务的（原子的）</strong>，如果有任何异常抛出，操作就会回滚。因此，在这个方法中的两个仓储共享相同的连接和事务。</p>
<p>当调用仓储的**GetAll()**方法时，会返回一个IQueryable。数据库连接应该在调用该方法后打开。这是因为IQueryable和Linq会延迟执行。数据库真正查询是在调用 **ToList()**方法时发生的。看下面的例子：</p>
<pre class=" language-C#"><code class="language-C#">public SearchPeopleOutput SearchPeople(SearchPeopleInput input)
{
    //获得 IQueryable<Person>
    var query = _personRepository.GetAll();

    //添加过滤
    if (!string.IsNullOrEmpty(input.SearchedName))
    {
        query = query.Where(person => person.Name.StartsWith(input.SearchedName));
    }

    if (input.IsActive.HasValue)
    {
        query = query.Where(person => person.IsActive == input.IsActive.Value);
    }

    //获取分页结果list
    var people = query.Skip(input.SkipCount).Take(input.MaxResultCount).ToList();

    return new SearchPeopleOutput {People = Mapper.Map<List<PersonDto>>(people)};
}
</code></pre>
<p>因为一个应用服务方法是一个工作单元，所以在执行这个方法期间数据库连接是打开的。如果在一个不是应用服务的类中调用了GetAll()方法，那么应该显式使用<strong>工作单元</strong>。</p>
<p>注意这里使用了AutoMapper类库将 List转成List。更多细节请看下一篇DTO博客。</p>
<h4 id="自动保存更改"><a href="#自动保存更改" class="headerlink" title="自动保存更改"></a>自动保存更改</h4><p>对于工作单元方法，ABP会在方法结束时自动保存所有的更改。假设我们有一个更新一个人的名字的应用服务方法：</p>
<pre class=" language-C#"><code class="language-C#">public void UpdateName(UpdateNameInput input)
{
    var person = _personRepository.Get(input.PersonId);
    person.Name = input.NewName;
}
</code></pre>
<p>只需要这样，name字段就改变了。我们甚至都不要调用_personRepository.Update方法。ORM框架会跟踪工作单元内的实体的所有更改，并将更改反映给数据库。</p>
<h1 id="ABP理论学习之数据传输对象-DTO"><a href="#ABP理论学习之数据传输对象-DTO" class="headerlink" title="ABP理论学习之数据传输对象(DTO)"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html">ABP理论学习之数据传输对象(DTO)</a></h1><hr>
<h2 id="本篇目录-17"><a href="#本篇目录-17" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#whyDTO">为何需要DTO</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#abstraction">领域层抽象</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#dataHide">数据隐藏</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#lazyLoading">序列化和懒加载问题</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#validation">DTO惯例和验证</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#autoMapping">DTO和实体的自动映射</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#attribute">使用特性和扩展方法进行映射</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTO.html#helper">帮助接口</a></strong></li>
</ul>
<p>DTO用于<strong>应用层</strong>和 <strong>展现层</strong>间的数据传输。</p>
<p>展现层调用具有DTO参数的**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPApplicationService.html">应用服务</a>**方法，然后应用服务使用领域对象来执行一些特定的业务逻辑，最后返回给展现层一个DTO。因此，展现层完全独立于领域层。在一个理想的分层应用中，展现层不直接和领域对象打交道（仓储，实体…）。</p>
<h3 id="为何需要DTO"><a href="#为何需要DTO" class="headerlink" title="为何需要DTO###"></a>为何需要DTO###</h3><p>为每个应用服务方法创建一个DTO起初可能被看作是一项乏味而又耗时的事情。但如果正确地使用它，那么DTOs可能会拯救你应用。为啥呢？</p>
<h4 id="领域层抽象"><a href="#领域层抽象" class="headerlink" title="领域层抽象"></a>领域层抽象</h4><p>DTO为展现层抽象领域对象提供了一种有效方式。这样，层与层之间就正确分离了。即使你想完全分离展现层，仍然可以使用已存在的应用层和领域层。相反，只要领域服务的契约（方法签名和DTOs）保持不变，即使重写领域层，完全改变数据库模式，实体和ORM框架，也不需要在展现层做任何改变。</p>
<h4 id="数据隐藏"><a href="#数据隐藏" class="headerlink" title="数据隐藏"></a>数据隐藏</h4><p>试想你有一个User实体，包含Id，Name，EmailAddress和Password字段。如果UserAppService的GetAllUsers()方法返回一个List，即使你没有在屏幕上显示它，那么任何人也都能看到所有user的密码。它不是涉及安全的，而是与数据隐藏相关的。应用服务都应该返回给展现层需要的，不要更多，也不很少，要的是恰到好处。</p>
<h4 id="序列化和懒加载问题"><a href="#序列化和懒加载问题" class="headerlink" title="序列化和懒加载问题"></a>序列化和懒加载问题</h4><p>当返回给展现层一个对象时，它很可能在某个地方序列化。比如，一个MVC方法返回JSON，一个对象会被序列化成JSON，然后发送到客户端。在那种情况，将一个实体返回到展现层是有问题的。这是怎么回事呢？</p>
<p>在一个真实应用中，实体之间是相互引用的。User实体可能有一个Role的引用。因此，如果你想序列化User，那么Role也会序列化。而且，如果Role有一个List且Permission类有一个PermissionGroup类的引用等等。你能想象所有的对象都会被序列化的那种场景吗？你可能会意外地序列化整个数据库。那么解决方案是什么呢？把属性标记为NonSerilized吗?不，你可能不知道它何时应该序列化，何时不应该。它可能在一个应用方法中需要，可能在另一个就不需要了。因此，在这种情景中，设计一个可安全序列化的，特别设计的DTOs是一种好的选择。</p>
<p>几乎所有的ORM框架都支持懒加载。它的特征是当需要时才从数据库中加载实体。假如说User类有一个Role类的引用。当从数据库中获得一个User时，此时Role属性还没有填充，当第一次读该Role属性时，它才从数据库中加载。因此，不要将这样的一个实体直接返回给展现层，它可能会轻易造成从数据库检索额外的实体。如果序列化工具读到了该实体，它会递归地读取所有属性，最终整个数据库可能会被检索（如果实体间有合适的关系）。</p>
<p>在展现层使用实体还会有更多的问题。最好压根不要在将包含领域（业务）层的程序集引用到展现层上。</p>
<h3 id="DTO惯例和验证"><a href="#DTO惯例和验证" class="headerlink" title="DTO惯例和验证###"></a>DTO惯例和验证###</h3><p>ABP高度支持DTOs，它提供了一些符合惯例的类和接口，并且对于DTO的命名和用法提出了一些建议。当按照下面描述的那样编写代码时，ABP会轻易地自动处理一些事情。</p>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>让我们看一个完整的例子。假如我们想要开发一个应用服务方法，作用是使用一个名字来搜索人，并返回一个人的集合。这种情况下，我们可能会有一个如下的Person实体：</p>
<pre class=" language-C#"><code class="language-C#">public class Person : Entity
{
    public virtual string Name { get; set; }
    public virtual string EmailAddress { get; set; }
    public virtual string Password { get; set; }
}
</code></pre>
<p>首先，我们定义一个应用服务的接口：</p>
<pre class=" language-C#"><code class="language-C#">public interface IPersonAppService : IApplicationService
{
    SearchPeopleOutput SearchPeople(SearchPeopleInput input);
}
</code></pre>
<p>ABP建议将input/output参数命名为MethodName<strong>Input</strong>和   MethodName<strong>Output</strong>，并为每个应用服务方法定义一个单独的input和output DTO。即使你的方法只需要或返回一个参数，最好也创建一个DTO类。这样，你的代码回更具有扩展性。以后你可以添加更多的属性而不用改变方法的签名，而且也不用使已存在的客户端应用发生重大变化。</p>
<p>当然，如果你的方法没有返回值，那么方法可以返回<strong>void</strong>。如果以后添加了一个返回值，也不会打破已存在的应用。如果你的方法不需要任何参数，那么你也不必定义一个输入DTO。但是如果未来很可能添加参数，那么也许最好还是编写一个输入DTO。这取决于你。</p>
<p>让我们看一下为这个例子定义的输入和输出的DTO：</p>
<pre class=" language-C#"><code class="language-C#">public class SearchPeopleInput : IInputDto
{
    [StringLength(40, MinimumLength = 1)]
    public string SearchedName { get; set; }
}

public class SearchPeopleOutput : IOutputDto
{
    public List<PersonDto> People { get; set; }
}

public class PersonDto : EntityDto
{
    public string Name { get; set; }
    public string EmailAddress { get; set; }
}
</code></pre>
<p><strong>验证：</strong>按照惯例，输入DTO实现了 <strong>IInputDto</strong>接口，输出DTO实现了 <strong>IOutputDto</strong>接口。当实现了IInputDto时，ABP会在方法执行前自动验证输入。这和ASP.NET MVC的验证很相似，但是注意应用服务不是控制器，它是纯粹的C#类。ABP使用拦截来自动检查输入。关于更多的验证，请看下篇DTO验证。</p>
<p><strong>EntityDto</strong>是一个声明了Id属性的简单类。因为这对于所有的实体都是公用的。如果你的实体的主键不是int的，那么还有一个泛型版本。PersonDto不包含Password属性，因为表现层不需要。甚至将所有人的密码都发送到展现层可能是很危险的。想象一下，如果Javascript客户端发送请求，任何人就会轻易地抓取到所有的密码。</p>
<p>接下来进一步实现之前的<strong>IPersonAppService</strong>。</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService : IPersonAppService
{
    private readonly IPersonRepository _personRepository;

    public PersonAppService(IPersonRepository personRepository)
    {
        _personRepository = personRepository;
    }

    public SearchPeopleOutput SearchPeople(SearchPeopleInput input)
    {
        //Get entities
        var peopleEntityList = _personRepository.GetAllList(person => person.Name.Contains(input.SearchedName));

        //Convert to DTOs
        var peopleDtoList = peopleEntityList
            .Select(person => new PersonDto
                                {
                                    Id = person.Id,
                                    Name = person.Name,
                                    EmailAddress = person.EmailAddress
                                }).ToList();

        return new SearchPeopleOutput { People = peopleDtoList };
    }
}
</code></pre>
<p>我们从数据库中获得实体，再将它们转成DTOs，然后返回到输出。注意我们没有验证输入，因为ABP会自动验证。ABP甚至会检查输入参数是否为null，如果为null，就会抛出异常。</p>
<p>但是很可能你不喜欢从一个Person实体到一个PersonDto对象的转换代码。这是相当无聊的事情，而且，Person实体可能会有更多的属性。</p>
<h3 id="DTO和实体的自动映射"><a href="#DTO和实体的自动映射" class="headerlink" title="DTO和实体的自动映射###"></a>DTO和实体的自动映射###</h3><p>幸好，我们有工具可以让这个变得很简单。<strong>AutoMapper</strong>就是之一（要学习AutoMapper，请看我的**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/AutoMapperContent.html">AutoMapper系列教程</a>**。它已经发布到Nuget上了，你可以轻松地将它添加到项目中。让我们再次写一下SearchPeople方法，但是这次是用AutoMapper：</p>
<pre class=" language-C#"><code class="language-C#">public SearchPeopleOutput SearchPeople(SearchPeopleInput input)
{
    var peopleEntityList = _personRepository.GetAllList(person => person.Name.Contains(input.SearchedName));
    return new SearchPeopleOutput { People = Mapper.Map<List<PersonDto>>(peopleEntityList) };
}
</code></pre>
<p>这样就ok了。你可以给实体和DTO添加更多的属性而不需要转换代码做任何改变。唯一要做的事情就是在使用前定义一个映射：</p>
<pre class=" language-C#"><code class="language-C#">Mapper.CreateMap<Person, PersonDto>();
</code></pre>
<p>AutoMapper创建了映射代码。这样，动态映射就不会成为性能问题了。它既快速又容易。AutoMapper为Person实体创建了PersonDto，并使用命名规范赋予DTO属性。命名规范可能是复杂的且可配置的。此外，你还可以定义自定义映射以及更多。</p>
<h4 id="使用特性和扩展方法进行映射"><a href="#使用特性和扩展方法进行映射" class="headerlink" title="使用特性和扩展方法进行映射"></a>使用特性和扩展方法进行映射</h4><p>ABP提供了若干特性和扩展方法来定义映射。首先，要将Abp.AutoMapper nuget包添加到项目中。然后，<strong>AutoMap</strong>特性是双向映射方式， <strong>AutoMapFrom</strong>和 <strong>AutoMapTo</strong>是单向映射方式。最后，使用<strong>MapTo</strong>扩展方法将一个对象映射到另一个对象。映射定义的例子如下：</p>
<pre class=" language-C#"><code class="language-C#">[AutoMap(typeof(MyClass2))] //定义双向映射
public class MyClass1
{
    public string TestProp { get; set; }
}

public class MyClass2
{
    public string TestProp { get; set; }
}
</code></pre>
<p>定义了上面的代码之后，就可以使用MapTo扩展方法映射它们了：</p>
<pre class=" language-C#"><code class="language-C#">var obj1 = new MyClass1 { TestProp = "Test value" };
var obj2 = obj1.MapTo<MyClass2>(); //从obj1的副本创建一个新的MyClass2对象
</code></pre>
<p>上面的代码从MyClass1的对象创建了MyClass2一个新的对象。此外，你可以像下面那样，映射到一个已存在的对象：</p>
<pre class=" language-C#"><code class="language-C#">var obj1 = new MyClass1 { TestProp = "Test value" };
var obj2 = new MyClass2();
obj1.MapTo(obj2);
</code></pre>
<h3 id="帮助接口-1"><a href="#帮助接口-1" class="headerlink" title="帮助接口###"></a>帮助接口###</h3><p>ASP.NET 提供了一些实现标准化公共DTO属性名称的帮助接口。</p>
<p><strong>ILimitedResultRequest</strong>定义了 <strong>MaxResultCount</strong>属性。这样你就可以在你的输入DTO中实现它来标准化有限的结果集。</p>
<p><strong>IPagedResultRequest</strong>通过添加了 <strong>SkipCount</strong>扩展了 <strong>ILimitedResultRequest</strong>。这样，我们可以在SearchPeopleInput中为分页显示实现这个接口：</p>
<pre class=" language-C#"><code class="language-C#">public class SearchPeopleInput : IInputDto, IPagedResultRequest
{
    [StringLength(40, MinimumLength = 1)]
    public string SearchedName { get; set; }

    public int MaxResultCount { get; set; }
    public int SkipCount { get; set; }
}
</code></pre>
<p>对于一个分页请求的结果，你可以返回一个实现了<strong>IHasTotalCount</strong>的输出DTO。命名标准化帮助我们创建可重复使用的代码和惯例。你也可以在 <strong>Abp.Application.Services.Dto</strong>命名空间下看到其他的接口和类。</p>
<h1 id="ABP理论学习之验证DTO"><a href="#ABP理论学习之验证DTO" class="headerlink" title="ABP理论学习之验证DTO"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html">ABP理论学习之验证DTO</a></h1><hr>
<h2 id="本篇目录-18"><a href="#本篇目录-18" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html#intro">验证介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html#annotaion">使用数据注解</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html#custom">自定义验证</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDTOValidation.html#normalization">标准化</a></strong></li>
</ul>
<h3 id="验证介绍"><a href="#验证介绍" class="headerlink" title="验证介绍###"></a>验证介绍###</h3><p>首先应该验证应用的输入。用户或者其它应用都可以向该应用发送输入。在一个web应用中，验证通常要实现两次：在客户端和服务器端。客户端的验证大多数情况下是为用户体验而实现的。在客户端最好先检查一下表单，并向用户展示不合法的字段。但是服务端的验证更关键且不可避免。</p>
<p>服务端的验证通常实现在应用服务层。应用服务方法应首先检查（验证）输入然后再使用它。ABP提供了一个很好的基础设施来验证应用服务方法的输入。</p>
<p>应用服务方法接收一个DTO（数据传输对象）作为输入。ABP有一个<strong>IValidate</strong>接口，凡是实现了该接口的DTO都可以自动地进行验证。因为<strong>IInputDto</strong>继承了IValidate，因此只要为输入DTOs实现IInputDto就可以确保验证了。</p>
<h3 id="使用数据注解"><a href="#使用数据注解" class="headerlink" title="使用数据注解###"></a>使用数据注解###</h3><p>ABP支持数据注解特性。假设我们要开发一个任务（Task）应用服务，该服务用于创建一个任务，它的输入参数类型如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class CreateTaskInput : IInputDto
{
    public int? AssignedPersonId { get; set; }

    [Required]
    public string Description { get; set; }
}
</code></pre>
<p>这里，<strong>Description</strong>属性标记为 <strong>Required</strong>。AssignedPersonId是可选的。在 <strong>System.ComponentModel.DataAnnotations</strong>命名空间中也有很多特性（如MaxLength,MinLength,RegularExpression等等）。来看一下任务应用服务的实现：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskAppService : ITaskAppService
{
    private readonly ITaskRepository _taskRepository;
    private readonly IPersonRepository _personRepository;

    public TaskAppService(ITaskRepository taskRepository, IPersonRepository personRepository)
    {
        _taskRepository = taskRepository;
        _personRepository = personRepository;
    }

    public void CreateTask(CreateTaskInput input)
    {
        var task = new Task { Description = input.Description };

        if (input.AssignedPersonId.HasValue)
        {
            task.AssignedPerson = _personRepository.Load(input.AssignedPersonId.Value);
        }

        _taskRepository.Insert(task);
    }
}
</code></pre>
<p>正如你所看到的，这里没写验证代码，因为ABP会自动进行验证。ABP也会检查输入是否为<strong>null</strong>。如果为null，就会抛出 <strong>AbpValidationException</strong>。因此，你也不用写检测null的代码（保卫语句）。如果输入的属性有任何一个是非法的，那么就会抛出相同的异常。</p>
<p>该机制和ASP.NET MVC的验证相似，但是注意的是应用服务类不是派生自Controller，而只是一个纯粹的类并且在web应用之外工作。</p>
<h3 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证###"></a>自定义验证###</h3><p>如果数据注解还不能满足你的情况，那么你可以实现<strong>ICustomValidate</strong>接口，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class CreateTaskInput : IInputDto, ICustomValidate
{
    public int? AssignedPersonId { get; set; }

    public bool SendEmailToAssignedPerson { get; set; }

    [Required]
    public string Description { get; set; }

    public void AddValidationErrors(List<ValidationResult> results)
    {
        if (SendEmailToAssignedPerson && (!AssignedPersonId.HasValue || AssignedPersonId.Value <= 0))
        {
            results.Add(new ValidationResult("AssignedPersonId must be set if SendEmailToAssignedPerson is true!"));
        }
    }
}
</code></pre>
<p>ICustomValidate接口声明了要实现的<strong>AddValidationErrors</strong>方法。这里，我们有一个 <strong>SendEmailToAssignedPerson</strong>属性。如果它的值是true， 而且没有提供<strong>AssignedPersonId</strong>或值是负数，那么我们就认为这里发生了验证错误，我们必须将<strong>ValidationResult</strong>对象添加到 <strong>results</strong>集合中。</p>
<h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化###"></a>标准化###</h3><p>我们可能在验证之后执行一个额外的操作来排列DTO参数。ABP定义了<strong>IShouldNormalize</strong>接口， 该接口中定义了<strong>Normalize</strong>方法来达到排列DTO参数的目的。如果你实现了该接口，那么就应该在验证之后（方法调用之前）调用Normalize方法。假如我们的DTO要有一个排序（Sorting）方向，如果没有提供的话，我们就要设置一个默认值：</p>
<pre class=" language-C#"><code class="language-C#">public class GetTasksInput : IInputDto, IShouldNormalize
{
    public string Sorting { get; set; }
        
    public void Normalize()
    {
        if (string.IsNullOrWhiteSpace(Sorting))
        {
            Sorting = "Name ASC";
        }
    }
}
</code></pre>
<h1 id="ABP理论学习之授权（Authorization）"><a href="#ABP理论学习之授权（Authorization）" class="headerlink" title="ABP理论学习之授权（Authorization）"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html">ABP理论学习之授权（Authorization）</a></h1><hr>
<h2 id="本篇目录-19"><a href="#本篇目录-19" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#define">定义权限</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#check">检查权限</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#AbpAuthorize">使用AbpAuthorize特性</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#IPermissionChecker">使用IPermissionChecker</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#Razor">Razor视图</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#Javascript">客户端（Javascript）</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuthorization.html#permissionManager">权限管理者</a></strong></li>
</ul>
<h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍###"></a>介绍###</h3><p>几乎所有的企业应用都在不同程度使用了授权。授权的目的在于检查是否允许用户在应用程序中执行特定的操作。ABP定义了一个<strong>基于权限的</strong>基础设施来实现授权。</p>
<blockquote>
<h4 id="关于IPermissionChecker"><a href="#关于IPermissionChecker" class="headerlink" title="关于IPermissionChecker"></a>关于IPermissionChecker</h4><p>授权系统使用了<strong>IPermissionChecker</strong>来检查权限。虽然你可以用自己的方式实现该接口，但是它已完全实现在了 <strong>module-zero</strong>项目中。如果没有实现该接口，那么系统会默认使用NullPermissionChecker将所有的权限授予给每个人。</p>
</blockquote>
<h3 id="定义权限"><a href="#定义权限" class="headerlink" title="定义权限###"></a>定义权限###</h3><p>一个唯一的权限是为需要授权的每个操作定义的。我们应该在使用权限之前定义一个权限。ABP的设计是模块化的，因此不同的模块可以有不同的权限。为了定义模块的权限，应该创建一个派生自<strong>AuthorizationProvider（以下翻译为授权提供者）</strong>的类。一个授权提供者的例子如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class MyAuthorizationProvider : AuthorizationProvider
{
    public override void SetPermissions(IPermissionDefinitionContext context)
    {
        var administration = context.CreatePermission("Administration");

        var userManagement = administration.CreateChildPermission("Administration.UserManagement");
        userManagement.CreateChildPermission("Administration.UserManagement.CreateUser");

        var roleManagement = administration.CreateChildPermission("Administration.RoleManagement");
    }
}
</code></pre>
<p><strong>IPermissionDefinitionContext</strong>有创建和获取权限的方法。</p>
<p>一个权限定义了一些属性：</p>
<ul>
<li><strong>Name：</strong>系统中 <strong>唯一的</strong>名字。最好为权限的名字定义一个const字符串而不是变量字符串。我们偏向使用“.”符号用于有层次的名字，但这不是强制的。你可以设置任何你喜欢的名字，唯一的一点是保证它必须是唯一的。</li>
<li>**DisplayName:**用于以后在UI上显示权限的本地化字符串。</li>
<li><strong>Description：</strong>用于以后在UI上显示权限定义的本地化字符串。</li>
<li><strong>IsGrantedByDefault：</strong>表示该权限是否授予给所有登录的用户，除非该权限显式禁止未授予给用户。该值一般默认为false。</li>
<li><strong>MultiTenancySides：</strong>对于多租户应用，租户或者租主可以使用同一个权限。这是一个<strong>Flags</strong>枚举，因此一个权限可以用于租户和租主。</li>
<li><strong>dependedFeature：</strong>可以用于声明一个功能的依赖。因此，只有功能依赖满足了，该权限才会被授予。</li>
</ul>
<p>一个权限可以有父权限和子权限。虽然这不会影响权限检查，但是在UI上组合权限有所帮助。</p>
<p>当创建了授权提供者之后，我们应该在模块的PreIntialize方法中注册它：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Authorization.Providers.Add<MyAuthorizationProvider>();
</code></pre>
<p>因为授权提供者会自动地注册到依赖注入系统中，所以，授权提供者通过一些其他资源，可以注入任何依赖（比如仓储）来生成权限定义。</p>
<h3 id="检查权限"><a href="#检查权限" class="headerlink" title="检查权限###"></a>检查权限###</h3><h4 id="使用AbpAuthorize特性"><a href="#使用AbpAuthorize特性" class="headerlink" title="使用AbpAuthorize特性"></a>使用AbpAuthorize特性</h4><p><strong>AbpAuthorize</strong>（MVC控制器是AbpMvcAuthorize，Web API控制器是AbpApiAuthorize）是最简单也是最普通的检查权限的方式。思考一下下面的应用服务方法：</p>
<pre class=" language-C#"><code class="language-C#">[AbpAuthorize("Administration.UserManagement.CreateUser")]
public void CreateUser(CreateUserInput input)
{
    //如果一个用户没有被授予 "Administration.UserManagement.CreateUser" 权限，那么ta就不能执行此方法
}
</code></pre>
<p>AbpAuthorize特性也会检查当前的用户是否已经登录（使用**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPSession.html">IAbpSession.UserId</a>**）。因此，如果我们为一个方法声明了AbpAuthorize，它至少会检查登录情况：</p>
<pre class=" language-C#"><code class="language-C#">[AbpAuthorize]
public void SomeMethod(SomeMethodInput input)
{
    //如果用户没有登录，那么ta就不能执行此方法
}
</code></pre>
<p><strong>AbpAuthorize特性需要注意的地方</strong></p>
<p>ABP对于授权使用了强大的动态方法拦截（interception）。因此，使用AbpAuthorize特性有一些限制：</p>
<ul>
<li>不能用于私有方法。</li>
<li>不能用于静态方法。</li>
<li>不能用于非注入类的方法（我们必须要使用依赖注入）。</li>
</ul>
<p>此外，</p>
<ul>
<li>可以用于任何 <strong>public</strong>方法，如果该方法是通过接口调用的（比如应用服务通过接口使用）。</li>
<li>方法应该是<strong>virtual</strong>的，如果它是从类的引用直接调用的（比如ASP.Net MVC或者Web API的控制器）。</li>
<li>如果方法是<strong>protected</strong>的，那么它应该是 <strong>virtual</strong>的。</li>
</ul>
<p><strong>注意：</strong>AbpAuthorize特性有三个：</p>
<p>在应用服务中（应用层），我们使用<strong>Abp.Authorization.AbpAuthorize</strong>类。<br> 在MVC控制器中（Web层），我们使用 <strong>Abp.Web.Mvc.Authorization.AbpMvcAuthorize</strong>类。<br> 在ASP.NET Web API中，我们使用 <strong>Abp.WebApi.Authorization.AbpApiAuthorize</strong>特性。<br> 这写特性的差异来自继承。在MVC端，派生自MVC自己的Authorize类。在Web API端，它派生自Web API的Authorize类。因此，它已经很好地集成到了MVC和Web API。但是在应用层，它完全是ABP自己的实现而没有扩展任何类。</p>
<h4 id="使用IPermissionChecker"><a href="#使用IPermissionChecker" class="headerlink" title="使用IPermissionChecker"></a>使用IPermissionChecker</h4><p>虽然AbpAuthorize特性对于大多数情况相当够用了，但是肯定存在我们会在一个方法体内检查权限的情况。我们可以注入并使用<strong>IPermissionChecker</strong>，如下面的例子所示：</p>
<pre class=" language-C#"><code class="language-C#">public void CreateUser(CreateOrUpdateUserInput input)
{
    if (!PermissionChecker.IsGranted("Administration.UserManagement.CreateUser"))
    {
        throw new AbpAuthorizationException("You are not authorized to create user!");
    }
    
    //如果一个用户没有"Administration.UserManagement.CreateUser" 权限，那么ta不能到达该点。
}
</code></pre>
<p>当然，你可以编写任何逻辑代码，因为<strong>IsGranted</strong>仅仅返回true或者false（也有Async版本）。如果你只是检查一个权限然后抛出一个如上所示的异常，那么你可以使用 <strong>Authorize</strong>方法：</p>
<pre class=" language-C#"><code class="language-C#">public void CreateUser(CreateOrUpdateUserInput input)
{
    PermissionChecker.Authorize("Administration.UserManagement.CreateUser");

    //如果一个用户没有"Administration.UserManagement.CreateUser" 权限，那么ta不能到达该点。
}
</code></pre>
<p>因为授权一般在应用层实现，所以<strong>ApplicationService</strong>基类注入并定义了PermissionChecker属性。这样，权限检查者不需要在应用服务类中注入就可以使用了。</p>
<h4 id="Razor视图"><a href="#Razor视图" class="headerlink" title="Razor视图"></a>Razor视图</h4><p>视图基类定义了IsGranted方法来检查当前用户是否具有权限。因此，我们可以有条件地渲染该视图。例子：</p>
<pre class=" language-C#"><code class="language-C#">@if (IsGranted("Administration.UserManagement.CreateUser"))
{
    <button id="CreateNewUserButton" class="btn btn-primary"><i class="fa fa-plus"></i> @L("CreateNewUser")</button>
}
</code></pre>
<h4 id="客户端（Javascript）"><a href="#客户端（Javascript）" class="headerlink" title="客户端（Javascript）"></a>客户端（Javascript）</h4><p>在客户端，我们可以使用定义在<strong>abp.auth</strong>命名空间下的API。在大多数情况，我们需要检查当前的用户是否具有特定的权限（使用权限名字）。例子：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>auth<span class="token punctuation">.</span><span class="token function">hasPermission</span><span class="token punctuation">(</span><span class="token string">'Administration.UserManagement.CreateUser'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>你也可以使用<strong>abp.auth.grantedPermissions</strong>来获得所有授权的权限或者使用 <strong>abp.auth.allPermissions</strong>来获取所有应用中可用的权限名。</p>
<p>注意：自ABP 0.7.8版本开始，<strong>将javascript端的abp.auth.hasPermission更名为abp.auth.isGranted。hasPermission已经过时了。在新的项目中不要使用abp.auth.hasPermission</strong>。</p>
<p><img src="/jiayueshe/jiayueshe.github/Users\Jiang\AppData\Roaming\Typora\typora-user-images\image-20210321205113812.png" alt="image-20210321205113812"></p>
<h1 id="ABP理论学习之功能管理"><a href="#ABP理论学习之功能管理" class="headerlink" title="ABP理论学习之功能管理"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPFeatures.html">ABP理论学习之功能管理</a></h1><hr>
<h2 id="本篇目录-20"><a href="#本篇目录-20" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPFeatures.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPFeatures.html#funcType">功能类型</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPFeatures.html#defineFunc">定义功能</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPFeatures.html#checkFunc">检查功能</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPFeatures.html#manager">功能管理者</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPFeatures.html#edition">版本说明</a></strong></li>
</ul>
<h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍###"></a>介绍###</h3><p>大多数的<strong>Saas</strong>(多租户)应用都有不同 <strong>功能</strong>的 <strong>版本</strong>（包）。因此，他们可以给租户（客户）提供不同的 <strong>价格和功能选项</strong>。</p>
<p>ABP提供了<strong>功能系统</strong>使得这个更简单。我们可以 <strong>定义</strong>功能，然后检查某个功能是否对一个租户 <strong>开启</strong>了，最后将功能系统 <strong>集成</strong>到其他的ABP概念中（如权限和菜单）。</p>
<blockquote>
<h4 id="关于IFeatureValueStore"><a href="#关于IFeatureValueStore" class="headerlink" title="关于IFeatureValueStore"></a>关于IFeatureValueStore</h4><p>功能系统使用了<strong>IFeatureValueStore</strong>来获得功能的值。虽然你可以用自己的方式实现该接口，但是它已经完全实现在了 <strong>module-zero</strong>项目中。如果没有实现该接口，那么默认会使用NullFeatureValueStore对所有的功能返回null（此时使用默认的功能值）。</p>
</blockquote>
<h3 id="功能类型"><a href="#功能类型" class="headerlink" title="功能类型###"></a>功能类型###</h3><p>有两种基本功能类型。</p>
<h4 id="布尔功能"><a href="#布尔功能" class="headerlink" title="布尔功能"></a>布尔功能</h4><p>可以是”true”或”false”。这种类型的功能（对于一个版本或者一个租户）可能是<strong>开启的</strong>或者 <strong>关闭的</strong>。</p>
<h4 id="值功能"><a href="#值功能" class="headerlink" title="值功能"></a>值功能</h4><p>可以是<strong>任意值</strong>。虽然它是以字符串存储和检索的，但是数值也可以轻松地存储为字符串。</p>
<p>比如，我们的应用程序可能是一个任务管理应用，我们可能在一个月内对于创建任务会有限制。假如说我们有两个不同的版本：一个版本每个月允许创建1000个任务，但是另一个每个月允许创建5000个任务。因此，这个功能应该存储为值，而不是简单的true或false。</p>
<h3 id="定义功能"><a href="#定义功能" class="headerlink" title="定义功能###"></a>定义功能###</h3><p>在检查功能之前应该先定义功能。一个模块可以通过从<strong>FeatureProvider</strong>类派生来定义自己的功能。这里有一个定义了3个功能的非常简单的功能提供者：</p>
<pre class=" language-c#"><code class="language-c#">public class AppFeatureProvider : FeatureProvider
{
    public override void SetFeatures(IFeatureDefinitionContext context)
    {
        var sampleBooleanFeature = context.Create("SampleBooleanFeature", defaultValue: "false");
        sampleBooleanFeature.CreateChildFeature("SampleNumericFeature", defaultValue: "10");
        context.Create("SampleSelectionFeature", defaultValue: "B");
    }
}
</code></pre>
<p>创建功能提供者之后，我们应该在模块的PreInitialize方法中注册，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Features.Providers.Add<AppFeatureProvider>();
</code></pre>
<h4 id="基本功能属性"><a href="#基本功能属性" class="headerlink" title="基本功能属性"></a>基本功能属性</h4><p>一个功能的定义至少要求两个属性：</p>
<ul>
<li><strong>Name：</strong>识别该功能唯一的名字（字符串）。</li>
<li>**DefaultValue:**默认值。当我们需要该功能的值时会用到该属性，而且对于当前的租户不可用。</li>
</ul>
<p>上面的代码样例中，我们定义了一个名为”SampleBooleanFeature”布尔功能，它的默认值是”false”（不可用）。我们也定义了两个值功能（SampleNumericFeature定义为SampleBooleanFeature的孩子）。</p>
<p>提示：为功能名称创建一个常量字符串，然后在任何地方使用时会防止拼写失误。</p>
<h4 id="其他功能属性"><a href="#其他功能属性" class="headerlink" title="其他功能属性"></a>其他功能属性</h4><p>虽然对于ABP来说一个唯一的名称和默认值属性已经足够了，但是对于细节的控制还有许多其他的功能属性。</p>
<ul>
<li><strong>Scope：</strong>FeatureScope枚举值之一。它可以是<strong>Edition</strong>（如果只为版本级别设置该功能）， <strong>Tenant</strong>（如果只为租户级别设置该功能），或者 <strong>All</strong>(如果为版本和租户都可以设置该功能，这种情况下，租户的设置会覆盖版本的设置)。默认值是All。</li>
<li>**DisplayName:**给用户显示该功能名称的本地化字符串。</li>
<li><strong>Description：</strong>给用户显示该功能细节描述的本地化字符串。</li>
<li>**InputType:**该功能的UI输入类型。</li>
<li>**Attributes:**任意的自定义键值对字典，可以和该功能关联起来。</li>
</ul>
<p>让我们看一下该功能的细节定义：</p>
<pre class=" language-C#"><code class="language-C#">public class AppFeatureProvider : FeatureProvider
{
    public override void SetFeatures(IFeatureDefinitionContext context)
    {
        var sampleBooleanFeature = context.Create(
            AppFeatures.SampleBooleanFeature,
            defaultValue: "false",
            displayName: L("Sample boolean feature"),
            inputType: new CheckboxInputType()
            );

        sampleBooleanFeature.CreateChildFeature(
            AppFeatures.SampleNumericFeature,
            defaultValue: "10",
            displayName: L("Sample numeric feature"),
            inputType: new SingleLineStringInputType(new NumericValueValidator(1, 1000000))
            );

        context.Create(
            AppFeatures.SampleSelectionFeature,
            defaultValue: "B",
            displayName: L("Sample selection feature"),
            inputType: new ComboboxInputType(
                new StaticLocalizableComboboxItemSource(
                    new LocalizableComboboxItem("A", L("Selection A")),
                    new LocalizableComboboxItem("B", L("Selection B")),
                    new LocalizableComboboxItem("C", L("Selection C"))
                    )
                )
            );
    }

    private static ILocalizableString L(string name)
    {
        return new LocalizableString(name, AbpZeroTemplateConsts.LocalizationSourceName);
    }
}
</code></pre>
<p>注意：ABP没有使用这里的InputType。当为功能创建输入时，应用程序会使用它们。ABP只是提供了这些选项使得它更容易。</p>
<h4 id="功能层次"><a href="#功能层次" class="headerlink" title="功能层次"></a>功能层次</h4><p>正如样例功能提供者所示，一个功能可以有<strong>子功能</strong>。一个父母功能一般定义为 <strong>布尔</strong>功能。只有父母功能可用时，孩子功能才可用。ABP不强制这样做，但是建议这样做。</p>
<h3 id="检查功能"><a href="#检查功能" class="headerlink" title="检查功能###"></a>检查功能###</h3><h4 id="使用RequireFeature特性"><a href="#使用RequireFeature特性" class="headerlink" title="使用RequireFeature特性"></a>使用RequireFeature特性</h4><p>我们可以为方法或类使用<strong>RequiredFeature</strong>特性，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">[RequiresFeature("ExportToExcel")]
public async Task<FileDto> GetReportToExcel(...)
{
    ...
}
</code></pre>
<p>该方法只有在”ExportToExcel”功能对<strong>当前租户</strong>开启时才会执行（当前租户从IAbpSession中获得）。如果没有开启该功能，那么就会自动抛出 <strong>AbpAuthorizationException</strong>。</p>
<p>当然，RequiresFeature特性应该用于<strong>布尔类型功能</strong>。否则，你会得到异常。</p>
<p><strong>RequiresFeature特性注意点</strong><br> ABP对于功能检查使用了强大的动态方法拦截（interception）。因此，为方法使用RequiresFeature特性时有一些限制条件：</p>
<ul>
<li>不能用于私有方法。</li>
<li>不能用于静态方法。</li>
<li>不能用于非注入类的方法（我们必须使用DI）。</li>
</ul>
<p>此外，</p>
<ul>
<li>如果该方法是通过一个<strong>接口</strong>（如应用服务通过接口调用）调用的，那么我们可以将它用于任何  <strong>public</strong>的方法。</li>
<li>如果一个方法直接从类的引用调用（如MVC或Web API控制器），那么它应该是<strong>virtual</strong>的。</li>
<li>如果一个方法是<strong>protected</strong>，那么该方法应该是 <strong>virtual</strong>。</li>
</ul>
<h4 id="使用IFeatureChecker"><a href="#使用IFeatureChecker" class="headerlink" title="使用IFeatureChecker"></a>使用IFeatureChecker</h4><p>我们可以注入并使用IFeatureChecker来手动检查一个功能（对于应用服务，MVC和Web API控制器，它会自动注入而且直接可以使用）。</p>
<p><strong>IsEnabled</strong></p>
<p>用于简单地检查给定的功能是否开启。例子：</p>
<pre class=" language-C#"><code class="language-C#">public async Task<FileDto> GetReportToExcel(...)
{
    if (await FeatureChecker.IsEnabledAsync("ExportToExcel"))
    {
        throw new AbpAuthorizationException("You don't have this feature: ExportToExcel");
    }
    
    ...
}
</code></pre>
<p>IsEnabledAsync和其他方法都有同步版本。</p>
<p>当然，IsEnabled方法应该用于<strong>布尔类型功能</strong>。否则可能会抛异常。</p>
<p>如果你只想检查一个功能，然后抛出例子中的异常，那么你只需要使用<strong>CheckEnabled</strong>方法就行了。</p>
<p><strong>GetValue</strong></p>
<p>用于获得值类型功能的当前值，例子：</p>
<pre class=" language-C#"><code class="language-C#">var createdTaskCountInThisMonth = GetCreatedTaskCountInThisMonth();
if (createdTaskCountInThisMonth >= FeatureChecker.GetValue("MaxTaskCreationLimitPerMonth").To<int>())
{
    throw new AbpAuthorizationException("You exceed task creation limit for this month, sorry :(");
}
</code></pre>
<p>FeatureChecker方法也有对于特定租户的重载，不仅仅只对于当前的租户。</p>
<h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><p>在客户端，我们使用<strong>abp.features</strong>命名空间来获得该功能的当前值。</p>
<p><strong>isEnabled</strong></p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> isEnabled <span class="token operator">=</span> abp<span class="token punctuation">.</span>features<span class="token punctuation">.</span><span class="token function">isEnabled</span><span class="token punctuation">(</span><span class="token string">'SampleBooleanFeature'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>getValue</strong></p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> value <span class="token operator">=</span> abp<span class="token punctuation">.</span>features<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token string">'SampleNumericFeature'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="功能管理者"><a href="#功能管理者" class="headerlink" title="功能管理者###"></a>功能管理者###</h3><p>如果需要定义功能，可以注入并使用<strong>IFeatureManager</strong>。</p>
<h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明###"></a>版本说明###</h3><p>ABP没有内置的版本系统，因为这么个系统要求数据库（存储版本，版本功能，租户-版本映射等等）。因此，版本系统实现在了module-zero中了。使用它你可以轻松地拥有一个版本系统，要不然你可以自己实现。</p>
<h1 id="ABP理论学习之审计日志"><a href="#ABP理论学习之审计日志" class="headerlink" title="ABP理论学习之审计日志"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuditLog.html">ABP理论学习之审计日志</a></h1><hr>
<h2 id="本篇目录-21"><a href="#本篇目录-21" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#config">配置</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#attribute">通过特性开启/关闭</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#notes">注意</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPAuditLog.html#sample">我项目中的例子</a></strong></li>
</ul>
<hr>
<h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>维基百科说： “审计跟踪（也叫审计日志）是与安全相关的按照时间顺序的记录，记录集或者记录源，它们提供了活动序列的文档证据，这些活动序列可以在任何时间影响一个特定的操作，步骤或其他”。</p>
</blockquote>
<p>ABP提供了一个基础设施，它可以自动记录所有和应用程序交互的日志。它可以记录具有调用者信息和参数的方法调用。</p>
<p>一般地，要保存的字段是：相关的<strong>租户Id</strong>，调用者的<strong>用户Id</strong>，调用的 <strong>服务名称</strong>（调用方法的类名），调用的<strong>方法名</strong> ， 执行<strong>方法名</strong>（序列化成Json） ， <strong>执行时间</strong> ， 执行<strong>时长</strong>（单位毫秒），客户端<strong>IP地址</strong> ，客户端<strong>计算机名称</strong>和<strong>异常</strong>（抛出异常的情况下）。</p>
<p>有了这些信息，我们不仅知道谁进行了该操作，而且可以测量应用的<strong>性能</strong>以及观察抛出的异常。甚至，你可以获得应用使用情况的<strong>统计数据（statistics）</strong>。</p>
<p>审计系统使用**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPSession.html">IAbpSession</a>**来获得当前的UserId和TenantId。</p>
<blockquote>
<h4 id="关于-IAuditingStore"><a href="#关于-IAuditingStore" class="headerlink" title="关于 IAuditingStore"></a>关于 IAuditingStore</h4><p>审计系统使用了IAuditingStore来存储信息。虽然你可以用你自己的方式来实现该接口，但是它已经完全实现在<strong>module-zero</strong>项目中。如果你没有实现该接口，那么默认会使用SimpleLogAuditingStore，并且它会将审计信息记录到日志中（log）。</p>
</blockquote>
<h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p>要配置审计，可以在模块的PreInitialize方法中使用<strong>Configuration.Auditing</strong>属性。审计是<strong>默认开启的</strong>。可以像下面那样关闭它：</p>
<pre class=" language-C#"><code class="language-C#">public class MyModule : AbpModule
{
    public override void PreInitialize()
    {
        Configuration.Auditing.IsEnabled = false;
    }

    //...
}
</code></pre>
<p>这儿是审计配置属性的列表：</p>
<ul>
<li><p><strong>IsEnabled</strong>:用于完全开启或关闭审计系统。默认为true。</p>
</li>
<li><p><strong>IsEnabledForAnonymousUsers</strong>:如果此值为true,那么没有登录到系统的用户的审计日志也会保存。默认为false。</p>
</li>
<li><p>MvcControllers</p>
<p>:用于为ASP.NET MVC控制器配置审计。</p>
<ul>
<li><strong>IsEnabled</strong>:用于为MVC控制器开启或关闭审计。默认为true</li>
<li><strong>IsEnabledForChildActions</strong>:用于为子MVC action开启或关闭审计。默认为false。</li>
</ul>
</li>
<li><p><strong>Selectors</strong>:用于选择其他的类保存审计日志。</p>
</li>
</ul>
<p>可以看到，对于MVC控制器的审计是单独配置的，因为它用到了不同的技术。</p>
<p><strong>Selectors</strong>是选择其他的类型来保存审计日志的谓词列表。一个选择器有一个唯一的名字和一个谓词。这个列表中唯一的默认选择器用于选择<strong>应用服务类</strong>。它是如下定义的：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Auditing.Selectors.Add(
    new NamedTypeSelector(
        "Abp.ApplicationServices",
        type => typeof (IApplicationService).IsAssignableFrom(type)
    )
);
</code></pre>
<p>你可以将你的选择器添加到模块的PreInitialize方法中。而且，如果你不喜欢为应用服务保存审计日志，那么你可以通过名称移除选择器。那就是为什么要有一个唯一名称的原因（使用简单的linq找出该选择器，然后可以移除它）。</p>
<h3 id="通过特性开启-关闭"><a href="#通过特性开启-关闭" class="headerlink" title="通过特性开启/关闭"></a>通过特性开启/关闭</h3><p>虽然可以通过配置选择审计类，但是也可以为一个单独的类或方法使用<strong>Audited</strong>和 <strong>DisableAuditing</strong>特性。举个例子：</p>
<pre class=" language-C#"><code class="language-C#">[Audited]
public class MyClass
{
    public void MyMethod1(int a)
    {
        //...
    }

    [DisableAuditing]
    public void MyMethod2(string b)
    {
        //...
    }

    public void MyMethod3(int a, int b)
    {
        //...
    }
}
</code></pre>
<p>除了MyMethod2方法之外，MyClass的所有方法都参与审计了，因为MyMethod2显式关闭了。审计特性可以用于想要参与审计的方法保存审计日志。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>为了保存审计日志，方法必须是<strong>public</strong>的。私有的和受保护的方法会被忽略。</li>
<li>如果方法是通过类的引用调用的，那么该方法必须是<strong>virtual</strong>的。因为ABP使用了动态代理和拦截，所以需要满足该条件。如果使用了接口（比如注入IPersonService接口使用PersonService类）注入，就不必满足“virtual”的条件了。对于MVC控制器的action不一定要满足，它们可以不是“virtual”的。</li>
</ul>
<h3 id="我项目中的例子"><a href="#我项目中的例子" class="headerlink" title="我项目中的例子"></a>我项目中的例子</h3><p>下面的代码是点击登录按钮提交表单数据的action方法：</p>
<pre class=" language-C#"><code class="language-C#">[HttpPost]
[UnitOfWork]
[DisableAuditing]
public virtual async Task<JsonResult> Login(LoginViewModel loginModel, string returnUrl = "")
{
    CheckModelState();

    _unitOfWorkManager.Current.DisableFilter(AbpDataFilters.MayHaveTenant);
    var loginResult = await GetLoginResultAsync(
        loginModel.UsernameOrEmailAddress,
        loginModel.Password,
        loginModel.TenancyName
        );
    await SignInAsync(loginResult.User, loginResult.Identity, loginModel.RememberMe);

    if (string.IsNullOrWhiteSpace(returnUrl))
    {
        returnUrl = Request.ApplicationPath;
    }
    return Json(new MvcAjaxResponse { TargetUrl = returnUrl });
}
</code></pre>
<p>下面的截图是数据库中的审计日志信息，大家可以看到今天还没有数据，最晚的数据是2015-12-18的数据：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151221133123781-741090354.png" alt="img"></p>
<p>登录系统之后，依然没有记录审计日志，下面统一截图。</p>
<p>下面我将上面的代码的特性**[DisableAuditing]**去掉，再次登录系统，可以看到有了审计记录，截图如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151221133942234-1080323149.png" alt="img"></p>
<p>分别按序号解释一下：</p>
<ol>
<li>首次到达登录页面；</li>
<li>登录成功，到达系统首页Index;</li>
<li>去掉**[DisableAuditing]**特性后，到达登陆页面；</li>
<li>将数据post提交到Login方法，记录了审计日志，包含各种登录参数；</li>
<li>登录成功，返回系统首页Index。</li>
</ol>
<p>从我的例子可以很明显地看出，默认情况下，ABP会自动记录所有的控制器，除非你给它加上**[DisableAuditing]**特性，否则，始终会记录审计日志。</p>
<h1 id="分布式服务层"><a href="#分布式服务层" class="headerlink" title="分布式服务层"></a>分布式服务层</h1><hr>
<h2 id="本篇目录-22"><a href="#本篇目录-22" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#intro">介绍</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#base">AbpApiController基类</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#localization">本地化</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#auditLogging">审计日志</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#authorization">授权</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#uow">工作单元</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPWebAPI.html#others">其他</a></strong></li>
</ul>
</li>
</ul>
<h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍###"></a>介绍###</h3><p>ABP通过<strong>Abp.Web.Api</strong>Nuget包集成了 <strong>ASP.NET Web API</strong>控制器。你可以像以往创建Asp.Net Web API控制器那样创建Web API控制器。依赖注入对于有规律的ApiController（其实就是继承自AbpApiController的控制器）是有效的。</p>
<p>但是你应该从<strong>AbpApiController</strong>派生控制器，它提供了许多有用的东西，并且更好地集成到了ABP中。</p>
<h3 id="AbpApiController基类"><a href="#AbpApiController基类" class="headerlink" title="AbpApiController基类###"></a>AbpApiController基类###</h3><p>下面是一个派生于AbpApiController的简单api控制器：</p>
<pre class=" language-C#"><code class="language-C#">public class UsersController : AbpApiController
{
        
}
</code></pre>
<h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>AbpApiController定义了<strong>L</strong>方法使得本地化更为简单。例子：</p>
<pre class=" language-C#"><code class="language-C#">public class UsersController : AbpApiController
{
    public UsersController()
    {
        LocalizationSourceName = "MySourceName";
    }

    public UserDto Get(long id)
    {
        var helloWorldText = L("HelloWorld");

        //...
    }
}
</code></pre>
<p>要使L方法生效，必须设置<strong>LocalizationSourceName</strong>。你可以在自己的api控制器基类中设置而不用在每个api控制器中都重复设置。</p>
<h4 id="审计日志"><a href="#审计日志" class="headerlink" title="审计日志"></a>审计日志</h4><p>审计日志不会为api控制器自动记录。如果你要为api控制器记录日志的话，应该在控制器或者它的action方法上声明<strong>Audited</strong>特性。请查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPAuditLog.html">审计日志</a>**获取更多信息。</p>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>你可以为api控制器或者action方法使用<strong>AbpApiAuthorize</strong>特性来阻止未授权的用户使用控制器和action方法。例子：</p>
<pre class=" language-C#"><code class="language-C#">public class UsersController : AbpApiController
{
    [AbpApiAuthorize("MyPermissionName")]
    public UserDto Get(long id)
    {
        //...
    }
}
</code></pre>
<p>AbpApiController也定义了检查权限的<strong>IsGranted方法</strong>作为快捷方式。请查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPAuthorization.html">授权</a>**一节获取更多信息。</p>
<h4 id="工作单元-2"><a href="#工作单元-2" class="headerlink" title="工作单元"></a>工作单元</h4><p>Web API的action方法默认不是工作单元。例如，如果你需要在action方法中打开数据库连接，就需要像下面那样声明<strong>UnitOfWork</strong>特性：</p>
<pre class=" language-C#"><code class="language-C#">public class UsersController : AbpApiController
{
    private readonly IRepository<User, long> _userRepository;

    public UsersController(IRepository<User, long> userRepository)
    {
        _userRepository = userRepository;
    }

    [UnitOfWork]
    public virtual List<UserDto> Users(string filter)
    {
        var users = _userRepository
            .GetAll()
            .Where(u => u.UserName.StartsWith(filter))
            .ToList();

        //...
    }
}
</code></pre>
<p>这里我们声明了<strong>UnitOfWork</strong>特性。因为仓储的 <strong>GetAll()**方法返回了 **IQueryable</strong>，而当它使用 <strong>ToList()**方法（由于IQueryable的延迟执行）时需要一个打开的数据库连接，所以这里需要声明该特性。注意该action方法应该声明为</strong>virtual**（否则拦截无法工作）。</p>
<p>请查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPUnitofWork.html">工作单元</a>**获取更多。</p>
<h4 id="其他-4"><a href="#其他-4" class="headerlink" title="其他"></a>其他</h4><p>你还可以使用预注入的 <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPSession.html">AbpSession</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPEventBus.html">EventBus</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ModuleZeroPermissonManagement.html">PermissionManager</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ModuleZeroPermissonManagement.html">PermissionChecker</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPSettingManagement.html#getSetting">SettingManager</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPFeatures.html#manager">FeatureManager</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPFeatures.html#checkFunc">FeatureChecker</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPLocalization.html#text">LocalizationManager</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPLogging.html">Logger</a></strong>, **<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPUnitofWork.html#uow">CurrentUnitOfWork</a>**等基属性以及更多。</p>
<h1 id="动态Web-API层"><a href="#动态Web-API层" class="headerlink" title="动态Web API层"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html">动态Web API层</a></h1><h2 id="本篇目录-23"><a href="#本篇目录-23" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#build">构建动态Web API控制器</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#ForAll">ForAll 方法</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#OverrideForAll">重写ForAll 方法</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#httpVerbs">Http动词</a></strong></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#proxy">动态Javascript代理</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#ajax">Ajax参数</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#single">单一服务脚本</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#angular">Angular支持</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#Durandal">Durandal支持</a></strong></li>
<li>**<a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#wrap">返回结果封装</a>**【2016/3/28 更新】</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#paramBinding">关于参数绑定</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#FromUri">FromUri和FromBody特性</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html#DTOs">DTOs vs 原始类型</a></strong></li>
</ul>
</li>
</ul>
<h3 id="构建动态Web-API控制器"><a href="#构建动态Web-API控制器" class="headerlink" title="构建动态Web API控制器"></a>构建动态Web API控制器</h3><p>ABP可以自动地为应用层生成<strong>Web API 层</strong>。比如说我们有一个应用层如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public interface ITaskAppService : IApplicationService
{
    GetTasksOutput GetTasks(GetTasksInput input);
    void UpdateTask(UpdateTaskInput input);
    void CreateTask(CreateTaskInput input);
}
</code></pre>
<p>我们想把这个服务作为Web API控制器暴露给客户端。ABP只需要一行配置就可以为该应用服务创建一个Web API控制器：</p>
<pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder.For<ITaskAppService>("tasksystem/task").Build();
</code></pre>
<p>OK了！在地址为**’/api/services/tasksystem/task’**的地方就创建了一个API控制器，现在客户端可以使用该应用服务的所有方法。这个配置应该在模块的Initlize方法中完成。</p>
<p>我们使用一个API控制器封装的<strong>ITaskAppService</strong>是一个应用服务。使用API控制器对应用服务进行封装不是强制的，但是这是传统推荐的方式。 <strong>“tasksystem/task”**一个具有随机命名空间的API控制器的名字。你应该至少定义一级的命名空间，但是你也可以定义更深层次的命名空间，比如 <em>“myCompany/myApplication/myNamespace1/myNamespace2/myServiceName”*。 *</em>‘/api/services’**是所有动态生成的Web API控制器的前缀。因此，该API控制器的地址将会是这个样子的 <em>‘/api/services/tasksystem/task’*，而GetTasks方法的地址将会是 *’/api/services/tasksystem/task/getTasks’*。因为在javascript中惯例遵循 *</em>camelCase</strong>规则，所以方法名都转成了camelCase格式。</p>
<h4 id="ForAll-方法"><a href="#ForAll-方法" class="headerlink" title="ForAll 方法"></a>ForAll 方法</h4><p>在应用服务层可能会有很多的应用服务，如果要为这些应用服务都构建API控制器的话，一个一个地构建简直是费时费力的事情。没关系，ABP中的DynamicApiControllerBuilder提供了一个为所有应用服务构建Web API控制器的方法，这样我们只需要调用一次就行了。例如：</p>
<pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder
    .ForAll<IApplicationService>(Assembly.GetAssembly(typeof(SimpleTaskSystemApplicationModule)), "tasksystem")
    .Build();
</code></pre>
<p>ForAll方法是接收接口类型的泛型方法。第一个参数是一个程序集，该程序集中含有派生自给定接口的类。最后一个参数是服务前缀的命名空间。比如说我们在给定的程序集中有ITaskAppService和IPersonAppService，对于这个配置的话，服务地址将会是 ‘/api/services/tasksystem/task’ 和  ‘/api/services/tasksystem/person’。计算服务名称的方法是：移除Service或者AppService后缀，以及I前缀（对于接口来说）。此外，服务名称会转成camel  Case(驼峰命名)的格式。如果你不喜欢这种转换，那么使用’WithServiceName’来决定服务发名称。此外，还有一个过滤服务的Where方法。除了个别应用服务之外，这个方法在你为其他所有的应用服务构建API控制器时很有用。</p>
<h4 id="重写ForAll-方法"><a href="#重写ForAll-方法" class="headerlink" title="重写ForAll 方法"></a>重写ForAll 方法</h4><p>在ForAll方法之后我们可以重写配置。例如：</p>
<pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder
    .ForAll<IApplicationService>(Assembly.GetAssembly(typeof(SimpleTaskSystemApplicationModule)), "tasksystem")
    .Build();

DynamicApiControllerBuilder
    .For<ITaskAppService>("tasksystem/task")
    .ForMethod("CreateTask").DontCreateAction()
    .Build();
</code></pre>
<p>在上面的代码中，我们为一个程序集中所有的应用服务构建了动态的Web API控制器。然后又为一个应用服务（ITaskAppService）重写了配置，目的是忽略该应用服务中的CreateTask方法。</p>
<h4 id="Http动词"><a href="#Http动词" class="headerlink" title="Http动词"></a>Http动词</h4><p>默认情况下，创建的方法都只能<strong>POST</strong>请求。我们也可以使用不同的方法来改变这种行为。<br> <strong>WithVerb方法</strong></p>
<p>我们可以为一个方法使用WithVerb，像下面那样：</p>
<pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder
    .For<ITaskAppService>("tasksystem/task")
    .ForMethod("GetTasks").WithVerb(HttpVerb.Get)
    .Build();
</code></pre>
<p><strong>HTTP特性</strong></p>
<p>我们可以在应用服务的接口的方法上添加HttpGet，HttpPost等特性。</p>
<pre class=" language-C#"><code class="language-C#">public interface ITaskAppService : IApplicationService
{
    [HttpGet]
    GetTasksOutput GetTasks(GetTasksInput input);

    [HttpPut]
    void UpdateTask(UpdateTaskInput input);

    [HttpPost]
    void CreateTask(CreateTaskInput input);
}
</code></pre>
<p>使用这些特性之前，应该在项目中添加**<a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Core">Microsoft.AspNet.WebApi.Core</a>**Nuget包的引用。</p>
<p><strong>命名规范</strong></p>
<p>不用为每个方法都声明HTTP动词，你可以使用如下所示的<strong>WithConventionalVerbs</strong>方法：</p>
<pre class=" language-C#"><code class="language-C#">DynamicApiControllerBuilder
    .ForAll<IApplicationService>(Assembly.GetAssembly(typeof(SimpleTaskSystemApplicationModule)), "tasksystem")
    .WithConventionalVerbs()
    .Build();
</code></pre>
<p>在这种情况下，Http动词会由方法名的前缀决定：</p>
<ul>
<li><strong>Get</strong>：方法名以Get开头。</li>
<li><strong>Put</strong>：方法名以Put或Update开头。</li>
<li><strong>Delete</strong>：方法名以Delete或Remove开头。</li>
<li><strong>Post</strong>：方法名以Post或Create开头。</li>
<li>其他情况，Post是HTTP动词的默认值</li>
</ul>
<p>我们可以通过对特定的方法使用WithVerb方法或者HTTP特性来覆盖上述惯例。</p>
<h3 id="动态Javascript代理"><a href="#动态Javascript代理" class="headerlink" title="动态Javascript代理"></a>动态Javascript代理</h3><p>在Javascript中，可以经由Ajax使用动态创建的web api控制器。ABP通过为动态的web  api控制器创建动态的Javascript代理简化了这个。因此，可以在Javascript中像调用一个function一样来调用一个动态的web api 控制器action：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>services<span class="token punctuation">.</span>tasksystem<span class="token punctuation">.</span>task<span class="token punctuation">.</span><span class="token function">getTasks</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    state<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//use result.tasks here...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Javascript代理是动态创建的。使用之前应该将下面动态的脚本包括在页面上。</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/api/AbpServiceProxies/GetAll<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre>
<p>服务方法返回了promise（查看**<a target="_blank" rel="noopener" href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</a>**）。可以在返回的promise后面继续注册done，fail，then等回调函数。服务方法内部使用了abp.ajax。如果需要的话，它们会处理错误并显示错误信息。</p>
<h4 id="Ajax参数"><a href="#Ajax参数" class="headerlink" title="Ajax参数"></a>Ajax参数</h4><p>你可以把一个自定义的ajax参数作为第二个参数传给代理方法。</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>services<span class="token punctuation">.</span>tasksystem<span class="token punctuation">.</span>task<span class="token punctuation">.</span><span class="token function">createTask</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    assignedPersonId<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
    description<span class="token punctuation">:</span> <span class="token string">'a new task description...'</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//override jQuery's ajax parameters</span>
    <span class="token keyword">async</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    timeout<span class="token punctuation">:</span> <span class="token number">30000</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">'successfully created a task!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>**<a target="_blank" rel="noopener" href="http://api.jquery.com/jQuery.ajax/">jQuery.ajax</a>**的所有参数在这里都是有效的。</p>
<h4 id="单一服务脚本"><a href="#单一服务脚本" class="headerlink" title="单一服务脚本"></a>单一服务脚本</h4><p>‘/api/AbpServiceProxies/GetAll’会在一个文件中生成所有的服务代理。使用’/api/AbpServiceProxies/Get?name=serviceName’也可以生成一个单独的服务代理，只需要在页面中包括下面的代码：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/api/AbpServiceProxies/Get?name<span class="token punctuation">=</span>tasksystem/task<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre>
<h4 id="Angular支持"><a href="#Angular支持" class="headerlink" title="Angular支持"></a>Angular支持</h4><p>ABP可以将动态的API控制器暴露给AngularJs服务。思考下面的例子：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    angular<span class="token punctuation">.</span><span class="token function">module</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">controller</span><span class="token punctuation">(</span><span class="token string">'TaskListController'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
        <span class="token string">'$scope'</span><span class="token punctuation">,</span> <span class="token string">'abp.services.tasksystem.task'</span><span class="token punctuation">,</span>
        <span class="token keyword">function</span><span class="token punctuation">(</span>$scope<span class="token punctuation">,</span> taskService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
            vm<span class="token punctuation">.</span>tasks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            taskService<span class="token punctuation">.</span><span class="token function">getTasks</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                state<span class="token punctuation">:</span> <span class="token number">0</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                vm<span class="token punctuation">.</span>tasks <span class="token operator">=</span> result<span class="token punctuation">.</span>tasks<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>我们可以使用服务的名字（包含命名空间）注射一个服务。然后，可以作为正常的Javascript函数调用它的function。注意，我们注册到了success句柄上（而不是done），因为它就像在angular的$http服务中。ABP使用AngularJs的$http服务。如果</p>
<p>你想要传递$http配置，可以作为服务方法的最后一个参数传递一个配置对象。</p>
<p>要使用自动生成的服务，应该在页面中包含需要的脚本：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>~/Abp/Framework/scripts/libs/angularjs/abp.ng.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>~/api/AbpServiceProxies/GetAll?type<span class="token punctuation">=</span>angular<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre>
<h4 id="Durandal支持"><a href="#Durandal支持" class="headerlink" title="Durandal支持"></a>Durandal支持</h4><p>ABP可以在一个**<a target="_blank" rel="noopener" href="http://durandaljs.com/">Durandal</a>**应用的模块中注入服务代理。看下面的viewmodel:</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'service!tasksystem/task'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token keyword">function</span> <span class="token punctuation">(</span>taskService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//taskService can be used here</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>ABP配置Durandal(实际上是Require.js)来理解这个’service!’前缀，然后注入合适的javascript服务代理。</p>
<h4 id="返回结果封装"><a href="#返回结果封装" class="headerlink" title="返回结果封装"></a>返回结果封装</h4><p>ABP通过 <strong>AjaxResponse</strong>封装了动态Web  API的action的返回值。查看《**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#Ajax">Ajax文档</a>**》获取更多关于封装的信息。你可以为每个应用服务或者每个方法开启或者禁用封装。看下面这个应用服务的例子：</p>
<pre class=" language-C#"><code class="language-C#">public interface ITestAppService : IApplicationService
{
    [DontWrapResult]
    DoItOutput DoIt(DoItInput input);
}
</code></pre>
<p>这里我们为DoIt方法禁用了封装。这个特性应该为接口声明而不是实现类。</p>
<p>如果你想更好地控制客户端的返回值，那么不封装返回的结果可能是很有用的。特别地，当使用不能和ABP标准的AjaxResponse协作的<strong>第三方客户端库</strong>时，可能需要禁用封装。这种情况下，你要自己处理异常。</p>
<p>注意：动态javascript代理可以理解返回的结果是否封装和运行正常。</p>
<h3 id="关于参数绑定"><a href="#关于参数绑定" class="headerlink" title="关于参数绑定"></a>关于参数绑定</h3><p>ABP在运行时创建了API控制器。因此，ASP.NET Web API的**<a target="_blank" rel="noopener" href="http://www.asp.net/web-api/overview/formats-and-model-binding/parameter-binding-in-aspnet-web-api">模型和参数绑定</a>**可以用于绑定模型和参数。</p>
<h4 id="FromUri和FromBody特性"><a href="#FromUri和FromBody特性" class="headerlink" title="FromUri和FromBody特性"></a>FromUri和FromBody特性</h4><p>为了在绑定时进行高级控制，可以在服务接口上使用FromUri和FromBody特性。</p>
<h4 id="DTOs-vs原始类型"><a href="#DTOs-vs原始类型" class="headerlink" title="DTOs vs原始类型"></a>DTOs vs原始类型</h4><p>我们强烈建议为应用服务和Web  API控制器的方法使用DTO作为参数类型，但是你也可以使用原始类型（如string，int，bool或者可空的类型如int?，bool?）作为参数类型。虽然可以在应用服务中使用不止一个参数，但是最好用一个复杂的类型将多个参数整合起来，否则客户端就不会生成动态代理服务。在日志记录中就会看到如下图所示的错误：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160107164212918-348748482.png" alt="img"></p>
<h2 id="ABP理论学习之OData集成-新增"><a href="#ABP理论学习之OData集成-新增" class="headerlink" title="ABP理论学习之OData集成(新增)"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html">ABP理论学习之OData集成(新增)</a></h2><hr>
<h2 id="本篇目录-24"><a href="#本篇目录-24" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#setup">安装</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#controller">创建控制器</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#example">例子</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPODataIntegration.html#sample">样例项目</a></strong></li>
</ul>
<h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍###"></a>介绍###</h3><blockquote>
<p><strong>OData</strong>在**<a target="_blank" rel="noopener" href="http://www.odata.org/">其官网</a><strong>的定义是：<br> 允许以一种 **简单且标准</strong>的方式创建和使用<strong>可查询的、可互操作的</strong>RESTful APIs。</p>
</blockquote>
<p>在ABP中也可以使用OData。**<a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Abp.Web.Api.OData">Abp.Web.Api.OData</a>** nuget包简化了它的使用。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装###"></a>安装###</h3><h4 id="安装Nuget包"><a href="#安装Nuget包" class="headerlink" title="安装Nuget包"></a>安装Nuget包</h4><p>我们应该首先将Abp.Web.Api.OData nuget包安装到WebApi项目中：<br> <code>Install-Package Abp.Web.Api.OData</code></p>
<h4 id="设置模块依赖"><a href="#设置模块依赖" class="headerlink" title="设置模块依赖"></a>设置模块依赖</h4><p>给我们的WebApi项目设置的模块设置AbpWebApiODataModule的依赖。例如：</p>
<pre class=" language-C#"><code class="language-C#">[DependsOn(typeof(AbpWebApiODataModule))]
public class MyProjectWebApiModule : AbpModule
{
    ...
}
</code></pre>
<p>请查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPModuleSystem.html">模块系统</a>**来理解模块依赖。</p>
<h4 id="配置实体类"><a href="#配置实体类" class="headerlink" title="配置实体类"></a>配置实体类</h4><p>OData要求声明那些可以用作OData资源的实体。我们应该在WebApi项目模块的PreInitialize方法中处理这件事，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">[DependsOn(typeof(AbpWebApiODataModule))]
public class MyProjectWebApiModule : AbpModule
{
    public override void PreInitialize()
    {
        var builder = Configuration.Modules.AbpWebApiOData().ODataModelBuilder;

        //Configure your entities here...
        builder.EntitySet<Person>("People");
    }

    ...
}
</code></pre>
<p>这里，我们得到了ODataModelBuilder的引用并设置了Person实体。类似地，你可以使用EntitySet来添加其他的实体。这里格外需要注意的是，括号里面的字符串People是指的控制器的前缀，这里我的控制器是PeopleController，当然你也可以设置为Persons等，我这里只是想说明要填的字符串更数据库的表名和自己定义的实体名没有关系。</p>
<p>查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ODataAspNetWebAPI.html">使用ASP.NET Web API 2创建OData v4 终结点</a>**获取更多关于builder的信息。</p>
<h3 id="创建控制器"><a href="#创建控制器" class="headerlink" title="创建控制器###"></a>创建控制器###</h3><p>Abp.Web.Api.OData nuget包 包括了<strong>AbpODataEntityController</strong>基类（它扩展了标准的ODataController），这样就可以更容易地创建控制器了。下面是一个为Person实体创建一个OData终端（endpoint）的例子：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonsController : AbpODataEntityController<Person>
{
    public PersonsController(IRepository<Person> repository)
        : base(repository)
    {
    }
}
</code></pre>
<p>就是这么简单，AbpODataEntityController的所有方法都是<strong>virtual</strong>声明的。这意味着你可以重写 ** Get, Post, Put, Patch, Delete**和其他的action方法以及添加自己的逻辑。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子###"></a>例子###</h3><p>下面看一个例子：<br> 我的应用的端口是：localhost:61759。这里我只演示一些基本的东西，因为OData是一个标准的协议，所以你可以在网上轻松地找到更高级的例子。</p>
<p>数据库中People表的数据如下图：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160121153817328-1398128883.png" alt="img"></p>
<h4 id="获取实体列表"><a href="#获取实体列表" class="headerlink" title="获取实体列表"></a>获取实体列表</h4><p>这里我来获取所有的Person:</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122174713984-423656261.png" alt="img"></p>
<h4 id="获取单个实体"><a href="#获取单个实体" class="headerlink" title="获取单个实体"></a>获取单个实体</h4><p>获取Id=2的那个Person的数据：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122174940953-254380383.png" alt="img"></p>
<h4 id="获取具有导航属性的单个实体"><a href="#获取具有导航属性的单个实体" class="headerlink" title="获取具有导航属性的单个实体"></a>获取具有导航属性的单个实体</h4><p>修改实体类的定义，重新定义如下：</p>
<p>Person实体的定义：</p>
<pre class=" language-C#"><code class="language-C#">namespace ABPMVCTest.Entities
{
    [Table("Persons")]
    public class Person:Entity
    {
        public virtual string Name { get; set; }
        public virtual bool Gender { get; set; }
        public virtual string UserName { get; set; }
        public virtual ICollection<Car> Cars { get; set; }

        public Person()
        {
        }

        public Person(string name, params Car[] cars)
        {
            Name = name;
            if (cars!=null)
            {
                Cars=new Collection<Car>();
                foreach (var car in cars)
                {
                    car.Person = this;
                    Cars.Add(car);
                }
            }
        }
    }
}
</code></pre>
<p>Car实体的定义：</p>
<pre class=" language-C#"><code class="language-C#">namespace ABPMVCTest.Entities
{
    [Table("Cars")]
    public class Car:Entity
    {
        public virtual Person Person{ get; set; }
        public virtual int PersonId { get; set; }
        public virtual CarBrand Brand { get; set; }
        public virtual int Price{ get; set; }

        public Car()
        {
        }

        public Car(CarBrand brand, int price)
        {
            Brand = brand;
            Price = price;
        }
    }
}
</code></pre>
<p>CarBrand（汽车品牌）实体的定义：</p>
<pre class=" language-C#"><code class="language-C#">namespace ABPMVCTest.Entities
{
    public enum CarBrand
    {
        Jeep,
        Buick,
        Lincoln,
        Kia,
        LandRover
    }
}
</code></pre>
<p>修改实体类之后，接下来给数据库填充数据。新增了3个人，Id分别是7，6，9；在Car表中分别给这三个人分配了汽车，如下图：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122183825828-1873120117.png" alt="img"></p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122183922390-1076933148.png" alt="img"></p>
<p>比如获取小明（Id=7）的数据，它具有一个Car导航属性，该属性代表此人的汽车对象：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160122183715906-1511156500.png" alt="img"></p>
<h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><p>下面将数据库的数据进行修改，如下图：<br> Persons表的数据：<br> <img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123182609422-9276329.png" alt="img"></p>
<p>Cars表的数据：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123180543562-2039656379.png" alt="img"></p>
<p>这里演示一个更高级的查询，包括过滤，排序和获取前2个结果，借助postman来演示：<br> 查询条件是：Id&lt;4，OrderBy UserName Desc，取前两条数据</p>
<p><strong>请求</strong><br> <code>http://localhost:61759/odata/People?$filter=Id lt 4&amp;$orderby=UserName&amp;$top=2</code></p>
<p><strong>响应</strong></p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123183405843-395742129.png" alt="img"></p>
<p>可以看到，只过滤出来了小红和小刚的数据。</p>
<p>OData支持分页，排序，过滤，投影以及更多。<br> 请查看**<a target="_blank" rel="noopener" href="http://www.odata.org/">官方文档</a>**获取更多信息。</p>
<h4 id="创建一个新实体"><a href="#创建一个新实体" class="headerlink" title="创建一个新实体"></a>创建一个新实体</h4><p>在这个例子中，我们将创建一个新的Person，借助postman，很容易发送一个post请求。</p>
<p><strong>请求</strong><br> 注意这里的报文头为Content-Type:”application/json”<br> <img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123185400562-1792073851.png" alt="img"></p>
<p><strong>响应</strong><br> <img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123185407437-1943751319.png" alt="img"></p>
<p>去数据库查看一下，发现已经多了一条刚才post的数据：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160123185642172-1269839742.png" alt="img"></p>
<p>当然了，我们也可以更新和删除实体，这里就不再做演示了，大家自行练习。</p>
<h4 id="获取元数据【MetaData】"><a href="#获取元数据【MetaData】" class="headerlink" title="获取元数据【MetaData】"></a>获取元数据【MetaData】</h4><p>我们还可以获得实体的元数据，如下所示：</p>
<p><strong>请求</strong></p>
<pre><code>http://localhost:61759/odata/$metadata
</code></pre>
<p><strong>响应</strong></p>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">edmx:</span>Edmx</span> <span class="token attr-name">Version</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>edmx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://docs.oasis-open.org/odata/ns/edmx<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">edmx:</span>DataServices</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Schema</span> <span class="token attr-name">Namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ABPMVCTest.Entities<span class="token punctuation">"</span></span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://docs.oasis-open.org/odata/ns/edm<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EntityType</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Key</span><span class="token punctuation">></span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PropertyRef</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
        
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Key</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.String<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Gender<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Boolean<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UserName<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.String<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Int32<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>NavigationProperty</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Cars<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Collection(ABPMVCTest.Entities.Car)<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
      
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EntityType</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EntityType</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Car<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Key</span><span class="token punctuation">></span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>PropertyRef</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
        
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Key</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>PersonId<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Int32<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Brand<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ABPMVCTest.Entities.CarBrand<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Price<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Int32<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Property</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Edm.Int32<span class="token punctuation">"</span></span> <span class="token attr-name">Nullable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>NavigationProperty</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Person<span class="token punctuation">"</span></span> <span class="token attr-name">Type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ABPMVCTest.Entities.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ReferentialConstraint</span> <span class="token attr-name">Property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>PersonId<span class="token punctuation">"</span></span> <span class="token attr-name">ReferencedProperty</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
        
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>NavigationProperty</span><span class="token punctuation">></span></span>
      
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EntityType</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EnumType</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CarBrand<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Jeep<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Buick<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Lincoln<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Kia<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Member</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>LandRover<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
      
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EnumType</span><span class="token punctuation">></span></span>
    
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Schema</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Schema</span> <span class="token attr-name">Namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Default<span class="token punctuation">"</span></span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://docs.oasis-open.org/odata/ns/edm<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EntityContainer</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EntitySet</span> <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>People<span class="token punctuation">"</span></span> <span class="token attr-name">EntityType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ABPMVCTest.Entities.Person<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
      
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EntityContainer</span><span class="token punctuation">></span></span>
    
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Schema</span><span class="token punctuation">></span></span>
  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">edmx:</span>DataServices</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">edmx:</span>Edmx</span><span class="token punctuation">></span></span>
</code></pre>
<h3 id="样例项目"><a href="#样例项目" class="headerlink" title="样例项目###"></a>样例项目###</h3><p>你可以在Github上获得样例代码，**<a href="https://github.com/aspnetboilerplate/sample-odata">点击查看</a>**</p>
<h1 id="展现层"><a href="#展现层" class="headerlink" title="展现层"></a>展现层</h1><hr>
<h2 id="本篇目录-25"><a href="#本篇目录-25" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMVCController.html#intro">介绍</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMVCController.html#base">AbpController基类</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMVCController.html#localization">本地化</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMVCController.html#exceptionHandling">异常处理</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMVCController.html#wrapping">响应结果的包装</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMVCController.html#auditLogging">审计日志</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMVCController.html#authorization">授权</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMVCController.html#uow">工作单元</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPMVCController.html#others">其他</a></strong></li>
</ul>
</li>
</ul>
<h3 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍###"></a>介绍###</h3><p>ABP通过Abp.Web.Mvc nuget包集成了<strong>ASP.NET MVC控制器</strong>。你可以像常规那样创建MVC控制器。依赖注入对于常规的MVC控制器可以正确地工作。</p>
<p>但是，你应该让你的控制器继承于<strong>AbpController</strong>，该基类控制器提供了很多有用的东西，而且更好地集成到了ABP中。</p>
<h3 id="AbpController基类"><a href="#AbpController基类" class="headerlink" title="AbpController基类"></a>AbpController基类</h3><p>下面是一个派生自AbpController的简单控制器：</p>
<pre class=" language-C#"><code class="language-C#">public class HomeController : AbpController
{
    public ActionResult Index()
    {
        return View();
    }
}
</code></pre>
<h4 id="本地化-1"><a href="#本地化-1" class="headerlink" title="本地化"></a>本地化</h4><p>AbpController中定义了<strong>L</strong>方法使得本地化更加简单。例子：</p>
<pre class=" language-C#"><code class="language-C#">public class HomeController : AbpController
{
    public HomeController()
    {
        LocalizationSourceName = "MySourceName";
    }
    
    public ActionResult Index()
    {
        var helloWorldText = L("HelloWorld");
        
        return View();
    }
}
</code></pre>
<p>要使L方法生效，必须设置LocalizationSourceName。你可以在自己的控制器基类中设置而不用在每个控制器中都重复设置。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>异常都是自动处理的，自动记录日志，而且会给客户端返回一个合适的响应。</p>
<p>查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPException.html">异常处理</a>**博客获得更多信息。</p>
<h4 id="响应结果的包装"><a href="#响应结果的包装" class="headerlink" title="响应结果的包装"></a>响应结果的包装</h4><p>如果返回类型是<strong>JsonResult</strong>（或者异步action方法的Task），ABP会默认封装该action方法的响应结果。你可以通过为控制器或者actions使用<strong>WrapResult和DontWrapResult</strong>特性来更改默认的封装（注意：以前有园友经常问到这个）。</p>
<p>查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#Ajax">ajax</a>**博客获取更多信息。</p>
<h4 id="审计日志-1"><a href="#审计日志-1" class="headerlink" title="审计日志"></a>审计日志</h4><p>如果你从AbpController派生控制器的话，那么审计日志会自动记录。</p>
<p>查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPAuditLog.html">审计日志</a>**博客获取更多信息。</p>
<h4 id="授权-1"><a href="#授权-1" class="headerlink" title="授权"></a>授权</h4><p>你可以为控制器或者action方法使用<strong>AbpMvcAuthorize</strong>特性来阻止未授权的用户使用控制器和action方法。例子：</p>
<pre class=" language-C#"><code class="language-C#">public class HomeController : AbpController
{
    [AbpMvcAuthorize("MyPermissionName")]
    public ActionResult Index()
    {
        return View();
    }
}
</code></pre>
<p>AbpApiController也定义了检查权限的<strong>IsGranted方法</strong>作为快捷方式。请查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPAuthorization.html">授权</a>**一节获取更多信息。</p>
<h4 id="工作单元-3"><a href="#工作单元-3" class="headerlink" title="工作单元"></a>工作单元</h4><p>MVC的action方法默认不是工作单元。例如，如果你需要在action方法中打开数据库连接，就需要像下面那样声明<strong>UnitOfWork</strong>特性：</p>
<pre class=" language-C#"><code class="language-C#">public class HomeController : AbpController
{
    private readonly IRepository<User, long> _userRepository;

    public HomeController(IRepository<User, long> userRepository)
    {
        _userRepository = userRepository;
    }

    [UnitOfWork]
    public virtual ActionResult Users(string filter)
    {
        var users = _userRepository
            .GetAll()
            .Where(u => u.UserName.StartsWith(filter))
            .ToList();

        return View(users);
    }
}
</code></pre>
<p>这里我们声明了<strong>UnitOfWork</strong>特性。因为仓储的 <strong>GetAll()**方法返回了 **IQueryable</strong>，而当它使用 <strong>ToList()**方法（由于IQueryable的延迟执行）时需要一个打开的数据库连接，所以这里需要声明该特性。注意该action方法应该声明为</strong>virtual**（否则拦截无法工作）。</p>
<p>请查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPUnitofWork.html">工作单元</a>**获取更多。</p>
<h4 id="其他-5"><a href="#其他-5" class="headerlink" title="其他"></a>其他</h4><p>你还可以使用预注入的 <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPSession.html">AbpSession</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPEventBus.html">EventBus</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ModuleZeroPermissonManagement.html">PermissionManager</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ModuleZeroPermissonManagement.html">PermissionChecker</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPSettingManagement.html#getSetting">SettingManager</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPFeatures.html#manager">FeatureManager</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPFeatures.html#checkFunc">FeatureChecker</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPLocalization.html#text">LocalizationManager</a></strong>, <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPLogging.html">Logger</a></strong>, **<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPUnitofWork.html#uow">CurrentUnitOfWork</a>**等基属性以及更多。</p>
<p>要了解以上属性，请查阅其他相应博客。</p>
<h1 id="ABP理论学习之Javascript-API-理论完结篇"><a href="#ABP理论学习之Javascript-API-理论完结篇" class="headerlink" title="ABP理论学习之Javascript API(理论完结篇)"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html">ABP理论学习之Javascript API(理论完结篇)</a></h1><h1 id="-1"><a href="#-1" class="headerlink" title="         "></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html">         </a></h1><p><strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPTheory.html">返回总目录</a></strong></p>
<hr>
<h2 id="本篇目录-26"><a href="#本篇目录-26" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#Ajax">Ajax</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#Notification">Notification</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#Message">Message</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#block">UI block和busy</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#eventBus">事件总线</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#Logging">Logging</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#other">其他工具功能</a></strong></li>
</ul>
<hr>
<blockquote>
<h4 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h4><p>不知不觉，我们送走了2015，同时迎来了2016。我相信，每一个人，都会在过去的一年有所失，但我更相信，我们所得到的更多。过去的就过去了，不要再计较了，但要从过去的各种不顺中汲取经验，这样，在全新的2016年里继续留下2015年遗憾的概率才会大大降低！祝大家在新的一年里，代码bug越来越少！</p>
<p>本来给这个**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPTheory.html">ABP理论学习系列</a>**的预算时间是2016年春节前完成，当时还恐怕完成不了任务，现在没想到在2016年元旦假期就完成了。原本计划两个月的完成的任务，结果用了不到一个月就完成了，我的效率还是蛮高的嘛！不过，这多亏了各位园友的鼓励和支持，才让我有了坚持下去的动力，在此谢谢了！</p>
<p>ABP理论学习完了，基本上的东西也就懂了！接下来，就需要好好地实战一把了！虽然我写了**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPPracticeContent.html">一步一步使用ABP搭建正式项目教程</a><strong>，但是那完全是让新手能迅速使用ABP搭建的项目跑起来。接下来，我会写一个</strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/category/773197.html">ABP项目进阶教程</a>**系列，教大家使用ABP框架搭建一个完整的例子，实战的同时，讲解一些难点的基本原理，也希望热爱ABP的园友们多多关注。</p>
<p>先声明一下，这篇文章稍长，希望大家多点耐心。</p>
</blockquote>
<hr>
<p>ABP提供了一些对象和函数集，使得了javascript开发简单且标准化。</p>
<p>下面，我们一一讲解ABP中的这些javascript API。</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax##"></a>Ajax##</h2><p>使用Ajax调用服务端的服务，并返回服务端响应的内容。因为ABP对于Ajax调用会返回一个标准的响应，因此，建议使用该方法处理标准的返回值。</p>
<h3 id="Ajax操作的问题"><a href="#Ajax操作的问题" class="headerlink" title="Ajax操作的问题"></a>Ajax操作的问题</h3><p>现代应用程序频繁使用Ajax调用，特别是在SPA中，它几乎是和服务器交互的唯一方式。</p>
<p>Ajax调用包含了许多重复性的步骤：</p>
<p>一般来讲，在客户端javascript代码应该提供一个URL，data是否提供是可选的，以及选择一个执行Ajax调用的方法（Post,Get…）。必须等待然后才能处理返回的值。当向服务端发起调用时可能会发生错误（一般是网络错误）。服务端也可能发生错误，服务器可能发送了一个具有错误信息的失败响应。客户端代码应该处理服务端响应的错误，并选择性地通知用户（可能展示一个error对话框）。如果没有错误，且服务器返回了数据，客户端也必须处理。此外，一般它会阻塞一些（或者整个）屏幕区域，并展示一个繁忙的指示标志，直到Ajax操作结束。</p>
<p>服务端应该接收请求，然后执行服务端的代码，捕获任何异常并返回一个有效的响应给客户端。在发生错误的情况下，它可以有选择地发送一个错误消息给客户端；成功时，它可以返回数据给客户端。</p>
<h3 id="ABP采用的方式"><a href="#ABP采用的方式" class="headerlink" title="ABP采用的方式"></a>ABP采用的方式</h3><p>ABP通过使用<strong>abp.ajax</strong>函数封装Ajax的调用，自动化了这其中的一些步骤。一个ajax调用的例子如下：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> newPerson <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">'Dougles Adams'</span><span class="token punctuation">,</span>
    age<span class="token punctuation">:</span> <span class="token number">42</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

abp<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    url<span class="token punctuation">:</span> <span class="token string">'/People/SavePerson'</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>newPerson<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">'created new person with id = '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>personId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>abp.ajax以一个对象作为接收<strong>选项</strong>。你可以传递任何在jQuery的$.ajax方法中有效的任何参数。这里有一些 <strong>默认</strong>的值：dataType是‘json’，type是‘POST’，contentType是‘application/json’（因此，在发送到服务器之前，我们可以调用JSON.stringify将javascript对象转成JSON字符串）。你可以通过将选项传给abp.ajax重写默认值。</p>
<p>abp.ajax返回了**<a target="_blank" rel="noopener" href="http://api.jquery.com/deferred.promise/">promise</a><strong>。因此，你可以写done,fail,then等处理函数。上面的例子中，我们向 **PeopleController的SavePerson</strong>的action发送了简单的Ajax请求。在 <strong>done</strong>处理函数中，我们获得了新添加的person的数据库Id，而且展示了一个成功的通知。让我们看一下该Ajax请求的 <strong>MVC控制器</strong>：</p>
<pre class=" language-C#"><code class="language-C#">public class PeopleController : AbpController
{
    [HttpPost]
    public JsonResult SavePerson(SavePersonModel person)
    {
        //TODO:将新的person保存到数据库，并返回该person的Id
        return Json(new {PersonId = 42});
    }
}
</code></pre>
<p><strong>SavePersonModel</strong>包含了Name和Age属性。SavePerson标记有 <strong>HttpPost</strong>特性，因为abp.ajax默认的方法是POST。这里通过返回一个匿名的对象简化了方法的实现。</p>
<p>这个看上去简单明了，但是ABP背后处理了许多重要的事情。让我们深入细节看一下：</p>
<h3 id="Ajax返回的消息"><a href="#Ajax返回的消息" class="headerlink" title="Ajax返回的消息"></a>Ajax返回的消息</h3><p>虽然我们直接返回了一个具有PersonId=2的对象，但是ABP会使用一个<strong>MVCAjaxResponse</strong>对象封装了它。实际的Ajax响应是像下面那样的：</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token property">"result"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"personId"</span><span class="token operator">:</span> <span class="token number">42</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"error"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>
  <span class="token property">"targetUrl"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>
  <span class="token property">"unAuthorizedRequest"</span><span class="token operator">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre>
<p>这里，所有的属性都是camelCase的（因为在javascript中这是惯例），即使在服务端代码中是PascalCased的。下面解释一下所有的字段：</p>
<ul>
<li><strong>success</strong>:一个布尔值，表示操作的成功状态。如果是true，abp.ajax会解析该promise，并调用 <strong>done</strong>处理函数。如果是false（如果在方法调用中发生了异常），它会调用 <strong>fail</strong>处理函数并使用abp.message.error函数展示一个 <strong>error</strong>消息。</li>
<li><strong>result</strong>：控制器的action返回的实际值。如果success是true，而且服务器发送了一个返回值，它才有效。</li>
<li><strong>error</strong>：如果success是false，那么该字段是一个包含了 <strong>message</strong>和 <strong>detail</strong>字段的对象。</li>
<li><strong>targetUrl</strong>:这为服务器提供了一种重定向客户端到其他Url的可能性。</li>
<li><strong>unAuthorizedRequest</strong>:这为服务器提供了通知客户端该操作没有授权或者用户没有认证的可能性。如果该值是true，那么abp.ajax会 <strong>重新加载</strong>当前的页面。</li>
</ul>
<p>通过从<strong>AbpController</strong>类中派生就可以将返回值转换成一个封装的Ajax响应。 <strong>abp.ajax</strong>会识别并计算该响应。因此，它们成对工作。如果没有发生错误的话，那么abp.ajax的done处理函数会获得控制器返回的实际值（一个具有personId属性的对象）。</p>
<p>当从<strong>AbpApiController</strong>类派生时，也会存在相同的机制。</p>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>正如上面描述的，ABP会处理服务器中的所有异常，并返回一个具有错误信息的对象，如下所示：</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"targetUrl"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>
  <span class="token property">"result"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>
  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token property">"error"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"An internal error occured during your request!"</span><span class="token punctuation">,</span>
    <span class="token property">"details"</span><span class="token operator">:</span> <span class="token string">"..."</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"unAuthorizedRequest"</span><span class="token operator">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre>
<p>可以看到，success是false，result是null。abp.ajax处理该对象，而且使用abp.message.error函数展示一个错误信息给用户。如果你的服务端代码抛出了一个<strong>UserFriendlyException</strong>类型的异常，它会直接给用户显示异常信息。否则，它会隐藏实际的错误（将错误写到日志中），并展示一个标准的“服务器内部错误…”信息给用户。所有的这些都是ABP自动处理的。</p>
<h3 id="动态Web-API-层"><a href="#动态Web-API-层" class="headerlink" title="动态Web API 层"></a>动态Web API 层</h3><p>虽然ABP提供了一种使得调用Ajax很简单的机制，但是在真实世界的应用中，为每个Ajax调用编写javascript函数是很经典的，比如：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//创建一个抽象了Ajax调用的function</span>
<span class="token keyword">var</span> savePerson <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> abp<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        url<span class="token punctuation">:</span> <span class="token string">'/People/SavePerson'</span><span class="token punctuation">,</span>
        data<span class="token punctuation">:</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//创建一个新的 person</span>
<span class="token keyword">var</span> newPerson <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">'Dougles Adams'</span><span class="token punctuation">,</span>
    age<span class="token punctuation">:</span> <span class="token number">42</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//保存该person</span>
<span class="token function">savePerson</span><span class="token punctuation">(</span>newPerson<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">'created new person with id = '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>personId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>对于每个Ajax调用都写个函数是个好的做法，但是这耗时且乏味。ASP.NET为应用服务层方法提供了自动生成这些类型的函数机制。请阅读**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPDynamicWebAPI.html">《动态Web API层》</a>**</p>
<h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification##"></a>Notification##</h2><p>展示自动关闭的通知。</p>
<p>我们喜欢一些事情发生时展示一些精致的自动消失的通知，比如当保存一条记录或者问题发生时。ABP为这个定义了标准的APIs。</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">'a message text'</span><span class="token punctuation">,</span> <span class="token string">'optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'a message text'</span><span class="token punctuation">,</span> <span class="token string">'optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'a message text'</span><span class="token punctuation">,</span> <span class="token string">'optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
abp<span class="token punctuation">.</span>notify<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'a message text'</span><span class="token punctuation">,</span> <span class="token string">'optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>通知API默认是使用**<a target="_blank" rel="noopener" href="http://codeseven.github.io/toastr/demo.html">toastr</a>**库实现的。要使toastr生效，你应该引用toastr的css和javascript文件，然后再在页面中包含abp.toastr.js作为适配器。一个toastr成功通知如下所示：</p>
<p><img src="http://i.imgur.com/xjBHBtD.png" alt="img"></p>
<p>你也可以用你最喜欢的通知库中实现通知。只需要在自定义javascript文件中重写所有的函数，然后把它添加到页面中而不是abp.toastr.js（你可以检查该文件看它是否实现，这个相当简单）中。</p>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message##"></a>Message##</h2><p>给用户展示消息对话框。</p>
<p>消息API用于给用户展示消息或者获得用户的确认。</p>
<p>消息API默认是使用**<a target="_blank" rel="noopener" href="http://tristanedwards.me/sweetalert">sweetalert</a><strong>实现的。要让sweetalert生效，你应该包含它的css和javascript文件，然后再页面中添加 **abp.sweet-alert.js</strong>的引用作为适配器。</p>
<h4 id="展示消息"><a href="#展示消息" class="headerlink" title="展示消息"></a>展示消息</h4><p>例子如下：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'some info message'</span><span class="token punctuation">,</span> <span class="token string">'some optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
abp<span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">'some success message'</span><span class="token punctuation">,</span> <span class="token string">'some optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
abp<span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'some warning message'</span><span class="token punctuation">,</span> <span class="token string">'some optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
abp<span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'some error message'</span><span class="token punctuation">,</span> <span class="token string">'some optional title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>一个成功的消息如下所示：</p>
<p><img src="http://i.imgur.com/gkHdu4k.png" alt="img"></p>
<h4 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h4><p>例子如下：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">confirm</span><span class="token punctuation">(</span>
    <span class="token string">'User admin will be deleted.'</span><span class="token punctuation">,</span>
    <span class="token string">'Are you sure?'</span><span class="token punctuation">,</span>
    <span class="token keyword">function</span> <span class="token punctuation">(</span>isConfirmed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>isConfirmed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//...删除用户</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>这里的第二个参数（title）是可选的，因此，回调函数也可以是第二个参数。</p>
<p>一个确认消息的例子如下所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160111104142897-1109234390.png" alt="img"></p>
<p>ABP内部使用了Message API。比如，如果Ajax调用失败了，那么它会调用abp.message.error。</p>
<h2 id="UI-block和Busy-API"><a href="#UI-block和Busy-API" class="headerlink" title="UI block和Busy API##"></a>UI block和Busy API##</h2><p>使用一个区域（一个div，form，整个页面等）阻塞用户的输入。此外，还使得一个区域处于繁忙状态（具有一个繁忙的指示器，如‘loading…’）。</p>
<h3 id="UI-Block-API"><a href="#UI-Block-API" class="headerlink" title="UI Block API"></a>UI Block API</h3><p>该API使用一个透明的涂层（transparent overlay）来阻塞整个页面或者该页面上的一个元素。这样，用户的点击就无效了。当保存一个表单或者加载一个区域（一个div或者整个页面）时这是很有用的，比如：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//阻塞整个页面</span>
abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#MyDivElement'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//可以使用jQuery 选择器..</span>
abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token string">'#MyDivElement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//..或者直接使用选择器</span>
abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">unblock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//解除阻塞整个页面</span>
abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">unblock</span><span class="token punctuation">(</span><span class="token string">'#MyDivElement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//解除阻塞特定的元素</span>
</code></pre>
<p>UI Block API默认使用jQuery的blockUI插件实现的。要是它生效，你应该包含它的javascript文件，然后在页面中包含<strong>abp.blockUI.js</strong>作为适配器。</p>
<h3 id="UI-Busy-API"><a href="#UI-Busy-API" class="headerlink" title="UI Busy API"></a>UI Busy API</h3><p>该API用于使得某些页面或者元素处于繁忙状态。比如，你可能想阻塞一个表单，然后当提交表单至服务器时展示一个繁忙的指示器。例子：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">setBusy</span><span class="token punctuation">(</span><span class="token string">'#MyLoginForm'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">clearBusy</span><span class="token punctuation">(</span><span class="token string">'#MyLoginForm'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>样例截图：</p>
<p><img src="http://i.imgur.com/ZmAirzt.png" alt="img"></p>
<p>该参数应该是一个选择器（如‘#MyLoginForm’）或者jQuery选择器（如$(‘#MyLoginForm’)）。要使得整个页面处于繁忙状态，你可以传入null（或者’body’）作为选择器。</p>
<p>setBusy函数第二个参数接收一个promise（约定），当该约定完成时会自动清除繁忙的状态。例子：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>ui<span class="token punctuation">.</span><span class="token function">setBusy</span><span class="token punctuation">(</span>
    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#MyLoginForm'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
    abp<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>    
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>因为abp.ajax返回promise，我们可以直接将它作为promise传入。要学习惯于promise更多的东西，查看jQuery的**<a target="_blank" rel="noopener" href="http://api.jquery.com/category/deferred-object/">Deferred</a>**。</p>
<p>UI Busy API是使用**<a target="_blank" rel="noopener" href="http://fgnass.github.io/spin.js/">spin.js</a><strong>实现的。要让它生效，应该包含它的javascript文件，然后在页面中包含</strong>abp.spin.js**作为适配器。</p>
<h2 id="事件总线-1"><a href="#事件总线-1" class="headerlink" title="事件总线"></a>事件总线</h2><p>用于注册和触发客户端的全局事件。</p>
<h3 id="介绍-13"><a href="#介绍-13" class="headerlink" title="介绍"></a>介绍</h3><p><strong>Pub/sub</strong>事件模型广泛用于客户端，ABP包含了一个简单的<strong>全局事件总线</strong>来 <strong>注册</strong>并 <strong>触发事件</strong>。</p>
<h4 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h4><p>可以使用<strong>abp.event.on</strong>来注册一个全局事件。一个注册的例子：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>event<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'itemAddedToBasket'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">' is added to basket!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>第一个参数是<strong>事件的唯一名称</strong>。第二个是回调函数，当特定事件被触发时，会被调用。</p>
<p>可以使用<strong>abp.event.off</strong>方法来从一个事件中取消注册。注意：要取消注册，要提供相同的函数。因此，对于上面的例子，你应该将回调函数设置为一个变量，然后在<strong>on和off</strong>方法中使用它。</p>
<h4 id="触发事件-1"><a href="#触发事件-1" class="headerlink" title="触发事件"></a>触发事件</h4><p><strong>abp.event.trigger</strong>用于触发一个全局事件。触发一个已经注册的事件的代码如下：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>event<span class="token punctuation">.</span><span class="token function">trigger</span><span class="token punctuation">(</span><span class="token string">'itemAddedToBasket'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    id<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">,</span>
    name<span class="token punctuation">:</span> <span class="token string">'Acme Light MousePad'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>第一个参数是<strong>该事件的唯一名称</strong>。第二个是（可选的）<strong>事件参数</strong>。你可以添加任何数量的参数，并且在回调方法中获得它们。</p>
<h2 id="Logging"><a href="#Logging" class="headerlink" title="Logging##"></a>Logging##</h2><p>在客户端记录日志。</p>
<h3 id="Javascript-Logging-API"><a href="#Javascript-Logging-API" class="headerlink" title="Javascript Logging API"></a>Javascript Logging API</h3><p>当你想要在客户端记录一些简单的日志时，你可以使用console.log(‘…’)API，这你已经知道了。但是这种写法不是所有的浏览器都支持的，而且可能会破坏你的脚本。因此，你应该首先检查console是否可用，此外，你可能想在别的地方记录日志，甚至你想以某种级别记录日志。ABP定义了安全的日志函数：</p>
<pre><code>abp.log.debug(&#39;...&#39;);
abp.log.info(&#39;...&#39;);
abp.log.warn(&#39;...&#39;);
abp.log.error(&#39;...&#39;);
abp.log.fatal(&#39;...&#39;);
</code></pre>
<p>你可以通过设置<strong>abp.log.level</strong>为abp.log.levels之一来更改日志级别（比如，abp.log.levels.INFO没有记录调试日志）。这些函数默认将日志记录到了浏览器的控制台里了。但如果你需要的话，你也可以重写或者扩展这个行为。</p>
<h2 id="其他工具功能"><a href="#其他工具功能" class="headerlink" title="其他工具功能##"></a>其他工具功能##</h2><p>ABP提供了一些通用的工具功能。</p>
<h3 id="abp-utils-createNamespace"><a href="#abp-utils-createNamespace" class="headerlink" title="abp.utils.createNamespace"></a>abp.utils.createNamespace</h3><p>用于立即创建更深的命名空间。假设我们有一个基命名空间‘abp’，然后想要创建或者获得‘abp.utils.strings.formatting’命名空间。不需要下面这样写：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//创建或获得namespace</span>
abp<span class="token punctuation">.</span>utils <span class="token operator">=</span> abp<span class="token punctuation">.</span>utils <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>strings <span class="token operator">=</span> abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>strings <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>strings<span class="token punctuation">.</span>formatting <span class="token operator">=</span> abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>strings<span class="token punctuation">.</span>formatting <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//给该namespace添加一个function</span>
abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>strings<span class="token punctuation">.</span>formatting<span class="token punctuation">.</span>format <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>我们可以这样写：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> formatting <span class="token operator">=</span> abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span><span class="token function">createNamespace</span><span class="token punctuation">(</span>abp<span class="token punctuation">,</span> <span class="token string">'utils.strings.formatting'</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//给该namespace添加一个function</span>
formatting<span class="token punctuation">.</span>format <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>这样就简化了安全地创建深入的命名空间了。注意，第一个参数是必须存在的根命名空间。</p>
<h3 id="abp-utils-formatString"><a href="#abp-utils-formatString" class="headerlink" title="abp.utils.formatString"></a>abp.utils.formatString</h3><p>这个和C#中的string.Format()很相似。用法示例：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span><span class="token function">formatString</span><span class="token punctuation">(</span><span class="token string">'Hello {0}!'</span><span class="token punctuation">,</span> <span class="token string">'World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//str = 'Hello World!'</span>
<span class="token keyword">var</span> str <span class="token operator">=</span> abp<span class="token punctuation">.</span>utils<span class="token punctuation">.</span><span class="token function">formatString</span><span class="token punctuation">(</span><span class="token string">'{0} number is {1}.'</span><span class="token punctuation">,</span> <span class="token string">'Secret'</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//str = 'Secret number is 42'</span>
</code></pre>
<h1 id="ABP理论学习之本地化-2016第一篇"><a href="#ABP理论学习之本地化-2016第一篇" class="headerlink" title="ABP理论学习之本地化(2016第一篇)"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLocalization.html">ABP理论学习之本地化(2016第一篇)</a></h1><hr>
<h2 id="本篇目录-27"><a href="#本篇目录-27" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLocalization.html#appLang">应用语言</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLocalization.html#source">本地化资源</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLocalization.html#text">获取本地化文本</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLocalization.html#extend">扩展本地化资源</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPLocalization.html#bestPractice">最佳实践</a></strong></li>
</ul>
<h3 id="应用语言"><a href="#应用语言" class="headerlink" title="应用语言###"></a>应用语言###</h3><p>一个应用至少有一种UI语言，许多应用不止有一种语言。ABP为应用提供了一个灵活的本地化系统。</p>
<p>第一件事情就是声明支持哪些语言。这个是在模块的<strong>PreInitialize</strong>方法中完成的，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Localization.Languages.Add(new LanguageInfo("en", "English", "famfamfam-flag-england", true));
Configuration.Localization.Languages.Add(new LanguageInfo("tr", "Türkçe", "famfamfam-flag-tr"));
</code></pre>
<p>在服务端，可以先注入<strong>ILocalizationManager</strong>,然后使用它。在客户端，可以使用 <strong>abp.localization</strong>Javascript API来获得所有可使用的语言和当前的语言。famfamfam-flag-england (和tr)只是一个Css类而已，你可以根据自己的需要改变它。然后在UI上使用它来展示相关的旗帜（比如各种国旗）。</p>
<p>ABP模板使用了本地化系统给用户呈现的是一个<strong>切换语言</strong>的下拉列表。你可以创建一个模板项目然后学习一下源代码。</p>
<h3 id="本地化资源"><a href="#本地化资源" class="headerlink" title="本地化资源###"></a>本地化资源###</h3><p>本地化文本可以存储在不同的资源中。甚至你可以在相同的应用中使用不止一种语言（如果你有不止一个模块，每个模块可以定义一个单独的本地化资源）。应该为本地化资源实现<strong>ILocalizationSource</strong>接口，然后将它注册到ABP的本地化配置中。</p>
<p>每个本地化资源必须有一个<strong>唯一的资源名</strong>。 <strong>XML文件</strong>和 <strong>资源</strong>文件是预定义的本地化资源类型。</p>
<h4 id="XML文件"><a href="#XML文件" class="headerlink" title="XML文件"></a>XML文件</h4><p>本地化文本可以存储在XML文件中，XML文件的内容就像下面展示的那样：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>localizationDictionary</span> <span class="token attr-name">culture</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>texts</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TaskSystem<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Task System<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TaskList<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Task List<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>NewTask<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>New Task<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Xtasks<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{0} tasks<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CompletedTasks<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Completed tasks<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>EmailWelcomeMessage<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hi,
Welcome to Simple Task System! This is a sample
email content.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>texts</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>localizationDictionary</span><span class="token punctuation">></span></span>
</code></pre>
<p>XML文件必须是<strong>utf-8</strong>编码， <strong>culture=”en”**声明该XML文件包含了英语文本。对于文本节点，</strong>name<strong>特性用于标识一个文本。你可以使用 **value</strong>特性或者 <strong>inner text</strong>(如上面的最后一个)给本地化文本赋值。如下所示，我们为<strong>每种语言</strong>创建了一个单独的XML文件：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151231232053042-1808284103.png" alt="img"></p>
<p>这里，<strong>SimpleTaskSystem</strong>是 <strong>资源名称</strong>，SimpleTaskSystem定义了 <strong>默认的语言</strong>。当请求一个文本时，ABP会从当前语言的XML文件中获取文本（使用Thread.CurrentThread.<strong>CurrentUICulture</strong>找到当前的语言）。如果不存在当前语言的文本，就会从默认语言的XML文件中获得文本。</p>
<p><strong>注册XML本地化资源</strong></p>
<p>XML文件可以存储在文件系统中或者可以内嵌在一个程序集中。</p>
<p>对于<strong>文件系统</strong>存储的XML，我们可以注册一个XML本地化资源，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Localization.Sources.Add(
    new DictionaryBasedLocalizationSource(
        "SimpleTaskSystem",
        new XmlFileLocalizationDictionaryProvider(
            HttpContext.Current.Server.MapPath("~/Localization/SimpleTaskSystem")
            )
        )
    );
</code></pre>
<p>这个是在模块的<strong>PreInitialize</strong>事件中完成的（看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPModuleSystem.html">模块系统</a>**获取更多信息）。ABP会找到所有给定目录的XML文件并注册这些本地化资源。</p>
<p>对于<strong>内嵌的XML文件</strong>，我们应该将所有的本地化XML文件标记为内嵌的资源（选中xml文件，打开属性窗口，将生成操作的值改为‘内嵌的资源’）。然后像下面那样注册该本地化资源：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Localization.Sources.Add(
    new DictionaryBasedLocalizationSource(
        "SimpleTaskSystem",
        new XmlEmbeddedFileLocalizationDictionaryProvider(
            Assembly.GetExecutingAssembly(),
            "MyCompany.MyProject.Localization.Sources"
            )
        )
    );
</code></pre>
<p><strong>XmlEmbeddedFileLocalizationDictionaryProvider</strong>会获得包含XML文件的程序集（GetExecutingAssembly简单地指向当前的程序集）和XML文件的 <strong>命名空间</strong>（程序集名称+xml文件的文件夹层次）。</p>
<p>注意：当给内嵌的XML文件起名字时，要加上语言后缀，但是不要使用“.”，比如“MySource.ch.xml”，而要使用短号“-”，比如“MySource-en.xml”。因为当寻找资源时，“.”会造成问题。</p>
<h4 id="JSON文件"><a href="#JSON文件" class="headerlink" title="JSON文件"></a>JSON文件</h4><p>JSON文件可以用于存储本地化资源的文本。JSON本地化文件的一个简单样例如下所示：</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"culture"</span><span class="token operator">:</span> <span class="token string">"en"</span><span class="token punctuation">,</span>
  <span class="token property">"texts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"TaskSystem"</span><span class="token operator">:</span> <span class="token string">"Task system"</span><span class="token punctuation">,</span>
    <span class="token property">"Xtasks"</span><span class="token operator">:</span> <span class="token string">"{0} tasks"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>JSON文件的格式应该是unicode(utf-8)格式。<code>&quot;culture&quot;:&quot;en&quot;</code>表示该Json文件包含了英文文本。如下所示，我们为<strong>每种语言</strong>创建了一个单独的Json文件：</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/3a2186cf-3d54-4e0c-b70a-98ead158721c.png" alt="图片"></p>
<p>这里的<strong>MySourceName</strong>是资源名称， MySourceName.json定义了 <strong>默认的语言</strong>，json文件和XML文件很相似。</p>
<p><strong>注册JSON本地化资源</strong><br> Json文件可以存储在<strong>文件系统</strong>中，也可以 <strong>内嵌</strong>到一个程序集中。<br> 对于文件系统存储JSON，我们可以注册一个Json本地化资源，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Localization.Sources.Add(
    new DictionaryBasedLocalizationSource(
        "MySourceName",
        new JsonFileLocalizationDictionaryProvider(
            HttpContext.Current.Server.MapPath("~/Localization/MySourceName")
            )
        )
    );
</code></pre>
<p>这是在模块的<strong>PerInitialize</strong>事件中完成的。ABP会在给定的目录中寻找所有的Json文件，并注册到本地化资源。</p>
<p>对于<strong>内嵌的Json文件</strong>，首先我们应该将所有的本地化Json文件标记为 <strong>内嵌的资源</strong>（选中Json文件，然后打开属性窗口，更改生成操作为内嵌的资源即可）。然后我们就可以像下面那样注册本地化资源了：</p>
<pre class=" language-C#"><code class="language-C#"> Configuration.Localization.Sources.Add(
    new DictionaryBasedLocalizationSource(
        "MySourceName",
        new JsonEmbeddedFileLocalizationDictionaryProvider(
            Assembly.GetExecutingAssembly(),
            "MyCompany.MyProject.Localization.Sources"
            )
        )
    );
</code></pre>
<p><strong>JsonEmbeddedFileLocalizationDictionaryProvider</strong>需要一个包含Json文件的程序集（GetExecutingAssembly指向当前的程序集）和Json文件的命名空间（命名空间是通过程序集名称+json文件的文件夹层次计算出来的）。</p>
<p><strong>注意：</strong>当我们给json文件添加了语言后缀时，不要使用“.”标记符号，如“MySource.tr.json”，而要使用分隔符如“<strong>MySource-tr.json</strong>”，因为“.”标记符号在寻找资源时可能会发生问题。</p>
<h4 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h4><p>本地化文本也可以存储在.NET的资源文件中。我们可以为每种语言创建一个资源文件，如下所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151231234452479-171479678.png" alt="img"></p>
<p><strong>MyTexts.resx</strong>包含了默认的语言文本， MyTexts.tr.resx包含了土耳其语言的文本。当我们打开MyTexts.resx时，我们可以看到所有文本：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151231234648354-476448936.png" alt="img"></p>
<p>在这种情况下，ABP使用了.NET中内置的本地化资源管理者。你应该为该资源配置一个本地化资源：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Localization.Sources.Add(
    new ResourceFileLocalizationSource(
        "MySource",
        MyTexts.ResourceManager
        ));
</code></pre>
<p>这里，<strong>MySource</strong>是资源的 <strong>唯一名字</strong>，而且 <strong>MyTexts.ResourceManager</strong>是获取本地化文本的资源管理者的引用。这个是在模块的 <strong>Initialize</strong>事件中完成的。</p>
<h4 id="自定义资源"><a href="#自定义资源" class="headerlink" title="自定义资源"></a>自定义资源</h4><p>自定义本地化资源实现了在不同的资源中（比如数据库）存储文本。你可以直接实现<strong>ILocalizationSource</strong>接口或者从<strong>DictionaryBasedLocalizationSource</strong>类中派生可以使得实现更容易。</p>
<h3 id="获取本地化文本"><a href="#获取本地化文本" class="headerlink" title="获取本地化文本###"></a>获取本地化文本###</h3><p>当创建了资源并把它注册到ABP的本地化系统之后，文本就能轻易地本地化了。</p>
<h4 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h4><p>在服务端，我们可以注入<strong>ILocalizationManager</strong>，然后使用它的 <strong>GetString</strong>方法。</p>
<pre class=" language-C#"><code class="language-C#">var s1 = _localizationManager.GetString("SimpleTaskSystem", "NewTask");
</code></pre>
<p>GetString方法会基于<strong>当前线程的UI文化（culture）</strong>获取字符串。如果没有找到，就会返回 <strong>默认语言</strong>对应的字符串。如果任何地方都没有定义该字符串，就会默认返回使用 <strong>“[]”</strong> 包装的 <strong>给定字符串</strong>（而不是抛出异常）。这种行为是可以配置的（你可以在模块的PreInitialize中使用Configuration.Loacalization.ReturnGivenTextIfNotFound属性进行配置）。</p>
<p>记得不要重复资源的名字(运行时会报错)，你可以首先获得<strong>该资源</strong>，然后从该资源中获得字符串：</p>
<pre class=" language-C#"><code class="language-C#">var source = _localizationManager.GetSource("SimpleTaskSystem");
var s1 = source.GetString("NewTask");
</code></pre>
<p>这会返回当前语言的文本。GetString方法也有重载方法通过参数获取不同语言和格式的文本。</p>
<p>如果我们不能注入ILocalizationManager（也许在一个不能到达依赖注入系统的静态上下文中），那么可以简单地使用<strong>LocalizationHelper</strong>静态类。但是尽可能地注入并使用ILocalizationManager，因为LocalizationHelper是静态的而且静态不好测试（对于写单元测试的人来说）。</p>
<p>如果你需要在**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPApplicationService.html">应用服务</a><strong>、MVC控制器、Razor视图或者其他派生自</strong>AbpServiceBase<strong>的类中本地化，那么可以使用快捷的 **L</strong>方法。</p>
<p><strong>在MVC控制器中</strong></p>
<p>一般在MVC控制器和视图中需要本地化文本。这里有一个快捷方式，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class HomeController : SimpleTaskSystemControllerBase
{
    public ActionResult Index()
    {
        var helloWorldText = L("HelloWorld");
        return View();
    }
}
</code></pre>
<p><strong>L</strong>方法用于本地化一个字符串。当然，你必须提供一个资源名，这里的HelloWorld就是从资源中找到的。它是在控制器基类SimpleTaskSystemControllerBase(以ControllerBase为后缀的控制器)中完成的，如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public abstract class SimpleTaskSystemControllerBase : AbpController
{
    protected SimpleTaskSystemControllerBase()
    {
        LocalizationSourceName = "SimpleTaskSystem";
    }
}
</code></pre>
<p>注意L派生自<strong>AbpController</strong>。因此，你可以使用 <strong>L</strong>方法轻松地本地化文本。</p>
<p><strong>在MVC视图中</strong></p>
<p>在视图中也可以使用相同的<strong>L</strong>方法：</p>
<pre class=" language-C#"><code class="language-C#"><div>
    <form id="NewTaskForm" role="form">
        <div class="form-group">
            <label for="TaskDescription">@L("TaskDescription")</label>
            <textarea id="TaskDescription" data-bind="value: task.description" class="form-control" rows="3" placeholder="@L("EnterDescriptionHere")" required></textarea>
        </div>
        <div class="form-group">
            <label for="TaskAssignedPerson">@L("AssignTo")</label>
            <select id="TaskAssignedPerson" data-bind="options: people, optionsText: 'name', optionsValue: 'id', value: task.assignedPersonId, optionsCaption: '@L("SelectPerson")'" class="form-control"></select>
        </div>
        <button data-bind="click: saveTask" type="submit" class="btn btn-primary">@L("CreateTheTask")</button>
    </form>
</div>
</code></pre>
<p>为了能够这样使用，你应该让你的视图派生自设置了资源名的一个基类：</p>
<pre class=" language-C#"><code class="language-C#">public abstract class SimpleTaskSystemWebViewPageBase : SimpleTaskSystemWebViewPageBase<dynamic>
{

}

public abstract class SimpleTaskSystemWebViewPageBase<TModel> : AbpWebViewPage<TModel>
{
    protected SimpleTaskSystemWebViewPageBase()
    {
        LocalizationSourceName = "SimpleTaskSystem";
    }
}
</code></pre>
<p>而且要在web.config中设置这个视图基类：</p>
<pre class=" language-webconfig"><code class="language-webconfig"><pages pageBaseType="SimpleTaskSystem.Web.Views.SimpleTaskSystemWebViewPageBase">
</code></pre>
<p>当你从ABP模板创建解决方案时，对于视图和控制器的所有这些都已经准备好了。</p>
<h4 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h4><p>ABP也使得在javascript代码中使用相同的本地化文本成为了可能。首先，你应该将动态的ABP脚本添加到页面中：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/AbpScripts/GetScripts<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre>
<p>ABP在客户端会自动生成需要的javascript代码来获得本地化的文本。然后，你就可以轻松地使用javascript获得一个本地化的文本，如下所示：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> s1 <span class="token operator">=</span> abp<span class="token punctuation">.</span>localization<span class="token punctuation">.</span><span class="token function">localize</span><span class="token punctuation">(</span><span class="token string">'NewTask'</span><span class="token punctuation">,</span> <span class="token string">'SimpleTaskSystem'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>这里，NewTask是文本名，SimpleTaskSystem是资源名。记住不要重复资源名。你也可以先获得资源名，然后获得文本：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> source <span class="token operator">=</span> abp<span class="token punctuation">.</span>localization<span class="token punctuation">.</span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token string">'SimpleTaskSystem'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token function">source</span><span class="token punctuation">(</span><span class="token string">'NewTask'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>格式化参数</strong></p>
<p>本地化方法也可以有额外的格式参数，例子：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>localization<span class="token punctuation">.</span><span class="token function">localize</span><span class="token punctuation">(</span><span class="token string">'RoleDeleteWarningMessage'</span><span class="token punctuation">,</span> <span class="token string">'MySource'</span><span class="token punctuation">,</span> <span class="token string">'Admin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//如果使用上面的getSource找到了资源，就使用source作为快捷方式</span>
<span class="token function">source</span><span class="token punctuation">(</span><span class="token string">'RoleDeleteWarningMessage'</span><span class="token punctuation">,</span> <span class="token string">'Admin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>如果RoleDeleteWarningMessage = ‘Role {0} will be deleted’， 那么本地化后的文本就是’Role Admin will be deleted’。</p>
<p><strong>默认的本地化资源</strong><br> 可以设置默认的本地化资源，然后就能够不使用资源名称也可以使用<code>abp.localization.localize</code>方法了。</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>localization<span class="token punctuation">.</span>defaultSourceName <span class="token operator">=</span> <span class="token string">'SimpleTaskSystem'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> s1 <span class="token operator">=</span> abp<span class="token punctuation">.</span>localization<span class="token punctuation">.</span><span class="token function">localize</span><span class="token punctuation">(</span><span class="token string">'NewTask'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>defaultSourceName是全局的，并且一次只能用于一个资源名称。</p>
<h3 id="扩展本地化资源"><a href="#扩展本地化资源" class="headerlink" title="扩展本地化资源###"></a>扩展本地化资源###</h3><p>假设我们已经有一个定义了自己本地化资源的模块。我们可能需要更改它的本地化文本，或者添加一些新的文本或者翻译为其他的语言。如何解决这个呢？ABP允许扩展一个本地化资源，当前只对XML文件有效（实际上任何本地化资源都实现了IDictionaryBasedLocalizationSource接口）。</p>
<p>ABP也定义了一些本地化资源。比如，<strong>Abp.Web</strong>nuget包定义了一个叫做 <strong>AbpWeb</strong>的本地化资源作为内嵌XML文件：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201601/577014-20160101131030401-240846594.png" alt="img"></p>
<p>默认的（英语）XML文件像下面这个样子（这里只展示一部分文本）：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>localizationDictionary</span> <span class="token attr-name">culture</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>texts</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>InternalServerError<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>An internal error occurred during your request!<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ValidationError<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Your request is not valid!<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    ...
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>texts</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>localizationDictionary</span><span class="token punctuation">></span></span>
</code></pre>
<p>要扩展AbpWeb资源，我们可以定义XML文件。假设我们只想更改<strong>InternalServerError</strong>文本，我们就可以像下面那样定义一个XML文件：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>localizationDictionary</span> <span class="token attr-name">culture</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>texts</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>InternalServerError<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Sorry :( It seems there is a problem. Let us to solve it and please try again later.<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>texts</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>localizationDictionary</span><span class="token punctuation">></span></span>
</code></pre>
<p>然后我们在模块的PreInitialize方法中注册它：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Localization.Sources.Extensions.Add(
    new LocalizationSourceExtensionInfo("AbpWeb",
        new XmlFileLocalizationDictionaryProvider(
            HttpContext.Current.Server.MapPath("~/Localization/AbpWebExtensions")
            )
        )
    );
</code></pre>
<p>如果我们想创建内嵌的资源XML文件（上面有讲），那么可以使用XmlEmbeddedFileLocalizationDictionaryProvider。ABP使用XML文件合并了基本的本地化资源。我们也可以添加新的语言文件。</p>
<p><strong>注意：</strong>我们可以使用Json文件来扩展XMl文件，反过来也一样。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论###"></a>结论###</h3><p>ABP提供了使用不同资源进行本地化的功能，也提供了在服务端和客户端代码中使用相同的本地化文本的基础设施。</p>
<p>XML文件，Json文件和资源文件都有自己的长处和弱势，我们建议使用XML文件或者Json文件代替资源文件。因为：</p>
<ul>
<li>XML/JSON文件更容易编辑，扩展或者移植。</li>
<li>当获取本地化文本时，XML/JSON文件要求string类型的key，而不是像资源文件需要编译时的属性。这个可以被认为是缺点，但是以后更改资源时相对容易一些。甚至我们将本地化不需要更改就可以移动到数据库或者使用了该本地化资源的代码中了（Module-zero已经实现了创建一个<strong>基于数据库和每个租户的</strong>本地化资源，查看《**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ModuleZeroLanguageManagement.html">Module Zero之语言管理</a>**》）。</li>
</ul>
<p>此外，如果你使用XML或者Json，建议不要按照name进行排序文本，而要按照创建日期进行排序。这样，当别人要将文本翻译为其他语言时，ta就可以轻松地看到哪一个文本是新添加的。</p>
<p>通过实现<strong>ILocalizationSource</strong>接口，你也可以创建你自己的本地化资源并集成到ABP中。 <strong>Module-zero</strong>实现了一个 <strong>基于数据库</strong>和 <strong>各租户</strong>的本地化资源。 <strong><a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ModuleZeroLanguageManagement.html">点击查看文档</a></strong></p>
<h1 id="ABP理论学习之导航-Navigation"><a href="#ABP理论学习之导航-Navigation" class="headerlink" title="ABP理论学习之导航(Navigation)"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNavigation.html">ABP理论学习之导航(Navigation)</a></h1><hr>
<h2 id="本篇目录-28"><a href="#本篇目录-28" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNavigation.html#create">创建菜单</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNavigation.html#register">注册导航提供者</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNavigation.html#show">展示菜单</a></strong></li>
</ul>
<p>每一个web应用在页面之间都有一些要导航的菜单。ABP提供了公用的基础设施来创建菜单并将菜单展示给用户。</p>
<h3 id="创建菜单"><a href="#创建菜单" class="headerlink" title="创建菜单###"></a>创建菜单###</h3><p>一个应用可能由不同的模块组成，每个模块可能有它自己的菜单项。想要定义菜单项，我们需要创建一个派生自<strong>NavigationProvider</strong>的类。</p>
<p>假设我们有一个如下所示的主菜单：</p>
<ul>
<li>Tasks</li>
<li>Reports</li>
<li>Administration<ul>
<li>User Management</li>
<li>Role Management</li>
</ul>
</li>
</ul>
<p>这里，Administration菜单项有两个<strong>子菜单项</strong>。创建这么一个菜单的导航提供者类如下所示：</p>
<pre class=" language-C#"><code class="language-C#">   public class SimpleTaskSystemNavigationProvider : NavigationProvider
{
    public override void SetNavigation(INavigationProviderContext context)
    {
        context.Manager.MainMenu
            .AddItem(
                new MenuItemDefinition(
                    "Tasks",
                    new LocalizableString("Tasks", "SimpleTaskSystem"),
                    url: "/Tasks",
                    icon: "fa fa-tasks"
                    )
            ).AddItem(
                new MenuItemDefinition(
                    "Reports",
                    new LocalizableString("Reports", "SimpleTaskSystem"),
                    url: "/Reports",
                    icon: "fa fa-bar-chart"
                    )
            ).AddItem(
                new MenuItemDefinition(
                    "Administration",
                    new LocalizableString("Administration", "SimpleTaskSystem"),
                    icon: "fa fa-cogs"
                    ).AddItem(
                        new MenuItemDefinition(
                            "UserManagement",
                            new LocalizableString("UserManagement", "SimpleTaskSystem"),
                            url: "/Administration/Users",
                            icon: "fa fa-users",
                            requiredPermissionName: "SimpleTaskSystem.Permissions.UserManagement"
                            )
                    ).AddItem(
                        new MenuItemDefinition(
                            "RoleManagement",
                            new LocalizableString("RoleManagement", "SimpleTaskSystem"),
                            url: "/Administration/Roles",
                            icon: "fa fa-star",
                            requiredPermissionName: "SimpleTaskSystem.Permissions.RoleManagement"
                            )
                    )
            );
    }
}
</code></pre>
<p>一个MenuItemDefinition一般有一个唯一的<strong>name</strong>，一个本地化的<strong>displayName</strong>，一个 <strong>url</strong>和一个 <strong>icon</strong>。而且，</p>
<ul>
<li>一个菜单项可能要求一个特定的用户具有展示该菜单的权限。此时可以使用<strong>requiredPermissionName</strong>属性。</li>
<li>一个菜单项可能依赖于一个功能。此时可以使用<strong>featureDependency</strong>。</li>
<li>一个菜单项可以定义一个<strong>customData</strong>和 <strong>order</strong>。</li>
</ul>
<p>**INavigationProviderContext **具有一个获得已存在菜单项、添加菜单以及菜单项的方法。这样，不同的模块就可以将自己的项添加到菜单上。</p>
<p>在一个应用中也可能有一个或更多的菜单，<strong>context.Manager.MainMenu</strong>引用了默认的主菜单。使用<strong>context.Manager.Menus</strong>可以创建和添加更多的菜单。</p>
<h4 id="注册导航提供者"><a href="#注册导航提供者" class="headerlink" title="注册导航提供者"></a>注册导航提供者</h4><p>创建导航提供者之后，我们应该在模块的<strong>PreInitialize</strong>事件里将它注册到ABP的配置中：</p>
<pre class=" language-C#"><code class="language-C#">Configuration.Navigation.Providers.Add<SimpleTaskSystemNavigationProvider>();
</code></pre>
<h3 id="展示菜单"><a href="#展示菜单" class="headerlink" title="展示菜单###"></a>展示菜单###</h3><p>可以注入<strong>IUserNavigationManager</strong>，然后使用它来获得菜单项，再将菜单项展示给用户。这样，我们就可以在服务端创建菜单了。</p>
<p>ABP在客户端自动生成获得菜单和菜单项的<strong>javascript API</strong>。 <strong>abp.nav</strong>命名空间下的方法和对象就是用于这个目的。比如，可以使用 <strong>abp.nav.menus.Mainmenu</strong>获得应用的主菜单。这样我们就能在客户端创建菜单了。</p>
<p>ABP模板使用了这个系统来创建菜单并将菜单展示给用户，你可以通过创建一个模板来查看源代码了解更多。</p>
<h1 id="ABP理论学习之异常处理"><a href="#ABP理论学习之异常处理" class="headerlink" title="ABP理论学习之异常处理"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPException.html">ABP理论学习之异常处理</a></h1><hr>
<h2 id="本篇目录-29"><a href="#本篇目录-29" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPException.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPException.html#enable">开启错误处理</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPException.html#nonAjax">非Ajax请求</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPException.html#show">展示异常信息</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPException.html#UserFriendlyException">UserFriendlyException</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPException.html#model">Error模型</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPException.html#Ajax">Ajax请求</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPException.html#event">异常事件</a></strong></li>
</ul>
<h3 id="介绍-14"><a href="#介绍-14" class="headerlink" title="介绍###"></a>介绍###</h3><p>在一个web应用中，异常通常是在MVC控制器的action方法和Web API控制器中处理的。当异常发生时，应用程序会通知用户发生的错误，也可能包含该错误产生的原因。</p>
<p>如果错误发生在一个常规的HTTP请求中，那么就会展示一个错误页面。如果一个错误发生在Ajax请求中，那么服务端会给客户端发送错误信息，然后处理后将错误展示给用户。</p>
<p>在所有的web应用中处理异常是一个乏味反复的工作。ABP的异常处理是自动化的。你大多数情况下不需要处理任何异常。ABP会处理所有的异常，记录异常信息日志，并返回给客户端合适且格式化的响应，而且也会在客户端处理这些响应并通知用户。</p>
<h3 id="开启错误处理"><a href="#开启错误处理" class="headerlink" title="开启错误处理###"></a>开启错误处理###</h3><p>要开启错误处理，必须开启<strong>customErrors</strong>模式。</p>
<pre class=" language-webconfig"><code class="language-webconfig"><customErrors mode="On" />
</code></pre>
<p>如果你不想在本机上处理错误，那么你可以将该值设置成“RemoteOnly”。</p>
<h3 id="非Ajax请求"><a href="#非Ajax请求" class="headerlink" title="非Ajax请求###"></a>非Ajax请求###</h3><p>如果请求是非Ajax的，那么就会显示一个错误页面。</p>
<h4 id="展示异常信息"><a href="#展示异常信息" class="headerlink" title="展示异常信息"></a>展示异常信息</h4><p>这里有个抛出任意异常的MVC控制器action。</p>
<pre class=" language-C#"><code class="language-C#">public ActionResult Index()
{
    throw new Exception("A sample exception message...");
}
</code></pre>
<p>当然，这个异常信息也可能被在该action中调用的其他方法抛出。ABP会处理这个异常，记录到日志，然后显示<strong>“Error.cshtml”</strong>视图。你也可以<strong>自定义</strong>该错误视图。一个错误视图的例子如下（它是ABP模板中默认的错误视图）：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151231212223792-1292368149.png" alt="img"></p>
<p>ABP会将该异常的细节隐藏给用户，然后展示一个标准的（本地化）错误信息，除非你显示抛出一个<strong>UserFriendlyException</strong>。</p>
<h4 id="UserFriendlyException"><a href="#UserFriendlyException" class="headerlink" title="UserFriendlyException"></a>UserFriendlyException</h4><p>UserFriendlyException是一个特殊类型的异常，它会直接展示给用户。看下面的例子：</p>
<pre class=" language-C#"><code class="language-C#">public ActionResult Index()
{
    throw new UserFriendlyException("Ooppps! There is a problem!", "You are trying to see a product that is deleted...");
}
</code></pre>
<p>ABP会记录这个错误日志，但是这次不会隐藏异常信息了，如下所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151231212718573-747775861.png" alt="img"></p>
<p>因此，如果你想要给用户展示一个特殊的错误信息，只要抛出一个UserFriendlyException（或者派生自它的异常）就行了。</p>
<h4 id="Error模型"><a href="#Error模型" class="headerlink" title="Error模型"></a>Error模型</h4><p>ABP将一个<strong>ErrorViewModel</strong>对象传给了Error视图：</p>
<pre class=" language-C#"><code class="language-C#">public class ErrorViewModel
{
    public AbpErrorInfo ErrorInfo { get; set; }

    public Exception Exception { get; set; }
}
</code></pre>
<p><strong>ErrorInfo</strong>包含了可以展示给用户的详细信息， <strong>Exception</strong>对象是抛出的异常。如果你想，你也可以检查它，然后展示额外的信息。比如，如果它是一个<strong>AbpValidationException</strong>，那么我们可以展示一个验证错误的信息：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151231213304698-1528714449.png" alt="img"></p>
<h3 id="Ajax请求"><a href="#Ajax请求" class="headerlink" title="Ajax请求###"></a>Ajax请求###</h3><p>如果请求是Ajax请求，那么ABP会返回一个Json对象给客户端。这对于MVC控制器和Web API控制器都是成立的。下面是返回一个错误对象的例子：</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"targetUrl"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>
  <span class="token property">"result"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>
  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token property">"error"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"An internal error occured during your request!"</span><span class="token punctuation">,</span>
    <span class="token property">"details"</span><span class="token operator">:</span> <span class="token string">"..."</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"unAuthorizedRequest"</span><span class="token operator">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>success:false</strong>表明发送了错误。<br> <strong>error</strong>对象提供了错误 <strong>信息</strong>和 <strong>细节</strong>。</p>
<p>当你使用ABP的基础设施在客户端发起Ajax请求时，客户端会自动地处理这个Json对象，然后使用message API给用户提示错误信息。</p>
<h3 id="异常事件"><a href="#异常事件" class="headerlink" title="异常事件###"></a>异常事件###</h3><p>ABP处理任何异常时都会触发<strong>AbpHandledExceptionData</strong>事件，注册该事件后就会收到通知（查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPEventBus.html">事件总线（EventBus）</a>**获取更多信息关于事件总线的信息）。例子：</p>
<pre class=" language-C#"><code class="language-C#">public class MyExceptionHandler : IEventHandler<AbpHandledExceptionData>, ITransientDependency
{
    public void HandleEvent(AbpHandledExceptionData eventData)
    {
        //TODO: 检查 eventData.Exception!
    }
}
</code></pre>
<p>如果你把这个样例类放到你的应用中（一般放到Web项目中），<strong>HandleEvent</strong>方法就会被ABP处理的所有异常调用。这样，你就可以研究Exception对象的细节了。</p>
<h1 id="ABP理论学习之内嵌资源文件"><a href="#ABP理论学习之内嵌资源文件" class="headerlink" title="ABP理论学习之内嵌资源文件"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEmbeddedFile.html">ABP理论学习之内嵌资源文件</a></h1><hr>
<h2 id="本篇目录-30"><a href="#本篇目录-30" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEmbeddedFile.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEmbeddedFile.html#create">创建内嵌文件</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEmbeddedFile.html#expose">暴露内嵌文件</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEmbeddedFile.html#consume">使用内嵌文件</a></strong></li>
</ul>
<h3 id="介绍-15"><a href="#介绍-15" class="headerlink" title="介绍###"></a>介绍###</h3><p>在一个web应用中，有供客户端使用的javascript，css，xml等文件。它们一般是作为分离的文件被添加到web项目中并发布。有时，我们需要将这些文件打包到一个程序集（类库项目，一个dll文件）中，作为内嵌资源散布到程序集中。ABP提供了一个基础设施使得这个很容易实现。</p>
<h3 id="创建内嵌文件"><a href="#创建内嵌文件" class="headerlink" title="创建内嵌文件###"></a>创建内嵌文件###</h3><p>我们首先应该创建一个资源文件并把它标记为<strong>内嵌的资源</strong>。任何程序集都可以包含内嵌的资源文件。假设我们有一个叫做“Abp.Zero.Web.UI.Metronic.dll”程序集，而且它包含了javascript，css，和图片文件：</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151225220358531-512438953.png" alt="img"></p>
<p>我们想要使这些文件在一个web应用中可用，首先，我们应该将想要暴露的文件标记为<strong>内嵌的资源</strong>。在这里，我选择了 <strong>metronic.js</strong>文件，右键打开属性面板（快捷键是F4）。</p>
<p><img src="https://images2015.cnblogs.com/blog/577014/201512/577014-20151225222645218-1301105987.png" alt="img"></p>
<p>选中你想在web应用中使用的所有文件，将<strong>生成操作（build action）</strong>的属性值选为<strong>内嵌的 资源</strong>。</p>
<h3 id="暴露内嵌文件"><a href="#暴露内嵌文件" class="headerlink" title="暴露内嵌文件###"></a>暴露内嵌文件###</h3><p>ABP使得暴露这些内嵌资源很容易，只需要一行代码：</p>
<pre><code>WebResourceHelper.ExposeEmbeddedResources(&quot;AbpZero/Metronic&quot;, Assembly.GetExecutingAssembly(), &quot;Abp.Zero.Web.UI.Metronic&quot;);
</code></pre>
<p>这行代码一般放在模块的Initialize方法中，下面解释一下这些参数：</p>
<ul>
<li>第一个参数为这些文件定义了<strong>根文件夹</strong>，它匹配了根命名空间。</li>
<li>第二个参数定义了包含这些文件的<strong>程序集</strong>。本例中，我传入了包含这行代码的程序集。但你也可以传入任何包含内嵌资源的程序集。</li>
<li>最后一个参数定义了这些文件在程序集的根命名空间。它是“默认的命名空间”加上“文件夹名”。默认的命名空间一般和程序集的名字是相同的，但是在程序集的属性中进行更改。这里 ，默认的命名空间是Abp(已经更改了)，因此Metronic文件夹的命名空间是“Abp.Zero.Web.UI.Metronic”。</li>
</ul>
<h3 id="使用内嵌文件"><a href="#使用内嵌文件" class="headerlink" title="使用内嵌文件###"></a>使用内嵌文件###</h3><p>可以直接使用内嵌的资源：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>~/AbpZero/Metronic/assets/global/scripts/metronic.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre>
<p>ABP知道这是一个内嵌的资源，因而可以从之前暴露的dll中获得文件。此外，还可以在razor视图中使用HtmlHelper的扩展方法<strong>IncludeScript</strong>:</p>
<pre class=" language-razor"><code class="language-razor">@Html.IncludeScript("~/AbpZero/Metronic/assets/global/scripts/metronic.js")
</code></pre>
<p>这会产生下面的代码：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/AbpZero/Metronic/assets/global/scripts/metronic.js?v<span class="token punctuation">=</span>635438748506909100<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre>
<p>唯一的不同就是参数<strong>v=635438748506909100</strong>。这样做的好处是阻止了浏览器端脚本的<strong>失败缓存</strong>。该值只有当你的dll重新生成（实际上是文件的最后写入时间）的时候才会改变，而且如果该值改变了，浏览器就不会缓存这个文件了。因此，建议使用IncludeScript方式。这对于非嵌入的物理资源也是有效的。对应于css文件，也存在相应的<strong>IncludeStyle</strong>方法。</p>
<h1 id="后台服务"><a href="#后台服务" class="headerlink" title="后台服务"></a>后台服务</h1><hr>
<h2 id="本篇目录-31"><a href="#本篇目录-31" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPBackgroundJobsAndWorkers.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPBackgroundJobsAndWorkers.html#jobs">后台工作</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPBackgroundJobsAndWorkers.html#workers">后台工作者</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPBackgroundJobsAndWorkers.html#running">让你的应用程序一直运行</a></strong></li>
</ul>
<h3 id="介绍-16"><a href="#介绍-16" class="headerlink" title="介绍"></a>介绍</h3><p>ABP提供了后台工作和后台工作者，它们会在应用程序的<strong>后台线程</strong>中执行一些任务。</p>
<h3 id="后台工作"><a href="#后台工作" class="headerlink" title="后台工作"></a>后台工作</h3><p>后台工作以队列和持续的方式在后台给一些即将被执行的任务排队。你可能因为某些原因需要后台工作，比如：</p>
<ul>
<li>执行<strong>长时间运行的任务</strong>。比如，一个用户按了“report”按钮来启动一个长时间运行的报告工作，点击了这个按钮你不可能让用户一直处于等待状态，所以你应该将这个工作（job）添加到 <strong>队列（queue）</strong>中，然后，当这项工作完成时，通过邮件将报告结果发送给该用户。</li>
<li>创建<strong>重复尝试（re-trying）和持续的任务</strong>来保证代码将会 <strong>成功执行</strong>。比如，你可以在后台工作中发送邮件以克服 <strong>临时失败</strong>，并 <strong>保证</strong>邮件最终能够发送出去。因此，当发送邮件的时候用户不需要等待。</li>
</ul>
<h4 id="创建一个后台工作"><a href="#创建一个后台工作" class="headerlink" title="创建一个后台工作"></a>创建一个后台工作</h4><p>我们可以通过继承<strong>BackgroundJob</strong>类或者直接实现 <strong>IBackgroundJob</strong>接口来创建一个后台工作类。</p>
<p>下面是一个最简单的后台工作：</p>
<pre class=" language-C#"><code class="language-C#">public class TestJob : BackgroundJob<int>, ITransientDependency
{
    public override void Execute(int number)
    {
        Logger.Debug(number.ToString());
    }
}
</code></pre>
<p>该后台工作定义了一个需要输入参数的<strong>Execute</strong>方法。参数类型是泛型参数类型。</p>
<p>后台工作必须注册到依赖注入系统中，实现<strong>ITransientDependency</strong>是最简单的方式。</p>
<p>接下来定义一个更现实的工作，它会在后台队列中发送邮件：</p>
<pre class=" language-C#"><code class="language-C#">public class SimpleSendEmailJob : BackgroundJob<SimpleSendEmailJobArgs>, ITransientDependency
{
    private readonly IRepository<User, long> _userRepository;
    private readonly IEmailSender _emailSender;

    public SimpleSendEmailJob(IRepository<User, long> userRepository, IEmailSender emailSender)
    {
        _userRepository = userRepository;
        _emailSender = emailSender;
    }

    public override void Execute(SimpleSendEmailJobArgs args)
    {
        var senderUser = _userRepository.Get(args.SenderUserId);
        var targetUser = _userRepository.Get(args.TargetUserId);

        _emailSender.Send(senderUser.EmailAddress, targetUser.EmailAddress, args.Subject, args.Body);
    }
}
</code></pre>
<p>我们注入了user仓储（为了获得用户信息）和email发送者（发送邮件的服务），然后简单地发送了该邮件。<strong>SimpleSendEmailJobArgs</strong>是该工作的参数，它定义如下：</p>
<pre class=" language-C#"><code class="language-C#">[Serializable]
public class SimpleSendEmailJobArgs
{
    public long SenderUserId { get; set; }

    public long TargetUserId { get; set; }

    public string Subject { get; set; }

    public string Body { get; set; }
}
</code></pre>
<p>工作参数应该是<strong>serializable(可序列化)**，因为要将它 **序列化并存储</strong>到数据库中。虽然ABP默认的后台工作管理者使用了JSON序列化（它不需要[Serializable]特性），但是最好定义 **[Serializable]**特性，因为我们将来可能会转换到其他使用二进制序列化的工作管理者。</p>
<p>记住，<strong>要保持你的参数简单</strong>，不要在参数中包含实体或者其他非可序列化的对象。正如上面的例子演示的那样，我们只存储了实体的 <strong>Id</strong>，然后在该工作的内部从仓储中获得该实体。</p>
<h4 id="添加新工作到队列"><a href="#添加新工作到队列" class="headerlink" title="添加新工作到队列"></a>添加新工作到队列</h4><p>当定义了一个后台工作后，我们就可以注入并使用<strong>IBackgroundJobManager</strong>来添加一个工作到队列中。看上面定义的TestJob的例子：</p>
<pre class=" language-C#"><code class="language-C#">public class MyService
{
    private readonly IBackgroundJobManager _backgroundJobManager;

    public MyService(IBackgroundJobManager backgroundJobManager)
    {
        _backgroundJobManager = backgroundJobManager;
    }

    public void Test()
    {
        _backgroundJobManager.Enqueue<TestJob, int>(42);
    }
}
</code></pre>
<p>当入队（Enqueue）时，我们将42作为参数传递。IBackgroundJobManager将会实例化并使用42作为参数执行TestJob。</p>
<p>让我们看一下如何为上面定义的SimpleSendEmailJob添加一个新的工作：</p>
<pre class=" language-C#"><code class="language-C#">[AbpAuthorize]
public class MyEmailAppService : ApplicationService, IMyEmailAppService
{
    private readonly IBackgroundJobManager _backgroundJobManager;

    public MyEmailAppService(IBackgroundJobManager backgroundJobManager)
    {
        _backgroundJobManager = backgroundJobManager;
    }

    public async Task SendEmail(SendEmailInput input)
    {
            await _backgroundJobManager.EnqueueAsync<SimpleSendEmailJob, SimpleSendEmailJobArgs>(
            new SimpleSendEmailJobArgs
            {
                Subject = input.Subject,
                Body = input.Body,
                SenderUserId = AbpSession.GetUserId(),
                TargetUserId = input.TargetUserId
            });
    }
}
</code></pre>
<p>Enqueu (或 EnqueueAsync)方法还有其他的参数，比如 <strong>priority和 delay（优先级和延迟）</strong>。</p>
<h4 id="默认的后台工作管理者"><a href="#默认的后台工作管理者" class="headerlink" title="默认的后台工作管理者"></a>默认的后台工作管理者</h4><p>IBackgroundJobManager默认是由<strong>BackgroundJobManager</strong>实现的。它可以被其他的后台工作提供者替代（看后面的Hangfire集成）。关于默认的BackgroundJobManager一些信息如下：</p>
<ul>
<li>它是一个在单线程中以<strong>FIFO（First In First Out）</strong>工作的简单工作队列，使用 <strong>IBackgroundJobStore</strong>来持久化工作。</li>
<li>它会<strong>重复尝试</strong>执行工作，直到工作成功执行（不会抛出任何异常）或者超时。默认的超时是一个工作2天。</li>
<li>当成功执行后，它会从存储（数据库）中<strong>删除</strong>该工作。如果超时了，就会将该工作设置为 <strong>abandoned（废弃的）</strong>，并保留在数据库中。</li>
<li>在重复尝试一个工作之间会<strong>增加等待时间</strong>。第一次重试时等待1分钟，第二次等待2分钟，第三次等待4分钟等等。</li>
<li>在固定的时间间隔轮询工作的存储。查询工作时先按优先级排序，再按尝试次数排序。</li>
</ul>
<p><strong>后台工作存储</strong><br> 默认的BackgroundJobManager需要一个数据存储来保存、获得工作。如果你没有实现<strong>IBackgroundJobStore</strong>，那么它会使用 <strong>InMemoryBackgroundJobStore</strong>，它不会将工作持久化到数据库中。你可以简单地实现它来存储工作到数据库或者你可以使用module-zero，它已经实现了IBackgroundJobStore。</p>
<p>如果你正在使用第三方的工作管理者（像Hangfire），那么不需要实现IBackgroundJobStore。</p>
<h4 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h4><p>你可以在模块的PreInitialize方法中使用<strong>Configuration.BackgroundJobs</strong>来配置后台工作系统。</p>
<p><strong>关闭工作执行功能</strong><br> 你可能想关闭应用程序的后台工作执行：</p>
<pre class=" language-C#"><code class="language-C#">public class MyProjectWebModule : AbpModule
{
    public override void PreInitialize()
    {
        Configuration.BackgroundJobs.IsJobExecutionEnabled = false;
    }

    //...
}
</code></pre>
<p>这种情况很罕见，但是想一下，如果你正在对相同的数据库运行多个应用的实例（在web应用中）。在这种情况下，每个应用都会为工作查询相同的数据库并执行它们。这会导致相同工作的多次执行和一些其它问题。要阻止这种情况发生，你有两种选择：</p>
<ul>
<li>你可以只为该应用的一个实例开启工作执行。</li>
<li>你可以为该web应用的所有实例关闭工作执行，然后创建一个会执行后台工作的独立应用（比如一个Windows服务）。</li>
</ul>
<h4 id="Hangfire集成"><a href="#Hangfire集成" class="headerlink" title="Hangfire集成"></a>Hangfire集成</h4><p>后台工作管理者设计成了可以被其他的后台工作管理者<strong>取代</strong>。查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPHangfireIntegration.html">Hangfire集成</a>**来替代默认的后台工作管理者。</p>
<h3 id="后台工作者"><a href="#后台工作者" class="headerlink" title="后台工作者"></a>后台工作者</h3><p>后台工作者不同于后台工作。它们是运行在应用后台的简单<strong>独立线程</strong>。一般来说，它们会定期地执行一些任务。比如：</p>
<ul>
<li>后台工作者可以定期运行来<strong>删除旧的日志</strong>。</li>
<li>后台工作者可以定期运行来<strong>确定不活跃的用户</strong>，并给他们发送邮件以使他们返回你的应用。</li>
</ul>
<h4 id="创建后台工作者"><a href="#创建后台工作者" class="headerlink" title="创建后台工作者"></a>创建后台工作者</h4><p>要创建后台工作者，我们应该实现<strong>IBackgroundWorker</strong>接口。除此之外，我们可以基于需求从  <strong>BackgroundWorkerBase</strong>或者 <strong>PeriodicBackgroundWorkerBase</strong>继承。</p>
<p>假设一个用户在过去30天内没有登录到该应用，那我们想要让Ta的状态为passive。看下面的代码：</p>
<pre class=" language-C#"><code class="language-C#">public class MakeInactiveUsersPassiveWorker : PeriodicBackgroundWorkerBase, ISingletonDependency
{
    private readonly IRepository<User, long> _userRepository;

    public MakeInactiveUsersPassiveWorker(AbpTimer timer, IRepository<User, long> userRepository)
        : base(timer)
    {
        _userRepository = userRepository;
        Timer.Period = 5000; //5 seconds (good for tests, but normally will be more)
    }

    [UnitOfWork]
    protected override void DoWork()
    {
        using (CurrentUnitOfWork.DisableFilter(AbpDataFilters.MayHaveTenant))
        {
            var oneMonthAgo = Clock.Now.Subtract(TimeSpan.FromDays(30));

            var inactiveUsers = _userRepository.GetAllList(u =>
                u.IsActive &&
                ((u.LastLoginTime < oneMonthAgo && u.LastLoginTime != null) || (u.CreationTime < oneMonthAgo && u.LastLoginTime == null))
                );

            foreach (var inactiveUser in inactiveUsers)
            {
                inactiveUser.IsActive = false;
                Logger.Info(inactiveUser + " made passive since he/she did not login in last 30 days.");
            }

            CurrentUnitOfWork.SaveChanges();
        }
    }
}
</code></pre>
<p>这是现实中的代码，并且在具有module-zero模块的ABP中直接有效。</p>
<ul>
<li>如果你从<strong>PeriodicBackgroundWorkerBase</strong> 类继承（如这个例子），那么你应该实现 <strong>DoWork</strong>方法来执行定期运行的代码。</li>
<li>如果从<strong>BackgroundWorkerBase</strong>继承或直接实现了 <strong>IBackgroundWorker</strong>，那么你要重写或者实现Start, Stop 和 WaitToStop方法。Start和Stop方法应该是 <strong>非阻塞的（non-blocking）</strong>，WaitToStop方法应该等待工作者完成当前重要的工作。</li>
</ul>
<h4 id="注册后台工作者"><a href="#注册后台工作者" class="headerlink" title="注册后台工作者"></a>注册后台工作者</h4><p>创建一个后台工作者后，我们应该把它添加到<strong>IBackgroundWorkerManager</strong>，通常放在模块的PostInitialize方法中：</p>
<pre class=" language-C#"><code class="language-C#">public class MyProjectWebModule : AbpModule
{
    //...

    public override void PostInitialize()
    {
        var workManager = IocManager.Resolve<IBackgroundWorkerManager>();
        workManager.Add(IocManager.Resolve<MakeInactiveUsersPassiveWorker>());
    }
}
</code></pre>
<p>虽然一般我们将工作者添加到PostInitialize方法中，但是没有强制要求。你可以在任何地方注入IBackgroundWorkerManager，在运行时添加工作者。<br> 当应用要关闭时，IBackgroundWorkerManager会停止并释放所有注册的工作者。</p>
<h4 id="后台工作者生命周期"><a href="#后台工作者生命周期" class="headerlink" title="后台工作者生命周期"></a>后台工作者生命周期</h4><p>后台工作者一般实现为单例的，但是没有严格限制。如果你需要相同工作者类的多个实例，那么可以使它成为transient（每次使用时创建），然后给IBackgroundWorkerManager添加多个实例。在这种情况下，你的工作者很可能会参数化（比如，你有单个LogCleaner类，但是两个LogCleaner工作者实例会监视并清除不同的log文件夹）。</p>
<h3 id="让你的应用程序一直运行"><a href="#让你的应用程序一直运行" class="headerlink" title="让你的应用程序一直运行"></a>让你的应用程序一直运行</h3><p>只有当你的应用运行时，后台工作和工作者才会工作。如果一个Asp.Net  应用长时间没有执行请求，那么它默认会关闭（shutdown）。如果你想让后台工作一直在web应用中执行（这是默认行为），那么你要确保web应用配置成了总是运行。否则，后台工作只有在应用使用时才会执行。</p>
<h1 id="实时服务"><a href="#实时服务" class="headerlink" title="实时服务"></a>实时服务</h1><h1 id="ABP理论学习之通知系统"><a href="#ABP理论学习之通知系统" class="headerlink" title="ABP理论学习之通知系统"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html">ABP理论学习之通知系统</a></h1><hr>
<h2 id="本篇目录-32"><a href="#本篇目录-32" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html#subscribe">订阅通知</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html#publish">发布通知</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html#manager">用户通知管理者</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html#realtime">实时通知</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html#store">通知存储</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNotificationSystem.html#definition">通知定义</a></strong></li>
</ul>
<h3 id="介绍-17"><a href="#介绍-17" class="headerlink" title="介绍"></a>介绍</h3><p>通知（Notification）用于告知用户系统中的特定事件。ABP提供了基于<strong>实时</strong>通知基础设施的发布订阅模型（pub/sub）。</p>
<h4 id="发送模型"><a href="#发送模型" class="headerlink" title="发送模型"></a>发送模型</h4><p>给用户发送通知有两种方式：</p>
<ul>
<li>首先用户订阅特定的通知类型，然后我们发布这种类型的通知，这种类型的通知会传递给所有<strong>已经订阅</strong>的用户。这就是发布订阅（pub/sub）模型。</li>
<li>直接给目标用户发送通知。</li>
</ul>
<h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><p>通知类型也有两种：</p>
<ul>
<li><strong>一般通知</strong>：是任意类型的通知。“如果一个用户给我发送了添加好友的请求就通知我”是这种通知类型的一个例子。</li>
<li><strong>实体通知</strong>：和特定的实体相关联。“如果一个用户在 <strong>这张</strong>图片上评论那么通知我”是基于实体的通知，因为它和特定的实体相关联。用户可能想获得某些图片的通知而不是所有的图片通知。</li>
</ul>
<h4 id="通知数据"><a href="#通知数据" class="headerlink" title="通知数据"></a>通知数据</h4><p>一个通知一般都会包括一个<strong>通知数据</strong>。比如，“如果一个用户给我发送了添加好友的请求就通知我”，这个通知可能有两个数据属性：发送者用户名（那哪一个用户发送的这个添加好友的请求）和请求内容（该用户在这个请求中写的东西）。很明显，该通知数据类型紧耦合于通知类型。不同的通知类型有不同的数据类型。</p>
<ul>
<li>通知数据是<strong>可选的</strong>。某些通知可能不需要数据。一些预定义的通知数据类型可能对于大多数情况够用了。 <strong>MessageNotificationData</strong>可以用于简单的信息， <strong>LocalizableMessageNotificationData</strong>可以用于本地化的，带参数的通知信息。</li>
</ul>
<h4 id="通知安全"><a href="#通知安全" class="headerlink" title="通知安全"></a>通知安全</h4><p>通知的安全性有5个级别，它们定义在NotificationSeverity枚举类中，分别是 Info,Success,Warn,Error和Fatal。默认值是Info。</p>
<h3 id="订阅通知"><a href="#订阅通知" class="headerlink" title="订阅通知"></a>订阅通知</h3><p><strong>INotificationSubscriptionManager</strong> 提供了订阅通知的API。例如：</p>
<pre class=" language-C#"><code class="language-C#">public class MyService : ITransientDependency
{
    private readonly INotificationSubscriptionManager _notificationSubscriptionManager;

    public MyService(INotificationSubscriptionManager notificationSubscriptionManager)
    {
        _notificationSubscriptionManager = notificationSubscriptionManager;
    }

    //订阅一个一般通知
    public async Task Subscribe_SentFrendshipRequest(int? tenantId, long userId)
    {
        await _notificationSubscriptionManager.SubscribeAsync(tenantId, userId, "SentFrendshipRequest");    
    }

    //订阅一个实体通知
    public async Task Subscribe_CommentPhoto(int? tenantId, long userId, Guid photoId)
    {
        await _notificationSubscriptionManager.SubscribeAsync(tenantId, userId, "CommentPhoto", new EntityIdentifier(typeof(Photo), photoId));   
    }
}
</code></pre>
<p>首先，我们注入了<strong>INotificationSubscriptionManager</strong>。第一个方法订阅了一个一般通知。当某人发送了一个添加好友的请求时，用户想得到通知。第二个方法订阅了一个和特定实体（Photo）相关的通知。如果任何人对这个特定的图片进行了评论，那么用户就会收到通知。</p>
<p>每一个通知应该有<strong>唯一的名字</strong>（比如例子中的SentFrendshipRequest和 CommentPhoto）。</p>
<p><strong>INotificationSubscriptionManager</strong>还有很多方法来管理通知，比如<strong>UnsubscribeAsync, IsSubscribedAsync, GetSubscriptionsAsync</strong>等方法。</p>
<h3 id="发布通知"><a href="#发布通知" class="headerlink" title="发布通知"></a>发布通知</h3><p><strong>INotificationPublisher</strong>用于发布通知，例如：</p>
<pre class=" language-C#"><code class="language-C#">public class MyService : ITransientDependency
{
    private readonly INotificationPublisher _notiticationPublisher;

    public MyService(INotificationPublisher notiticationPublisher)
    {
        _notiticationPublisher = notiticationPublisher;
    }

    //给特定的用户发送一个一般通知
    public async Task Publish_SentFrendshipRequest(string senderUserName, string friendshipMessage, long targetUserId)
    {
        await _notiticationPublisher.PublishAsync("SentFrendshipRequest", new SentFrendshipRequestNotificationData(senderUserName, friendshipMessage), userIds: new[] { targetUserId });
    }

    //给特定的用户发送一个实体通知
    public async Task Publish_CommentPhoto(string commenterUserName, string comment, Guid photoId, long photoOwnerUserId)
    {
        await _notiticationPublisher.PublishAsync("CommentPhoto", new CommentPhotoNotificationData(commenterUserName, comment), new EntityIdentifier(typeof(Photo), photoId), userIds: new[] { photoOwnerUserId });
    }

    //给具特定严重级别程度的所有订阅用户发送一个一般通知
    public async Task Publish_LowDisk(int remainingDiskInMb)
    {
        //例如 "LowDiskWarningMessage"的英文内容 -> "Attention! Only {remainingDiskInMb} MBs left on the disk!"
        var data = new LocalizableMessageNotificationData(new LocalizableString("LowDiskWarningMessage", "MyLocalizationSourceName"));
        data["remainingDiskInMb"] = remainingDiskInMb;

        await _notiticationPublisher.PublishAsync("System.LowDisk", data, severity: NotificationSeverity.Warn);    
    }
}
</code></pre>
<p>在第一个例子中，我们向单个用户发布了一个通知。<em>SentFrendshipRequestNotificationData</em>应该从 <strong>NotificationData</strong>继承，比如：</p>
<pre class=" language-C#"><code class="language-C#">[Serializable]
public class SentFrendshipRequestNotificationData : NotificationData
{
    public string SenderUserName { get; set; }

    public string FriendshipMessage { get; set; }

    public SentFrendshipRequestNotificationData(string senderUserName, string friendshipMessage)
    {
        SenderUserName = senderUserName;
        FriendshipMessage = friendshipMessage;
    }
}
</code></pre>
<p>在第二个例子中，我们向特定的用户发送了一个特定实体的通知。通知数据类CommentPhotoNotificationData一般不需要<strong>serializble</strong>(因为默认使用了JSON序列化)。但是建议把它标记为serializable，因为你可能需要在应用之间移动通知，也可能在未来使用二进制的序列。此外，正如之前声明的那样，通知数据是可选的，而且对于所有的通知可能不是必须的。</p>
<p>注意：如果我们对特定的用户发布了一个通知，那么他们不需要订阅那些通知。</p>
<p>在第三个例子中，我们没有定义一个专用的通知数据类。相反，我们直接使用了内置的具有基于字典数据的<strong>LocalizableMessageNotificationData</strong>，并且以 <strong>Warn</strong>发布了通知。<strong>LocalizableMessageNotificationData</strong>可以存储基于字典的任意数据（这对于自定义的通知数据类也是成立的，因为它们也从 <strong>NotificationData类继承</strong>）。在本地化时我们使用了“ <strong>remaingDiskInMb</strong>”作为参数。本地化信息可以包含这些参数（比如例子中的”Attention! Only {remainingDiskInMb} MBs left on the disk!”）</p>
<h3 id="用户通知管理者"><a href="#用户通知管理者" class="headerlink" title="用户通知管理者"></a>用户通知管理者</h3><p><strong>IUserNotificationManager</strong>用于管理用户的通知，它有 <strong>get,update或delete</strong>用户通知的方法。你可以为你的应用程序准备一个通知列表页面。</p>
<h3 id="实时通知"><a href="#实时通知" class="headerlink" title="实时通知"></a>实时通知</h3><p>当使用IUserNotificationManager来查询通知时，我们一般想实时地将通知推送到客户端。</p>
<p>通知系统使用了<strong>IRealTimeNotifier</strong>向用户发送实时通知。这可以使用任何类型的实时通讯系统来实现。ABP在一个单独的包中使用了 <strong>SignalR</strong>来实现。ABP官网的起始模板已经安装了SignalR。</p>
<p>注意：通知系统在一个后台工作中异步调用<strong>IRealTimeNotifier</strong>。因此，通知发送时可能伴有轻微的延迟。</p>
<h4 id="客户端-4"><a href="#客户端-4" class="headerlink" title="客户端"></a>客户端</h4><p>当接收到一个实时通知时，ABP会在客户端触发一个<strong>全局的事件（global event）</strong>。你可以像下面那样注册来获取通知：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>event<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'abp.notifications.received'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>userNotification<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>userNotification<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>abp.notifications.received</strong>事件对于每个接收到的实时通知都会触发。你可以像上面那样注册该事件来获取通知。查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPJavascriptAPI.html#eventBus">javascript事件总线</a>**文档获取更多信息。对于上面的“System.LowDisk”例子，下面是接收到的通知消息的JSON数据：</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
    <span class="token property">"userId"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token property">"state"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token property">"notification"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"notificationName"</span><span class="token operator">:</span> <span class="token string">"System.LowDisk"</span><span class="token punctuation">,</span>
        <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">"message"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token property">"sourceName"</span><span class="token operator">:</span> <span class="token string">"MyLocalizationSourceName"</span><span class="token punctuation">,</span>
                <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"LowDiskWarningMessage"</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Abp.Notifications.LocalizableMessageNotificationData"</span><span class="token punctuation">,</span>
            <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token property">"remainingDiskInMb"</span><span class="token operator">:</span> <span class="token string">"42"</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token property">"entityType"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>
        <span class="token property">"entityTypeName"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>
        <span class="token property">"entityId"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>
        <span class="token property">"severity"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token property">"creationTime"</span><span class="token operator">:</span> <span class="token string">"2016-02-09T17:03:32.13"</span><span class="token punctuation">,</span>
        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"0263d581-3d8a-476b-8e16-4f6a6f10a632"</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"4a546baf-bf17-4924-b993-32e420a8d468"</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在这个对象中，</p>
<ul>
<li><p><strong>userId</strong>:当前的用户Id。一般来说不需要这个，因为你知道当前的用户。</p>
</li>
<li><p><strong>state</strong>： <strong>UserNotificationState</strong>枚举的值。0：未读，1：已读。</p>
</li>
<li><p>notification</p>
<p>:通知细节。</p>
<ul>
<li><strong>notificationName</strong>:通知的唯一名称。（当发布该通知时使用相同的值）</li>
<li><strong>data</strong>:通知数据。在本例中，我们使用了**LocalizableMessageNotificationData **（正如之前的例子中发布的）。</li>
<li><strong>message</strong>:本地的信息通知。我们可以使用 <strong>sourceName</strong>和 <strong>name</strong>来本地化UI上的信息。</li>
<li><strong>type</strong>:通知数据类型。全类型名称，包括命名空间。当处理该通知数据时我们可以检查该类型。</li>
<li><strong>properties</strong>：基于字典的自定义属性。</li>
<li><strong>entityType, entityTypeName和entityId</strong>：和通知相关的实体的信息。</li>
<li><strong>severity</strong>： <strong>NotificationSeverity</strong>枚举的值。0: Info, 1: Success, 2: Warn, 3: Error, 4: Fatal。</li>
<li><strong>creationTime</strong>:该通知创建的时间。</li>
<li><strong>id</strong>:通知的Id。</li>
</ul>
</li>
<li><p><strong>id</strong>:用户的通知id。</p>
</li>
</ul>
<p>当然，你不仅可以记录该通知。你还可以使用通知数据将通知信息展示给该用户。例如：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>event<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'abp.notifications.received'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>userNotification<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>userNotification<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>data<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'Abp.Notifications.LocalizableMessageNotificationData'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> localizedText <span class="token operator">=</span> abp<span class="token punctuation">.</span>localization<span class="token punctuation">.</span><span class="token function">localize</span><span class="token punctuation">(</span>
            userNotification<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>data<span class="token punctuation">.</span>message<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
            userNotification<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>data<span class="token punctuation">.</span>message<span class="token punctuation">.</span>sourceName
        <span class="token punctuation">)</span><span class="token punctuation">;</span>

        $<span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span>userNotification<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>data<span class="token punctuation">.</span>properties<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            localizedText <span class="token operator">=</span> localizedText<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'{'</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">'}'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'New localized notification: '</span> <span class="token operator">+</span> localizedText<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>userNotification<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>data<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'Abp.Notifications.MessageNotificationData'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'New simple notification: '</span> <span class="token operator">+</span> userNotification<span class="token punctuation">.</span>notification<span class="token punctuation">.</span>data<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>要处理通知数据，我们应该检查该数据类型。这个例子简单地从通知数据中获得信息。对于本地化的信息（LocalizableMessageNotificationData），我们要本地化该信息并替换参数。对于简单的信息（MessageNotificationData），我们直接获得该信息。当然，在一个真实项目中，我们不使用alert函数。我们可以使用<code>abp.notify</code>api来展示漂亮的UI通知。</p>
<p>如果你要实现这么上面的逻辑，那么有一种更简单且可伸缩的方式。当接收到一个push通知时，你可以只使用一句代码来显示UI通知：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>event<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'abp.notifications.received'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>userNotification<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    abp<span class="token punctuation">.</span>notifications<span class="token punctuation">.</span><span class="token function">showUiNotifyForUserNotification</span><span class="token punctuation">(</span>userNotification<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>这句代码会展示一个UI通知如下所示（上面System.LowDisk通知的例子）：</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/11f2d44b-fa5d-456f-8512-25a714df7c31.png" alt="图片"></p>
<p>对于内置的通知数据类型（LocalizableMessageNotificationData和 MessageNotificationData）是有效的。如果你有自定义的通知数据类型，那么你应该注册数据格式化器，如下所示：</p>
<pre class=" language-javascript"><code class="language-javascript">abp<span class="token punctuation">.</span>notifications<span class="token punctuation">.</span>messageFormatters<span class="token punctuation">[</span><span class="token string">'MyProject.MyNotificationDataType'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>userNotification<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">...</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//format and return message here</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>这样，<strong>showUiNotifyForUserNotification</strong>就可以对你的数据类型创建要显示的信息了。如果你只需要格式化信息，那么你可以直接使用 **abp.notifications.getFormattedMessageFromUserNotification(userNotification)**，它内部还是使用了showUiNotifyForUserNotification。</p>
<p>当接收到一个push通知时，启动模板包含了展示UI通知的代码。</p>
<h3 id="通知存储"><a href="#通知存储" class="headerlink" title="通知存储"></a>通知存储</h3><p>通知系统使用了<strong>INotificationStore</strong>来持久化通知。为了使通知系统合适地工作，应该实现这个接口。你可以自己实现或者使用module-zero（它已经实现了该接口）。</p>
<h3 id="通知定义"><a href="#通知定义" class="headerlink" title="通知定义"></a>通知定义</h3><p>在使用之前你不必定义一个通知。你无需定义任何类型的<strong>通知名</strong>就可以使用它们。但是，定义通知名可能会给你带来额外的好处。比如，你以后要研究应用程序中所有的通知，在这种情况下，我们可以给我们的模块定义一个<strong>通知提供器</strong>（notification provider ），如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class MyAppNotificationProvider : NotificationProvider
{
    public override void SetNotifications(INotificationDefinitionContext context)
    {
        context.Manager.Add(
            new NotificationDefinition(
                "App.NewUserRegistered",
                displayName: new LocalizableString("NewUserRegisteredNotificationDefinition", "MyLocalizationSourceName"),
                permissionDependency: new SimplePermissionDependency("App.Pages.UserManagement")
                )
            );
    }
}
</code></pre>
<p><strong>“App.NewUserRegistered”**是该通知的唯一名称。我们定义了一个本地的 **displayName</strong>（然后当在UI上订阅了该通知时，我们可以显示该通知）。最后，我们声明了只有拥有了**”App.Pages.UserManagement”**权限的用户才可以使用该通知。</p>
<p>也有一些其他的参数，你可以在代码中研究。对于一个通知定义，只有通知名称是<strong>必须</strong>的。</p>
<p>当定义了这么一个通知提供器之后，我们应该在模块的PreInitialize事件中进行注册，如下所示：</p>
<pre class=" language-c#"><code class="language-c#">public class AbpZeroTemplateCoreModule : AbpModule
{
    public override void PreInitialize()
    {
        Configuration.Notifications.Providers.Add<MyAppNotificationProvider>();
    }

    //...
}
</code></pre>
<p>最后，要获得通知定义，在应用程序中注入并使用<strong>INotificationDefinitionManager</strong>。</p>
<h1 id="ABP理论学习之SignalR集成"><a href="#ABP理论学习之SignalR集成" class="headerlink" title="ABP理论学习之SignalR集成"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSignalRIntegration.html">ABP理论学习之SignalR集成</a></h1><hr>
<h2 id="本篇目录-33"><a href="#本篇目录-33" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSignalRIntegration.html#intro">介绍</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSignalRIntegration.html#install">安装</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSignalRIntegration.html#connEstablishment">建立连接</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSignalRIntegration.html#built-in">内置功能</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPSignalRIntegration.html#yourCode">你自己的SignaR代码</a></strong></li>
</ul>
<h3 id="介绍-18"><a href="#介绍-18" class="headerlink" title="介绍###"></a>介绍###</h3><p><strong><a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Abp.Web.SignalR">Abp.Web.SignalR</a></strong> 使得在基于ABP的应用程序中使用 <strong>SignalR</strong>相当容易。查看**<a target="_blank" rel="noopener" href="http://www.asp.net/signalr">SignalR文档</a>**获取更多关于SignalR的详细信息。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装###"></a>安装###</h3><h4 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h4><p>将**<a target="_blank" rel="noopener" href="http://www.nuget.org/packages/Abp.Web.SignalR">Abp.Web.SignalR</a>**nuget包安装到你的项目中（一般是web层），然后给你的模块添加一个依赖：</p>
<pre class=" language-C#"><code class="language-C#">[DependsOn(typeof(AbpWebSignalRModule))]
public class YourProjectWebModule : AbpModule
{
    //...
}
</code></pre>
<p>然后在你的OWIN Startup类中使用<strong>MapSignalR</strong>方法：</p>
<pre class=" language-C#"><code class="language-C#">[assembly: OwinStartup(typeof(Startup))]
namespace MyProject.Web
{
    public class Startup
    {
        public void Configuration(IAppBuilder app)
        {
                app.MapSignalR();

            //...
        }
    }
}
</code></pre>
<p>注意：Abp.Web.SignalR只依赖于Microsoft.AspNet.SignalR.Core包。因此，如果你之前没有安装，那么你也需要将**<a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Microsoft.AspNet.SignalR">Microsoft.AspNet.SignalR</a>**安装到你的web项目中。</p>
<h4 id="客户端-5"><a href="#客户端-5" class="headerlink" title="客户端"></a>客户端</h4><p>在页面上应该添加<strong>abp.signalr.js</strong>脚本。它位于**<a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Abp.Web.Resources">Abp.Web.Resources</a>**包中（在启动模块中已经安装了）。我们应该在signalr总线之后包含它：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"~/signalr/hubs"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"~/Abp/Framework/scripts/libs/abp.signalr.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>就这样，SignalR就配置好了，也就集成到了你的项目中。</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接###"></a>建立连接###</h3><p>当页面上包含<strong>abp.signalr.js</strong>时，ABP会 <strong>自动连接</strong> 到服务器（从客户端）。一般来说这很好，但是也可能存在你不想这样的情况。那么你可以在包含 <strong>abp.signalr.js</strong>之前添加下面的代码来关闭自动连接。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span>
    abp<span class="token punctuation">.</span>signalr <span class="token operator">=</span> abp<span class="token punctuation">.</span>signalr <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    abp<span class="token punctuation">.</span>signalr<span class="token punctuation">.</span>autoConnect <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>这样，当你需要连接到服务器时，你可以手动调用**abp.signalr.connect()**函数。</p>
<p>当客户端连接到服务器时，会触发全局事件“<strong>abp.signalr.connected</strong>”。当该连接成功建立时，你可以注册到该事件以采取相应行动。</p>
<h3 id="内置功能"><a href="#内置功能" class="headerlink" title="内置功能###"></a>内置功能###</h3><p>你可以在应用程序中使用SignalR的所有功能，此外，<strong>Abp.Web.SignalR</strong>包实现了一些内置的功能。</p>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p><strong>Abp.Web.SignalR</strong>包实现了 <strong>IRealTimeNotifier</strong>来向客户端发送实时通知（查看《**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPNotificationSystem.html">通知系统</a>**》）。因此，你的用户可以获得实时的推送通知。</p>
<h4 id="在线客户端"><a href="#在线客户端" class="headerlink" title="在线客户端"></a>在线客户端</h4><p>ABP提供了<strong>IOnlineClientManager</strong>来获取关于在线用户的信息（比如，注入IOnlineClientManager然后使用GetByUserIdOrNull, GetAllClients, IsOnline 方法 ）。为了能够正确地工作，IOnlineClientManager需要一个通讯基础设施。<strong>Abp.Web.SignalR</strong>提供了一个这样的基础设施。因此，如果安装了SignalR，那么在应用的任何层都可以注入并使用IOnlineClientManager。</p>
<h4 id="PascalCase-vs-camelCase"><a href="#PascalCase-vs-camelCase" class="headerlink" title="PascalCase vs. camelCase"></a>PascalCase vs. camelCase</h4><p>Abp.Web.SignalR包在序列化时使用<strong>CamelCasePropertyNamesContractResolver</strong>覆盖了SignalR默认的 <strong>ContractResolver</strong>。因此，我们在服务端的类具有 <strong>PascalCase</strong>属性，而在客户端作为 <strong>camelCase</strong>使用来发送/接收对象（因为在javascript中camelCase是更受人喜欢的命名）。如果你想在某些程序集中忽略这个，那么你可以将那些程序集添加AbpSignalRContractResolver.IgnoredAssemblies 列表中。</p>
<h3 id="你自己的SignaR代码"><a href="#你自己的SignaR代码" class="headerlink" title="你自己的SignaR代码###"></a>你自己的SignaR代码###</h3><p><strong>Abp.Web.SignalR</strong> 包也简化了你的SignalR代码。假设我们想添加一个集线器（Hub）到应用程序中：</p>
<pre class=" language-C#"><code class="language-C#">public class MyChatHub : Hub, ITransientDependency
{
    public IAbpSession AbpSession { get; set; }

    public ILogger Logger { get; set; }

    public MyChatHub()
    {
        AbpSession = NullAbpSession.Instance;
        Logger = NullLogger.Instance;
    }

    public void SendMessage(string message)
    {
        Clients.All.getMessage(string.Format("User {0}: {1}", AbpSession.UserId, message));
    }

    public async override Task OnConnected()
    {
        await base.OnConnected();
        Logger.Debug("A client connected to MyChatHub: " + Context.ConnectionId);
    }

    public async override Task OnDisconnected(bool stopCalled)
    {
        await base.OnDisconnected(stopCalled);
        Logger.Debug("A client disconnected from MyChatHub: " + Context.ConnectionId);
    }
}
</code></pre>
<p>我们实现了<strong>ITransientDependency</strong>来简化将我们的集线器hub注册到依赖注入系统中（你可以基于你的需求使它是单例的【singleton】）。我们也使用属性注入了session和logger。</p>
<p><strong>SendMessage</strong>是hub的一个方法，它可以被客户端使用。在这个方法中，我们可以调用所有客户端的 <strong>getMessage</strong>函数。正如你看到的那样，我们可以使用AbpSession来获得当前的用户id(如果用户登录了系统)。为了演示，我们也重写了 <strong>OnConnected 和 OnDisconnected</strong>，实际这里是不需要的。</p>
<p>这里，客户端的javascript代码使用了我们的集线器hub发送/接收信息。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> chatHub <span class="token operator">=</span> $<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>myChatHub<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//获取 hub的引用</span>

chatHub<span class="token punctuation">.</span>client<span class="token punctuation">.</span>getMessage <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//为即将到来的信息注册</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'received message: '</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

abp<span class="token punctuation">.</span>event<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'abp.signalr.connected'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//为连接事件注册</span>
chatHub<span class="token punctuation">.</span>server<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">"Hi everybody, I'm connected to the chat!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给服务器发送信息</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>然后，无论何时需要向服务器发送信息，我们都可以使用chatHub。这里再提醒一下，想要获取更多关于SignalR的信息，可以点击查看**<a target="_blank" rel="noopener" href="http://www.asp.net/signalr">SinalR文档</a>**。</p>
<h1 id="基础设施层-1"><a href="#基础设施层-1" class="headerlink" title="基础设施层"></a>基础设施层</h1><h1 id="ABP理论学习之NHibernate集成"><a href="#ABP理论学习之NHibernate集成" class="headerlink" title="ABP理论学习之NHibernate集成"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNHibernate.html">ABP理论学习之NHibernate集成</a></h1><hr>
<h2 id="本篇目录-34"><a href="#本篇目录-34" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#nuget">Nuget包</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#config">配置</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#mapping">实体映射</a></strong></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#repository">仓储</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#base">仓储基类</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#implement">实现仓储</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#custom">自定义仓储方法</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPNHibernate.html#seeAlso">阅读其他</a></strong></li>
</ul>
<p>ABP可以使用任何ORM框架工作，并且已经内置了<strong>NHibernate</strong>集成。这篇文章会解释如何在ABP中使用NHibernate。阅读本文的前提是假设你已经熟悉了EF的基本知识。</p>
<h3 id="Nuget包"><a href="#Nuget包" class="headerlink" title="Nuget包###"></a>Nuget包###</h3><p>在ABP中使用NH作为ORM的Nuget包是<strong>Abp.NHibernate</strong>。你应该将它添加到应用程序中。最好在应用程序中分离的程序集(dll)中实现NHibernate，并让该程序集依赖Abp.NHibernate包。</p>
<h3 id="配置-4"><a href="#配置-4" class="headerlink" title="配置###"></a>配置###</h3><p>要开始使用NHibernate,应该首先要配置它。配置代码应该写在模块的PreInitialize方法中。</p>
<pre class=" language-C#"><code class="language-C#">[DependsOn(typeof(AbpNHibernateModule))]
public class SimpleTaskSystemDataModule : AbpModule
{
    public override void PreInitialize()
    {
        var connStr = ConfigurationManager.ConnectionStrings["Default"].ConnectionString;

        Configuration.Modules.AbpNHibernate().FluentConfiguration
            .Database(MsSqlConfiguration.MsSql2008.ConnectionString(connStr))
            .Mappings(m => m.FluentMappings.AddFromAssembly(Assembly.GetExecutingAssembly()));
    }

    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}
</code></pre>
<p><strong>AbpNHibernate</strong>模块为了使ABP能够使用NHibernate工作提供了基本的功能和适配器。</p>
<h4 id="实体映射"><a href="#实体映射" class="headerlink" title="实体映射"></a>实体映射</h4><p>在下面的样例配置中，使用了当前程序集中的所有映射类进行了流畅地映射。一个映射类的例子如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class TaskMap : EntityMap<Task>
{
    public TaskMap()
        : base("TeTasks")
    {
        References(x => x.AssignedUser).Column("AssignedUserId").LazyLoad();

        Map(x => x.Title).Not.Nullable();
        Map(x => x.Description).Nullable();
        Map(x => x.Priority).CustomType<TaskPriority>().Not.Nullable();
        Map(x => x.Privacy).CustomType<TaskPrivacy>().Not.Nullable();
        Map(x => x.State).CustomType<TaskState>().Not.Nullable();
    }
}
</code></pre>
<p><strong>EntityMap</strong>是ABP继承了 <strong>ClassMap</strong>的一个类，它会自动映射 <strong>Id</strong>属性并在构造函数中获得<strong>表名</strong>。因此，我们可以从它派生并使用 **<a target="_blank" rel="noopener" href="http://www.fluentnhibernate.org/">FluentNHibernate</a>**映射其他的属性。当然，你可以直接从ClassMap派生，可以使用FluentNHibernate的所有API，也可以使用NHinernate其他的映射技术（比如映射XML文件）。</p>
<h3 id="仓储"><a href="#仓储" class="headerlink" title="仓储###"></a>仓储###</h3><p>你可以使用仓储的默认实现而不用在项目中创建仓储类。或者可以创建派生自NhRepositoryBase的仓储类。</p>
<h4 id="仓储基类"><a href="#仓储基类" class="headerlink" title="仓储基类"></a>仓储基类</h4><p>虽然可以从ABP的NhRepositoryBase中派生仓储类，但是最佳实践是创建自己的继承了NhRepositoryBase的基类。这样，我们就可以轻松地将一些公用的方法添加到仓储中了。例子如下：</p>
<pre class=" language-C#"><code class="language-C#">//所有仓储的基类
public abstract class MyRepositoryBase<TEntity, TPrimaryKey> : NhRepositoryBase<TEntity, TPrimaryKey>
    where TEntity : class, IEntity<TPrimaryKey>
{
    protected MyRepositoryBase(ISessionProvider sessionProvider)
        : base(sessionProvider)
    {
    }

    //为所有的仓储添加一些公共的方法
}

//Id为整数的实体的快捷方式
public abstract class MyRepositoryBase<TEntity> : MyRepositoryBase<TEntity, int>
    where TEntity : class, IEntity<int>
{
    protected MyRepositoryBase(ISessionProvider sessionProvider)
        : base(sessionProvider)
    {
    }

    //不要在这里添加任何方法，在上面的方法中添加（因为该方法继承了上面的方法）
}

public class TaskRepository : MyRepositoryBase<Task>, ITaskRepository
{
    public TaskRepository(ISessionProvider sessionProvider)
        : base(sessionProvider)
    {
    }

    //这里添加一些task仓储特有的方法
}
</code></pre>
<h4 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h4><p>你不需要为实体类创建仓储，只需要使用预定义的仓储方法。例子：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService : IPersonAppService
{
    private readonly IRepository<Person> _personRepository;

    public PersonAppService(IRepository<Person> personRepository)
    {
        _personRepository = personRepository;
    }

    public void CreatePerson(CreatePersonInput input)
    {        
        person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };
        
        _personRepository.Insert(person);
    }
}
</code></pre>
<p>PersonAppService通过构造函数注入了<strong>IRepository</strong>并使用仓储中的<strong>Insert</strong>方法。使用这种方法，你可以轻松地注入 <strong>IRepository</strong>(或者IRepository&lt;TEntity,TPrimaryKey&gt;)，然后使用预定义的方法。所有预定义的方法列表，请查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPRepository.html">仓储文档</a>**。</p>
<h4 id="自定义仓储方法"><a href="#自定义仓储方法" class="headerlink" title="自定义仓储方法"></a>自定义仓储方法</h4><p>如果你想添加一些自定义的方法，那么首先应该给它添加仓储接口（这是最佳实践），然后在仓储类中实现。ABP提供了一个基类<strong>NhRepositoryBase</strong>来轻松地实现仓储。要实现仓储接口，只需要从仓储基类中派生仓储就可以了。</p>
<p>假设我们有一个Task（任务）实体，该任务可以派给一个Person（人）实体，而且Task实体有这么几种状态，包括new,assigned,completed等等。我们可能需要写一个自定义方法来根据一些条件和AssignedPerson来获取任务的列表。看下面的代码：</p>
<pre class=" language-C#"><code class="language-C#">public interface ITaskRepository : IRepository<Task, long>
{
    List<Task> GetAllWithPeople(int? assignedPersonId, TaskState? state);
}

public class TaskRepository : NhRepositoryBase<Task, long>, ITaskRepository
{
    public TaskRepository(ISessionProvider sessionProvider)
        : base(sessionProvider)
    {
    }

    public List<Task> GetAllWithPeople(int? assignedPersonId, TaskState? state)
    {
        var query = GetAll();

        if (assignedPersonId.HasValue)
        {
            query = query.Where(task => task.AssignedPerson.Id == assignedPersonId.Value);
        }

        if (state.HasValue)
        {
            query = query.Where(task => task.State == state);
        }

        return query
            .OrderByDescending(task => task.CreationTime)
            .Fetch(task => task.AssignedPerson)
            .ToList();
    }
}
</code></pre>
<p>GetAll()方法返回了<strong>IQueryable</strong>，然后使用给定的参数添加了一些 <strong>Where</strong>过滤。最后使用 **ToList()**获得Tasks的列表。</p>
<p>你也可以在仓储方法中使用<strong>Session</strong>对象来调用NHibernate的全部API。</p>
<p>仓储应该在它的构造函数中获得一个ISessionProvider。这样的话，我们就可以在单元测试中轻松地注入一个伪造的session提供者了。在运行时，ABP会自动地注入正确的session提供者。</p>
<h1 id="ABP理论学习之EntityFramework集成"><a href="#ABP理论学习之EntityFramework集成" class="headerlink" title="ABP理论学习之EntityFramework集成"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html">ABP理论学习之EntityFramework集成</a></h1><hr>
<h2 id="本篇目录-35"><a href="#本篇目录-35" class="headerlink" title="本篇目录"></a>本篇目录</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html#nuget">Nuget包</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html#DbContext">创建DbContext</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html#repository">仓储</a><ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html#base">仓储基类</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html#implement">实现仓储</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html#custom">自定义仓储方法</a></strong></li>
</ul>
</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/farb/p/ABPEntityFramework.html#seeAlso">阅读其他</a></strong></li>
</ul>
<p>ABP可以使用任何ORM框架工作，并且已经内置了<strong>EntityFramework</strong>集成。这篇文章会解释如何在ABP中使用EntityFramework。阅读本文的前提是假设你已经熟悉了EF的基本知识。</p>
<h3 id="Nuget包-1"><a href="#Nuget包-1" class="headerlink" title="Nuget包###"></a>Nuget包###</h3><p>在ABP中使用EF作为ORM的Nuget包是<strong>Abp.EntityFramework</strong>。你应该将它添加到应用程序中。最好在应用程序中分离的程序集(dll)中实现EntityFramework，并让该程序集依赖Abp.EntityFramework包。</p>
<h3 id="创建DbContext"><a href="#创建DbContext" class="headerlink" title="创建DbContext###"></a>创建DbContext###</h3><p>要使用EF工作，你应该为应用程序定义一个<strong>DbContext</strong>。定义DbContext的一个例子如下所示：</p>
<pre class=" language-C#"><code class="language-C#">public class SimpleTaskSystemDbContext : AbpDbContext
{
    public virtual IDbSet<Person> People { get; set; }
    public virtual IDbSet<Task> Tasks { get; set; }

    public SimpleTaskSystemDbContext()
        : base("MyConnectionStringName")
    {
        
    }

    protected override void OnModelCreating(DbModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.Entity<Person>().ToTable("StsPeople");
        modelBuilder.Entity<Task>().ToTable("StsTasks").HasOptional(t => t.AssignedPerson);
    }
}
</code></pre>
<p>除了派生自<strong>AbpDbContext</strong>而不是DbContext之外，它还是一个常规的DbContext。AbpDbContext的构造函数有很多重载。你可以使用你需要的那个。</p>
<p>EntityFramework可以以一种惯例的方式将类映射到数据库中对应的表。除非你要做一些自定义的东西，否则你不需要做任何配置。在这个例子中，我们将实体映射到不同的表，默认地，Task实体会映射到<strong>Tasks</strong>表。但是我们将它改成了<strong>StsTasks</strong>表，这里没有用数据注解特性配置，我更喜欢使用流畅的配置。你也可以选择你喜欢的方式。</p>
<h3 id="仓储-1"><a href="#仓储-1" class="headerlink" title="仓储###"></a>仓储###</h3><p>ABP提供了一个基类<strong>EfRepositoryBase</strong>可以轻松地实现仓储。为了实习IRepository接口，只需要从这个类中派生仓储就可以了。但是最好创建你自己的继承了EfRepositoryBase的基类。这样，你就可以给仓储轻松地添加一些共享的方法了。</p>
<h4 id="仓储基类-1"><a href="#仓储基类-1" class="headerlink" title="仓储基类"></a>仓储基类</h4><p>一个简单任务系统（SimpleTaskSystem）应用的所有仓储的基类例子如下所示：</p>
<pre class=" language-C#"><code class="language-C#">//所有仓储的基类
public class SimpleTaskSystemRepositoryBase<TEntity, TPrimaryKey> : EfRepositoryBase<SimpleTaskSystemDbContext, TEntity, TPrimaryKey>
    where TEntity : class, IEntity<TPrimaryKey>
{
    public SimpleTaskSystemRepositoryBase(IDbContextProvider<SimpleTaskSystemDbContext> dbContextProvider)
        : base(dbContextProvider)
    {
    }

    //为所有的仓储添加一些公共的方法
}

//Id为整数的实体的快捷方式
public class SimpleTaskSystemRepositoryBase<TEntity> : SimpleTaskSystemRepositoryBase<TEntity, int>
    where TEntity : class, IEntity<int>
{
    public SimpleTaskSystemRepositoryBase(IDbContextProvider<SimpleTaskSystemDbContext> dbContextProvider)
        : base(dbContextProvider)
    {
    }

    //不要在这里添加任何方法，在上面的方法中添加（因为该方法继承了上面的方法）
}
</code></pre>
<p>注意我们是从EfRepositoryBase&lt;SimpleTaskSystemDbContext, TEntity, TPrimaryKey&gt;继承的。这就声明了ABP在仓储中使用的数据上下文是SimpleTaskSystemDbContext。</p>
<h4 id="默认实现仓储"><a href="#默认实现仓储" class="headerlink" title="默认实现仓储"></a>默认实现仓储</h4><p>你不需要为实体类创建仓储，只需要使用预定义的仓储方法。例子：</p>
<pre class=" language-C#"><code class="language-C#">public class PersonAppService : IPersonAppService
{
    private readonly IRepository<Person> _personRepository;

    public PersonAppService(IRepository<Person> personRepository)
    {
        _personRepository = personRepository;
    }

    public void CreatePerson(CreatePersonInput input)
    {        
        person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };
        
        _personRepository.Insert(person);
    }
}
</code></pre>
<p>PersonAppService通过构造函数注入了<strong>IRepository</strong>并使用仓储中的<strong>Insert</strong>方法。使用这种方法，你可以轻松地注入 <strong>IRepository</strong>(或者IRepository&lt;TEntity,TPrimaryKey&gt;)，然后使用预定义的方法。所有预定义的方法列表，请查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPRepository.html">仓储文档</a>**。</p>
<h4 id="自定义仓储方法-1"><a href="#自定义仓储方法-1" class="headerlink" title="自定义仓储方法"></a>自定义仓储方法</h4><p>要实现一个自定义的仓储，只需要从上面创建的仓储基类中派生就可以了。</p>
<p>假设我们有一个Task（任务）实体，该任务可以派给一个Person（人）实体，而且Task实体有这么几种状态，包括new,assigned,completed等等。我们可能需要写一个自定义方法来根据一些条件和AssignedPerson来获取任务的列表。看下面的代码：</p>
<pre class=" language-C#"><code class="language-C#">public interface ITaskRepository : IRepository<Task, long>
{
    List<Task> GetAllWithPeople(int? assignedPersonId, TaskState? state);
}

public class TaskRepository : SimpleTaskSystemRepositoryBase<Task, long>, ITaskRepository
{
    public TaskRepository(IDbContextProvider<SimpleTaskSystemDbContext> dbContextProvider)
        : base(dbContextProvider)
    {
    }

    public List<Task> GetAllWithPeople(int? assignedPersonId, TaskState? state)
    {
        var query = GetAll();

        if (assignedPersonId.HasValue)
        {
            query = query.Where(task => task.AssignedPerson.Id == assignedPersonId.Value);
        }

        if (state.HasValue)
        {
            query = query.Where(task => task.State == state);
        }

        return query
            .OrderByDescending(task => task.CreationTime)
            .Include(task => task.AssignedPerson)
            .ToList();
    }
}
</code></pre>
<p>我们首先定义了一个<strong>ITaskRepository</strong>接口，然后实现了它。GetAll()方法返回了<strong>IQueryable</strong>，然后使用给定的参数添加了一些 <strong>Where</strong>过滤。最后使用 **ToList()**获得Tasks的列表。</p>
<p>你也可以在仓储方法中使用<strong>Context</strong>对象到达DbContext,然后可以直接使用EF基础设施了。</p>
<p>仓储应该获得一个IDbContextProvider。这样的话，我们就可以在单元测试中轻松地注入一个伪造的DbContext提供者了。在运行时，ABP会自动地注入正确的DbContext提供者。</p>
<h3 id="阅读其他"><a href="#阅读其他" class="headerlink" title="阅读其他###"></a>阅读其他###</h3><p>你也可以查看**<a target="_blank" rel="noopener" href="http://www.cnblogs.com/farb/p/ABPRepository.html">仓储文档</a>**获取更多关于仓储的知识。</p>
<h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">蒋岳生</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://github.com/jiayueshe/jiayueshe.github.io/2021/03/22/abp/2016abp-xue-xi-bo-ke-tkb-zhi-jian/">https://github.com/jiayueshe/jiayueshe.github.io/2021/03/22/abp/2016abp-xue-xi-bo-ke-tkb-zhi-jian/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">蒋岳生</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/abp/">
                                    <span class="chip bg-color">abp</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/03/22/kaikeba/shu-ju-jie-gou-he-suan-fa/suan-fa-lian-biao/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="数据结构和算法--堆栈">
                        
                        <span class="card-title">数据结构和算法--堆栈</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            数据结构和算法
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-03-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" class="post-category">
                                    数据结构和算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">数据结构和算法</span>
                    </a>
                    
                    <a href="/tags/leetcode/">
                        <span class="chip bg-color">leetcode</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/03/20/kaikeba/biao-dan-she-ji-qi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="低代码平台——可视化表单">
                        
                        <span class="card-title">低代码平台——可视化表单</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            低代码平台——可视化表单
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-03-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/" class="post-category">
                                    可视化
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0/">
                        <span class="chip bg-color">低代码平台</span>
                    </a>
                    
                    <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96%E8%A1%A8%E5%8D%95/">
                        <span class="chip bg-color">可视化表单</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">JiangYuesheng</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">288.1k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/jiayueshe/jiayueshe.github.io" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>
    

        
            <a href="mailto:732767079@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
                <i class="fas fa-envelope-open"></i>
            </a>
            

                <!-- 

 -->

                
                    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=732767079" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 732767079" data-position="top" data-delay="50">
                        <i class="fab fa-qq"></i>
                    </a>
                    
                        <!-- 


 -->

                        
                            <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
                                <i class="fas fa-rss"></i>
                            </a>
                            </div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
